# 第三章 密码学与技术基础

在本章中，你将介绍密码学的概念、理论和实践方面。将更加关注在区块链技术背景下特别相关的方面。此外，还将讨论来自金融市场的概念，以便为后续章节中涵盖的材料提供基础。

你还将了解密码算法的实际实现，以便你可以亲身体验密码功能。为此，使用了**OpenSSL**命令行。

在开始理论基础之前，下一节将讨论 OpenSSL 的安装，这样你就可以在阅读理论材料的同时进行一些实际工作。

在 Ubuntu Linux 发行版上，OpenSSL 通常已经可用；但是，也可以使用以下命令进行安装：

```
$ sudo apt-get install openssl

```

在接下来的章节中，首先将讨论理论基础，然后介绍相关的实际实验。

# 介绍

密码学是在对手存在的情况下使信息安全的科学。它提供了一种在假定对手拥有无限资源的情况下进行安全通信的手段。密码用于加密数据，以便如果被对手拦截，数据对他们来说是毫无意义的，除非进行解密，这需要秘密密钥。

密码学通常用于提供保密服务。单独使用时，它不能被视为一个完整的解决方案，但在更大的安全系统中作为一个重要的构建模块来解决安全问题。

密码学提供了各种安全服务，例如**机密性，完整性，认证**（实体认证和数据起源认证）和**不可否认性**。此外，在各种安全系统中还需要责任制。

在进一步讨论密码学之前，首先需要解释一些数学术语和概念，以便完全理解本章后面提供的材料。下一节介绍了这些概念。值得注意的是，本节旨在作为基础介绍。对于所有这些术语的解释和相关背景的证明将需要相当复杂的数学，这超出了本书的范围。关于这些主题的更多细节可以在任何标准的数论、代数或密码学教科书中找到。

## 数学

由于密码学的主题是基于数学的，本节将介绍一些基本概念，这些概念将帮助你理解本章后面的概念。

### 集合

集合是一组不同的对象，例如，*X= {1, 2, 3, 4, 5}*。

### 群组

群是一种带有一个操作的可交换集合，该操作将集合的两个元素组合在一起。群操作是封闭的，并且与定义的单位元素相关联。此外，集合中的每个元素都有逆元。封闭（闭合）意味着，例如，元素 A 和 B 在集合中，对这些元素执行操作后得到的结果元素也在集合中。结合性意味着元素的分组不会影响操作的结果。

### 域

域是一个包含加法和乘法群的集合。更准确地说，集合中的所有元素形成加法和乘法群。它满足特定的加法和乘法公理。对于所有群操作，还应用了分配律。该定律规定，即使重新排列任何项或因子，也将产生相同的和或乘积。

### 有限域

有限域是具有有限元素集合的域。这些结构也称为伽罗华域，在密码学中特别重要，因为它们可以用于生成算术运算的准确和无误结果。例如，素有限域用于椭圆曲线密码学中构建离散对数问题。

### 秩

这是一个域中的元素数量。也称为域的基数。

### 素域

这是一个有着素数个元素的有限域。它具有特定的加法和乘法规则，域中每个非零元素都有逆元。加法和乘法运算是模 *p* 来执行的。

### 环

如果阿贝尔群上可以定义多个操作，那么该群就变成了环。还有一些需要满足的属性。环必须具有封闭、结合和分配属性。

### 循环群

循环群是一种可以由称为群生成元的单个元素生成的群。换句话说，如果对群中的特定元素重复应用群操作，则可以生成群中的所有元素。

### 阿贝尔群

当集合中元素的操作是可交换的时，形成了阿贝尔群。交换律基本上意味着更改元素的顺序不会影响操作的结果，例如，*A X B = B X A*。

### 模算术

在模算术中也称为时钟算术，当数字达到一定的固定数值时，会重新开始。这个固定数值是一个称为模数的正数，所有运算都是根据这个固定数值进行的。类比于时钟，有从 1 到 12 的数字。当数字达到 12 时，数字 1 重新开始。换句话说，这种算术处理的是除法操作后的余数。例如，50 mod 11 是 6，因为 50 / 11 的余数是 6。

这完成了对一些数学概念的基本介绍；在下一节中，您将介绍密码学。

## 密码学

正如前面讨论的，密码学提供了各种安全服务，这些安全服务将在这里讨论。

## 机密性

机密性是确保信息仅对授权实体可用的保证。

## 完整性

完整性是确保信息仅由授权实体可修改的保证。

## 身份验证

身份验证提供了有关实体身份或消息有效性的保证。这里讨论了两种类型的身份验证。

### 实体认证

实体认证是确保实体当前参与并活跃在通信会话中的保证。传统上，用户被分配一个用户名和密码，用于访问他们正在使用的平台。这称为单因素身份验证，因为只有一个因素，即*你所知道的东西*，也就是密码和用户名。由于各种原因，比如密码泄露，这种类型的身份验证并不是很安全；因此，现在通常使用额外的因素来提供更好的安全性。对用户身份识别使用额外技术的方式称为多因素身份验证或两因素身份验证（如果只使用两种方法）。如果使用超过两个因素进行身份验证，则称为多因素身份验证。以下是描述的各种因素：

1.  第一个因素是你所拥有的东西，比如硬件令牌或智能卡。在这种情况下，用户可以使用硬件令牌以及登录凭据来访问系统。这提供了双因素身份验证的保护。拥有硬件令牌并知道登录凭据的用户将能够访问系统。必须同时具备两个因素才能访问系统，从而使该方法成为双因素身份验证机制。

1.  第二个因素是你是什么，它使用生物特征来识别用户。在这种方法中，用户使用指纹、视网膜、虹膜或手形等生物特征来提供额外的身份验证因素。这样，可以确保用户确实在身份验证机制中出现，因为生物特征是一个人独特的。然而，需要谨慎实施以确保高水平的安全性，因为一些研究表明，在某些情况下，生物特征系统可以被规避。

### 数据来源认证

也称为消息认证，这是确保信息来源已验证的保证。数据来源认证意味着数据完整性，因为如果一个来源得到证实，那么数据必须没有被修改。最常用的是各种方法，比如**消息认证码**（**MACs**）和数字签名。这些术语将在本章后面详细解释。

## 不可否认

不可否认是确保实体不能通过提供无法伪造的证据来否认先前承诺或行动的保证。它是一种提供无法伪造的证据表明特定行动已发生的安全服务。在有争议的情况下，这一属性非常必要，例如，当一个实体否认在电子商务系统上下订单时。该服务在电子交易中生成加密证据，以便在争议情况下，可以用作行动的确认。多年来，不可否认一直是一个活跃的研究领域。电子交易中的争议是一个常见问题，需要解决这些问题以提高消费者对服务的信心水平。

不可否认协议通常在通信网络中运行，并用于提供一个实体（发起者或接收者）在网络上采取了行动的证据。在这种情况下，有两种通信模型可以用于将消息从发起者*A*传输到接收者*B*：

1.  消息直接从发起者*A*发送到接收者*B*。

1.  消息从发起者*A*发送到交付代理，然后将消息交付给接收者*B*。

不可否认协议的主要要求是公平性、有效性和及时性。在许多场景中，与仅涉及两方的情况不同，一个交易中涉及多个参与者。例如，在电子交易系统中，可能有许多实体，如清算代理、经纪人和交易者参与单个交易。在这种情况下，两方不可否认协议是不合适的。为解决这个问题，已经开发了**多方不可否认协议**（**MPNR**）。

## 账户责任制

账户责任制是确保影响安全性的行动可以追溯到负责方的保证。这通常由系统中的日志记录和审计机制提供，在需要详细审计的业务性质的系统中，例如，在电子交易系统中。详细的日志记录对于追溯实体的行动至关重要，例如，当一笔交易在带有日期和时间戳的审计记录中放置，并且实体的身份生成并保存在日志文件中时。该日志文件可以选择加密，并且可以是数据库的一部分或系统上的独立 ASCII 文本日志文件。

# 密码原语

密码原语是安全协议或系统的基本构建模块。在下一节中，您将介绍用于构建安全协议和系统的必要的密码算法。**安全协议**是通过利用适当的安全机制来实现所需的安全目标所采取的一系列步骤。

不同类型的安全协议正在使用，例如**认证协议**、**不可否认协议**和**密钥管理协议**。

下图显示了一个通用的密码学模型：

![密码学原语](img/B05975_03_01.jpg)

显示通用加密和解密模型的模型

在上图中，**P**、**E**、**C**和**D**分别表示明文、加密、密文和解密。此外，基于先前显示的模型，值得解释各种概念，如实体、发送方、接收方、对手、密钥和信道。

+   **实体**：它可以是发送、接收或对数据执行操作的人或系统

+   **发送方**：发送方是传输数据的实体

+   **接收方**：接收方是接收数据的实体

+   **对手**：这是试图规避安全服务的实体

+   **密钥**：密钥是用于加密或解密数据的一些数据

+   **信道**：信道提供了实体之间的通信介质

密码学主要分为两类，即对称加密和非对称加密。

## 对称密码学

对称密码学是一种加密类型，其中用于加密数据的密钥与解密数据的密钥相同，因此也被称为共享密钥密码学。在通信双方之间进行数据交换之前，必须建立或同意密钥。这就是它也被称为**秘密密钥密码学**的原因。

对称密码学有两种类型，流密码和块密码。**数据加密标准**（**DES**）和**高级加密标准**（**AES**）是常见的块密码示例，而 RC4 和 A5 是常用的流密码。

### 流密码

这些密码是加密算法，使用密钥流逐位对明文进行加密。有两种类型的流密码：同步和异步。同步流密码是仅密钥取决于密钥的流密码，而异步流密码的密钥流也取决于加密数据。

在流密码中，加密和解密基本上是相同的函数，因为它们都是简单的模 2 加法或 XOR 操作。流密码中的关键要求是密钥流的安全性和随机性。已经开发了各种技术来生成随机数，所有密钥生成器都必须具有密码学安全性：

![流密码](img/B05975_03_02.jpg)

流密码的操作

### 块密码

这些是将要加密的文本（明文）分成固定长度的块并逐块应用加密的加密算法。块密码通常是使用称为费斯泰尔密码的设计策略构建的。最近的块密码，如 AES（Rijndael），是使用称为**替代-置换网络**（**SPN**）的替代和置换的组合构建的。

费斯特尔密码是基于*霍斯特·费斯特尔*开发的结构，这个结构是基于将多轮重复操作结合起来以实现称为混淆和扩散的可取的密码属性的想法。费斯特尔网络通过将数据分成两个块（左和右）并通过带键的轮函数处理这些块来操作。

混淆使得密文与明文之间的关系复杂化。这是通过实践中的替换来实现的。例如，明文中的 'A' 被加密文本中的 'X' 替换。在现代密码算法中，替换是使用称为 S 盒的查找表执行的。扩散属性在加密数据上统计性地传播明文，这确保即使在输入文本中改变了一个比特，也会导致至少一半（平均）的比特在密文中改变。混淆是为了使得即使使用相同的密钥创建了许多加密和解密数据对，也很难找到加密密钥。在实践中，这是通过转位或排列来实现的。

使用费斯特尔密码的一个关键优势是加密和解密操作几乎是相同的，并且只需要对加密过程进行反转即可实现解密。DES 是费斯特尔密码的一个主要示例：

![分组密码](img/B05975_03_03.jpg)

分组密码的简化操作

分组密码的各种操作模式为**电子密码本**（**ECB**）、**密码块链接**（**CBC**）、**输出反馈模式**（**OFB**）或**计数器模式**（**CTR**）。这些模式用于指定加密函数应用于明文的方式。这些模式将在本节的后面进行解释，但在这里先介绍前四种分组密码加密模式的分类。

#### 分组加密模式

在这种模式下，明文被分成固定长度的块，具体取决于所使用的密码类型，然后在每个块上应用加密函数。

#### 密钥流生成模式

在这种模式下，加密函数生成一个密钥流，然后与明文流进行异或运算，以实现加密。

#### 消息认证模式

在这种模式下，通过加密函数计算消息认证码。MAC 基本上是一个提供完整性服务的密码校验和。使用分组密码生成 MAC 的最常见方法是 CBC-MAC，其中链的最后一个块的某些部分被用作 MAC。

#### 密码哈希

哈希函数基本上用于将消息压缩为固定长度的摘要。在这种模式下，分组密码被用作压缩函数，以产生明文的哈希。

讨论了最常见的分组加密模式。

#### 电子密码本

这是一种基本的操作模式，其中加密数据是通过将加密算法分别应用于每个明文块而产生的。这是最简单的模式，但不应在实践中使用，因为它是不安全的，可能会泄露信息：

![电子码本](img/B05975_03_04.jpg)

电子码本模式用于区块密码

#### 密码块链

在这种模式下，每个明文块都与前一个加密块进行异或运算。CBC 模式使用初始化向量 IV 来加密第一个块。建议随机选择 IV：

![密码块链](img/B05975_03_05.jpg)

密码块链模式

#### 计数器模式

CTR 模式有效地将块密码用作流密码。在这种情况下，提供了一个唯一的 nonce，它与计数器值连接起来以产生一个**密钥流**：

![计数器模式](img/B05975_03_06.jpg)

计数器模式

还有其他模式，如**密码反馈模式**（**CFB**）、**Galois 计数器模式**（**GCM**）和输出反馈模式，也被用于各种场景中。

在下一节中，您将介绍目前主要的区块密码 AES 的设计和机制。首先，将介绍关于导致新 AES 标准开发的数据加密标准（DES）的一些历史。

## 数据加密标准（DES）

DES 是由美国**国家标准与技术研究院**（**NIST**）作为加密的标准算法引入的，并且在 1980 年代和 1990 年代主要使用，但它并没有被证明对抗暴力攻击很有抵抗力，这是由于技术和密码学研究的进步。特别是在 1998 年 7 月，**电子前沿基金会**（**EFF**）使用专用机器破解了 DES。DES 使用的密钥只有 56 位，这引起了一些担忧。这个问题在引入**三重 DES**（**3DES**）时得到了解决，它提议使用三个 56 位密钥和相同数量的 DES 算法执行，从而几乎使暴力攻击变得不可能。但是其他限制，如性能慢和 64 位的块大小，是不可取的。

## 高级加密标准（AES）

在 2001 年的一次公开竞赛之后，由密码学家*Joan Daemen*和*Vincent Rijmen*发明的加密算法 Rijndael 被 NIST 在 2001 年进行了轻微修改后标准化为 AES。到目前为止，还没有发现比暴力方法更好的对 AES 的攻击。原始的 Rijndael 允许使用不同的密钥和块大小，如 128 位、192 位和 256 位，但在 AES 标准中，只允许使用 128 位的块大小。然而，允许使用 128 位、192 位和 256 位的密钥大小。

### AES 步骤

在 AES 算法处理期间，一个称为 *state* 的 4x4 字节数组使用多轮进行修改。完整的加密需要 10 到 14 轮，具体取决于密钥的大小。以下表格显示了密钥大小和所需轮数：

![AES 步骤](img/B05975_03_56.png)

一旦状态用密码的输入初始化，就会在四个阶段执行四个操作以加密输入。这些阶段是 `AddRoundKey`、`SubBytes`、`ShiftRows` 和 `MixColumns`：

1.  在 `AddRoundKey` 步骤中，状态数组与从主密钥派生的子密钥进行异或。

1.  这是替换步骤，其中使用查找表（S-盒）来替换状态数组的所有字节。

1.  此步骤用于以循环递增的方式将状态数组中除第一行之外的每一行向左移位。

1.  最后，在这一步中，所有字节都以列方式线性混合。

前述步骤描述了一轮 AES。在最后一轮（根据密钥大小为 10、12 或 14 轮），第 4 阶段被替换为 `Addroundkey`，以确保前三步不能简单地被反转回去：

![AES 步骤](img/B05975_03_07.jpg)

AES 块图，显示第 1 轮，最后一轮混合步骤不执行

各种加密货币钱包使用 AES 加密来加密本地存储的数据。特别是在比特币钱包中，使用 AES 256 且采用 CBC 模式。

#### 使用 AES 进行加密和解密的 OpenSSL 示例

```
:~/Crypt$ openssl enc -aes-256-cbc -in message.txt -out message.bin
enter aes-256-cbc encryption password:
Verifying - enter aes-256-cbc encryption password:
:~/Crypt$ ls -ltr
total 12
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
:~/Crypt$ cat message.bin

```

![使用 AES 进行加密和解密的 OpenSSL 示例](img/B05975_03-2.png)

请注意 `message.bin` 是一个二进制文件；有时，将此二进制文件编码为文本格式以确保兼容性/互操作性是可取的。可以使用以下命令来执行此操作：

```
:~/Crypt$ openssl enc -base64 -in message.bin -out message.b64
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
:~/Crypt$ cat message.b64
U2FsdGVkX193uByIcwZf0Z7J1at+4L+Fj8/uzeDAtJE=
:~/Crypt$

```

要解密 AES 加密的文件，可以使用以下命令。从前面示例中获取 `message.bin` 的示例：

```
:~/Crypt$ openssl enc -d -aes-256-cbc -in message.bin -out message.dec
enter aes-256-cbc decryption password:
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
:~/Crypt$ cat message.dec
datatoencrypt
:~/Crypt$

```

敏锐的读者可能已经注意到，尽管在除 ECB 之外的所有块加密操作模式中都需要提供初始化向量，但未提供初始化向量。原因是 OpenSSL 会自动从给定的密码中派生初始化向量。用户可以使用开关指定初始化向量：

```
-K/-iv    ,  (Initialization Vector) should be provided in Hex.

```

要解码 base64，使用以下命令。从前面示例中获取 `message.b64` 文件：

```
:~/Crypt$ openssl enc -d -base64 -in message.b64 -out message.ptx
:~/Crypt$ ls -ltr
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:06 message.dec
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 06:16 message.ptx

```

![使用 AES 进行加密和解密的 OpenSSL 示例](img/B05975_03_40.png)

OpenSSL 支持许多类型的密码；您可以根据前面提供的示例来探索这些选项。以下屏幕截图显示了支持的密码类型列表：

![使用 AES 进行加密和解密的 OpenSSL 示例](img/image_03_008.jpg)

屏幕截图显示了 OpenSSL 中可用的丰富库选项。

# 非对称密码学

非对称密码学是一种加密技术，其中用于加密数据的密钥与用于解密数据的密钥不同。也称为公钥密码学，它使用公钥和私钥分别加密和解密数据。目前使用各种非对称加密方案，如 RSA、DSA 和 El-Gammal。

下图显示了公钥密码学的概述：

![非对称加密](img/B05975_03_09.jpg)

使用公钥/私钥进行加密解密

图解释了发送方如何使用接收方的公钥加密数据，然后通过网络传输到接收方。一旦到达接收方，就可以使用接收方的私钥对其进行解密。这样，私钥保留在接收方，不需要共享密钥来执行加密和解密，这与对称加密的情况不同。

另一个图表显示了如何使用公钥密码学来验证接收方接收到的消息的完整性。在这个模型中，发送方使用其私钥对数据进行签名，并将消息传输到接收方。一旦消息在接收方接收到，就可以使用发送方的公钥验证其完整性。请注意，此模型不执行加密。此模型仅用于消息认证和验证目的：

![非对称加密](img/B05975_03_10.jpg)

公钥密码签名方案模型

公钥密码系统提供的安全机制包括密钥建立、数字签名、身份验证、加密和解密。

密钥建立机制涉及设计允许在不安全通道上设置密钥的协议。数字签名可以提供不可否认的服务，这在许多场景中是一种非常理想的属性。有时，不仅要对用户进行身份验证，还要识别参与交易的实体；这也可以通过数字签名和挑战-响应协议的组合来实现。最后，提供机密性的加密机制也可以使用公钥密码系统来实现，例如 RSA、ECC 或 El-Gammal。

与对称密钥算法相比，公钥算法在计算上较慢。因此，它们不常用于加密大文件或需要加密的实际数据。它们通常用于交换对称算法的密钥，一旦密钥安全建立，就可以使用对称密钥算法加密数据。

公钥密码算法基于各种基础数学问题。这里描述了三个主要的非对称算法家族。

## 整数因子化

这些方案基于大整数的因子化是非常困难的事实。RSA 是这种类型算法的主要示例。

## 离散对数

这基于模算术中的一个问题，即计算模函数的结果很容易，但计算生成器的指数在计算上是不可行的。换句话说，从结果找到输入非常困难。这是一个单向函数。

例如，考虑以下方程式：

*3^(2 )mod 10 = 9*

现在给定 9，找到 2，生成器 3 的指数非常困难。这个难题通常用于**迪菲－赫尔曼**密钥交换和数字签名算法。

## 椭圆曲线

这基于先前讨论的离散对数问题，但是在椭圆曲线的背景下。椭圆曲线是一个代数立方曲线，在此处可以用下面显示的方程来定义。该曲线是非奇异的，这意味着它没有尖点或自交点。它具有两个变量*a, b*，以及一个无穷远点。

![椭圆曲线](img/image_03_012.jpg)

在这里，*a*、*b*是可以有各种值的整数，并且是椭圆曲线所定义的域的元素。椭圆曲线可以定义在实数、有理数、复数或有限域上。为了加密目的，使用椭圆曲线覆盖素数有限域而不是实数。此外，素数应大于 3。可以通过改变*a*、*b*的值来生成不同的曲线。

基于椭圆曲线的主要加密系统是**椭圆曲线数字签名算法**（**ECDSA**）和**椭圆曲线迪菲－赫尔曼**（**ECDH**）密钥交换。

# 公钥和私钥

为了理解公钥密码，首先需要看看公钥和私钥的概念。

私钥，顾名思义，基本上是由用户随机生成的保密的数字。私钥需要受到保护，不应授权任何未经授权的访问；否则，公钥密码方案的整个方案将受到威胁，因为这是用于解密消息的关键。私钥的长度可以根据所使用的算法的类型和类别而有所不同。例如，在 RSA 中，通常使用 1024 位或 2048 位的密钥。1024 位密钥大小不再被认为是安全的，建议在实践中使用至少 2048 位。

公钥是私钥-公钥对的公共部分。 公钥是公开可用的，并由私钥所有者发布。 然后，任何想要向公钥发布者发送加密消息的人都可以通过使用已发布的公钥加密消息并将其发送给私钥持有者来这样做。 没有其他人能够解密消息，因为相应的私钥被预期接收者安全持有。 一旦接收到公钥加密消息，接收方可以使用私钥解密消息。 公钥的一些问题，如发布者的真实性和识别，也是一些关注点。

## RSA

这里讨论了 RSA 的描述。 RSA 是由*Ron Rivest*，*Adi Shamir*和*Leonard Adelman*于 1977 年发明的，因此得名 RSA。 这基于整数分解问题，其中两个大素数的乘积很容易，但很难将其分解为两个原始数。

RSA 算法的关键工作在于密钥生成过程中。 执行以下步骤以生成 RSA 密钥对。

模数生成：

+   选择*p*和*q*非常大的素数

+   将*p*和*q*相乘，*n=p.q* 生成模数 *n*

生成互质数：

+   假设一个叫*e*的数字。

+   它应满足某些条件，即它应大于 1 且小于*(p-1)(q-1)*。 换句话说，e 必须是这样一个数字，除了 1 以外没有其他数字可以被*e*和*(p-1)(q-1)*整除。 这称为互质，即*e*是*(p-1)(q-1)*的互质数。

生成公钥：

+   步骤 1 生成的模数和步骤 2 生成的*e*共同构成一个公钥。 这部分是可以与任何人分享的公共部分； 但是，*p*和*q*需要保密。

生成私钥：

+   这里称为私钥 d，它是从*p*，*q*和*e*计算的。 私钥基本上是模*(p-1)(q-1)*的 e 的逆。 在等式形式中，它是这样的：

    *ed = 1 mod(p-1)(q-1)*

通常使用扩展欧几里德算法来计算*d*； 该算法接受*p*、*q*和*e*并计算*d*。 这个方案的关键思想是，任何知道*p*和*q*的人都可以很容易地计算出私钥*d*，通过应用扩展欧几里德算法，但是不知道*p*和*q*的值的人无法生成*d*。 这也意味着*p*和*q*应该足够大，使得模数*n*变得非常困难（计算上不可行）进行因式分解。

### 使用 RSA 进行加密和解密

RSA 使用以下方程产生密文：

*C = P^e mod n*

这意味着明文*P*被提升到*e*次方，然后被缩减到模*n*。

RSA 中的解密由以下方程给出：

*P = C^d mod n*

这意味着拥有公钥对(*n*，*e*)的接收方可以通过将*C*提升到私钥 d 的值并缩减到模*n*来解密数据。

### 椭圆曲线密码学（ECC）

ECC 基于离散对数问题，该问题基于有限域（Galois 域）上的椭圆曲线。ECC 相对于其他类型的公钥算法的主要优势在于，它需要更小的密钥大小，同时提供与 RSA 等算法相同级别的安全性。源自 ECC 的两个值得注意的方案是用于密钥交换的**椭圆曲线 Diffie-Hellman**（**ECDH**）和用于数字签名的**椭圆曲线数字签名算法**（**ECDSA**）。它也可以用于加密，但通常不会在实践中用于此目的；相反，密钥交换和数字签名更常用。由于 ECC 需要更少的空间来运行，因此它在嵌入式平台或存储资源有限的系统中变得非常流行。作为比较，相同级别的安全性可以通过仅使用 256 位操作数在 ECC 中实现，而在 RSA 中需要 3072 位。

#### 椭圆曲线背后的数学

为了理解 ECC，有必要对椭圆曲线的基本数学进行简要介绍。椭圆曲线基本上是一种称为 Weierstrass 方程的多项式方程，它在有限域上生成一个曲线。最常用的域是所有算术操作都在模*a*素数*p*上执行的域。椭圆曲线群由有限域上曲线上的点组成。

椭圆曲线可以在此处定义为一个方程：

![椭圆曲线背后的数学](img/image_03_017.jpg)

在这里，*A*和*B*属于有限域*Zp*或*FP*（素有限域），还有一个特殊值叫做无穷点。无穷点![椭圆曲线背后的数学](img/image_03_019.jpg)用于为曲线上的点提供身份操作。

此外，还需要满足一个条件，确保前述方程没有重复根。这意味着曲线是非奇异的。

这个条件在下面的方程中描述，这是需要满足的标准要求。更确切地说，这确保了曲线是非奇异的：

![椭圆曲线背后的数学](img/image_03_020.jpg)

椭圆曲线的实数表示可以如下图所示可视化。这是一个在实数上的方程图：

![椭圆曲线背后的数学](img/image_03_012.jpg)

椭圆曲线密码学中实际使用的曲线是在有限素域上的，但在这里，它们显示在实数上，因为在*R*上绘制时更容易可视化操作：

![椭圆曲线背后的数学](img/image_03_022.jpg)

实数上的椭圆曲线，a = -3，b = 3

为了构造基于椭圆曲线的离散对数问题，需要一个足够大的循环群。首先，将群元素标识为满足上述方程的一组点。之后，需要在这些点上定义群操作。

椭圆曲线上的群操作包括点加法和点倍增。 点加法是一个过程，其中两个不同点相加，点倍增意味着同一点加上自身。 这两种操作都可以像下图所示那样进行可视化。

#### 点加法

点加法在以下图表中显示。 这是椭圆曲线上点加法的几何表示。 在这种方法中，一条穿过曲线的线穿过两点*P*和*Q*，产生曲线和线之间的第三点。 这个点被镜像为*P+Q*，代表加法结果为*R*。 如下图所示的*P+Q*：

![点加法](img/image_03_023.jpg)

在 R 上可视化的点加法

定义的群操作符号为*+*进行加法生成以下方程：

P + Q = R

在这种情况下，两点相加以计算曲线上第三点的坐标：

![点加法](img/image_03_024.jpg)

更精确地说，坐标被添加如下方程所示：

*(*x1, y1) + (x2, y2) = (x3, y3)

点加法方程如下：

![点加法](img/image_03_025-1.jpg)![点加法](img/image_03_026.jpg)

在这里，这是结果：

![点加法](img/image_03_028.jpg)

*P*在前面的方程中代表穿过*P*和*Q*的线。

此处示例的点加法是使用 Certicom 的在线计算器产生的。 该示例显示了在有限域*F[23]*上的方程的加法和解。 这与之前示例形成对比，前者是基于实数的，仅显示了曲线但不显示方程的解：

![点加法](img/image_03_029.jpg)

使用 Certicom 的在线计算器工具进行点加法示例

在这个例子中，左侧的图显示了满足下面方程的点：

![点加法](img/image_03_030.jpg)

有 27 个解决方案满足之前在有限域*F[23]*上的方程。 选择*P*和*Q*相加以得到点*R*。 右侧显示了计算，计算出第三点*R*。 注意，这里*l*用于表示穿过*P*和*Q*的线。

作为一个示例，展示方程如何被图示中的点满足，选择一个点(*x, y*)，其中*x = 3*，*y = 6*。

将这些值代入方程中表明方程确实成立。 如下所示：

![点加法](img/image_03_031.jpg)![点加法](img/image_03_032.jpg)![点加法](img/image_03_033.jpg)![点加法](img/image_03_034.jpg)

下一部分将介绍点倍增的概念，这是椭圆曲线上可以执行的另一种操作。

#### 点倍增

椭圆曲线上的另一种群操作称为**点倍增**，并在下图中描述。这是一个过程，其中*P*被加到自身中。在这种方法中，通过曲线画出一条切线，如下图所示。得到第二点，即切线和曲线的交点。然后将此点镜像，得到结果，即*2P = P + P*：

![Point doubling](img/image_03_035.jpg)

代表实数上点倍增的图

在点倍增的情况下，方程如下：

![Point doubling](img/image_03_025-2.jpg)![Point doubling](img/image_03_026.jpg)![Point doubling](img/image_03_028.jpg)

在这里，*S*是穿过*P*的切线（切线）。这是上图中所示的顶部线。在前面的例子中，曲线作为简单示例绘制在实数上，并未显示方程的解。

下面是一个示例，显示了在有限域*F[23]*上椭圆曲线的解和点倍增。左侧的图显示了满足方程的点：

![Point doubling](img/image_03_030.jpg)![Point doubling](img/image_03_041.jpg)

使用 certicom 在线计算工具的点倍增示例

如前所示，在右侧显示了一个计算结果，找到*P*加到自身后的*R*（点倍增）。这里没有*Q*，因为这里使用同一点*P*进行倍增。请注意，在计算中，*l*用于表示穿过*P*的切线。

在下一部分，将介绍离散对数问题。

## 离散对数问题

ECC 中的离散对数问题基于这样一个思想：在某些条件下，椭圆曲线上的所有点形成一个循环群。在椭圆曲线上，公钥是生成点的随机倍数，而私钥是用于生成倍数的随机选择的整数。换句话说，私钥是随机选择的整数，而公钥是曲线上的一个点。离散对数问题用于找到在椭圆曲线上所有点中的某个整数私钥（一个整数）。接下来的方程精确地显示了这一点。考虑一个椭圆曲线*E*，其中有两个元素*P*和*T*。离散对数问题是找到一个整数 d，满足*1 <= d <= #E*，使得：

*P + P + . . . +P = d P = T*

这里，*T*是公钥（曲线上的点），d 是私钥。换句话说，公钥是生成器的随机倍数，而私钥是用于生成倍数的整数。*#E*表示椭圆曲线的阶，这基本上意味着椭圆曲线的循环群中存在的点的数量。循环群是由椭圆曲线上的点和无穷远点组合而成的。

密钥对与椭圆曲线的特定域参数相关联。域参数包括字段大小、字段表示、来自字段*a*和*b*的两个元素、两个字段元素*Xg*和*Yg*、计算为*G=(Xg, Yg)*的点*G*的阶 n 和余因子*h = #E(Fq)/n*。稍后将在本节中描述使用 OpenSSL 的实际示例。

有各种推荐和标准化使用作为 ECC 曲线的参数。在这里，你将看到 SECP256K1 规范的一个例子。这是比特币中使用的规范：

![离散对数问题](img/image_03_042.jpg)

SECP256K1 的规范来源于 http://www.secg.org/sec2-v2.pdf

这个六元组中所有这些值的说明在此处给出。

*P*是指定有限域大小的素数*p*。

*a*和*b*是椭圆曲线方程的系数。

*G*是生成所需子群的基点，也称为生成器。基点可以以压缩或非压缩形式表示。在实际实现中，无需存储曲线上的所有点。压缩生成器有效是因为可以仅使用*x*坐标和*y*坐标的最低有效位来识别曲线上的点。

*n*是子群的阶。

*h*是子群的余因子。

在下一节中，将展示使用 OpenSSL 的示例，以帮助您了解 RSA 的实践方面。

在以下部分中，将展示如何使用 OpenSSL 生成 RSA 公钥和私钥对。

### 如何生成公钥和私钥对

首先，展示了如何使用 OpenSSL 生成 RSA 私钥。

#### 私钥

```
~/Crypt$ openssl genpkey -algorithm RSA -out privatekey.pem -pkeyopt rsa_keygen_bits:1024
...............................++++++
....................++++++

```

执行命令后，会生成一个名为`privatekey.pem`的文件，其中包含生成的私钥。如下所示：

```
~/Crypt$ cat privatekey.pem
-----BEGIN PRIVATE KEY-----
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKJOFBzPy2vOd6em
Bk/UGrzDy7TvgDYnYxBfiEJId/r+EyMt/F14k2fDTOVwxXaXTxiQgD+BKuiey/69
9itnrqW/xy/pocDMvobj8QCngEntOdNoVSaN+t0f9nRM3iVM94mz3/C/v4vXvoac
PyPkr/0jhIV0woCurXGTghgqIbHRAgMBAAECgYEAlB3s/N4lJh0l1TkOSYunWtzT
6isnNkR7g1WrY9H+rG9xx4kP5b1DyE3SvxBLJA6xgBle8JVQMzm3sKJrJPFZzzT5
NNNnugCxairxcF1mPzJAP3aqpcSjxKpTv4qgqYevwgW1A0R3xKQZzBKU+bTO2hXV
D1oHxu75mDY3xCwqSAECQQDUYV04wNSEjEy9tYJ0zaryDAcvd/VG2/U/6qiQGajB
eSpSqoEESigbusKku+wVtRYgWWEomL/X58t+K01eMMZZAkEAw6PUR9YLebsm/Sji
iOShV4AKuFdi7t7DYWE5Ulb1uqP/i28zN/ytt4BXKIs/KcFykQGeAC6LDHZyycyc
ntDIOQJAVqrE1/wYvV5jkqcXbYLgV5YA+KYDOb9Y/ZRM5UETVKCVXNanf5CjfW1h
MMhfNxyGwvy2YVK0Nu8oY3xYPi+5QQJAUGcmORe4w6Cs12JUJ5p+zG0s+rG/URhw
B7djTXm7p6b6wR1EWYAZDM9MArenj8uXAA1AGCcIsmiDqHfU7lgz0QJAe9mOdNGW
7qRppgmOE5nuEbxkDSQI7OqHYbOLuwfCjHzJBrSgqyi6pj9/9CbXJrZPgNDwdLEb
GgpDKtZs9gLv3A==
-----END PRIVATE KEY-----

```

#### 生成公钥

由于私钥在数学上与公钥相关联，因此可以从私钥生成或派生公钥。以前述私钥的示例为例，公钥可以生成如下：

```
:~/Crypt$ openssl rsa -pubout -in privatekey.pem -out publickey.pem
writing RSA key

```

公钥可以使用文件阅读器或任何文本查看器查看，如下所示：

```
:~/Crypt$ cat publickey.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0
74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv
6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----

```

为了查看关于各种组件的更多详细信息，如在过程中使用的模数、素数、生成的私钥的指数和系数，可以使用以下命令（由于输出太大，未显示完整输出）：

```
:~/Crypt$ openssl rsa -text -in privatekey.pem
Private-Key: (1024 bit)
modulus:
 00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4:
 1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48:
 77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70:
 c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd:
 f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3:
 f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f:
 f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7:
 be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae:
 ad:71:93:82:18:2a:21:b1:d1
publicExponent: 65537 (0x10001)
privateExponent:
 00:94:1d:ec:fc:de:25:26:1d:25:d5:39:0e:49:8b:
 a7:5a:dc:d3:ea:2b:27:36:44:7b:83:55:ab:63:d1:
 fe:ac:6f:71:c7:89:0f:e5:bd:43:c8:4d:d2:bf:10:
 4b:24:0e:b1:80:19:5e:f0:95:50:33:39:b7:b0:a2:
 6b:24:f1:59:cf:34:f9:34:d3:67:ba:00:b1:6a:2a:
 f1:70:5d:66:3f:32:40:3f:76:aa:a5:c4:a3:c4:aa:
 53:bf:8a:a0:a9:87:af:c2:05:b5:03:44:77:c4:a4:
 19:cc:12:94:f9:b4:ce:da:15:d5:0f:5a:07:c6:ee:
 f9:98:36:37:c4:2c:2a:48:01
prime1:
 00:d4:61:5d:38:c0:d4:84:8c:4c:bd:b5:82:74:cd:
 aa:f2:0c:07:2f:77:f5:46:db:f5:3f:ea:a8:90:19:
 a8:c1:79:2a:52:aa:81:04:4a:28:1b:ba:c2:a4:bb:
 ec:15:b5:16:20:59:61:28:98:bf:d7:e7:cb:7e:2b:
 4d:5e:30:c6:59
prime2:
 00:c3:a3:d4:47:d6:0b:79:bb:26:fd:28:e2:88:e4:
 a1:57:80:0a:b8:57:62:ee:de:c3:61:61:39:52:56:
 f5:ba:a3:ff:8b:6f:33:37:fc:ad:b7:80:57:28:8b:
 3f:29:c1:72:91:01:9e:00:2e:8b:0c:76:72:c9:cc:
 9c:9e:d0:c8:39

```

同样，可以使用以下命令查看公钥。公钥和私钥都是 base64 编码的：

```
~/Crypt$ openssl pkey -in publickey.pem -pubin -text
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0
74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv
6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----
Public-Key: (1024 bit)
Modulus:
 00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4:
 1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48:
 77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70:
 c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd:
 f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3:
 f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f:
 f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7:
 be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae:
 ad:71:93:82:18:2a:21:b1:d1
Exponent: 65537 (0x10001)

```

现在公钥可以公开共享，任何想要给我们发送消息的人都可以使用公钥加密消息并将其发送给我们。然后，我们可以使用相应的私钥解密文件。

### 如何使用 OpenSSL 进行 RSA 加密和解密

首先，在本节中，将介绍一个示例，演示如何使用 RSA 进行加密。

#### 加密

以前例中生成的私钥为例，可以构建加密文本文件`message.txt`的命令，如下所示：

```
:~/Crypt$ openssl rsautl -encrypt -inkey publickey.pem -pubin -in message.txt -out message.rsa

```

这将生成一个名为`message.rsa`的文件，它是以二进制格式存储的。如果我们在 nano 编辑器中打开`message.rsa`，它将显示一些垃圾数据：

![加密](img/image_03_043.jpg)

显示垃圾数据的 message.rsa

#### 解密

为了解密 RSA 加密的文件，可以使用以下命令：

```
:~/Crypt$ openssl rsautl -decrypt -inkey privatekey.pem -in message.rsa -out message.dec

```

现在，如果使用 cat 读取文件，可以看到解密后的明文，如下所示：

```
:~/Crypt$ cat message.dec
datatoencrypt

```

### 使用 OpenSSL 的 ECC

OpenSSL 提供了一个非常丰富的函数库，用于执行椭圆曲线密码学。下面的部分展示了如何在 OpenSSL 中实际使用 ECC 函数。

#### ECC 私钥和公钥对

在这个例子中，首先展示了使用 OpenSSL 库中可用的 ECC 函数创建私钥的示例。

#### 私钥

ECC 是基于各种标准定义的域参数。我们可以使用以下命令查看 OpenSSL 中所有可用标准定义和推荐曲线的列表：

```
Crypt$ openssl ecparam -list_curves
 secp112r1 : SECG/WTLS curve over a 112 bit prime field
 secp112r2 : SECG curve over a 112 bit prime field
 secp128r1 : SECG curve over a 128 bit prime field
 secp128r2 : SECG curve over a 128 bit prime field
 secp160k1 : SECG curve over a 160 bit prime field
 secp160r1 : SECG curve over a 160 bit prime field
 secp160r2 : SECG/WTLS curve over a 160 bit prime field
 secp192k1 : SECG curve over a 192 bit prime field
 secp224k1 : SECG curve over a 224 bit prime field
 secp224r1 : NIST/SECG curve over a 224 bit prime field
 secp256k1 : SECG curve over a 256 bit prime field
 secp384r1 : NIST/SECG curve over a 384 bit prime field
 secp521r1 : NIST/SECG curve over a 521 bit prime field
 prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field
.
.
.
.
 brainpoolP384r1: RFC 5639 curve over a 384 bit prime field
 brainpoolP384t1: RFC 5639 curve over a 384 bit prime field
 brainpoolP512r1: RFC 5639 curve over a 512 bit prime field
 brainpoolP512t1: RFC 5639 curve over a 512 bit prime field

```

由于这会产生一个很长的输出，完整的输出未显示并在中间被截断。在以下示例中，使用 SECP256k1 来演示 ECC 的用法。

#### 生成私钥

```
~/Crypt$ openssl ecparam -name secp256k1 -genkey -noout -out ec-privatekey.pem
~/Crypt$ cat ec-privatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIJHUIm9NZAgfpUrSxUk/iINq1ghM/ewn/RLNreuR52h/oAcGBSuBBAAK
oUQDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8JdcGXYGxHdzr0Jt1NInaYE0GG
ChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END EC PRIVATE KEY-----

```

名为`ec-privatekey.pem`的文件现在包含基于 SECP256K1 曲线生成的 EC 私钥。

为了从私钥生成公钥，请发出以下命令：

```
~/Crypt$ openssl ec -in ec-privatekey.pem -pubout -out ec-pubkey.pem
read EC key
writing EC key

```

读取文件产生以下输出，显示生成的公钥：

```
~/Crypt$ cat ec-pubkey.pem
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8J
dcGXYGxHdzr0Jt1NInaYE0GGChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END PUBLIC KEY-----

```

现在`ec-pubkey.pem`文件包含了从`ec-privatekey.pem`派生出的公钥。

可以使用以下命令进一步探索私钥：

```
~/Crypt$ openssl ec -in ec-privatekey.pem -text -noout
read EC key
Private-Key: (256 bit)
priv:
 00:91:d4:22:6f:4d:64:08:1f:a5:4a:d2:c5:49:3f:
 88:83:6a:d6:08:4c:fd:ec:27:fd:12:cd:ad:eb:91:
 e7:68:7f
pub:
 04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
 3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
 47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
 4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
 33:c1:62:a3:9e
ASN1 OID: secp256k1

```

类似地，可以使用以下命令进一步探索公钥：

```
drequinox@drequinox-OP7010:~/Crypt$ openssl ec -in ec-pubkey.pem -pubin -text -noout
read EC key
Private-Key: (256 bit)
pub:
 04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
 3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
 47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
 4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
 33:c1:62:a3:9e
ASN1 OID: secp256k1
drequinox@drequinox-OP7010:~/Crypt$

```

也可以生成一个带有所需参数的文件-在本例中为`SECP256K1`-然后进一步探索以了解底层参数：

```
~/Crypt$ openssl ecparam -name secp256k1 -out secp256k1.pem
drequinox@drequinox-OP7010:~/Crypt$ cat secp256k1.pem
-----BEGIN EC PARAMETERS-----
BgUrgQQACg==
-----END EC PARAMETERS-----

```

该文件现在包含了所有`SECP256K1`参数，并且可以使用以下命令进行分析：

```
drequinox@drequinox-OP7010:~/Crypt$ openssl ecparam -in secp256k1.pem -text -param_enc explicit -noout
Field Type: prime-field
Prime:
 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
 ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff:
 ff:fc:2f
A:    0
B:    7 (0x7)
Generator (uncompressed):
 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87:
 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16:
 f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc:
 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0:
 8f:fb:10:d4:b8
Order:
 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
 ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0:
 36:41:41
Cofactor:  1 (0x1)

```

前面的示例显示了使用的素数和 SECP256K1 曲线域参数的生成器、阶数和余因子的 A 和 B 值。

还有另一类被称为散列函数的加密原语。散列函数不用于加密数据，而是产生数据的固定长度摘要。

## 加密原语

这种加密原语的分类可以如图所示：

![加密原语](img/B05975_03_18.jpg)

加密原语

## 散列函数

哈希函数用于将任意长的输入字符串创建为固定长度的摘要。哈希函数是无密钥的，提供数据完整性服务。它们通常使用迭代和专用哈希函数构建技术构建。各种哈希函数族可用，如 MD、SHA1、SHA-2、SHA-3、RIPEMD 和 Whirlpool。哈希函数通常用于数字签名和消息认证码，如 HMACs。它们有三个安全性质，即原像抗性、第二原像抗性和碰撞抗性。这些性质稍后在本节中解释。

**哈希函数**通常用于提供数据完整性服务。这些可以用作单向函数，并构造其他加密原语，如 MAC 和数字签名。一些应用程序使用哈希函数来生成**伪随机数**（**PRNGs**）。哈希函数不需要密钥。哈希函数必须满足两个实用和三个安全性质，具体取决于完整性的要求级别。

### 将任意消息压缩为固定长度摘要

这个特性与一个哈希函数必须能够接受任意长度的长输入文本并输出一个固定长度的压缩消息有关。哈希函数产生各种位大小的压缩输出，通常在 128 位和 512 位之间。

### 易于计算

哈希函数是高效快速的单向函数。要求是无论消息大小如何，都要非常快速计算。如果消息太大，效率可能会降低，但函数仍然应足够快速以供实际使用。

在下一节中，讨论了哈希函数的安全性质。

### 原像抗性

考虑一个方程式：

*h(x) = y*

这里，*h*是哈希函数，*x*是输入，*y*是哈希。第一个安全性质要求 *y* 不能被反向计算为 *x*。*x* 被认为是 *y* 的 *原像*，因此称为原像抗性。这也称为单向属性。

### 第二原像抗性

这个特性要求给定 *x* 和 *h(x)*，几乎不可能找到任何其他消息 *m*，其中 *m != x* 且 *m* 的哈希等于 *x* 的哈希。*h(m) = h(x)*。这个属性也被称为弱碰撞抗性。

### 碰撞抗性

这个特性要求两个不同的输入消息不应该哈希到相同的输出。换句话说，*h(x) != h(z)*。这个属性也被称为强碰撞抗性。

由于其本质，哈希函数始终会有一些碰撞，即两个不同的消息哈希到相同的输出，但它们应该是计算上不可行的。所有哈希函数中都希望存在一种称为**雪崩效应**的概念。雪崩效应指的是在输入文本中进行小改变，甚至是一个单字符的改变，都会导致完全不同的哈希输出。

哈希函数通常是按照迭代哈希函数方法设计的。在这种方法中，输入消息按块压缩多轮，以产生压缩的输出。一种流行的迭代哈希函数类型是 Merkle-Damgard 构造。这种构造基于将输入数据分成相等大小的块的想法，然后以迭代方式将它们通过压缩函数馈送。压缩函数的碰撞抵抗性确保了哈希输出也是抗碰撞的。压缩函数可以使用块密码构建。除了 Merkle-Damgard 外，研究人员还提出了各种其他压缩函数构造，例如，*Miyaguchi-Preneel*和*Davies-Meyer*。

有多个哈希函数类别。您将在接下来的部分介绍这些类别。

### 消息摘要（MD）

消息摘要函数在 20 世纪 90 年代初非常流行。MD4 和 MD5 是该类别的成员。两个 MD 函数都被发现不安全，不建议再使用。MD5 是一个 128 位哈希函数，通常用于文件完整性检查。

### 安全哈希算法（SHAs）

**SHA-0**：这是由 NIST 在 1993 年引入的 160 位函数。

**SHA-1**：SHA-1 后来由 NIST 作为 SHA-0 的替代品引入。这也是一个 160 位的哈希函数。SHA-1 在 SSL 和 TLS 实现中常用。值得注意的是，SHA-1 现在被认为是不安全的，并且正在被证书颁发机构弃用。现在不鼓励在任何新的实现中使用它。**SHA-2**：此类别包括根据哈希位数定义的四个函数：SHA-224、SHA-256、SHA-384 和 SHA-512。

**SHA-3**：这是最新的 SHA 函数系列。SHA3-224、SHA3-256、SHA3-384 和 SHA3-512 是这个系列的成员。SHA3 是 Keccak 的 NIST 标准版本。Keccak 采用了一种称为*海绵构造*的新方法，而不是常用的 Merkle-Damgard 转换。

**RIPEMD**：RIPEMD 是*RACE 完整性基元评估消息摘要*的首字母缩写。它基于构建 MD4 所使用的设计思想。RIPEMD 有多个版本，包括 128 位、160 位、256 位和 320 位。

**Whirlpool**：这是基于 Rijndael 密码的修改版本 W。它使用 Miyaguchi-Preneel 压缩函数，这是一种用于将两个固定长度输入压缩为单个固定长度输出的单向函数类型。它是一个单块长度压缩函数：

![安全哈希算法（SHAs）](img/B05975_03_19.jpg)

哈希函数的三个安全性质

哈希函数有许多实际应用范围，从简单的文件完整性检查和密码存储到在加密协议和算法中使用。它们用于哈希表、分布式哈希表、布隆过滤器、病毒指纹、点对点 P2P 文件共享等许多其他应用。

在区块链中，哈希函数起到非常重要的作用。特别是，工作量证明函数使用 SHA-256 两次来验证矿工所花费的计算工作量。RIPEMD 160 用于产生比特币地址。这将在后面的章节中进行更详细的讨论。

#### 安全哈希算法（SHA）的设计

在下一节中，你将了解到 SHA-256 和 SHA-3 的设计。这两者分别用于比特币和以太坊。以太坊不使用 NIST 标准的 SHA-3，而是原始算法 Keccak，这个算法被提交给 NIST。然后经过一些修改，如增加轮数和简化消息填充，Keccak 被 NIST 标准化为 SHA-3。

#### SHA-256

SHA-256 具有输入消息大小<2⁶⁴ 位。块大小为 512 位，字长为 32 位。输出为 256 位摘要。

压缩函数处理一个 512 位消息块和一个 256 位中间哈希值。该函数的两个主要组成部分是压缩函数和消息调度表。

算法工作如下：

+   预处理：

    1.  对消息进行填充，以使块长度为 512 位，如果小于所需的 512 位块大小。

    1.  将消息解析成消息块，以确保消息及其填充被分成大小相等的 512 位块。

    1.  设置初始哈希值，即通过取前八个质数的平方根的小数部分的前 32 位获得的八个 32 位字。这些初始值是随机选择的，以初始化过程并给予算法中不存在后门的信心级别。

+   哈希计算：

    1.  每个消息块按顺序处理，并需要 64 轮才能计算出完整的哈希输出。每轮使用略有不同的常数，以确保没有两轮是相同的。

    1.  首先，准备消息调度表。

    1.  然后，初始化八个工作变量。

    1.  然后，计算中间哈希值。

    1.  最后，处理消息并产生输出哈希：![SHA-256](img/B05975_03_20.jpg)

        SHA 256 压缩函数的一轮

在前面的图表中，*a*、*b*、*c*、*d*、*e*、*f*、*g*和*h*是寄存器。 **Maj** 和 **Ch** 会进行按位操作。 ![SHA-256](img/image_03_048.jpg) 进行按位旋转。轮常数为 **W[j]** 和 **K[j]**，它们被加上 *mod 2³²*。

#### SHA3（Keccak）的设计

SHA-3 的结构与通常的 SHA-1 和 SHA-2 非常不同。SHA-3 背后的关键思想是基于非键控置换，而不是其他常见哈希函数的结构使用键控置换。Keccak 也不使用 Merkle-Damgard 转换来处理哈希函数中的任意长度输入消息，这是常用的。Keccak 使用了一种称为海绵和挤压构造的新方法，基本上是一个随机置换模型。SHA3 的不同变体已经标准化，例如 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128 和 SHAKE256。SHAKE128 和 SHAKE256 是可扩展输出函数，也是由`NIST.XOF`函数标准化的，允许将输出扩展到任意所需长度。

以下图示显示了 SHA3 或 Keccak 基础的海绵和挤压模型。类比于海绵，首先，数据在应用填充后被吸收到海绵中，然后使用 XOR 将其转换为置换状态的子集，然后将输出从表示转换后状态的海绵函数中挤压出来。速率是海绵函数的输入块大小，而容量确定了通用安全级别：

![SHA3（Keccak）的设计](img/B05975_03_21.jpg)

SHA3 中的吸收和挤压函数

#### OpenSSL 哈希函数示例

以下命令将使用 SHA256 算法对 Hello 消息产生 256 位的哈希：

```
:~/Crypt$ echo -n 'Hello' | openssl dgst -sha256
(stdin)= 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969

```

注意即使是文本中的微小变化，比如更改*H*的大小写，也会导致输出哈希的巨大变化。这被称为*雪崩效应*，如前所述：

```
:~/Crypt$ echo -n 'hello' | openssl dgst -sha256
(stdin)= 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824

```

注意，两个输出完全不同：

```
Hello: 18:5f:8d:b3:22:71:fe:25:f5:61:a6:fc:93:8b:2e:26:43:06:ec:30:4e:da:51:80:07:d1:76:48:26:38:19:69
hello: 2c:f2:4d:ba:5f:b0:a3:0e:26:e8:3b:2a:c5:b9:e2:9e:1b:16:1e:5c:1f:a7:42:5e:73:04:33:62:93:8b:98:24

```

#### 消息认证码（MACs）

MACs 有时被称为密钥哈希函数，可以用来提供消息完整性和认证。换句话说，它们用于提供数据源认证。这些是使用发送方和接收方之间的共享密钥的对称加密基元。MACs 可以使用块密码或哈希函数构造。

#### 使用块密码的 MACs

在这种方法中，块密码以**密码块链接模式**（**CBC 模式**）的方式用于生成 MAC。任何块密码-例如，在 CBC 模式下的 AES-都可以使用。消息的 MAC 实际上是 CBC 操作的最后一轮的输出。MAC 输出的长度与用于生成 MAC 的块密码的块长度相同。MAC 可以通过计算消息的 MAC 并将其与接收到的 MAC 进行比较来简单验证。如果它们相同，则确认消息完整性；否则，消息被视为已更改。还应注意，MAC 类似于数字签名，但由于它们的对称性质，它们无法提供不可否认的服务。

#### HMACs（基于哈希的消息认证码）

与哈希函数类似，它们产生固定长度的输出并以任意长的消息作为输入。在这个方案中，发送方使用 MAC 对消息进行签名，接收方使用共享密钥进行验证。密钥使用两种方法之一，即秘密前缀或秘密后缀方法与消息进行散列。在第一种方法中，密钥与消息连接在一起，即密钥在前，消息在后，而在后一种方法中，密钥在消息之后：

*秘密前缀：M = MACk(x) = h(k||x)*

*秘密后缀：M=MACk(x) = h(x||k)*

这两种方法各有优缺点。已经发现了对这两种方案的一些攻击。有 HMAC 构造方案使用各种技术，例如研究人员提出的 **ipad** 和 **opad**（内部填充和外部填充），在某些假设下被认为是安全的：

![HMAC（基于哈希的消息认证码）](img/B05975_03_22.jpg)

MAC 函数的操作

### Merkle 树

Merkle 树的概念是由 *Ralph Merkle* 提出的。这里展示了 Merkle 树的可视化，这使得理解变得容易。Merkle 树允许对大型数据集进行安全高效的验证。

它是一种二叉树，首先，输入被放置在叶子节点（没有子节点的节点），然后对子节点的值进行哈希以产生父节点（内部节点）的值，直到获得单个哈希值，称为 Merkle 根：

![Merkle 树](img/B05975_03_23.jpg)

Merkle 树

### Patricia 树

要了解 Patricia 树，首先，你将被介绍到 **trie** 的概念。Trie 或数字树是一种用于存储数据集的有序树数据结构。

**Practical Algorithm to Retrieve Information Coded in Alphanumeric** (**Patricia**)，也称为基数树，是 trie 的一种紧凑表示，在此树中，作为父节点的唯一子节点与其父节点合并。

**Merkle-Patricia 树**，基于 Patricia 和 Merkle 的定义，是一棵树，其中根节点包含整个数据结构的哈希值。

### 分布式哈希表 (DHTs)

哈希表是一种用于将键映射到值的数据结构。内部使用哈希函数计算到桶数组的索引，从中可以找到所需的值。桶使用哈希键存储记录，并按特定顺序组织。

在前面提供的定义的基础上，人们可以将分布式哈希表看作是一种数据结构，在这种数据结构中，数据分布在各个节点上，节点相当于点对点网络中的桶。

以下图表直观展示了分布式哈希表的工作原理。该示例显示数据通过哈希函数传递，生成一个紧凑的键。此键然后与对等网络上的数据（值）关联。当网络上的用户请求数据（通过文件名）时，文件名可以再次进行哈希以生成相同的键，然后可以请求网络上的任何节点来查找相应的数据。DHT 提供了去中心化、容错性和可伸缩性：

![分布式哈希表（DHTs）](img/B05975_03_24.jpg)

分布式哈希表

### 数字签名

数字签名提供了一种将消息与产生消息的实体相关联的手段。数字签名用于提供数据的来源认证和不可否认性。它们经过两个步骤计算。RSA 数字签名方案的高级步骤如下所示：

1.  计算数据包的哈希值。这将提供数据完整性保证，因为哈希可以在接收者端重新计算并与原始哈希匹配，以检查数据是否在传输过程中被修改。从技术上讲，消息签名可以在不先对数据进行哈希的情况下工作，但这并不被认为是安全的。

1.  第二步将哈希值用签名者的私钥签名。由于只有签名者拥有私钥，所以保证了签名和签名数据的真实性。

数字签名具有一些重要属性，例如真实性、不可伪造性和不可复用性。真实性意味着数字签名可被接收方验证。不可伪造性确保只有消息的发送者才能使用私钥使用签名功能。换句话说，其他人不应该能够产生由合法发送者生成的签名消息。不可复用性意味着数字签名不能从一条消息中分离并再次用于另一条消息。

通用数字签名函数的操作显示在以下图表中：

![数字签名](img/B05975_03_25.jpg)

数字签名（左）和验证过程（右）的运作（RSA 数字签名示例）

如果发送方想要向接收方发送一个经过认证的消息，可以使用两种方法。这里介绍了使用数字签名和加密的两种方法。

#### 先签名后加密

在此方法中，发送方使用私钥对数据进行数字签名，将签名附加到数据上，然后使用接收方的公钥加密数据和数字签名。与接下来描述的先加密再签名方案相比，这被认为是一种更安全的方案。

#### 先加密后签名

在此方法中，发送方使用接收方的公钥加密数据，然后对加密数据进行数字签名。

### 注意

实际上，包含数字签名的数字证书是由将公钥与身份关联起来的**证书颁发机构**（**CA**）颁发的。

在实践中使用各种方案，如 RSA、数字签名算法和基于椭圆曲线的数字签名算法。RSA 是最常用的；然而，随着椭圆曲线密码学的推动，基于 ECDSA 的方案也变得非常流行。

在这里详细描述了 ECDSA 方案。

## 椭圆曲线数字签名算法（ECDSA）

为了使用 ECDSA 方案签名和验证，需要首先生成第一对密钥：

1.  首先，定义一个椭圆曲线 *E*：

    1.  与模数 *P*。

    1.  系数 *a* 和 *b*。

    1.  形成素数阶循环群的生成点 *A*。

1.  随机选择一个整数 *d*，使得 *0 < d < q*。

1.  计算公钥 *B* 使得 *B = d A*。

公钥是形式为以下内容的六元组：

Kpb = (p,a,b,q,A,B)

私钥在步骤 2 中随机选择 *d*：

Kpr = d

现在可以使用私钥和公钥生成签名。

1.  首先，选择一个临时密钥 *Ke*，其中 *0 < Ke < q*。必须确保 *Ke* 是真正随机的，并且没有两个签名具有相同的密钥；否则，可以计算出私钥。

1.  使用 *R = Ke A* 计算另一个值 *R*，即通过将 *A*（生成点）和随机临时密钥相乘得到。

1.  使用 *x* 坐标值初始化变量 *r*。*r = xR*。

1.  签名可以按如下方式计算：![椭圆曲线数字签名算法（ECDSA）](img/B05975_02-1.jpg)

在这里，*m* 是正在计算签名的消息，*h(m)* 是消息 *m* 的哈希值。

遵循此过程执行签名验证。

1.  计算辅助值 w，如 *w = s^(-1)mod q*。

1.  辅助值 *u1 = w. h(m) mod q*。

1.  辅助值 *u2 = w. r mod q*。

1.  计算点 *P*，*P = u1A + u2B*。

1.  验证如下进行。

1.  如果在第 4 步中计算得到的点 *P* 的 x 坐标与签名参数 *r mod q* 的值相同，则 *r*, *s* 被接受为有效签名。

    即：

    *Xp = r mod q 意味着有效签名*

    *Xp != r mod q 意味着无效签名*

这里显示了各种实际示例，展示了如何使用 OpenSSL 生成、使用和验证 RSA 数字签名。

### 如何生成数字签名

第一步是生成消息文件的哈希值：

```
:~/Crypt$ openssl dgst -sha256 message.txt
SHA256(message.txt)= eb96d1f89812bf4967d9fb4ead128c3b787272b7be21dd2529278db1128d559c

```

生成哈希值和签名可以一步完成，如下所示。注意，`privatekey.pem`是在之前的步骤中生成的：

```
:~/Crypt$ openssl dgst -sha256 -sign privatekey.pem -out signature.bin message.txt

```

现在让我们显示显示相关文件的目录：

```
:~/Crypt$ ls -ltr
total 36
-rw-rw-r-- 1 drequinox drequinox  14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox  32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox  45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox  32 Sep 21 06:16 message.ptx
-rw-rw-r-- 1 drequinox drequinox 916 Sep 21 06:28 privatekey.pem
-rw-rw-r-- 1 drequinox drequinox 272 Sep 21 06:30 publickey.pem
-rw-rw-r-- 1 drequinox drequinox 128 Sep 21 06:43 message.rsa
-rw-rw-r-- 1 drequinox drequinox  14 Sep 21 06:49 message.dec
-rw-rw-r-- 1 drequinox drequinox 128 Sep 21 07:05 signature.bin
:~/Crypt$ cat signature.bin

```

![如何生成数字签名](img/B05975_03_55.png)

为了验证签名，可以执行以下操作：

```
:~/Crypt$ openssl dgst -sha256 -verify publickey.pem -signature signature.bin message.txt
Verified OK
:~/Crypt$

```

同样，如果使用了不合法的其他签名文件，验证将失败，如下所示：

```
:~/Crypt$ openssl dgst -sha256 -verify publickey.pem -signature someothersignature.bin message.txt
Verification Failure

```

您现在将看到一个示例，展示了如何使用 OpenSSL 执行与 ECDSA 相关的操作。

### 使用 OpenSSL 进行 ECDSA

首先，使用以下命令生成私钥：

```
~/Crypt$ openssl ecparam -genkey -name secp256k1 -noout -out eccprivatekey.pem 
~/Crypt$ cat eccprivatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIMVmyrnEDOs7SYxS/AbXoIwqZqJ+gND9Z2/nQyzcpaPBoAcGBSuBBAAK
oUQDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPwNRo/k4Y/CZA4pXvlyTgH5LYm
QbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END EC PRIVATE KEY-----

```

现在，公钥是由私钥生成的：

```
~/Crypt$ openssl ec -in eccprivatekey.pem -pubout -out eccpublickey.pem
read EC key
writing EC key
~/Crypt$ cat eccpublickey.pem
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPw
NRo/k4Y/CZA4pXvlyTgH5LYmQbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END PUBLIC KEY-----
~/Crypt$

```

现在假设需要对名为`testsign.txt`的文件进行签名和验证。可以按照以下步骤实现：

1.  创建一个测试文件：

    ```
    ~/Crypt$ echo testing > testsign.txt
    ~/Crypt$ cat testsign.txt
    testing

    ```

1.  运行以下命令，使用私钥为`testsign.txt`文件生成签名：

    ```
    ~/Crypt$ openssl dgst -ecdsa-with-SHA1 -sign eccprivatekey.pem     
            testsign.txt > ecsign.bin

    ```

1.  最后，验证命令可以按照这里所示运行：

    ```
    ~/Crypt$ openssl dgst -ecdsa-with-SHA1 -verify eccpublickey.pem   
            -signature ecsign.bin testsign.txt
    Verified OK

    ```

也可以使用之前生成的私钥生成证书：

```
~/Crypt$ openssl req -new -key eccprivatekey.pem -x509 -nodes -days 365 -out ecccertificate.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:GB
State or Province Name (full name) [Some-State]:Cambridge
Locality Name (eg, city) []:Cambridge
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dr.Equinox!
Organizational Unit Name (eg, section) []:NA
Common Name (e.g. server FQDN or YOUR name) []:drequinox
Email Address []:drequinox@drequinox.com

```

可以使用以下命令来查看证书：

```
~/Crypt$ openssl x509 -in ecccertificate.pem -text -noout

```

![使用 OpenSSL 进行 ECDSA](img/image_03_057.jpg)

使用 SHA-256 的 ECDSA 算法的 X509 证书

这里介绍了与区块链相关或未来区块链生态系统潜在使用相关的密码学其他主题。

### 同态加密

通常，公钥密码系统（如 RSA）是乘法同态或加法同态的，比如派列尔密码系统，称为**部分同态**系统。加法同态系统适用于电子投票和银行业务应用。直到最近，没有支持两种操作的系统，但在 2009 年，*Craig Gentry*发现了一个**完全同态**系统。由于这些方案允许对加密数据进行处理而无需解密，它们有许多不同的可能应用，特别是在需要保护隐私但数据也需要由潜在不受信任的方进行处理的场景，例如，云计算和在线搜索引擎。同态加密的最新发展非常有前景，研究人员正在积极努力使其更加高效和实用。这在区块链技术中特别感兴趣，如后面的书中所述，因为它可以解决区块链中的机密性和隐私问题。

### 签名加密

签名加密是一种公钥密码学原语，提供了数字签名和加密的所有功能。它是由*Yuliang Zheng*发明的，现已成为 ISO 标准 ISO/IEC 29150:2011\. 传统上，签名然后加密或先加密后签名方案用于提供不可伪造性，认证和不可否认性，但是使用签名加密，数字签名和加密的所有服务都是在成本低于先签名后加密方案的情况下提供的。

这是**成本（签名和加密） << 成本（签名）+ 成本（加密）**的单一逻辑步骤。

### 零知识证明

零知识证明是由*GoldWasser*，*Micali*和*Rackoff*引入的。这些证明用于证明关于一个断言的有效性而毫无关于该断言的任何信息。零知识证明需要满足完整性，准确性和零知识性等三个属性。

完整性确保如果某个断言为真，则验证者将被证明者说服。完备性属性确保如果一个断言为假，则没有不诚实的证明者能够说服验证者相反。零知识属性，顾名思义，是零知识证明的关键属性，它确保关于断言除了它是真还是假之外绝对不会透露任何信息。

零知识证明在区块链领域引起了研究人员的特别关注，因为其隐私属性在金融和许多其他领域（如法律和医学）中非常受欢迎。零知识证明机制成功实现的一个最新例子是 Zcash 加密货币。在 Zcash 中，实现了一种特定类型的零知识证明，称为**零知识简洁非交互知识证明**（**ZK-Snark**）。这将在第五章 *替代币*中详细讨论。

### 盲签名

盲签名是由*大卫·朱姆*在 1982 年提出的，基于公钥数字签名方案，如 RSA。盲签名背后的关键思想是让签名者签署消息而不实际透露消息内容。这是通过在签署之前掩盖或盲化消息来实现的，因此得名盲签名。这种盲签名随后可以像普通数字签名一样针对原始消息进行验证。盲签名被引入作为允许数字货币方案发展的机制。

### 编码方案

除了加密原语外，二进制到文本编码方案在各种场景中也被使用。最常见的用法是将二进制数据转换为文本，以便可以通过不支持处理二进制数据的协议进行处理、保存或传输。例如，有时，图像以 base64 编码的形式存储在数据库中，这允许文本字段能够存储图片。一个常用的编码方案是 base64。另一个名为 base58 的编码方案因其在比特币中的使用而广受欢迎。

密码学是一个广阔的领域，本节介绍了从一般密码学到区块链和加密货币的角度理解密码学所必需的基本概念。在下一节中，您将介绍基本的金融市场概念。

即将到来的部分描述了关于交易、交易所和交易生命周期的一般术语。更多相关信息将在后面的章节中提供，讨论具体的用例。

# 金融市场和交易

金融市场的存在是为了促进储蓄者向投资者的转移。在经济体系中，有两个部门，即家庭和企业。金融市场在本质上充当储蓄者和投资者之间的中介。基本上有三种类型的市场，即货币市场、信贷市场和资本市场。货币市场是短期市场，资金被借给公司或银行进行银行间贷款。外汇市场或 FX 是另一种货币市场的类别，其中货币进行交易。信贷市场主要由零售银行组成，他们从中央银行借款，然后以抵押贷款或贷款的形式将其贷给公司或家庭。

资本市场促进金融工具的买卖，主要是股票和债券。资本市场可分为两种类型，即一级市场和二级市场。股票是公司直接向投资者发行的，而在二级市场，投资者通过证券交易所将其证券转售给其他投资者。各种电子交易系统被交易所用来促进金融工具的交易。

## 交易

市场是交易员进行交易的地方。它可以涵盖各种资产类别。

交易可以定义为交易员购买或出售各种金融工具以获取利润和对冲风险的活动。投资者、借款人、套保者、资产交换者和赌徒是交易员的几种类型。当交易员欠款时，他们持有空头头寸，例如，如果他们卖出了一份合同，而当他们购买一份合同时，他们持有多头头寸。有各种方式进行交易，例如通过经纪人或直接在交易所或场外进行交易。经纪人是为客户安排交易的代理人。经纪人代表客户以给定价格或以最佳可能价格进行交易。

## 交易所

交易所通常被认为是一个非常安全、受监管和可靠的交易场所。最近，与传统的基于交易大厅的交易相比，电子交易越来越受欢迎。现在，交易员将订单发送到中央电子订单簿，然后通过通信网络将订单、价格和相关属性发布到所有关联系统，从而实质上创建了一个虚拟市场。只有交易所的成员才能进行交易。为了在没有这些限制的情况下进行交易，交易对手可以直接参与场外交易。

### 订单和订单属性

订单是交易的指令，是交易系统的主要组成部分。它们具有以下一般属性：

1.  工具名称。

1.  数量。

1.  方向（买或卖）。

1.  代表各种条件的订单类型，例如，限价订单和止损订单，例如 1500 股英国苏格兰皇家银行普通股，价格为 15.50 英镑。

订单是根据买入价和卖出价进行交易的。交易员通过将买入价和卖出价附加到其订单上来表明他们的买入或卖出意向。交易员将购买的价格称为买入价。交易员愿意出售的价格称为卖出价。

### 订单管理和路由系统

订单路由系统根据业务逻辑将订单路由并发送到不同的目的地。客户使用它们将订单发送给他们的经纪人，然后经纪人将这些订单发送给经销商、结算所和交易所。

有不同类型的订单；最常见的两种是市价订单和限价订单。市价订单是以市场当前最佳价格交易的指令，这些订单立即以现货价格填补。另一方面，限价订单是以最佳价格交易的指令，但只有在不低于交易员设置的限价时才能进行交易。这也可能更高，这取决于订单的方向，即买入或卖出。所有这些订单都在订单簿中管理，订单簿是交易所维护的订单列表，记录交易员的买卖意向。

仓位是承诺以给定价格出售或购买一定数量的金融工具，例如证券、货币或商品。交易员买卖的合同、证券、商品和货币通常被称为交易工具，并归入资产类别的大伞下。最常见的类别包括实物资产、金融资产、衍生合同和保险合同。

### 交易的组成部分

交易单是与交易相关的所有细节的组合。然而，根据工具和资产类别的不同，可能会有一些变化，但一般来说，所有工具都具有下一节讨论的属性。

### 注意

**基础工具**

基础工具是交易的基础。它可以是货币、债券、利率、商品或股票。

### 一般属性

这包括与每笔交易相关的一般识别信息和基本特征。常见属性包括唯一 ID、工具名称、类型、状态、交易日期和时间。

### 经济

这些是与交易价值相关的特征，例如买入或卖出价值、标记、交易所、价格和数量。

### 销售

销售指的是与销售特征相关的详细信息，例如销售人员的姓名，它只是一个信息字段，通常不会对交易生命周期产生任何影响。

### 交易对手方

交易对手方是交易的重要组成部分，因为它显示交易的另一方，并且需要成功结算交易。通常的属性包括交易对手方名称、地址、付款类型、任何参考 ID、结算日期和交付类型。

## 交易生命周期

一般的交易生命周期包括从下单到执行再到结算的各个阶段。这个生命周期将逐步描述如下：

+   **执行前**：在这个阶段下达订单。

+   **执行和预订**：当订单匹配并执行时，它就转变为一笔交易。在这个阶段，双方之间的合同就正式成熟。

+   **确认**：这是双方同意交易细节的阶段。

+   **预定后**：这个阶段涉及各种审核和验证过程，以确保交易的正确性。

+   **结算**：这是交易过程中最关键的部分，此时交易已经最终确定。

+   **隔夜（日终处理）**：日终处理包括报告生成、盈亏计算和各种风险计算。

+   在所有提到的流程中，都涉及许多人员和业务功能。通常，这些功能被划分为前台、中台和后台等功能。

在接下来的章节中，你将了解一些概念，这些概念对于理解监管金融行业的严格和必要规则和法规至关重要。一些概念在此处描述，而在后续章节中将讨论特定用例，这些想法将帮助你理解描述的场景。

## 订单预期者

订单预期者试图在其他交易员能够进行交易之前获利。这基于一种预期，其中交易员知道其他交易活动将如何影响价格。抢先者、情绪导向的技术交易者和挤压者都是订单预期者的一些示例。

## 市场操纵

在英国和其他国家，市场操纵是严格违法的。欺诈交易员可能在市场中传播虚假信息，导致价格波动，从而获得非法利润。通常，操纵市场行为是以交易为基础的，其中包括普遍和特定时间的操纵。可能导致人为股票短缺、虚假活动印象和价格操纵以获得犯罪利益的行动都包括在这一类别中。

之前讨论的这两个术语与金融犯罪相关。并且有可能开发基于区块链的系统来阻止市场滥用。这将在后续章节中详细讨论，特定用例将在那时讨论。

# 总结

本章旨在介绍密码学和金融市场的概念，以便为您理解后续章节中提供的材料提供背景信息。首先，您被介绍了密码学的基础知识，然后介绍了各种方案，如对称和非对称密码。通过使用 OpenSSL 命令行展示了一些实际示例，以便您可以尝试各种命令并第一手体验各种密码功能。此外，在本章开头提供了一些数学背景知识，特别是椭圆曲线密码学。本章介绍的所有密码学概念都与区块链技术相关，并已实施或已提出在各种区块链、加密货币和相关生态系统中实施。此外，您还对金融行业进行了简要介绍，因为它为稍后在本书中与分布式分类账技术相关的各种示例设定了背景。由于密码学和金融是广泛的主题，本章涵盖的材料旨在是入门性质的（有一些例外情况），特定主题将在后续章节中在相关和必要时进行更详细的扩展。
