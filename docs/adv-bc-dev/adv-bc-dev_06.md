# 第六章：公钥密码

在本章中，您将了解公钥密码的概念和实际应用，也称为非对称加密或非对称密钥密码。我们将继续使用 OpenSSL，就像在前一章中所做的那样，来实验一些密码算法的应用，以便您能够获得实践经验。我们将从公钥密码的理论基础开始，逐渐建立相关的实践练习。此外，我们还将研究哈希函数，这是区块链中广泛使用的另一个密码原语。之后，我们将介绍一些新的、先进的密码构造。

# 非对称加密

**非对称加密**指的是一种密码学类型，其中用于加密数据的密钥与用于解密数据的密钥不同。这也被称为**公钥密码**。它分别使用公钥和私钥进行数据的加密和解密。目前使用各种非对称加密方案，包括 RSA、DSA 和 ElGammal。

以下图表显示了公钥密码的概述：

![](img/b7af59a8-4995-4bc5-8961-ec9fd8ec62ac.jpg)

使用公/私密钥进行加密/解密

前图说明了发送方如何使用接收者的公钥和加密函数**E**将数据**P**进行加密，产生一个输出为加密数据**C**，然后通过网络传输给接收者。一旦到达接收者，可以使用接收者的私钥将加密数据**C**输入函数**D**中进行解密，将输出纯文本**P**。这样，私钥保留在接收方手中，无需共享密钥即可进行加密和解密，这是对称加密的情况。

以下图表显示了接收者如何使用公钥密码来验证接收到的消息的完整性。在这个模型中，发送方使用他们的私钥对数据进行签名，并将消息传输给接收方。一旦消息被接收，发送方的公钥就会验证其完整性。

值得注意的是，在这个模型中没有进行加密操作。这里只是为了帮助你充分理解本章后面涵盖的消息认证和验证部分：

![](img/a47c83d3-ffb8-416d-b187-09451a09a1b8.jpg)

公钥密码签名方案模型

前图显示了发送方如何使用签名函数**S**用他的私钥对明文**P**进行数字签名，并产生数据**C**，发送给接收者，接收者使用发送方的公钥和函数**V**来验证**C**，以确保消息确实来自发送方。

公钥密码系统提供的安全机制包括密钥建立，数字签名，身份验证，加密和解密。

**密钥建立机制**关注的是设计允许在不安全通道上设置密钥的协议。 在许多场景中，不可否认的服务是一种非常理想的属性，可以使用**数字签名**提供。 有时，不仅要对用户进行身份验证，还要识别涉及交易的实体也很重要。 这也可以通过数字签名和**挑战-响应协议**的组合来实现。 最后，提供机密性的加密机制也可以使用公钥密码系统获得，例如 RSA、ECC 和 ElGammal。

公钥算法在计算方面比对称密钥算法慢。 因此，它们不常用于加密大文件或需要加密的实际数据。 通常用于交换对称算法的密钥。 一旦安全地建立了密钥，就可以使用对称密钥算法对数据进行加密。

公钥密码算法基于各种基础数学函数。 这里描述了三种主要的非对称算法类别。

# 整数因子分解

**整数因子分解方案**基于大整数很难因子分解的事实。 RSA 是这种类型算法的典型示例。

# 离散对数

**离散对数方案**基于模算术中的一个问题。 计算模函数的结果很容易，但是找到生成器的指数是计算上不可行的。 换句话说，从结果中找到输入是极其困难的。 这是一个单向函数。

例如，考虑以下方程：

*3² mod 10 = 9*

现在，给定*9*，是前面方程中发现的结果，其指数为前面问题中的生成器*3*，这是极难确定的。 这个困难的问题通常在 Diffie-Hellman 密钥交换和数字签名算法中使用。

# 椭圆曲线

**椭圆曲线算法**基于前面讨论的离散对数问题，但是在椭圆曲线的上下文中。 **椭圆曲线**是一个代数立方曲线，可以由以下方程定义。 曲线是非奇异的，这意味着它没有尖点或自交点。 它有两个变量*a*和*b*，以及一个无穷远点。

![](img/64ca3d25-c233-4be3-8f6a-fb9b31a04dac.jpg)

在这里，*a*和*b*是整数，其值是定义椭圆曲线的域上的元素。 椭圆曲线可以在实数、有理数、复数或有限域上定义。 为了加密目的，使用素数有限域上的椭圆曲线，而不是实数。 此外，素数应大于 3。 通过改变*a*和/或*b*的值可以生成不同的曲线。

基于椭圆曲线的最显著使用的加密系统是**椭圆曲线数字签名算法**(**ECDSA**)和**椭圆曲线迪菲-赫尔曼**(**ECDH**)密钥交换。

要理解公钥密码学，需要探讨的关键概念是公钥和私钥。

# 公钥和私钥

**私钥**，顾名思义，是用户随机生成并保密的数字。私钥需要受到保护，不得未经授权访问；否则，公钥密码的整个方案都会受到威胁，因为这是用于解密消息的密钥。私钥可以根据使用的算法的类型和类别的不同长度而不同。例如，在 RSA 中，通常使用 1024 位或 2048 位的密钥。1024 位密钥大小不再被认为是安全的，建议至少使用 2048 位密钥大小。

**公钥**是由私钥所有者免费提供并发布的。此后任何希望向公钥发布者发送加密消息的人都可以使用公开的公钥对消息进行加密并将其发送给私钥持有人。其他人无法解密消息，因为相应的私钥被拟定的接收方安全地持有。收件人收到具有公钥加密的消息后，可以使用私钥解密消息。然而，公钥存在一些问题，包括公钥发布者的真实性和身份识别。

在下一节中，我们将介绍两个非对称密钥密码学的例子：RSA 和 ECC。RSA 是公钥密码学的第一个实现，而 ECC 广泛用于区块链技术。

# RSA

**RSA**是由 Ron Rivest，Adi Shamir 和 Leonard Adelman 在 1977 年发明的，因此被称为**Rivest–Shamir–Adleman** (**RSA**)。这种公钥密码学基于整数分解问题，其中两个大素数的乘法很容易，但将其（乘法结果，积）分解回两个原始数字很困难。

与 RSA 算法相关的工作要点是在密钥生成过程中。RSA 密钥对通过执行以下步骤生成：

1.  **模数生成**:

+   +   选择*p*和*q*，它们是非常大的质数

    +   将*p*和*q*相乘，*n=p.q*生成模数*n*

1.  **生成互质**:

+   +   假设一个称为*e*的数字。

    +   *e*应满足某种条件；即，它应大于*1*且小于*(p-1) (q-1)*。换句话说，*e*必须是这样一个数字，除了*1*之外没有任何其他数字可以整除*e*和*(p-1) (q-1)*。这被称为**互素**，也就是*e*是*(p-1) (q-1)*的互素。

1.  **生成公钥**:

步骤 1 生成的模数和步骤 2 生成的互质 *e* 构成了一对共同的公钥。这部分是可以与任何人共享的公共部分；然而，*p* 和 *q* 需要保密。

1.  **生成私钥**：

这里称为 *d* 的私钥是从 *p*、*q* 和 *e* 计算得出的。私钥基本上是 *e 模 (p-1) (q-1)* 的倒数。用方程表示如下：

*ed = 1 mod (p-1) (q-1)*

通常，扩展欧几里得算法用于计算 *d*。该算法接受 *p*、*q* 和 *e*，并计算 *d*。这种方案的关键思想是，任何知道 *p* 和 *q* 的人都可以通过应用扩展欧几里得算法轻松计算出私钥 *d*。然而，不知道 *p* 和 *q* 值的人无法生成 *d*。这也意味着 *p* 和 *q* 应该足够大，使得模数 *n* 因子分解变得极其困难（计算上不可行）。

# 使用 RSA 进行加密和解密

RSA 使用以下方程产生密文：

*C = P**^e* *mod n*

这意味着明文 *P* 被提升到 *e* 次方，然后对模 *n* 进行了缩减。RSA 中的解密由以下方程提供：

*P = C*^(*d*) *mod n*

这意味着拥有公钥对（*n*，*e*）的接收方可以通过将 *C* 提升到私钥 *d* 的值并减少到模 *n* 来解密数据。

# 椭圆曲线密码学

**椭圆曲线密码学**（**ECC**）基于有限域上的椭圆曲线离散对数问题（伽罗华域）。ECC 相对于其他类型的公钥算法的主要优点是，它需要更小的密钥大小，同时提供与 RSA 等算法相同级别的安全性。源自 ECC 的两个值得注意的方案是用于密钥交换的 ECDH 和用于数字签名的 ECDSA。

ECC 也可以用于加密，但在实践中通常不用于此目的。相反，它通常用于密钥交换和数字签名。由于 ECC 需要更少的空间来运行，因此在嵌入式平台和存储资源有限的系统中变得非常流行。相比之下，与 RSA 中的 3072 位操作数相比，仅使用 256 位操作数即可实现相同级别的安全性。

# ECC 背后的数学

要理解 ECC，有必要对底层数学进行基本介绍。椭圆曲线基本上是一种称为**魏尔斯特拉斯方程**的多项式方程，它在有限域上生成曲线。最常用的域是所有算术运算都在模 *a* 素数 *p* 上执行的域。椭圆曲线群由有限域上的曲线上的点组成。

椭圆曲线在以下方程中定义：

![](img/a52dd3ea-55f8-4baf-9183-5067219248fd.jpg)

在这里，*A* 和 *B* 属于有限域 *Zp* 或 *Fp*（素有限域），还有一个称为 **无穷点** 的特殊值。无穷点（∞）用于为曲线上的点提供标识操作。

此外，还需要满足一个条件，确保前面提到的方程没有重复根。这意味着曲线是非奇异的。

在以下方程中描述了条件，这是需要满足的标准要求。更确切地说，这确保了曲线是非奇异的：

![](img/a3b7475e-c472-414c-a7cc-4d16caa967ea.jpg)

为了基于椭圆曲线构造离散对数问题，需要一个足够大的循环群。首先，群元素被确定为满足上述方程的一组点。然后，需要在这些点上定义群操作。

椭圆曲线上的群操作是点加法和点倍增。**点加法**是指添加两个不同的点，而 **点倍增** 意味着将同一点加到自身。

# 点加法

点加法在下图中展示。这是椭圆曲线上点加法的几何表示。在这种方法中，通过曲线画一条对角线，该对角线与曲线在两点 **P** 和 **Q** 处相交，如图所示，这产生了曲线和线之间的第三点。这个点被镜像为 **P+Q**，表示加法的结果为 **R**。

这在下图中显示为 **P+Q**：

![](img/c9a2b339-1742-4c5b-952b-1eb749dc40cf.jpg)

在实数域上的点加法

用于加法的 *+* 符号表示的群操作产生以下方程：

*P + Q = R*

在这种情况下，两点相加以计算曲线上第三点的坐标：

*P + Q = R*

更确切地说，这意味着坐标相加，如下方程所示：

*(x[1], y[1]) + (x[2], y[2]) = (x[3], y[3])*

点加法的方程如下：

*X[3] = s²**- x[1] - x[2]* m*od p*

*y[3] = s (x[1] - x[3]) - y[1] mod p*

在这里，我们看到前述方程的结果：

![](img/8972cc8e-3050-4e16-9504-9ccfddad995d.png)

前述方程中的 *S* 描述了穿过 *P* 和 *Q* 的线。

在下图中显示了点加法的一个示例。它是使用 Certicom 的在线计算器生成的。此示例显示了在有限域 **F[23]** 上的方程的加法和解。这与之前显示的实数示例相反，后者仅显示曲线但不提供方程的解：

![](img/9f6fceaa-0c99-4d4f-8f22-16dbbfe8634f.png)

点加法示例

在前面的例子中，左侧的图表显示满足此方程的点：

![](img/3ecadf22-9e90-4977-8043-f04c9d79808c.jpg)

有 27 个解用于*F[23]*上先前显示的方程。选择*P*和*Q*用于添加以产生点*R*。计算显示在右侧，计算第三个点*R*。请注意，在这里，*l*用于描绘通过*P*和*Q*的线。

作为示例，展示了如何通过图中的点满足方程的选择，其中选择了一个点(*x*, *y*)，其中*x = 3*，*y = 6*。

使用这些值显示了方程确实被满足：

*![](img/09541fff-46ad-41df-9dc5-858c75b94bc1.jpg)*

![](img/6ee629ef-d851-49e4-8441-29013653a08f.jpg)![](img/ef8e215b-33f5-46e8-bbaa-79c3c75b24df.jpg)![](img/cf17b893-4c7b-46ff-98c6-4913e2ad6db5.jpg)

下一小节介绍了可在椭圆曲线上执行的另一项运算，即点加倍的概念。

# 点加倍

椭圆曲线上的另一种运算被称为**点加倍**。 这是一个过程，其中**P**被加到自身。在这种方法中，穿过曲线的切线被绘制，如下图所示。得到第二个点，即通过切线和曲线的交点。

然后，将此点镜像以得出结果，即*2P = P + P*：

![](img/f655f36c-e056-40fa-ae7d-b4ee18d8b88d.jpg)

代表在实数上进行点加倍的图

对于点加倍，方程变为：

![](img/2f33933d-ffd3-47a9-9f8a-4afda9111a01.png)![](img/170ffee6-4b7b-402f-acc6-473c2f94f64d.jpg)![](img/25581de2-950d-49e5-8475-e43af6504f1d.png)

在这里，*S*是穿过*P*的切线（切线）的斜率。它是前面示图上方的线。在前面的示例中，曲线以实数绘制为一个简单的例子，并未显示方程的解。

以下示例显示了在有限域**F[23]**上的椭圆曲线的解和点加倍。左侧的图表显示满足方程的点：

![](img/efe6ba05-892a-4b69-8bdc-7365e484edb3.jpg)![](img/93e8293e-8049-4235-8489-abd4487968d4.png)

点加倍的例子

如前图右侧所示，计算在*P*加入自身后找到*R*的标记*(点加倍)*。没有在这里显示的*Q*，并且相同的点*P*用于加倍。请注意，在计算中，*l*用于描绘穿过*P*的切线。

在下一节中，将介绍离散对数问题的概念。

# ECC 中的离散对数问题

ECC 中的离散对数问题基于这样的思想，即在某些条件下，椭圆曲线上的所有点形成一个循环群。

在椭圆曲线上，公钥是生成点的随机倍数，而私钥是用于生成该倍数的随机选择的整数。换句话说，私钥是随机选择的整数，而公钥是曲线上的一个点。离散对数问题用于找到私钥（一个整数），其中该整数落在椭圆曲线上的所有点之内。以下方程更准确地展示了这个概念。

考虑一个椭圆曲线*E*，其中有两个元素*P*和*T*。离散对数问题是找到整数*d*，其中*1 <= d <= #E*，使得：

![](img/effb0730-ce10-4840-a3b3-b26f824c76a3.jpg)

在这里，*T* 是公钥（曲线上的一个点），*d* 是私钥。换句话说，公钥是生成器的随机倍数，而私钥是用于生成该倍数的整数。*#E*表示椭圆曲线的阶，这意味着椭圆曲线的循环群中存在的点的数量。**循环群**由椭圆曲线上的点和无穷点的组合形成。

密钥对与椭圆曲线的特定域参数相关联。域参数包括字段大小、字段表示、来自字段*a*和*b*的两个元素、两个字段元素*Xg*和*Yg*、点*G*的顺序*n*计算为*G = (Xg, Yg)*，以及余因子*h = #E(Fq)/n*。后面的章节中将描述使用 OpenSSL 的实际示例。

推荐和标准化了各种参数以作为 ECC 的曲线使用。这里展示了`secp256k1`规范的一个例子。这是比特币中使用的规范：

![](img/03dde81b-a50c-4e82-820c-58ecc49ae1ca.jpg)

来自 http://www.secg.org/sec2-v2.pdf 的`secp256k1`规范

六元组中所有这些值的解释如下：

+   *P* 是指定有限域大小的素数*p*。

+   *a* 和 *b* 是椭圆曲线方程的系数。

+   *G* 是生成所需子群的基点，也称为*生成器*。基点可以以压缩或未压缩形式表示。在实际实现中，没有必要存储曲线上的所有点。压缩的生成器有效是因为可以仅使用*x*坐标和*y*坐标的最低有效位来识别曲线上的点。

+   *n* 是子群的阶。

+   *h* 是子群的余因子。

在下一节中，展示了使用 OpenSSL 的两个示例，帮助您了解 RSA 和 ECC 加密的实际方面。

# 使用 OpenSSL 进行 RSA

下面的示例说明了如何使用 OpenSSL 命令行生成 RSA 公钥和私钥对。

# RSA 公钥和私钥对

首先，下面的小节展示了如何使用 OpenSSL 生成 RSA 私钥。

# 私钥

执行以下命令生成私钥：

```
$ openssl genpkey -algorithm RSA -out privatekey.pem -pkeyopt \
 rsa_keygen_bits:1024
...............................++++++
....................++++++  
```

命令中使用的反斜杠（`\`）是用于续行的。

执行该命令后，将生成一个名为`privatekey.pem`的文件，其中包含生成的私钥，如下所示：

```
$ cat privatekey.pem
-----BEGIN PRIVATE KEY-----
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKJOFBzPy2vOd6em Bk/UGrzDy7TvgDYnYxBfiEJId/r+EyMt/F14k2fDTOVwxXaXTxiQgD+BKuiey/69 9itnrqW/xy/pocDMvobj8QCngEntOdNoVSaN+t0f9nRM3iVM94mz3/C/v4vXvoac PyPkr/0jhIV0woCurXGTghgqIbHRAgMBAAECgYEAlB3s/N4lJh0l1TkOSYunWtzT 6isnNkR7g1WrY9H+rG9xx4kP5b1DyE3SvxBLJA6xgBle8JVQMzm3sKJrJPFZzzT5 NNNnugCxairxcF1mPzJAP3aqpcSjxKpTv4qgqYevwgW1A0R3xKQZzBKU+bTO2hXV D1oHxu75mDY3xCwqSAECQQDUYV04wNSEjEy9tYJ0zaryDAcvd/VG2/U/6qiQGajB eSpSqoEESigbusKku+wVtRYgWWEomL/X58t+K01eMMZZAkEAw6PUR9YLebsm/Sji iOShV4AKuFdi7t7DYWE5Ulb1uqP/i28zN/ytt4BXKIs/KcFykQGeAC6LDHZyycyc ntDIOQJAVqrE1/wYvV5jkqcXbYLgV5YA+KYDOb9Y/ZRM5UETVKCVXNanf5CjfW1h MMhfNxyGwvy2YVK0Nu8oY3xYPi+5QQJAUGcmORe4w6Cs12JUJ5p+zG0s+rG/URhw B7djTXm7p6b6wR1EWYAZDM9MArenj8uXAA1AGCcIsmiDqHfU7lgz0QJAe9mOdNGW 7qRppgmOE5nuEbxkDSQI7OqHYbOLuwfCjHzJBrSgqyi6pj9/9CbXJrZPgNDwdLEb 
GgpDKtZs9gLv3A==
-----END PRIVATE KEY-----  
```

# 公钥

由于私钥在数学上与公钥相关联，因此也可以从私钥生成或派生公钥。使用前述私钥的示例，可以生成公钥，如下所示：

```
$ openssl rsa -pubout -in privatekey.pem -out publickey.pem 

writing RSA key  
```

可以使用文件阅读器或任何文本查看器查看公钥：

```
$ cat publickey.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0 74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv 6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF 
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----  
```

为了查看各种组件的更多细节，例如在加密过程中使用的模数、素数，或者生成的私钥的指数和系数，可以使用以下命令（这里仅显示部分输出，因为实际输出非常长）：

```
$ openssl rsa -text -in privatekey.pem 
Private-Key: (1024 bit)
modulus: 
   00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4: 
   1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48: 
   77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70: 
   c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd: 
   f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3: 
   f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f: 
   f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7: 
   be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae:  
   ad:71:93:82:18:2a:21:b1:d1 
publicExponent: 65537 (0x10001)
privateExponent: 
   00:94:1d:ec:fc:de:25:26:1d:25:d5:39:0e:49:8b: 
   a7:5a:dc:d3:ea:2b:27:36:44:7b:83:55:ab:63:d1: 
   fe:ac:6f:71:c7:89:0f:e5:bd:43:c8:4d:d2:bf:10: 
   4b:24:0e:b1:80:19:5e:f0:95:50:33:39:b7:b0:a2: 
   6b:24:f1:59:cf:34:f9:34:d3:67:ba:00:b1:6a:2a: 
   f1:70:5d:66:3f:32:40:3f:76:aa:a5:c4:a3:c4:aa: 
   53:bf:8a:a0:a9:87:af:c2:05:b5:03:44:77:c4:a4: 
   19:cc:12:94:f9:b4:ce:da:15:d5:0f:5a:07:c6:ee:  
   f9:98:36:37:c4:2c:2a:48:01 
prime1: 
   00:d4:61:5d:38:c0:d4:84:8c:4c:bd:b5:82:74:cd: 
   aa:f2:0c:07:2f:77:f5:46:db:f5:3f:ea:a8:90:19: 
   a8:c1:79:2a:52:aa:81:04:4a:28:1b:ba:c2:a4:bb: 
   ec:15:b5:16:20:59:61:28:98:bf:d7:e7:cb:7e:2b:   
   4d:5e:30:c6:59 
prime2: 
   00:c3:a3:d4:47:d6:0b:79:bb:26:fd:28:e2:88:e4: 
   a1:57:80:0a:b8:57:62:ee:de:c3:61:61:39:52:56: 
   f5:ba:a3:ff:8b:6f:33:37:fc:ad:b7:80:57:28:8b: 
   3f:29:c1:72:91:01:9e:00:2e:8b:0c:76:72:c9:cc: 
   9c:9e:d0:c8:39 
```

# 探索公钥

同样，可以使用以下命令探索公钥。公钥和私钥都是 base64 编码的：

```
$ openssl pkey -in publickey.pem -pubin -text
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiThQcz8trznenpgZP1Bq8w8u0 74A2J2MQX4hCSHf6/hMjLfxdeJNnw0zlcMV2l08YkIA/gSronsv+vfYrZ66lv8cv 6aHAzL6G4/EAp4BJ7TnTaFUmjfrdH/Z0TN4lTPeJs9/wv7+L176GnD8j5K/9I4SF 
dMKArq1xk4IYKiGx0QIDAQAB
-----END PUBLIC KEY-----
Public-Key: (1024 bit)
Modulus:
   00:a2:4e:14:1c:cf:cb:6b:ce:77:a7:a6:06:4f:d4:
   1a:bc:c3:cb:b4:ef:80:36:27:63:10:5f:88:42:48:
   77:fa:fe:13:23:2d:fc:5d:78:93:67:c3:4c:e5:70:
   c5:76:97:4f:18:90:80:3f:81:2a:e8:9e:cb:fe:bd:
   f6:2b:67:ae:a5:bf:c7:2f:e9:a1:c0:cc:be:86:e3:
   f1:00:a7:80:49:ed:39:d3:68:55:26:8d:fa:dd:1f:
   f6:74:4c:de:25:4c:f7:89:b3:df:f0:bf:bf:8b:d7:
   be:86:9c:3f:23:e4:af:fd:23:84:85:74:c2:80:ae: 
   ad:71:93:82:18:2a:21:b1:d1
Exponent: 65537 (0x10001)  
```

现在公钥可以公开共享，任何想要向您发送消息的人都可以使用公钥加密消息并将其发送给您。然后，您可以使用相应的私钥解密文件。

# 加密和解密

在本节中，将介绍一个示例，演示如何使用 OpenSSL 中的 RSA 执行加密和解密操作。

# 加密

使用前面示例中生成的私钥，可以构造如下所示的加密文本文件`message.txt`的命令：

```
$ echo datatoencrypt > message.txt

$ openssl rsautl -encrypt -inkey publickey.pem -pubin -in message.txt \
  -out message.rsa  
```

这将生成一个名为`message.rsa`的文件，它是以二进制格式保存的。如果你在 nano 编辑器或你选择的任何其他文本编辑器中打开`message.rsa`，它将显示一些垃圾数据，如下图所示：

![图片](img/eda866a3-6754-4c86-851f-b3cc95453af7.png)

显示垃圾数据（加密）的`message.rsa`

# 解密

为了解密 RSA 加密的文件，可以使用以下命令：

```
$ openssl rsautl -decrypt -inkey privatekey.pem -in message.rsa \
  -out message.dec  
```

现在，如果使用`cat`读取文件，可以看到解密后的明文，如下所示：

```
$ cat message.dec 
datatoencrypt  
```

# 使用 OpenSSL 进行 ECC

OpenSSL 提供了一个非常丰富的函数库，用于执行 ECC。以下小节显示了如何在 OpenSSL 中实际使用 ECC 函数。

# ECC 私钥和公钥对

在这个小节中，首先介绍了一个示例，演示了使用 OpenSSL 库中可用的 ECC 函数创建私钥的过程。

# 私钥

ECC 是基于各种标准定义的域参数。您可以使用以下命令查看 OpenSSL 中定义的所有可用标准以及推荐的曲线列表。（再次强调，这里仅显示部分输出，并且在中间被截断。）

```
$ openssl ecparam -list_curves
secp112r1 : SECG/WTLS curve over a 112 bit prime field 
secp112r2 : SECG curve over a 112 bit prime field 
secp128r1 : SECG curve over a 128 bit prime field 
secp128r2 : SECG curve over a 128 bit prime field
secp160k1 : SECG curve over a 160 bit prime field 
secp160r1 : SECG curve over a 160 bit prime field 
secp160r2 : SECG/WTLS curve over a 160 bit prime field
secp192k1 : SECG curve over a 192 bit prime field
secp224k1 : SECG curve over a 224 bit prime field
secp224r1 : NIST/SECG curve over a 224 bit prime field
secp256k1 : SECG curve over a 256 bit prime field
secp384r1 : NIST/SECG curve over a 384 bit prime field
secp521r1 : NIST/SECG curve over a 521 bit prime field
prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field
 .
 .
 .
 .
brainpoolP384r1: RFC 5639 curve over a 384 bit prime field 
brainpoolP384t1: RFC 5639 curve over a 384 bit prime field 
brainpoolP512r1: RFC 5639 curve over a 512 bit prime field 
brainpoolP512t1: RFC 5639 curve over a 512 bit prime field  
```

在下面的示例中，使用`secp256k1`来演示 ECC 的使用。

# 生成私钥

要生成私钥，请执行以下命令：

```
$ openssl ecparam -name secp256k1 -genkey -noout -out ec-privatekey.pem
$ cat ec-privatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIJHUIm9NZAgfpUrSxUk/iINq1ghM/ewn/RLNreuR52h/oAcGBSuBBAAK oUQDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8JdcGXYGxHdzr0Jt1NInaYE0GG 
ChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END EC PRIVATE KEY-----  
```

现在名为`ec-privatekey.pem`的文件包含基于`secp256k1`曲线生成的**椭圆曲线**（**EC**）私钥。要从私钥生成公钥，发出以下命令：

```
$ openssl ec -in ec-privatekey.pem -pubout -out ec-pubkey.pem 
read EC key
writing EC key  
```

读取文件会产生以下输出，显示生成的公钥：

```
$ cat ec-pubkey.pem
-----BEGIN PUBLIC KEY----- 
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE0G33mCZ4PKbg5EtwQjk6ucv9Qc9DTr8J
dcGXYGxHdzr0Jt1NInaYE0GGChFMT5pK+wfvSLkYl5ul0oczwWKjng==
-----END PUBLIC KEY-----  
```

现在`ec-pubkey.pem`文件包含从`ec-privatekey.pem`导出的公钥。可以使用以下命令进一步探究私钥：

```
$ openssl ec -in ec-privatekey.pem -text -noout 
read EC key
Private-Key: (256 bit) 
priv:
   00:91:d4:22:6f:4d:64:08:1f:a5:4a:d2:c5:49:3f:
   88:83:6a:d6:08:4c:fd:ec:27:fd:12:cd:ad:eb:91: 
   e7:68:7f
pub:
   04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
   3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
   47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
   4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
   33:c1:62:a3:9e 
ASN1 OID: secp256k1  
```

同样，可以使用以下命令进一步探究公钥：

```
$ openssl ec -in ec-pubkey.pem -pubin -text -noout
read EC key
Private-Key: (256 bit) 
pub:
   04:d0:6d:f7:98:26:78:3c:a6:e0:e4:4b:70:42:39:
   3a:b9:cb:fd:41:cf:43:4e:bf:09:75:c1:97:60:6c:
   47:77:3a:f4:26:dd:4d:22:76:98:13:41:86:0a:11:
   4c:4f:9a:4a:fb:07:ef:48:b9:18:97:9b:a5:d2:87:
   33:c1:62:a3:9e 
ASN1 OID: secp256k1  
```

也可以生成包含所需参数的文件，例如`secp256k1`，然后进一步探究它以理解底层参数：

```
$ openssl ecparam -name secp256k1 -out secp256k1.pem 
$ cat secp256k1.pem
-----BEGIN EC PARAMETERS-----
BgUrgQQACg==
-----END EC PARAMETERS-----  
```

该文件现在包含所有`secp256k1`参数，可以使用以下命令进行分析：

```
$ openssl ecparam -in secp256k1.pem -text -param_enc explicit -noout    
```

此命令将产生类似于这里显示的输出：

```
Field Type: prime-field 
Prime:
   00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
   ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff: 
   ff:fc:2f
A:  0
B:  7 (0x7)
Generator (uncompressed): 
   04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87:
   0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16:
   f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc:
   0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0:
   8f:fb:10:d4:b8
Order:
   00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
   ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0:
   36:41:41
Cofactor:  1 (0x1)  
```

前面的例子显示了所使用的素数，以及`A`和`B`的值，还有`secp256k1`曲线域参数的生成器、阶和余因子。

通过前述示例，我们通过加密和解密的角度完成了对公钥密码学的介绍。其他相关构造，如数字签名，将在本章后面讨论。

在下一节中，我们将讨论另一类加密原语，即哈希函数。哈希函数不用于加密数据，而是产生提供给哈希函数作为输入的数据的固定长度摘要。

# 哈希函数

**哈希函数**用于创建任意长输入字符串的固定长度摘要。哈希函数是无密钥的，它们提供数据完整性服务。通常使用迭代和专用哈希函数构建技术来构建它们。

各种哈希函数可供选择，例如 MD、SHA-1、SHA-2、SHA-3、RIPEMD 和 Whirlpool。哈希函数通常用于数字签名和**消息认证码**（**MACs**），如 HMACs。它们具有三种安全性质，即原像抗性、第二原像抗性和碰撞抗性。这些性质将在本节后面进行解释。

哈希函数通常也用于提供数据完整性服务。它们可以被用作单向函数，也可以被用来构建其他加密原语，如 MACs 和数字签名。一些应用程序将哈希函数用作生成**伪随机数生成器**（**PRNGs**）的手段。根据所需完整性级别，哈希函数必须满足两个实用性和三个安全性质。这些性质将在以下子节中讨论。

# 将任意消息压缩为固定长度的摘要。

此属性与哈希函数必须能够接受任意长度的输入文本并输出固定长度的压缩消息有关。哈希函数通常以不同的位大小产生压缩输出，通常在 128 位到 512 位之间。

# 易于计算

哈希函数是高效且快速的单向函数。哈希函数需要非常快速地计算，而不管消息大小如何。如果消息太大，效率可能会降低，但函数仍应足够快以供实际使用。

在下一节中，将讨论哈希函数的安全性质。

# 原像抗性

可以使用以下简单方程来解释此属性：

*h(x) = y*

在这里，*h*是哈希函数，*x*是输入，*y*是哈希。第一个安全属性要求*y*不能被逆向计算到*x*。*x*被视为*y*的原像，因此被称为**原像抗性**。这也被称为单向属性。

# 第二原像抗性

**第二原像抗性**属性要求给定*x*和*h(x)*，几乎不可能找到任何其他消息*m*，其中*m != x*且*消息 m 的哈希 = 消息 x 的哈希*或*h(m) = h(x)*。此属性也称为**弱碰撞抗性**。

# 碰撞抗性

**碰撞抗性**属性要求两个不同的输入消息不应散列到相同的输出。换句话说，*h(x) != h(z)*。此属性也称为**强碰撞抗性**。

所有这些属性都显示在以下图表中：

![](img/c9d1573f-712d-4a5c-a697-8c2b44dc4c8b.jpg)

哈希函数的三个安全性质

由于其本质，哈希函数总会存在一些碰撞。这是两个不同的消息散列到相同的输出的情况。但是，找到它们应该是计算上不可行的。所有哈希函数中都希望存在一种称为**雪崩效应**的概念。雪崩效应规定，即使是输入文本中的一个小变化，甚至是单个字符的变化，也将导致完全不同的散列输出。

哈希函数通常是通过遵循迭代哈希函数方法设计的。使用此方法，输入消息按块进行多轮压缩，以产生压缩输出。一种流行的迭代哈希函数类型是**Merkle-Damgard 结构**。该结构基于将输入数据划分为相等的块大小，然后通过迭代方式将它们馈送到压缩函数中的想法。压缩函数的碰撞抗性确保了哈希输出也是抗碰撞的。可以使用分组密码构建压缩函数。除了 Merkle-Damgard 之外，研究人员还提出了各种其他压缩函数的构造，例如 Miyaguchi-Preneel 和 Davies-Meyer。

在以下各小节中介绍了多种哈希函数类别。

# 消息摘要

**消息摘要**（**MD**）函数在 1990 年代初很流行。MD4 和 MD5 属于此类。这两个 MD 函数都被发现是不安全的，不再建议使用。MD5 是一个常用于文件完整性检查的 128 位哈希函数。

# 安全哈希算法

以下列出了最常见的**安全哈希算法**（**SHAs**）：

+   **SHA-0**：这是 NIST 在 1993 年引入的一个 160 位的函数。

+   **SHA-1**：SHA-1 是由 NIST 于 1995 年引入的，作为 SHA-0 的替代。这也是一个 160 位的哈希函数。SHA-1 在 SSL 和 TLS 实现中被普遍使用。值得注意的是，SHA-1 现在被认为是不安全的，并且正在被证书颁发机构弃用。在任何新的实现中都不推荐使用它。

+   **SHA-2**：这个类别包括了根据哈希位数定义的四个函数：SHA-224、SHA-256、SHA-384 和 SHA-512。

+   **SHA-3**：这是最新的 SHA 函数系列。SHA-3-224、SHA-3-256、SHA-3-384 和 SHA-3-512 是该系列的成员。SHA-3 是 Keccak 的 NIST 标准化版本。Keccak 使用了一种称为**海绵构造**的新方法，而不是常用的 Merkle-Damgard 转换。

+   **RIPEMD**：RIPEMD 是**RACE 完整性原语评估消息摘要**的缩写。它基于构建 MD4 的设计思想。RIPEMD 有多个版本，包括 128 位、160 位、256 位和 320 位。

+   **Whirlpool**：这基于修改版的 Rijndael 密码，称为 *W*。它使用 Miyaguchi-Preneel 压缩函数，这是一种用于将两个固定长度输入压缩为单个固定长度输出的单向函数类型。它是一个单个块长度的压缩函数。

哈希函数具有许多实际应用，从简单的文件完整性检查和密码存储到在加密协议和算法中使用。它们被用于哈希表、分布式哈希表、布隆过滤器、病毒指纹、点对点文件共享等许多应用中。

哈希函数在区块链中发挥着重要作用。特别是，PoW 函数特别是两次使用 SHA-256 来验证矿工所花费的计算工作。RIPEMD 160 用于生成比特币地址。这将在后面的章节中进一步讨论。

在下一节中，将介绍 SHA 算法的设计。

# 安全哈希算法的设计

在接下来的部分中，您将了解到 SHA-256 和 SHA-3 的设计。这两者分别在比特币和以太坊中使用。以太坊不使用 NIST 标准 SHA-3，而是使用原始算法 Keccak。经过一些修改（如增加轮数和更简单的消息填充），NIST 将 Keccak 标准化为 SHA-3。

# SHA-256 的设计

SHA-256 具有输入消息大小 < 2⁶⁴-bits。块大小为 512-bits，字长为 32-bits。输出为 256-bit 摘要。

压缩函数处理 512-bit 消息块和 256-bit 中间散列值。此函数的主要组成部分有两个：压缩函数和消息调度。

算法运行如下，经过八个步骤：

1.  **预处理**：

1.  1.  使用消息填充来调整块的长度为 512-bits，如果小于所需的块大小。

    1.  将消息解析为消息块，从而确保消息及其填充被分成等长的 512 位块。

    1.  设置初始散列值，由取首八个素数的平方根的小数部分的前 32 位得到的八个 32 位字组成。这些初始值是随机选择的来初始化过程，它们提供了一定的信心，即算法中不存在后门。

1.  **散列计算**：

1.  1.  然后按顺序处理每个消息块，并需要 64 轮来计算完整的散列输出。每轮使用略有不同的常量来确保没有两轮相同。

    1.  准备消息调度。

    1.  初始化八个工作变量。

    1.  计算中间散列值。

    1.  最后，处理消息，并生成输出散列：

![](img/8898ab05-ef16-472b-a4db-53c6dc83e2eb.jpg)

SHA-256 压缩函数一轮

在上图中，**a**、**b**、**c**、**d**、**e**、**f**、**g** 和 **h** 是寄存器。*Maj* 和 *Ch* 以位方式应用。**∑[0]** 和 **∑[1]** 执行位旋转。循环常量为 **W[j]** 和 **K[j]**，它们相加后取余 *2³²*。

# 设计 SHA-3（Keccak）

SHA-3 的结构与 SHA-1 和 SHA-2 很不相同。SHA-3 背后的关键思想是基于无键排列，而不是其他典型的散列函数构造使用的有键排列。Keccak 也不使用常用于处理散列函数中的任意长度输入消息的 Merkle-Damgard 转换。在 Keccak 中使用了一种称为 **海绵和挤压构造** 的新方法。这是一个随机排列模型。SHA-3 有不同的变种进行了标准化，如 SHA-3-224、SHA-3-256、SHA-3-384、SHA-3-512、SHAKE-128 和 SHAKE-256。SHAKE-128 和 SHAKE-256 是**可扩展输出函数**（**XOFs**），也被 NIST 标准化。XOFs 允许输出扩展到任意所需长度。

下图显示了海绵和挤压模型，这是 SHA-3 或 Keccak 的基础。类似于海绵，数据首先被吸收到海绵中，然后应用填充。然后，它通过异或变换为置换状态的子集，并且输出被从代表转换后的状态的海绵函数中挤出。速率是海绵函数的输入块大小，而容量确定了一般安全级别：

![](img/6041f3d7-28e7-4fc4-bd0c-7ee20f5f858f.jpg)

SHA-3 吸收和挤压函数

# OpenSSL 哈希函数示例

以下命令将使用 SHA-256 算法对`Hello`消息生成 256 位的哈希值：

```
$ echo -n 'Hello' | openssl dgst -sha256
(stdin)= 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969  
```

注意，即使是文本中的微小更改，例如更改字母 `H` 的大小写，也会导致输出哈希的巨大变化。这被称为雪崩效应，正如之前所讨论的那样：

```
$ echo -n 'hello' | openssl dgst -sha256
(stdin)= 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824  
```

请注意，两个输出完全不同：

```
Hello: 
18:5f:8d:b3:22:71:fe:25:f5:61:a6:fc:93:8b:2e:26:43:06:ec:30:4e:da:51:80:07: 
d1:76:48:26:38:19:69

hello: 
2c:f2:4d:ba:5f:b0:a3:0e:26:e8:3b:2a:c5:b9:e2:9e:1b:16:1e:5c:1f:a7:42:5e:73:
04:33:62:93:8b:98:24  
```

通常，哈希函数不使用密钥。然而，如果它们与密钥一起使用，则可以用于创建另一种称为 MACs 的加密构造。

# 消息认证码

MACs 有时被称为**密钥散列函数**，可用于提供消息完整性和身份验证。更具体地说，它们用于提供数据的源身份验证。这些是对称加密原语，使用发送方和接收方之间的共享密钥。MACs 可以使用块密码或散列函数构造。

# 使用块密码的 MACs

使用此方法，块密码以 **密码块链**（**CBC**）模式用于生成 MAC。任何块密码，例如 AES 在 CBC 模式下，都可以使用。消息的 MAC 实际上是 CBC 操作的最后一轮的输出。MAC 输出的长度与用于生成 MAC 的块密码的块长度相同。

MACs 的验证很简单，只需计算消息的 MAC 并将其与接收到的 MAC 进行比较。如果它们相同，则确认了消息完整性；否则，消息被视为已被更改。还应注意，MACs 的工作方式类似于数字签名，但由于其对称性质，它们无法提供不可否认的服务。

# 基于哈希的 MACs

与哈希函数类似，**基于哈希的 MACs**（**HMACs**）产生固定长度的输出，并将任意长的消息作为输入。在此方案中，发送方使用 MAC 对消息进行签名，接收方使用共享密钥进行验证。密钥使用两种方法之一与消息一起使用，分别称为**密钥前缀**或**密钥后缀**。使用密钥前缀方法时，密钥与消息连接在一起；也就是说，密钥在前，消息在后，而使用密钥后缀方法时，密钥在消息之后，如下面的方程所示：

*密钥前缀：M = MACk(x) = h(k||x)*

*密钥后缀：M=MACk(x) = h(x||k)*

这两种方法都有优缺点。对这两种方案的一些攻击已经发生。密码研究人员提出了使用各种技术的 HMAC 构造方案，例如**ipad**和**opad**（内部填充和外部填充）。这些方案在一些假设下被认为是安全的：

![](img/15ff69dd-c88d-44f7-85fa-94e19e01e3a7.png)

MAC 函数的操作

在点对点网络和区块链技术中使用哈希函数的各种强大应用。一些显著的例子，如默克尔树、帕特里夏树和**分布式哈希表**（**DHT**），将在以下子章节中讨论。

# 默克尔树

默克尔树的概念由 Ralph Merkle 引入。这里显示了默克尔树的图表。**默克尔树**可以安全有效地验证大型数据集。

![](img/ac4efc16-8250-4415-a374-7de2d84f8c1e.jpg)

默克尔树

默克尔树是一种二叉树，其中首先将输入放置在叶节点（没有子节点的节点）上，然后将子节点的值对的值哈希在一起，以产生父节点（内部节点）的值，直到达到一个称为**默克尔根**的单一哈希值。

# 帕特里夏树

要理解帕特里夏树，您首先会介绍**trie**的概念。Trie，或数字树，是一种用于存储数据集的有序树数据结构。

**用于检索字母数字编码信息的实用算法**（**Patricia**），也称为*基数树*，是 trie 的紧凑表示，其中作为父节点的唯一子节点与其父节点合并。

基于帕特里夏和默克尔的定义，**Merkle-Patricia 树**是一个具有根节点的树，该根节点包含整个数据结构的哈希值。

# 分布式哈希表

哈希表是一种用于将键映射到值的数据结构。在内部，使用哈希函数来计算一个索引，以便从存储桶数组中找到所需的值。桶中使用哈希键存储记录，并按特定顺序组织。

考虑到之前提供的定义，可以将 DHT 视为数据分布在各个节点上，而节点等价于点对点网络中的存储桶的数据结构。

下图显示了分布式哈希表（DHT）的工作原理。数据通过哈希函数传递，然后生成一个紧凑的密钥。然后将此密钥与点对点网络上的数据（值）相关联。当网络上的用户请求数据（通过文件名）时，可以再次对文件名进行哈希以生成相同的密钥，然后可以请求网络上的任何节点以查找相应的数据。DHT 提供了分散性、容错性和可扩展性：

![](img/f1733460-028b-4fca-993a-4eb9b134e370.jpg)

分布式哈希表

哈希函数的另一个应用是数字签名，它们可以与非对称加密结合使用。这个概念在下面的小节提供的示例中有详细讨论。

# 数字签名

**数字签名**提供了将消息与消息来源实体关联起来的一种方式。数字签名用于提供数据的原始认证和不可否认性。

数字签名在区块链中使用，发送方在向网络广播交易之前使用他们的私钥对交易进行数字签名。这种数字签名证明他们是资产的合法所有者，例如比特币。这些交易再次被网络上的其他节点验证，以确保资金确实属于声称是所有者的节点（用户）。我们将在本书专门介绍比特币和以太坊的章节中更详细地讨论这些概念。

数字签名分为两步进行计算。例如，RSA 数字签名方案的高级步骤如下。

# RSA 数字签名算法

下面是 RSA 数字签名算法：

1.  **计算数据包的哈希值**：这将提供数据的完整性保证，因为接收方可以再次计算哈希并与原始哈希匹配，以检查数据在传输过程中是否被修改。从技术上讲，消息签名可以在不先对数据进行哈希处理的情况下工作，但被认为不安全。

1.  **用签名者的私钥对哈希值进行签名**：因为只有签名者有私钥，所以可以确保签名和签名数据的真实性。

数字签名有一些重要的属性，如真实性、不可伪造性和不可重用性。**真实性**意味着数字签名可以被接收方验证。**不可伪造性**属性确保只有消息发送者可以使用私钥进行签名功能。换句话说，其他人不能生成合法发送者产生的签名消息。**不可重用性**意味着数字签名不能与消息分离并再次用于另一个消息。

通用数字签名功能的操作如下图所示：

![](img/768942b4-41c0-46ec-890f-71aded46f7d0.jpg)

数字签名（左）和验证过程（右）（RSA 数字签名示例）

如果发送方想给接收方发送一个经过身份验证的消息，可以使用两种方法：先签名再加密和先加密再签名。以下是这两种方法使用数字签名加密的方式。

# 先签名再加密

采用这种方法，发送方使用私钥对数据进行数字签名，将签名附加到数据上，然后使用接收方的公钥对数据和数字签名进行加密。与接下来描述的 *先加密再签名* 方案相比，这被认为是一种更安全的方案。

# 先加密再签名

使用这种方法，发送方使用接收方的公钥加密数据，然后对加密数据进行数字签名。

在实践中，包含数字签名的数字证书由一个将公钥与身份关联起来的 **证书颁发机构**（**CA**）颁发。

在实践中使用了各种方案，如 RSA、**数字签名算法**（**DSA**）和基于 ECDSA 的数字签名方案。RSA 是最常用的；然而，随着 ECC 的发展，基于 ECDSA 的方案也变得相当流行。在区块链中，这是有利的，因为 ECC 提供了与 RSA 相同的安全级别，但使用的空间更少。此外，在 ECC 中，密钥的生成速度比 RSA 快得多，因此有助于系统的整体性能。下表显示了 ECC 能够以更小的密钥尺寸提供与基于 RSA 的系统相同级别的加密强度：

| **RSA 密钥尺寸（位）** | **椭圆曲线密钥尺寸（位）** |
| --- | --- |
| 1024 | 160 |
| 2048 | 224 |
| 3072 | 256 |
| 7680 | 384 |
| 15360 | 521 |

RSA 和椭圆曲线密钥尺寸提供相同级别安全性的比较

ECDSA 方案在以下子部分中进行了详细描述。

# 椭圆曲线数字签名算法

为了使用 ECDSA 方案进行签名和验证，首先需要生成密钥对：

1.  首先，定义一个椭圆曲线 *E*：

+   +   与模数 **P**

    +   系数 *a* 和 **b**

    +   形成素数阶循环群的生成点 *A*

1.  选择一个随机整数 *d*，使得 *0 < d < q.*

1.  计算公钥 *B* 使得 *B = d A.*

公钥的形式如下所示的六元组：

*Kpb = (p,a,b,q,A,B)*

私钥 *d* 在步骤 2 中随机选择：

*Kpr = d*

现在可以使用私钥和公钥生成签名。

1.  首先，选择一个临时密钥 *K[e]*，其中 *0 < K[e] < q*。应确保 *K[e]* 是真正随机的，并且没有两个签名具有相同的密钥；否则，私钥可以被计算出来。

1.  使用 *R = K[e] A* 计算另一个值 *R*；即，通过将 *A*（生成点）和随机的临时密钥相乘。

1.  使用点 *R* 的 *x* 坐标值初始化变量 *r*，使得 *r = xR*。

1.  签名可以按以下方式计算：

![](img/55683d0a-f05a-4933-97e6-b2a8cca24162.jpg)

这里，*m* 是正在计算签名的消息，*h(m)* 是消息 *m* 的哈希值。

签名验证是按照以下流程进行的：

1.  辅助值 *w* 计算为 *w = s-1 mod q*。

1.  辅助值 *u1 = w. h(m) mod q*。

1.  辅助值 *u2 = w. r mod q*。

1.  计算点 *P*, *P = u1A + u2B*.

1.  验证如下进行：

*r*, *s* 在第 4 步计算的点*P*的*x*坐标与签名参数*r mod q*的值相同时被接受为有效签名；即：

*Xp = r mod q 意味着有效签名*

*Xp != r mod q 意味着无效签名*

以下子章节展示了各种实际示例，演示了如何使用 OpenSSL 生成、使用和验证 RSA 数字签名。

# 如何使用 OpenSSL 生成数字签名

第一步是生成消息文件的哈希：

```
$ openssl dgst -sha256 message.txt 
SHA256(message.txt)=
eb96d1f89812bf4967d9fb4ead128c3b787272b7be21dd2529278db1128d559c  
```

散列生成和签名可以在一步中完成，如下所示。请注意，`privatekey.pem`是在先前提供的步骤中生成的：

```
$ openssl dgst -sha256 -sign privatekey.pem -out signature.bin message.txt  
```

现在，让我们显示显示相关文件的目录：

```
$ ls -ltr 
total 36
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 05:54 message.txt
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 05:57 message.bin
-rw-rw-r-- 1 drequinox drequinox 45 Sep 21 06:00 message.b64
-rw-rw-r-- 1 drequinox drequinox 32 Sep 21 06:16 message.ptx
-rw-rw-r-- 1 drequinox drequinox 916 Sep 21 06:28 privatekey.pem
-rw-rw-r-- 1 drequinox drequinox 272 Sep 21 06:30 publickey.pem
-rw-rw-r-- 1 drequinox drequinox 128 Sep 21 06:43 message.rsa
-rw-rw-r-- 1 drequinox drequinox 14 Sep 21 06:49 message.dec
-rw-rw-r-- 1 drequinox drequinox  128 Sep 21 07:05 signature.bin
```

通过执行以下命令查看`signature.bin`的内容：

```
$ cat signature.bin
```

执行此命令将返回以下输出：

![](img/0cd2032e-dda0-4d8d-a682-0f750464b8fc.png)

为验证签名，可以执行以下操作：

```
$ openssl dgst -sha256 -verify publickey.pem -signature \
  signature.bin message.txt
Verified OK  
```

类似地，如果使用了不合法的其他签名文件，验证将失败，如下所示：

```
$ openssl dgst -sha256 -verify publickey.pem -signature someothersignature.bin message.txt
Verification Failure  
```

接下来，展示了一个示例，显示了如何使用 OpenSSL 执行与 ECDSA 相关的操作。

# 使用 OpenSSL 的 ECDSA

首先，使用以下命令生成私钥：

```
$ openssl ecparam -genkey -name secp256k1 -noout -out eccprivatekey.pem
$ cat eccprivatekey.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIMVmyrnEDOs7SYxS/AbXoIwqZqJ+gND9Z2/nQyzcpaPBoAcGBSuBBAAK oUQDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPwNRo/k4Y/CZA4pXvlyTgH5LYm QbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END EC PRIVATE KEY-----  
```

接下来，从私钥生成公钥：

```
$ openssl ec -in eccprivatekey.pem -pubout -out eccpublickey.pem 
read EC key
writing EC key
$ cat eccpublickey.pem
-----BEGIN PUBLIC KEY----- 
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEEKKS4E4+TATIeBX8o2J6PxKkjcoWrXPw
NRo/k4Y/CZA4pXvlyTgH5LYmQbU0qUtPM7dAEzOsaoXmetqB+6cM+Q==
-----END PUBLIC KEY-----  
```

现在，假设需要对名为`testsign.txt`的文件进行签名和验证。可以按照以下步骤实现：

1.  创建一个测试文件：

```
      $ echo testing > testsign.txt
      $ cat testsign.txt 
      testing 
```

1.  运行以下命令，为`testsign.txt`文件使用私钥生成签名：

```
      $ openssl dgst -ecdsa-with-SHA1 -sign eccprivatekey.pem \ 
        testsign.txt > ecsign.bin  
```

1.  最后，验证命令可按照这里显示的方式运行：

```
      $ openssl dgst -ecdsa-with-SHA1 -verify eccpublickey.pem \
        -signature ecsign.bin testsign.txt 
      Verified OK
```

证书也可以通过使用先前生成的私钥生成，方法如下：

```
$ openssl req -new -key eccprivatekey.pem -x509 -nodes -days 365 \
  -out ecccertificate.pem     
```

这个命令将生成与这里显示的类似输出。输入适当的参数以生成证书：

```
You are about to be asked to enter information that will be incorporated into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank
For some fields there will be a default value, 
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:GB
State or Province Name (full name) [Some-State]:Cambridge 
Locality Name (eg, city) []:Cambridge
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dr.Equinox! Organizational Unit Name (eg, section) []:NA
Common Name (e.g. server FQDN or YOUR name) []:drequinox 
Email Address []:drequinox@drequinox.com  
```

可以使用以下命令查看证书：

```
$ openssl x509 -in ecccertificate.pem -text -noout  
```

以下输出显示了证书：

![](img/1fca7c9d-e81f-4e83-b4ff-bfc0506a80dd.png)

使用 SHA-256 算法和 ECDSA 算法的 X509 证书

以下密码学主题的介绍是因为它们与区块链的相关性或在未来区块链生态系统中的潜在用途。

# 同态加密

通常，例如 RSA 等公钥密码系统是乘法同态或加法同态的，如 Paillier 密码系统，称为**部分同态加密**（**PHE**）系统。加法同态加密适用于电子投票和银行业务应用。

直到最近，没有一个系统支持这两种操作，但是在 2009 年，克雷格·根特里发现了一个**全同态加密** (**FHE**) 系统。由于这些方案使得加密数据的处理不需要解密，它们在许多不同的潜在应用中有着很多不同的潜在应用，特别是在需要保持隐私的情况下，但数据也被要求由潜在不受信任的方进行处理的场景，例如，云计算和在线搜索引擎。同态加密的最新发展非常有前景，研究人员正在积极努力使其更有效和更实用。这在区块链技术中尤其有趣，正如本书后文所述，因为它可以解决区块链中的保密性和隐私问题。

# 签名加密

**签名加密** 是一种提供数字签名和加密所有功能的公钥密码原语。郑育亮发明了签名加密，现在它是 ISO 标准 ISO/IEC 29150:2011。传统上，使用签名然后加密或加密然后签名方案来提供不可伪造性、身份验证和不可否认性，但是使用签名加密，所有数字签名和加密的服务都以比签名然后加密方案更低的成本提供。

签名加密使得*成本（签名和加密） << 成本（签名） + 成本（加密）* 在一个单独的逻辑步骤中实现。

# 零知识证明

**零知识证明** (**ZKPs**) 是由 Goldwasser、Micali 和 Rackoff 于 1985 年引入的。这些证明用于证明某个断言的有效性，而不泄露任何与断言有关的信息。ZKPs 所需的三个属性是：完备性、声音性和零知识性质。

**完备性** 确保如果某个断言为真，则验证者将被证明者说服。**声音性** 属性确保如果一个断言是假的，那么没有不诚实的证明者能说服验证者相反。**零知识性质**，正如其名称所暗示的，是 ZKP 的关键属性，确保除了该断言是真还是假之外，绝对不会透露任何关于断言的信息。

ZKP 在区块链领域引起了研究人员的特别兴趣，因为它们的隐私属性在金融和许多其他领域中非常受欢迎，包括法律和医学。成功实现 ZKP 机制的最新例子是 Zcash 加密货币。在 Zcash 中，实现了一种特定类型的 ZKP，称为**零知识简洁非交互式知识论证** (**ZK-SNARK**)。这将在 第十章 *替代货币* 中详细讨论。

# 盲签名

**盲签名**是由 David Chaum 于 1982 年引入的。它们基于公钥数字签名方案，如 RSA。盲签名背后的关键思想是让签名者在实际上不透露消息的情况下对消息进行签名。这通过在签名之前伪装或盲化消息来实现，因此称为*盲签名*。这种盲签名然后可以像普通数字签名一样对原始消息进行验证。盲签名被引入作为允许数字货币方案发展的机制。

# 编码方案

除了密码学基元外，二进制到文本的**编码方案**也在各种场景中使用。最常见的用途是将二进制数据转换为文本，以便可以通过不支持处理二进制数据的协议进行处理、保存或传输。例如，有时，图像以 base64 编码的形式存储在数据库中，这使得文本字段能够存储图片。一个常用的编码方案是 base64。另一个名为 base58 的编码方案因在比特币中的使用而广受欢迎。

密码学是一个庞大的领域，本节仅介绍了对于理解密码学以及从区块链和加密货币角度来看的基本概念。在下一节中，将介绍基本的金融市场概念。

本节描述了与交易、交易所和交易生命周期相关的一般术语。更详细的信息将在后面的章节中提供，其中将讨论特定的用例。

# 金融市场和交易

金融市场使金融证券如债券、股票、衍生品和货币得以交易。广义上有三种类型的市场：货币市场、信贷市场和资本市场：

+   **货币市场**：这是短期市场，资金借出给公司或银行进行同业拆借。外汇或 FX 是货币市场的另一个类别，其中进行货币交易。

+   **信贷市场**：这些主要由零售银行组成，他们从中央银行借款，以抵押贷款或贷款的形式向公司或家庭提供贷款。

+   **资本市场**：这些促进金融工具的买卖，主要是股票和债券。资本市场可以分为两种类型：一级市场和二级市场。股票直接由公司在一级市场发行给投资者，而在二级市场，投资者通过证券交易所将其证券转售给其他投资者。今天，交易所使用各种电子交易系统来促进金融工具的交易。

# 交易

市场是各方进行交易的地方。它可以是一个实际的地点，也可以是一个电子的或虚拟的地点。在这些市场上交易各种金融工具，包括股票、外汇、商品和各种类型的衍生品。最近，许多金融机构推出了软件平台，以交易不同资产类别的各种类型的工具。

**交易**可以定义为交易员买卖各种金融工具以获取利润和对冲风险的活动。投资者、借款人、对冲者、资产交换者和赌徒是交易员的几种类型。当交易员欠某物时，即如果他们卖出了一份合约，则他们持有空头仓位；当他们买入一份合约时，则持有多头仓位。有各种各样的交易方式，例如通过经纪人或直接在交易所或**场外交易**（**OTC**）进行交易，买方和卖方直接彼此交易，而不是使用交易所。**经纪人**是为客户安排交易的代理商。经纪人代表客户以给定价格或最佳价格交易。

# 交易所

**交易所**通常被认为是一个非常安全、受监管和可靠的交易场所。在过去的十年中，电子交易比传统的基于交易大厅的交易更受欢迎。现在，交易员将订单发送到一个中央电子订单簿，订单、价格和相关属性通过通信网络发布到所有关联系统，从而实质上创建了一个虚拟市场。只有交易所成员才能进行交易。为了避免这些限制，交易对手可以直接参与场外交易。

# 订单和订单属性

**订单**是交易的指令，它们是交易系统的主要构建块。它们具有以下一般属性：

+   工具名称

+   交易数量

+   方向（买入或卖出）

+   表示各种条件的订单类型，例如，限价订单和止损订单是一旦价格达到订单中指定的价格就进行买入或卖出的订单，例如，以 200 英镑购买谷歌股票。限价订单允许以特定价格或更好价格出售或购买股票。例如，如果价格是 100 美元或更高，就出售微软股票。

订单通过买价和卖价交易。交易员通过给他们的订单附加买价和卖价来表明他们的买卖意向。交易员愿意购买的价格称为**买价**。交易员愿意出售的价格称为**卖价**。

# 订单管理和路由系统

**订单路由系统**根据业务逻辑将订单路由并交付到不同的目的地。客户使用它们将订单发送给他们的经纪人，然后经纪人将这些订单发送给经销商、结算所和交易所。

有不同类型的订单。其中两种最常见的是市场订单和限价订单。

**市场订单**是以市场当前最佳价格进行交易的指令。这些订单会立即以现货价格填补。另一方面，**限价订单**是以可用的最佳价格进行交易的指令，但前提是它不低于交易员设定的限价。根据订单的方向，限价也可以更高。所有这些订单都由交易所维护的**订单簿**管理，它记录了交易员的买卖意向。

**头寸**是对以特定价格出售或购买一定数量的金融工具（包括证券、货币或大宗商品）的承诺。交易员买卖的合同、证券、商品和货币通常被称为**交易工具**，它们属于**资产类别**的广泛范畴。最常见的类别包括实物资产、金融资产、衍生合约和保险合约。

# 交易的组成部分

**交易单据**是与一项交易相关的所有细节的组合。但是，这些元素的具体内容取决于工具的类型和资产类别。这些元素在以下小节中描述。

# 底层工具

**底层工具**是交易的基础。它可以是货币、债券、利率、商品或股票。

金融工具的属性将在以下小节中讨论。

# 一般特性

这包括与每笔交易相关的一般识别信息和基本特征。典型属性包括唯一 ID、工具名称、类型、状态、交易日期和时间。

# 经济特性

**经济特性**与交易价值相关，例如购买或出售价值、股票代码、交易所、价格和数量。

# 销售

**销售**指与销售相关的特征细节，例如销售人员的名称。这只是一个信息字段，通常不会对交易生命周期产生任何影响。

# 对手方

**对手方**是交易的重要组成部分，因为它显示了交易中涉及的另一方（交易中的另一方），并且需要成功结算交易。常见的属性包括对手方名称、地址、支付类型、任何参考 ID、结算日期和交付类型。

# 交易生命周期

一个一般的**交易生命周期**包括从下单到执行和结算的各个阶段。这个生命周期逐步描述如下：

+   **预执行**：在这个阶段下单。

+   **成交和预订**：当订单被匹配和执行时，它会转化为一笔交易。在这个阶段，交易对手之间的合约就成熟了。

+   **确认**：在这里，交易双方就交易的各种具体事项达成一致。

+   **后预订**：这个阶段涉及到各种仔细审查和验证过程，以确认交易的正确性。

+   **结算**：这是交易生命周期中最关键的部分。在这个阶段，交易就已经最终确定了。

+   **隔夜（日终处理）**：日终处理包括报告生成、损益计算和各种风险计算。

该生命周期也显示在以下截图中：

![](img/d6e1a330-91a8-4bb6-8d17-d734d5d54968.png)

交易生命周期

在所有上述流程中，涉及到许多人和业务职能。最常见的是将这些职能划分为前台、中台和后台等职能。 

在接下来的部分，将介绍一些对于理解严格而必要的金融行业规章制度至关重要的概念。一些这里描述的概念在后面的章节中再次描述，当讨论具体的应用案例时。这些想法将帮助您理解所描述的场景。

# 订单预测者

**订单预测者**试图在其他交易员进行交易之前获利。这是基于一个交易员预期他人的交易活动将如何影响价格。先行者、情绪导向的技术交易者和挤压者都是订单预测者的一些实例。

# 市场操纵

**市场操纵**在许多国家严格禁止。欺诈交易者可以在市场中传播虚假信息，这可能导致价格波动，从而实现非法获利。通常，操纵市场行为是基于交易的，包括普遍性和特定时间的操纵。可以创建股票人为短缺、虚假活动的印象和价格操纵以获取犯罪利益的行为都包括在此类别中。

这两个名词都和金融犯罪有关。然而，由于区块链系统的透明度和安全性，有可能开发基于区块链的系统来阻截市场滥用。

# 总结

我们从介绍非对称密钥加密开始了本章。我们讨论了诸如 RSA 和 ECC 之类的各种构造。我们还使用 OpenSSL 进行了一些实验，以验证理论概念如何实际实现。之后，我们详细讨论了哈希函数及其特性和用法。接下来，我们涵盖了 Merle 树等概念，这些概念在区块链中被广泛使用，实际上是其核心。我们还介绍了其他概念，如 Patricia 树和哈希表。
