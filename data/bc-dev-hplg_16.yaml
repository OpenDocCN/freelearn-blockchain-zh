- en: Exploring an Enterprise Blockchain Application Using Hyperledger Fabric
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyperledger Fabric探索企业区块链应用
- en: The previous chapter, we discussed the Ethereum blockchain. Ethereum is a public
    blockchain; anyone can read the blockchain data and make legitimate changes. Anyone
    can write a new block into the chain. Ethereum is fully autonomous and is not
    controlled by anyone. The smart contract is written in Solidity, as a nearly Turing
    complete language, that can run on the **Ethereum virtual machine** (**EVM**)
    to execute various transactions. Developers can build and deploy **d****ecentralized
    applications** (**DApps**) using these smart contracts. Ether is a cryptocurrency in
    Ethereum, and acts as fuel for every operation in Ethereum, including executing
    smart contracts, DApps, transactions, and so on. However, this is not the only
    way to build a blockchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了以太坊区块链。以太坊是一个公共区块链；任何人都可以阅读区块链数据并进行合法的更改。任何人都可以向链中写入一个新区块。以太坊是完全自治的，不受任何人控制。智能合约用Solidity语言编写，作为一个几乎图灵完备的语言，可以在**以太坊虚拟机**
    (**EVM**)上执行各种交易。开发人员可以使用这些智能合约构建和部署**去中心化应用** (**DApps**)。以太是以太坊中的加密货币，作为执行以太坊中的每个操作的燃料，包括执行智能合约、DApps、交易等。然而，这并不是构建区块链的唯一方法。
- en: Blockchains that require an access control layer built into the blockchain nodes
    to read restricted information on the blockchain can be created. This will limit
    the number of participants in the network who can transact in the consensus mechanism
    of the blockchain's network. This kind of blockchain is called a permissioned
    blockchain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建需要在区块链节点中建立访问控制层以读取区块链上受限信息的区块链。这将限制网络中能够参与共识机制中交易的参与者数量。这种区块链称为许可区块链。
- en: 'The differences between public and permissioned blockchains are shown in the
    following table:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了公共和许可区块链之间的区别：
- en: '|  | **Permissionless** | **Permissioned** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|  | **无需许可** | **许可** |'
- en: '| Public | Everyone can read the transaction data.Everyone can validate a transaction
    in the block.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '| 公共 | 每个人都可以阅读交易数据。每个人都可以验证区块中的交易。'
- en: '**Speed**: Poor'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 差'
- en: '**Consensus**: Proof-of-Work'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**: 工作量证明'
- en: '**Blockchain**: Bitcoin, Ethereum'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链**: 比特币、以太坊'
- en: '**Token**: Needed'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代币**: 需要'
- en: '| Everyone can read the transaction data.Only predefined users can validate
    a transaction.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '| 每个人都可以阅读交易数据。只有预定义的用户可以验证交易。'
- en: '**Speed**: Good'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 良好'
- en: '**Consensus**: Proof-of-Work'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**: 工作量证明'
- en: '**Blockchain**: Ethereum after Casper'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链**: 卡斯帕后的以太坊'
- en: '**Token**: Needed'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代币**: 需要'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Private | Only predefined users can read transaction data.Only predefined
    users can validate a transaction.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '| 私有 | 只有预定义的用户可以读取交易数据。只有预定义的用户可以验证交易。'
- en: '**Speed**: Good'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 良好'
- en: '**Consensus**: **Federated byzantine agreement** (**FBA**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**: **联邦拜占庭协议** (**FBA**)'
- en: '**Token**: Not needed'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代币**: 不需要'
- en: '| Only predefined users can read transaction data.Only entitled users can validate
    a transaction.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有预定义的用户可以读取交易数据。只有有权的用户可以验证交易。
- en: '**Speed**: Good'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 良好'
- en: '**Consensus**: **Practical Byzantine Fault Tolerance Algorithm** (**PBFT**)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**: **实用拜占庭容错算法** (**PBFT**)'
- en: '**Blockchain**: Hyperledger Fabric'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链**: Hyperledger Fabric'
- en: '**Token**: Not needed'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代币**: 不需要'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Hyperledger Fabric is one such private permissioned blockchains. In this chapter,
    we will discuss the Hyperledger Fabric blockchain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric是一种私有的许可区块链之一。在本章中，我们将讨论Hyperledger Fabric区块链。
- en: Hyperledger Fabric is an open source enterprise blockchain technology. The project
    was initially contributed by IBM and digital asset. Hyperledger Fabric is one
    of the blockchain projects hosted by the Linux foundation. The smart contract
    in Hyperledger Fabric is called *chaincode*, which defines the business logic
    for Fabric applications. The modular architecture design enables Fabric to support
    high degrees of confidentiality, resiliency, flexibility, and scalability. The
    components in Fabric, such as consensus and membership services, can be plug and
    play.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric是一种开源企业区块链技术。该项目最初由IBM和数字资产贡献。Hyperledger Fabric是Linux基金会托管的区块链项目之一。Hyperledger
    Fabric中的智能合约称为*链码*，它定义了Fabric应用的业务逻辑。模块化的架构设计使Fabric能够支持高度的机密性、恢复能力、灵活性和可扩展性。Fabric中的组件，如共识和成员服务，可以插拔式部署。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Issuance claim
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行声明
- en: Setting up a Hyperledger Fabric environment
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Hyperledger Fabric环境
- en: Write a chaincode
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写链码
- en: Configuring Hyperledger Fabric
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Hyperledger Fabric
- en: Issuance claim
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发行索赔
- en: In this section, we will explore and implement an issuance claim use case.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨并实施一个发行索赔的用例。
- en: No one wants to have an insurance claim, but when things do go wrong and accidents
    happen, this may result in financial losses. These losses will be covered by your
    insurance policy. The traditional insurance claims process has stayed the same
    for decades, as there are a number of key issues in the process, including false
    claims, fraud detection, slow and complex claims processing, human error, undesirable
    customer experience, and inefficient information flows in reinsurance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人希望有保险索赔，但当事情出错和发生事故时，这可能会导致财务损失。这些损失将由您的保险单承担。传统的保险理赔流程几十年来都保持不变，因为流程中存在许多关键问题，包括虚假索赔、欺诈检测、缓慢和繁琐的索赔处理、人为错误、不佳的客户体验以及再保险中信息流的低效。
- en: With blockchain, the transaction record in the ledger is immutable and the state
    data can only be updated when all parties agree. The record in the blockchain
    can be shared in real time. This allows insurers to move quickly, as most of the
    required information for claims verification can be processed in no time. Insurers
    can track the use of asset data in the blockchain. The paperwork can be eliminated
    and customers can submit claims via a web application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区块链，分类账中的交易记录是不可变的，只有当所有各方都同意时，状态数据才能更新。区块链中的记录可以实时共享。这使得保险公司可以迅速行动，因为大部分用于索赔验证的必要信息可以在短时间内处理。保险公司可以跟踪区块链中资产数据的使用情况。文件工作可以被消除，客户可以通过网络应用提交索赔。
- en: 'Let''s take a look at the insurance claim process, as shown in the following
    screenshot. For demonstration purposes, we simplified the claim process, as it
    can be much more complex in a real-world use case:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下保险索赔流程，如下截图所示。为了演示目的，我们简化了索赔流程，因为在实际应用中可能会更加复杂：
- en: '![](img/2e09b04a-3c1a-43fb-be57-fcd9ef2b82db.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e09b04a-3c1a-43fb-be57-fcd9ef2b82db.png)'
- en: 'For the preceding process, the steps are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述流程，步骤如下：
- en: An insuree reports a claim to a broker
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被保险人向经纪人报告索赔
- en: A broker provides requested information
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经纪人提供请求的信息
- en: A broker submits a claim to an issuer
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经纪人向发行人提交索赔
- en: An issuer confirms the claim
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发行人确认索赔
- en: An issuer process and approves the claim
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发行人处理并批准索赔
- en: Setting up a Hyperledger Fabric environment
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Hyperledger Fabric环境
- en: So far, we have learned about the key concepts of Hyperledger Fabric. In this
    section, we will set up a Hyperledger Fabric development environment. Before continuing
    with the installation steps, let's take a look at the prerequisites for fabric
    installation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Hyperledger Fabric的关键概念。在本节中，我们将建立一个Hyperledger Fabric开发环境。在继续进行安装步骤之前，让我们看一下fabric安装的先决条件。
- en: Installation prerequisites
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: The following are the prerequisites for installing the required development
    tools.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的开发工具的先决条件如下：
- en: '| Ubuntu Linux 14.04 / 16.04 LTS (both 64-bit), or macOS 10.12 | Docker Engine:
    Version 17.03 or higher |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu Linux 14.04 / 16.04 LTS（均为64位），或 macOS 10.12 | Docker Engine：版本17.03或更高
    |'
- en: '| Docker-Compose: Version 1.8 or higher | Node: 8.9 or higher (note version
    9 is not supported) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Docker-Compose：版本1.8或更高 | Node：8.9或更高（注意不支持9版本） |'
- en: '| npm: v5.x | git: 2.9.x or higher |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| npm：v5.x | git：2.9.x或更高 |'
- en: '| Python: 2.7.x |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Python：2.7.x |  |'
- en: 'We will use Ubuntu for our development environment. We can download the prerequisites
    using the following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在开发环境中使用Ubuntu。我们可以使用以下命令下载先决条件：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It may prompt for your password, since it uses `sudo` during its execution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能在执行过程中提示您输入密码，因为它在执行过程中使用了`sudo`。
- en: Installing Hyperledger Fabric
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Hyperledger Fabric
- en: 'Create and navigate to the project folder called `insurance-claim`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并转到名为`insurance-claim`的项目文件夹，如下所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the following command to install the Hyperledger Fabric platform-specific
    binaries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以安装Hyperledger Fabric特定于平台的二进制文件：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After this executes, it downloads the following platform-specific binaries
    in the `bin` folder, which is located under the `fabric-samples` folder. You can
    set `fabric-samples/bin` as a `PATH` variable as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，它会在`bin`文件夹中下载以下特定于平台的二进制文件，该文件夹位于`fabric-samples`文件夹下。您可以将`fabric-samples/bin`设置为`PATH`变量，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also provide `bootstrap-hyperledger.sh` from the code files in this book,
    and you can download it from the Packt site. Once you get the file, you can directly
    run the following script, and it will create a bin folder and download binaries
    to this folder:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从本书的代码文件中提供 `bootstrap-hyperledger.sh`，您可以从 Packt 网站下载。一旦获得文件，您可以直接运行以下脚本，它将创建一个
    bin 文件夹并将二进制文件下载到此文件夹中：
- en: '![](img/e37a3890-b4e9-4004-b6c6-d1d6f293c437.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e37a3890-b4e9-4004-b6c6-d1d6f293c437.png)'
- en: These components will be part of our Hyperledger Fabric network.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将成为我们的 Hyperledger Fabric 网络的一部分。
- en: Writing chaincode
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写链码
- en: Chaincode is similar to a *smart contract*. It defines and executes the business
    logic invoked by authorized participants in a specific network. A chaincode is
    written in Go or Node.js. In our example, we will use Go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Chaincode 类似于*智能合约*。它定义并执行由特定网络中的授权参与者调用的业务逻辑。链码是用 Go 或 Node.js 编写的。在我们的示例中，我们将使用
    Go。
- en: There are many IDEs and tools to support Golang. Here are some popular IDEs
    that work great with Golang.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 IDE 和工具支持 Golang。以下是一些与 Golang 配合得很好的流行 IDE。
- en: Development tools
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: There are various tools that support Go development. Some popular IDEs are listed
    in the following sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种工具支持 Go 开发。一些流行的 IDE 在以下部分列出。
- en: LiteIDE
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LiteIDE
- en: LiteIDE is an open source Go IDE that was directly designed for Golang. There
    are a bunch of useful features available for Go developers, including a configurable
    code editor, customized build commands, many building options, and Golang support.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE 是专为 Golang 设计的开源 Go IDE。有许多适用于 Go 开发人员的有用功能，包括可配置的代码编辑器、自定义构建命令、许多构建选项和
    Golang 支持。
- en: JetBrains Gogland
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JetBrains Gogland
- en: Gogland has a powerful built-in autocomplete engine, errors detection, code
    refactoring tools, and more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gogland 拥有强大的内置自动完成引擎、错误检测、代码重构工具等等。
- en: Visual Studio Code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can install Go extension in Visual Studio Code. It provides code hints and
    the ability to debug code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Visual Studio Code 中安装 Go 扩展。它提供代码提示和调试代码的能力。
- en: 'In this chapter, we will use LiteIDE to develop our chaincode. Follow the official
    LiteIDE installation guide to set up your local IDE environment, which is available
    from the following link:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 LiteIDE 来开发我们的链码。请按照官方 LiteIDE 安装指南设置您的本地 IDE 环境，该指南可从以下链接获取：
- en: '[https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/install.md](https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/install.md).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/install.md](https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/install.md).'
- en: Chaincode key concept and APIs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chaincode 关键概念和 API
- en: 'There are three important functions in Fabric chaincode: `Init`, and `Invoke`,
    `Query`. Every chaincode program must implement the chaincode interface, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 链码中有三个重要的函数：`Init`、`Invoke`、`Query`。每个链码程序都必须实现链码接口，如下所示：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Init()` is called when the application initializes its internal data for other
    chaincode functions to use. It is triggered when a chaincode receives an instantiate
    or upgrade transaction.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Init()`在应用程序初始化其内部数据以供其他链码函数使用时被调用。当链码接收到实例化或升级事务时，它将被触发。'
- en: When the application client proposes an update or query transaction, the `Invoke()`;
    function is called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序客户端提出更新或查询事务时，将调用`Invoke()`函数。
- en: '`Query()` is called when a chaincode queries a chaincode state. Hyperledger
    Fabric uses LevelDB (key/value store) as the default database to store world;state
    data. You can use a key to get the current ledger state data. The query function
    reads the value of a chaincode state by passing in the key value.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当链码查询链码状态时，将调用`Query()`。Hyperledger Fabric 使用 LevelDB（键值存储）作为存储 world;state
    数据的默认数据库。您可以使用键来获取当前账本状态数据。查询函数通过传入键值读取链码状态的值。
- en: The shim package provides APIs for the chaincode to access its state variables,
    transaction context, and call other chaincodes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: shim 包提供了用于链码访问其状态变量、事务上下文和调用其他链码的 API。
- en: '`ChaincodeStubInterface` is one of the important interfaces. It provides various
    functions that let you query, update, and delete assets in the ledger. These are
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStubInterface` 是其中一个重要的接口。它提供了各种函数，让您可以查询、更新和删除账本中的资产。这些函数如下所示：'
- en: '| `GetState(key string) ([]byte, error)` | `GetState` returns the value of
    the specified key from the ledger |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `GetState(key string) ([]byte, error)` | `GetState` 函数从账本中返回指定键的值。'
- en: '| `PutState(key string, value []byte) error` | `PutState` puts the specified
    key and value into the transaction''s writeset as a data-write proposal |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `PutState(key string, value []byte) error` | `PutState`将指定的键和值放入交易的写集作为数据写提案|'
- en: '| `DelState(key string) error` | `DelState` records the specified key to be
    deleted in the writeset of the transaction proposal |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `DelState(key string) error` | `DelState`记录了交易提案的写集中将要删除的指定键|'
- en: Defining an issuance claim
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发行理赔
- en: 'Let''s write a chaincode. Open LiteIDE and create a new file called `claimcontract.go`,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一段链码。打开LiteIDE并创建一个名为`claimcontract.go`的新文件，如下所示：
- en: '![](img/d95fe9a2-5608-4e08-89f7-0f366490d8ee.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d95fe9a2-5608-4e08-89f7-0f366490d8ee.png)'
- en: 'In the insurance claim use case analysis, we analysed the participants in the
    issuance claim process. There are three participants for whom we need to define
    a chaincode: insuree, broker, and insurer, as shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在保险理赔使用案例分析中，我们分析了发行理赔流程中的参与者。我们需要定义一个链码的参与者有三个：被保险人、经纪人和保险人，如下例所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `Insuree`, we define `Id`, `firstname`, `LastName`, `SSN`, and `policyNumber`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Insuree`中，我们定义了`Id`、`firstname`、`LastName`、`SSN`和`policyNumber`。
- en: 'In Go language, it allows the first letter of a field name as to be either
    uppercase or lowercase. When we need an exported field to be public for any piece
    of code to use it, it needs to be a capitalized letter. You can use encoding in
    the JSON package to unmarshal data into struct, which defines the field name in
    JSON as the `firstName` key, as shown in the following format:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，字段名的第一个字母可以是大写或小写。当我们需要一个导出字段对任何代码使用时，它需要是一个大写字母。你可以使用JSON包中的编码将数据解析为结构体，定义JSON中的字段名为`firstName`，如下所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The broker and insurers data models are similar and only different in type.
    We define them as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪人和保险人的数据模型类似，只是类型不同。我们将其定义如下：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the issuance claim process, `Insuree` initializes a claim request. The claim
    document will keep track of each step of the process in the blockchain. It records
    all necessary information, including status, user claim description, `insueeId`,
    `brokerId`, `insurerId`, process time at each step, and comments entered from
    an authorized party, as shown in the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在发行理赔流程中，`Insuree`初始化理赔请求。理赔文件将在区块链中跟踪流程的每一步。它记录了所有必要的信息，包括状态、用户理赔描述、`insueeId`、`brokerId`、`insurerId`、每个步骤的处理时间以及授权方输入的评论，如下例所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Initializing the chaincode
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化链码
- en: 'Next, we''ll implement the `Init` function. `Init()` allows the chaincode to
    initialize the insuree data to start the claim request. In our case, we will set
    up and register the insuree person information, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`Init`函数。`Init()`允许链码初始化被保险人数据以开始理赔请求。在我们的情况下，我们将设置并注册被保险人的个人信息，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ChaincodeStubInterface.GetStringArg` gets the input arguments. It expects
    that the length of the arguments should be 5\. With all required insurer data,
    we build Insurer JSON data and encode it to JSON byte strings –`json.Marshal(insureeData`.
    Then, we store the key and the value on the ledger. If all went well, it returns
    a `peer.Response` object with success to Fabric''s `client.c`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStubInterface.GetStringArg`获取输入参数。它期望参数的长度应为5。拥有所有必需的保险人数据后，我们构建保险人JSON数据，并将其编码为JSON字节字符串–`json.Marshal(insureeData)`。然后，我们将键和值存储在分类账上。如果一切顺利，它将返回一个成功的`peer.Response`对象给Fabric的`client.c`。'
- en: Invoking the chaincode
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用链码
- en: 'To trigger the invoke function, you can call the name of the chaincode application
    function and pass `shim.ChaincodeStubInterface` as the signature. In the insurance
    claim case, we defined several functions to support our use case, for example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发调用函数，可以调用链码应用函数的名称，并将`shim.ChaincodeStubInterface`作为签名传递。在保险理赔案例中，我们定义了几个函数来支持我们的用例，例如：
- en: '`AddCompany`, `ReportLost`, `RequestedInfo`, `SubmitClaim`, `ConfirmClaimSubmission`,
    `ApproveClaim`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddCompany`, `ReportLost`, `RequestedInfo`, `SubmitClaim`, `ConfirmClaimSubmission`,
    `ApproveClaim`.'
- en: 'We also defined a query to keep track of the current claim request and `getHistory`
    to get all of the historical claim transaction records, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个查询来跟踪当前理赔请求和`getHistory`来获取所有历史理赔交易记录，如下所示：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: AddCompany
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddCompany
- en: '`AddCompany` is similar to how we added insuree at the Init step. Chaincode
    can register brokers and insurers through this function. The company type can
    be a *broker* or *insurer*, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddCompany`类似于我们在初始化步骤添加被保险人的方式。链码可以通过此函数注册经纪人和保险人。公司类型可以是*经纪人*或*保险人*，如下所示：'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ReportLost
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告丢失
- en: 'In this step, the insuree reports the lost item to the broker with all the
    claim information. This function also records the current system process time
    at the `processAt` field. `currentts.Format(2006-01-02 15:04:05)` is a Go custom
    format; it will convert the current time into YYYY-MM-dd hh:mm:ss format, as shown
    in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，投保人向经纪人报告丢失物品，并提供所有索赔信息。此函数还在`processAt`字段记录当前系统处理时间。`currentts.Format(2006-01-02
    15:04:05)`是一个Go自定义格式；它将当前时间转换为YYYY-MM-dd hh:mm:ss格式，如以下示例所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: RequestedInfo
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequestedInfo
- en: 'After the insuree reports a loss, the next step is for the broker to return
    `RequestedInfo`, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 投保人报告损失后，下一步是经纪人返回`RequestedInfo`，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the remaining process functions are quite similar, we define `UpdateClaim`
    as a common function to share with the remaining steps.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于剩余的流程函数非常相似，我们将`UpdateClaim`定义为一个通用函数，与剩余步骤共享。
- en: The `UpdateClaim` function first gets `claimId` and the current participant
    comment from input arguments. It then queries and gets a claim from the blockchain
    to decode the claim data and turns it into a JSON string—`json.Unmarshal(claimBytes,
    &claim)`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateClaim`函数首先从输入参数中获取`claimId`和当前参与者评论。然后，它查询并从区块链中获取索赔以解码索赔数据，并将其转换为JSON字符串—`json.Unmarshal(claimBytes,
    &claim)`。'
- en: Before updating the claim content, it will validate the input claim status and
    make sure it is on the expected step. If all goes well, we will update the claim
    status, participant comment, and process time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新索赔内容之前，它将验证输入的索赔状态并确保其处于预期步骤上。如果一切顺利，我们将更新索赔状态、参与者评论和处理时间。
- en: Finally, we update the claim data with `claimId` as a key on the ledger.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`claimId`作为键在账本上更新索赔数据。
- en: SubmitClaim, ConfirmClaimSubmission, ApproveClaim
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交索赔，确认提交索赔，批准索赔
- en: Submitting, confirming, and approving the claim are very similar to `RequestedInfo`,
    and these steps are called by the `UpdateClaim` function. Only the comment, status,
    and process time values are different.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提交、确认和批准索赔与`RequestedInfo`非常相似，并且这些步骤由`UpdateClaim`函数调用。只有评论、状态和处理时间值不同。
- en: Query
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询
- en: 'Queries are how you read data from the ledger. The query function is used to
    query the chaincode''s state. As we put claim data in the ledger with `claimId`,
    in order to read the current claim, we call `GetState`, passing `claimId` as key,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是您从分类帐中读取数据的方式。查询函数用于查询链码的状态。由于我们将索赔数据存储在以`claimId`为键的分类帐中，为了读取当前索赔，我们调用`GetState`，传递`claimId`作为键，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: getHistory
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getHistory
- en: As its name indicates, the `gethistory` function reads a claim of all historical
    values records for a key, as well as the `TxId` and claim value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`gethistory`函数读取一个键的所有历史值记录的索赔，以及`TxId`和索赔值。
- en: 'We first define the `AuditHistory` struct, which has `TxId` and value. `GetHistoryForKey`
    returns the list of results with `resultsIterator`, which contains all historical
    transaction records. We iterate through these records and add them to an array
    of `AuditHistory`. Later, we convert it to JSON byte and send the data back as
    a response, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义了`AuditHistory`结构，其中包含`TxId`和值。`GetHistoryForKey`通过`resultsIterator`返回结果列表，其中包含所有历史交易记录。我们遍历这些记录并将它们添加到一个`AuditHistory`数组中。后来，我们将其转换为JSON字节并作为响应发送回来，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This covers our issuance claim chaincode. We will learn about Hyperledger Fabric
    configuration in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们的发行索赔链码。我们将在下一节学习有关Hyperledger Fabric配置的信息。
- en: Configuring Hyperledger Fabric
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Hyperledger Fabric
- en: 'There are three entities in the insurance claim network—insuree, broker, and
    insurer. All of these participants will register in Fabric as a peer node. The
    following table describes the three peer roles and MSP information:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 保险索赔网络中有三个实体—投保人、经纪人和保险公司。所有这些参与者都将在Fabric中注册为对等节点。以下表格描述了三个对等角色和MSP信息：
- en: '| **User ID** | **Role** | **Organization MSP ID** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **用户ID** | **角色** | **组织MSP ID** |'
- en: '| `user_001` | INSUREE | Org1MSP |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `user_001` | 投保人 | Org1MSP |'
- en: '| `broker_001` | BROKER | Org2MSP |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `broker_001` | 经纪人 | Org2MSP |'
- en: '| `insurer_001` | INSURER | Org3MSP |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `insurer_001` | 保险公司 | Org3MSP |'
- en: We have one insuree who joins the organization with MSP ID org1, one broker
    who joins the organization with MSP ID org2, and one insurer who joins the organization
    with MSP ID org3\. For bootstrapping the fabric network, we need to first generate
    crypto material for all three components that we need to run.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个保险人加入了具有 MSP ID org1 的组织，一个经纪人加入了具有 MSP ID org2 的组织，以及一个保险人加入了具有 MSP ID
    org3 的组织。为了引导 fabric 网络，我们需要首先为我们需要运行的三个组件生成加密材料。
- en: Generating the certificate
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成证书
- en: 'We need to define `crypto-config.yaml` and use the cryptogen tool to generate
    the certificates for each peer. Cryptogen is available in the tools image. `crypto-config.yaml`
    contains the following information:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义 `crypto-config.yaml` 并使用 cryptogen 工具为每个节点生成证书。Cryptogen 可在工具镜像中获得。`crypto-config.yaml`
    包含以下信息：
- en: '**OrdererOrgs**: Definition of organizations managing orderer nodes'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OrdererOrgs**：管理排序节点的组织定义'
- en: '**PeerOrgs**: Definition of organizations managing peer nodes'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PeerOrgs**：管理对等节点的组织定义'
- en: 'OrdererOrgs contains the following information about the ordered node in the
    cluster:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: OrdererOrgs 包含关于集群中排序节点的以下信息：
- en: '**Name**: Name of the orderer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：订单者的名称'
- en: '**Domain**: Domain URL for orderer; in our case, it is ic.com'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域**：订单者的域 URL；在我们的案例中，它是 ic.com'
- en: '**Hostname**: Hostname for the orderer'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机名**：订单者的主机名'
- en: 'Here is an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'PeerOrgs contains the following information about the peer node in the cluster:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PeerOrgs 包含关于集群中对等节点的以下信息：
- en: '**Name**: Name of the organization; we have three different orgs : `Org1`,
    `Org2`, and `Org3`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：组织的名称；我们有三个不同的组织：`Org1`、`Org2` 和 `Org3`'
- en: '**Template count**: Number of peer nodes for an organization'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板计数**：组织的节点数'
- en: '**Users count**: Number of users for an organization'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户计数**：组织的用户数'
- en: 'Here is an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the command thats used to generate the crypto material:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于生成加密材料的命令：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After running the cryptogen tool, you should see the following output in the
    console:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 cryptogen 工具后，您应该在控制台上看到以下输出：
- en: '![](img/f372e012-65e2-4067-a56e-eb6f5df2e836.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f372e012-65e2-4067-a56e-eb6f5df2e836.png)'
- en: Generating an orderer genesis block
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成订单者创世区块
- en: 'After generating the certificate, the next step in the process is to generate
    the orderer genesis block. The `configtxgen` command allows users to create and
    inspect channel config. The `configtxgen` tool''s output is largely controlled
    by the content of `configtx.yaml`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成证书后，该过程的下一步是生成订单者创世区块。`configtxgen` 命令允许用户创建和检查通道配置。`configtxgen` 工具的输出主要由
    `configtx.yaml` 的内容控制，如下所示：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We defined three organizations in the `Organizations` section of the `configtx`
    file; we specified each organization name, `ID`, `MSPDir`, and `AnchorPeers`.
    `MSPDir` describes cryptogen generated output MSP directories. `AnchorPeers` points
    to the peer node''s host and port. It updates transactions in order to enable
    communication between peers of different organizations and finds all active participants
    of the channel, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `configtx` 文件的 `Organizations` 部分定义了三个组织；我们指定了每个组织的名称、`ID`、`MSPDir` 和 `AnchorPeers`。`MSPDir`
    描述了 cryptogen 生成的输出 MSP 目录。`AnchorPeers` 指向节点的主机和端口。它更新事务以便在不同组织的节点之间启用通信，并找到通道的所有活动参与者，如下所示：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An output similar to the following will be displayed on the console:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下的输出将显示在控制台上：
- en: '![](img/a5b82468-8507-471d-826c-776cb47d8500.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5b82468-8507-471d-826c-776cb47d8500.png)'
- en: Generating a channel configuration transaction
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成通道配置事务
- en: '`configtxgen` writes a channel creation transaction to `channel.tx` by executing
    a channel configuration transaction, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`configtxgen` 通过执行通道配置事务将通道创建事务写入 `channel.tx`，如下所示：'
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An output similar to the following will be displayed on the console:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下的输出将显示在控制台上：
- en: '![](img/2cc154e6-09db-4255-ba74-2b39c82e620d.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cc154e6-09db-4255-ba74-2b39c82e620d.png)'
- en: Output for executing channel configuration transaction
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行通道配置事务的输出
- en: Overview of Hyperledger Fabric Docker composer configuration files
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger Fabric Docker 组合器配置文件概述
- en: 'Hyperledger Fabric utilizes Docker compose to define fabric application services.
    The `docker-compose-cli.yaml` service section is the place for defining all peer
    services and related containers. Hyperledger Fabric''s *first-network* provides
    a `.yaml` template to help you quickly start to create yaml files from scratch:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 利用 Docker compose 来定义 fabric 应用服务。`docker-compose-cli.yaml`
    服务部分是定义所有对等服务和相关容器的地方。Hyperledger Fabric 的 *first-network* 提供了一个 `.yaml` 模板，帮助您快速开始从头创建
    yaml 文件：
- en: '[https://github.com/hyperledger/fabric-samples/tree/release-1.2/first-network](https://github.com/hyperledger/fabric-samples/tree/release-1.2/first-network).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/hyperledger/fabric-samples/tree/release-1.2/first-network](https://github.com/hyperledger/fabric-samples/tree/release-1.2/first-network)。'
- en: 'In `docker-compose-cli.yaml`, we define the following information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-compose-cli.yaml` 中，我们定义了以下信息：
- en: '`networks`: Definition of the blockchain network name. In our case, it is `icn`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networks`：定义区块链网络名称。在我们的案例中，它是 `icn`。'
- en: '`services`: Definition of all peer services and related Docker containers'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`：定义所有对等服务和相关 Docker 容器'
- en: '`cli`: Definition of the Cli container that is used to replace the SDK client,
    and environment variables for Docker compose command-line behavior'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cli`：定义了用于替代 SDK 客户端的 Cli 容器，并设置了 Docker compose 命令行行为的环境变量'
- en: 'Here is an example configuration for the network and service section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络和服务部分的示例配置：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, there is a file extension directory: `base/docker-compose-base.yaml`.
    Docker compose supports sharing common configuration for individual services with
    the *extends *field. We will discuss more on `docker-compose-base.yaml` later.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个文件扩展目录：`base/docker-compose-base.yaml`。Docker compose 支持使用 *extends*
    字段为单个服务共享公共配置。我们稍后会详细讨论 `docker-compose-base.yaml`。
- en: 'Here is an example of configuration for `cli` section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `cli` 部分的配置示例：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `docker-compose` tool uses the `docker-compose-cli.yaml` file to initialize
    the fabric runtime environment. Blow are some of the most common commands you
    will use when using `docker-compose-cli.yaml` file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具使用 `docker-compose-cli.yaml` 文件来初始化 fabric 运行时环境。以下是在使用
    `docker-compose-cli.yaml` 文件时您将使用的一些最常见的命令：'
- en: '| `TTY` | TTY basically means *a console*, and we set it as true. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `TTY` | TTY 基本上意味着 *控制台*，我们将其设置为 true。'
- en: '| `Image` | Points to the fabric-tools image directory. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | 指向 fabric-tools 图像目录。'
- en: '| `Environment` | Specifies environment variables, for example, GOPATH, a TLS-related
    file location generated by the cryptogen tool. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Environment` | 指定环境变量，例如 GOPATH，由 cryptogen 工具生成的与 TLS 相关的文件位置。'
- en: '| `working_dir` | Sets the working directory for the peer. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `working_dir` | 设置了对等体的工作目录。'
- en: '| `command` | Specifies the command that is issued when the container starts.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `command` | 指定容器启动时发出的命令。'
- en: '| `volumes` | Maps the directories that are being used in the environment configurations.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `volumes` | 映射了在环境配置中使用的目录。'
- en: '| `depends_on` | Starts services in dependency order. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `depends_on` | 按依赖顺序启动服务。'
- en: It then generates four fabric-peer transaction node containers, one fabric-order
    orderer node container, and one fabric-tools cli container.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后生成四个 fabric-peer 事务节点容器，一个 fabric-order 订单节点容器和一个 fabric-tools cli 容器。
- en: Fabric project directory structure
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fabric 项目目录结构
- en: 'In our Fabric sample first-network, the project structure is similar to the
    following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Fabric 示例 first-network 中，项目结构类似于以下内容：
- en: '![](img/401e9804-ae43-4ca3-88db-b4998ae19425.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/401e9804-ae43-4ca3-88db-b4998ae19425.png)'
- en: 'As we discussed previously, the `docker-compose-cli.yaml` service extends from
    `base/docker-compose-base.yaml`. There are two file base directories: `peer-base.yaml`
    and `docker-compose-base.yaml`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，`docker-compose-cli.yaml` 服务是从 `base/docker-compose-base.yaml` 继承的。有两个文件基目录：`peer-base.yaml`
    和 `docker-compose-base.yaml`。
- en: Docker-compose-base.yaml
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker-compose-base.yaml
- en: 'This file contains the base configurations, including each peer and orderer
    container environment and port number. This defines the overall topology of the
    insurance claim network, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含基本配置，包括每个对等体和订单容器的环境和端口号。这定义了保险索赔网络的整体拓扑，如下：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Peer-base.yaml
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Peer-base.yaml
- en: 'This file defines peer network configuration for the insurance claim `docker-compose-base.yaml`,
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件为保险索赔 `docker-compose-base.yaml` 定义了对等网络配置，如下：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The command in the peer gets the peer to install the system chaincode and other configurations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等体中的命令让对等体安装系统链码和其他配置。
- en: 'We have an overview of the critical Hyperledger Fabric configuration files,
    so let''s start our insurance claim network using the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了关键的 Hyperledger Fabric 配置文件的概述，所以让我们使用以下代码启动我们的保险索赔网络：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Starting the Hyperledger Fabric network
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 Hyperledger Fabric 网络
- en: 'Now, it is time to bring up our Hyperledger Fabric network. We will use Docker
    commands to kick off the new Docker compose initially:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候启动我们的 Hyperledger Fabric 网络了。我们将使用 Docker 命令来初始化新的 Docker 组合：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The Docker container will trigger the command defined in `docker-compose-cli.yaml`,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器将触发在 `docker-compose-cli.yaml` 中定义的命令，如下所示：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`script.sh` is a script that contains a series of instructions to fabric deployment
    and test commands. We also define some business-specific shell script functions
    in `utils.sh`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`script.sh` 是一个包含一系列用于部署和测试命令的脚本。我们还在 `utils.sh` 中定义了一些业务特定的 shell 脚本函数。'
- en: Creating a channel
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个通道
- en: 'First, we need to create a channel to build a genesis block. Run the following
    command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个通道以构建创世块。运行以下命令：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command reads a genesis block from `channel.tx` that is then used to join
    the channel and creates the icchannel channel. Here is the result on the console:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从 `channel.tx` 中读取一个创世块，然后用于加入通道并创建 `icchannel` 通道。这是控制台上的结果：
- en: '![](img/3eab0ba7-884e-42ac-a4be-6c2ea65d69eb.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eab0ba7-884e-42ac-a4be-6c2ea65d69eb.png)'
- en: Output for the console that joins and creates the channel
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的输出，加入并创建通道
- en: Joining channels
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入通道
- en: 'After the ordering service creates the channel, we can add the peers to the
    channel, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在订购服务创建通道之后，我们可以将对等节点添加到通道中，如下所示：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the result on the console:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台上的结果：
- en: '![](img/f00ebe02-5fe4-4dbb-87fa-e93f6d014dc4.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f00ebe02-5fe4-4dbb-87fa-e93f6d014dc4.png)'
- en: Adding peers to the channel
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将对等节点添加到通道中
- en: We can see that `peer0.org1`, `peer0.org2`, and `peer0.org3` are joined in the
    channel.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `peer0.org1`、`peer0.org2` 和 `peer0.org3` 加入了通道。
- en: Updating the anchor
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锚点
- en: 'The last operation that we need to complete before we start to interact with
    our issuance claim network is to update the anchor peers. Anchor peers receive
    and broadcast transaction updates to the other peers in the organization. Anchor
    peers are searchable in the network. Therefore, any peer registered as an anchor
    peer can be discovered by an order peer or any other peer, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始与我们的发行索赔网络进行交互之前，我们需要完成的最后一个操作是更新锚定对等点。锚定对等点接收并广播事务更新给组织中的其他对等点。锚定对等点在网络中是可搜索的。因此，任何注册为锚定对等点的对等点都可以被订购对等点或任何其他对等点发现，例如：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the console output for this step:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此步骤的控制台输出：
- en: '![](img/cfd90e65-7700-481b-a9cc-662ecea8a326.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfd90e65-7700-481b-a9cc-662ecea8a326.png)'
- en: Getting discovered by an order peer or any other peer
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 被订购对等节点或任何其他对等节点发现
- en: Installing chaincode
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装链码
- en: 'After the previous steps, we are almost ready to use our issuance claim blockchain
    application. However first, we need to install `claimcontract.go` chaincode on
    our network, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤之后，我们几乎可以使用我们的发行索赔区块链应用程序了。但是首先，我们需要在我们的网络上安装 `claimcontract.go` 链码，如下所示：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will see the output of the preceding command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到前述命令的输出：
- en: '![](img/05e22867-8162-4128-807b-21a8278e9152.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05e22867-8162-4128-807b-21a8278e9152.png)'
- en: Installing chaincode to our network
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 安装链码到我们的网络
- en: Instantiating the chaincode
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化链码
- en: 'After installing the chaincode, we need to instantiate it. As we discussed
    previously, we will onboard insuree in the `init()` chaincode. Therefore, we need
    to pass the required arguments to create an insuree participant, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装链码之后，我们需要实例化它。正如我们之前讨论的，我们将在 `init()` 链码中引入被保人。因此，我们需要传递必需的参数来创建一个被保人参与者，如下所示：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the output for this step:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此步骤的输出：
- en: '![](img/18f3917e-a0af-4a2f-bdc1-72c3b2e9e038.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18f3917e-a0af-4a2f-bdc1-72c3b2e9e038.png)'
- en: Creating an insuree participant
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个被保人参与者
- en: 'We query the insuree to verify that the record has been created in the blockchain,
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询被保人以验证记录是否已在区块链中创建，如下所示：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see from this output that the insuree (`user_001`) was added in our
    blockchain:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中我们可以看到，被保人（`user_001`）已经被添加到我们的区块链中：
- en: '![](img/e4cceefe-13f3-4adc-a553-7878bc339945.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4cceefe-13f3-4adc-a553-7878bc339945.png)'
- en: Insuree added in our block chain
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 被保人添加到我们的区块链中
- en: Invoking add broker
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用添加经纪人
- en: 'Let''s onboard a broker to our insurance claim blockchain, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个经纪人加入到我们的保险索赔区块链中，如下所示：
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is the result:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](img/7b9827ae-e4d0-4ce7-bfe8-b7edbf36b36e.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b9827ae-e4d0-4ce7-bfe8-b7edbf36b36e.png)'
- en: Onboarding a broker to our insurance claim blockchain
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将经纪人引入我们的保险索赔区块链
- en: Invoking add insurer
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用添加保险商
- en: 'Add the last party insurer to the insurance claim blockchain, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一方保险商添加到保险索赔区块链中，如下所示：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output that''s displayed is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的输出如下：
- en: '![](img/23f1a783-2301-4690-b9d4-40d56b144e28.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23f1a783-2301-4690-b9d4-40d56b144e28.png)'
- en: Adding a last party insurer to insurance claim blockchain
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一方保险商添加到保险索赔区块链中
- en: Invoking ReportLost
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 ReportLost
- en: All of the participants have joined the network, and it is time to start the
    insurance claim process. An insuree reports a claim to a broker, Here is the command
    to invoke 'ReportLost' chaincode.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参与者都已加入网络，现在是开始保险索赔流程的时候了。被保险人向经纪人报告索赔，以下是调用'ReportLost'链代码的命令。
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following output will be displayed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/72710c2b-a755-42f4-baf1-f02358711cd3.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72710c2b-a755-42f4-baf1-f02358711cd3.png)'
- en: Isuree reporting a claim to a broker
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 被保险人向经纪人报告索赔
- en: Invoking RequestedInfo
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 RequestedInfo
- en: 'A broker provides the requested information, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪人提供请求的信息，如下所示：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following output will be displayed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/8c75a8ea-a6f4-4dfd-b4b9-03bb13fde591.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c75a8ea-a6f4-4dfd-b4b9-03bb13fde591.png)'
- en: Providing the requested information
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 提供所请求的信息
- en: Invoking SubmitClaim
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 SubmitClaim
- en: 'A broker submits a claim to an issuer, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪人向发行人提交索赔，如下所示：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following output will be displayed:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/3d8fdace-39c9-4fb7-b588-13449e5e709b.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d8fdace-39c9-4fb7-b588-13449e5e709b.png)'
- en: Submitting a claim to the issuer
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 向发行人提交索赔
- en: Invoking ConfirmClaimSubmission
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 ConfirmClaimSubmission
- en: 'An issuer confirms the claim, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 发行人确认索赔，如下所示：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following output will be displayed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/26f3b52b-577f-4cf7-993e-a271992d55fa.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f3b52b-577f-4cf7-993e-a271992d55fa.png)'
- en: Confirming the claim
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 确认索赔
- en: Invoking ApproveClaim
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 ApproveClaim
- en: 'An issuer processes and approves a claim, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 发行人处理并批准索赔，如下所示：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following output will be displayed:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/62b5c939-cc78-4331-81a2-0cf836ecd4d5.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62b5c939-cc78-4331-81a2-0cf836ecd4d5.png)'
- en: Processing and approving the claim
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 处理并批准索赔
- en: Querying claim history
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询索赔历史
- en: 'After an issuer approves the claim, the entire process flow is done and we
    can use the Fabric API to query the entire life cycle of the claim, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在发行人批准索赔后，整个流程完成，我们可以使用Fabric API查询索赔的整个生命周期，如下所示：
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From the output obtained from this query, we can see the entire Fabric transaction
    history of the claim request.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从此查询获得的输出中，我们可以看到索赔请求的整个Fabric交易历史。
- en: This ends our test execution.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行结束。
- en: End-to-end test execution
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试执行
- en: 'We have gone over each step of insurance claim fabric execution. To simplify
    the entire end-to-end application flow, you can navigate to the `insurance-claim`
    folder and then run the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了保险索赔流程的每一步。为了简化整个端到端应用程序流程，您可以导航到`insurance-claim`文件夹，然后运行以下命令：
- en: '[PRE43]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output result will be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/62d8148f-3987-43b4-8a66-8be30fe451b8.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62d8148f-3987-43b4-8a66-8be30fe451b8.png)'
- en: Simplifying the entire end to end application flow
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 简化整个端到端应用程序流程
- en: 'The final output is as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出如下：
- en: '![](img/327ba575-e472-423e-9311-acb735d11d70.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/327ba575-e472-423e-9311-acb735d11d70.png)'
- en: Insurance claim End to End Test completes
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 保险索赔端到端测试完成
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the basics of Hyperledger Fabric's. After
    setting up a development environment, we wrote a chaincode for an insurance claim
    use case. We then studied fabric composer configuration. Finally, we ran the end-to-end
    fabric test execution for our insurance claim application. We can see that it
    is quite complex to use Hyperledger Fabric to implement an insurance claim application.
    In the next chapter, we will learn how to use Hyperledger Composer to quickly
    write an insurance claim application.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Hyperledger Fabric的基础知识。在设置开发环境之后，我们为保险索赔用例编写了链代码。然后，我们学习了面料组合器配置。最后，我们对我们的保险索赔应用程序进行了端到端的面料测试执行。我们可以看到，使用Hyperledger
    Fabric实现保险索赔应用程序相当复杂。在下一章中，我们将学习如何使用Hyperledger Composer快速编写保险索赔应用程序。
