- en: Day Three - Implementing Business Logic in Your Smart Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三天 - 在您的智能合约中实现业务逻辑
- en: Well, today is all about functions. We're going to dive deeper into how to create
    them, how they work, and how we use them to create the business logic that makes
    our smart contract work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，今天就讲函数。我们将更深入地了解如何创建它们，它们是如何工作的，以及我们如何使用它们来创建使我们的智能合约工作的业务逻辑。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Solidity functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity 函数
- en: Adding code to functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数添加代码
- en: Function visibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可见性
- en: Using functions to execute business logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数执行业务逻辑
- en: Understanding modifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解修饰符
- en: Solidity functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 函数
- en: 'A function is an executable unit of code within a contract. To create one,
    you specify the `function` keyword, give the function a name, specify any parameters
    it will need to complete its job, set its visibility, add any modifiers required,
    state if it''s a view or a pure function, mark it as payable if it can receive
    ether, and define any returned variables that it will produce; then, we have the
    opening and closing curly braces, and in between these curly braces is where we''ll
    add our code for the function. You won''t have all of these options in every function—this
    is just the order that they go in when you do. For example, you can''t have a
    function marked as pure and payable, because a pure function isn''t allowed to
    modify state – which receiving ether would do. This will become clearer over the
    course of today''s lessons, as we work with more functions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是合约内的可执行代码单元。要创建一个函数，您需要指定`function`关键字，给函数命名，指定完成其工作所需的任何参数，设置其可见性，添加所需的任何修饰符，声明它是一个视图还是纯函数，如果它可以接收以太币则标记为可付款，并定义任何将产生的返回变量；然后，我们有开放和闭合的花括号，在这些花括号之间是我们将添加函数代码的地方。并非每个函数都具有所有这些选项
    - 这只是您进行操作时它们的顺序。例如，您不能将函数标记为纯函数且可付款，因为纯函数不允许修改状态 - 而接收以太币会这样做。在今天的课程中，随着我们使用更多的函数，这将变得更加清晰：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the `return` keyword in a function to indicate that a function will
    return a value to the caller. For example, we can declare an unsigned integer
    named `sum` that gets its value from the result of the `addThis` function, which
    takes two parameters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中使用`return`关键字表示函数将向调用方返回一个值。例如，我们可以声明一个名为`sum`的无符号整数，其值来自`addThis`函数的结果，该函数接受两个参数：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We declare that it''s a function, name it `addThis`, specify that it takes
    two unsigned integers as `(unit a, unit b)` parameters, mark it as `internal`,
    and then specify that it returns an unsigned integer. So, this `returns` keyword
    doesn''t return anything, it only specifies the `function` signature that it''s
    going to, it''s only down here in the body where we use the `return` keyword and
    we actually return the value to the caller, in this case `return a + b` is the
    variable sum. Both pieces – the `returns` keyword in the function signature and
    the return itself – are required. Our add this function might look like the following
    code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明它是一个函数，命名为`addThis`，指定它以两个无符号整数`(unit a, unit b)`作为参数，将其标记为`internal`，然后指定它返回一个无符号整数。所以，这个`returns`关键字不会返回任何东西，它只是指定了函数签名，只有在函数体中使用`return`关键字并实际将值返回给调用者时才会出现，本例中的`return
    a + b`即为变量`sum`。函数签名中的`returns`关键字和返回本身两个部分都是必需的。我们的加法函数可能如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also specify the return like this, where we say this function will return
    the `c` variable, and then inside the function block we assign the `c` variable to
    the sum of `a + b` and return it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像这样指定返回，即我们说这个函数将返回`c`变量，然后在函数块内部，我们将`c`变量分配给`a + b`的总和并返回它：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding code to functions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数添加代码
- en: 'Functions create the application logic for your contract; this means they have
    to do things, and telling them what to do means writing code. The code you write
    goes in between the curly braces of the function. Inside the curly braces, the
    execution of code goes one line at a time from top to bottom. The exception to
    that is if you have conditional logic such as this `if` statement. If `isWinner`
    is not true these lines of code within the curly braces for the `if` block or
    skip, and program execution resumes at the first line of code after the `if` block.
    When the function gets to the last line of code or return statement, the function
    exits:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数为合约创建应用逻辑；这意味着它们必须执行某些操作，并告诉它们该做什么意味着编写代码。你编写的代码放在函数的花括号之间。花括号内部，代码的执行一次从上到下一行一行地进行。唯一的例外是如果你有条件逻辑，比如这个`if`语句。如果`isWinner`不为真，那么花括号内的这些代码行将被跳过，程序执行将在`if`块之后的第一行代码处恢复。当函数到达最后一行代码或返回语句时，函数退出：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Variable scope
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'This brings us to a really interesting point: something called **variable scope**.
    Take a look at this. We have a variable called `saySomething` with a value of
    `"hello"`. Inside this `doStuff` function, we have another variable called `saySomething`
    with a value of `"goodbye"`. So, while we''re inside this function, what do you
    think the value of `saySomething` is? If you said goodbye, you''re right, the `saySomething` variable inside
    the function is said to be shadowing the same variable name outside the function,
    and as you can see that''s a bad thing. When this function exits, the value of
    `saySomething` is now back to the original value of `"hello"`; that''s because
    the variables declared inside this function only exist within the function. Once
    the function exits, those variables are gone. Outside of the `doStuff` function,
    there''s not even a thing called `saySomethingElse` that can be accessed. That''s
    an important point to remember when you''re building your functions: what variables
    are needed inside the function and what data is needed from the function after
    it exits:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们到一个非常有趣的点：叫做**变量作用域**的东西。看一下这个。我们有一个叫做`saySomething`的变量，值为`"hello"`。在这个`doStuff`函数内部，我们有另一个叫做`saySomething`的变量，值为`"goodbye"`。那么，当我们在这个函数内部时，你觉得`saySomething`的值是什么？如果你说是goodbye，你是对的，在函数内部的`saySomething`变量被称为遮蔽了函数外部相同变量名的变量，并且你可以看到这是个坏事。当这个函数退出时，`saySomething`的值现在恢复到了原始值`"hello"`；这是因为在这个函数内声明的变量只存在于函数内部。一旦函数退出，这些变量就消失了。在`doStuff`函数之外，甚至没有一个叫做`saySomethingElse`的东西可以被访问。在构建函数时，记住一个重要的点：函数内部需要哪些变量，以及函数退出后需要哪些数据：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Events
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: There's a special type of function called an **event**; it's a way for us to
    use the EVM or Ethereum virtual machine logging facilities. This is important
    to us, because, if you remember, when our player takes an action in the game,
    it's not in real time; it goes to the Ethereum Network where it waits to be confirmed
    by miners and then and only then is it written to the blockchain. When that happens,
    any events associated with that transaction are fired off. We can use those to
    call JavaScript callbacks in our application and update the UI for the player.
    Events are inheritable members of the contract, which means any events written
    into a contract are available to any contracts inherited from it. And, finally,
    the event arguments themselves are stored in the transactions log; that's a special
    data structure of the blockchain where we can see which events fired as part of
    the transaction.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊类型的函数叫做**事件**；它是我们使用以太坊虚拟机日志设施的一种方式。这对我们很重要，因为，如果你记得的话，当我们的玩家在游戏中采取行动时，它并不是实时的；它会发送到以太坊网络，在那里等待矿工确认，然后才会被写入区块链。当发生这种情况时，与该交易相关的任何事件都会被触发。我们可以利用这些来调用JavaScript回调函数并更新玩家的UI。事件是合约的可继承成员，这意味着任何写入合约的事件都可以被从中继承的任何合约使用。最后，事件参数本身存储在交易日志中；这是区块链的一个特殊数据结构，我们可以看到其中哪些事件作为交易的一部分触发了。
- en: 'Let''s take a look at a real event to get a better idea of what I mean. Inside
    our contract, we define an event using the `event` keyword, give it a name—and
    notice here that the name starts with a capital letter: `PlayerWon `—then add
    parameters for the data points we want to index:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个真实的事件，以更好地理解我的意思。在我们的合约内部，我们使用`event`关键字定义一个事件，给它一个名字——注意这里的名字以大写字母开头：`PlayerWon`——然后为我们想要索引的数据点添加参数：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside of our `winOrLose` function, once we determine the player has won, we
    can omit the player one event that writes the player''s address and the amount
    they won to the transaction log. In the JavaScript for our application, we can
    listen for this event and when we receive it let the player know the good news:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`winOrLose`函数中，一旦我们确定玩家赢了，我们就可以省略玩家获胜事件，将玩家的地址和他们赢得的金额写入事务日志。在我们应用的JavaScript中，我们可以监听此事件，当我们收到时让玩家知道这个好消息：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Constructor
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: Another special function I want to introduce you to is the constructor. It's
    called when a contract is created and it can only be executed once. Once the contract
    is created, it can never be called again. It's typically used to set the initial
    state of variables used by your contract. You'll see some examples, and only one
    constructor is allowed per contract, so overloading is not supported.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我想介绍给你的另一个特殊函数是构造函数。当合约被创建时调用它，它只能执行一次。一旦合约被创建，它就永远不能被再次调用。它通常用于设置合约使用的变量的初始状态。你会看到一些例子，每个合约只允许一个构造函数，因此不支持重载。
- en: 'Here, we have part of our gaming contract and inside the contract we''ve declared
    two variables, `owner` and `online`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的游戏合约的一部分，在合约内部，我们声明了两个变量，`owner`和`online`：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we declare our constructors so when this contract gets created we''re
    going to set the `owner` variable equal to the address of the person who deployed
    this contract. At the same time, we''re going to set the `online` variable equal
    to `true`, indicating that our game is open for business. These two variables
    are important to us and using the constructor to set them when the contract is
    created allows us to lock in their value as quickly as possible after creation.
    One other variation of this you''ll see is a function with the same name as the
    contract. So, instead of this `constructor` function, you''ll see a function named
    `Gaming`. It does the same thing, but using the `contract` name as the function
    name to create the constructor is deprecated and shouldn''t be used anymore. A
    lot of code still has it, though, so I wanted you to know about it so you can
    identify it when you see it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明我们的构造函数，这样当这个合约被创建时，我们将把`owner`变量设置为部署此合约的人的地址。同时，我们将把`online`变量设置为`true`，表示我们的游戏正在营业。这两个变量对我们很重要，使用构造函数在合约创建后尽快设置它们的值使我们能够尽快锁定它们的值。你将看到的另一种变体是一个与合约同名的函数。所以，不是这个`constructor`函数，你会看到一个名为`Gaming`的函数。它做同样的事情，但使用`contract`名称作为函数名来创建构造函数已经被弃用，不应再使用。不过，很多代码仍然在使用，所以我想让你知道，这样你在看到它时就能识别出来：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fallback function
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fallback函数
- en: The last special function we're going to talk about is the **fallback functio**n.
    A contract can have one unnamed function that's our fallback function. It can't
    have any arguments and it can't return anything, and it's executed if a contract
    is called and no functions in the contract match the call. It's also executed
    when the contract receives ether but no data. You may be thinking that sounds
    pretty useless at this point, but let me show you an example of why you may need
    to include one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个我们要讨论的特殊函数是**fallback函数**。合约可以有一个未命名函数，即我们的fallback函数。它不能有任何参数，也不能返回任何东西，如果合约被调用而合约中没有与调用匹配的函数，则执行它。当合约接收到以太币但没有数据时也会执行它。你可能会觉得这听起来在这一点上没什么用，但让我给你举个例子，说明为什么你可能需要包含一个。
- en: 'Imagine our gaming contract. Let''s say someone sends ether to this contract
    with no data. Our contract doesn''t know what to do with that so it reverts the
    transaction and the ether is returned to the caller. But what if this were a different
    application, and in that application you needed to be able to accept ether via
    direct transfers from an external account such as directly from a person''s Ethereum
    wallet? The only way to do that is with a fallback function. Creating a fallback
    function and marking it as payable will allow your contract to receive direct
    transfers of ether. The downside of this is you need to consider what you''re
    going to do with that ether: mainly, that you have to have a way to get it out.
    If, for instance, someone mistakenly sent ether to your contract and they meant
    to send it to a different address, if your fallback function is marked `payable`
    you''ll receive that ether and if you don''t have a function allowing you to withdraw
    it, it''s going to be stuck there forever:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们的游戏合约。假设有人向这个合约发送了以太币，但没有附带任何数据。我们的合约不知道该怎么办，所以就撤销了交易，以太币退还给调用者。但如果这是另一个应用程序，而且在该应用程序中，您需要能够通过直接从外部账户进行转账（例如直接从某人的以太坊钱包）接受以太币怎么办呢？唯一的方法就是使用降级函数。创建一个降级函数，并将其标记为`payable`，可以使您的合约接收以太币的直接转账。然而，这样做的缺点是您需要考虑如何处理这些以太币：主要是，您必须有一种方法将其取出。例如，如果有人错误地将以太币发送到您的合约，而他们本来是想把它发送到另一个地址，如果您的降级函数被标记为`payable`，您将收到这笔以太币，如果没有一种允许您提取它的功能，它就会永远被困在那里：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, that's the basics of functions. In the next section, we're going cover
    function visibility. Let's dig deeper into how visibility affects the capabilities
    of functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是函数的基础知识。在下一节中，我们将介绍函数的能见度。让我们深入探讨能见度如何影响函数的功能。
- en: Function visibility
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数能见度
- en: The `visibility` keyword is a required element when defining a function. By
    specifying the visibility, we can control who can call it and who can inherit
    it. We can also optionally define whether or not the function should read state
    variables, or even view them at all.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，`visibility`关键字是一个必需的元素。通过指定能见度，我们可以控制谁可以调用它，谁可以继承它。我们还可以选择性地定义函数是否应读取状态变量，或者根本不查看它们。
- en: Visibility in a nutshell
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能见度简要说明
- en: 'We defined the visibility modifiers yesterday, and today we will reinforce
    the differences using this table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们昨天定义了能见度修饰符，今天我们将使用这个表格来巩固它们之间的区别：
- en: '|  | **Called Externally** | **Called Internally** | **Inheritable** | **Automatic
    Getter** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | **外部调用** | **内部调用** | **可继承** | **自动获取器** |'
- en: '| **External** | Yes | No | Yes | No |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **外部** | 是 | 否 | 是 | 否 |'
- en: '| **Public** | Yes | Yes | Yes | Yes |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **公共** | 是 | 是 | 是 | 是 |'
- en: '| **Internal** | No | Yes | Yes | No |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **内部** | 否 | 是 | 是 | 否 |'
- en: '| **Private** | No | Yes | No | No |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **私有** | 否 | 是 | 否 | 否 |'
- en: External functions can be called externally. They can also be called internally
    using the `this` keyword, but because that's kind of a workaround, I didn't check
    the box for called internally; and they're inheritable, so you'll have access
    to all the external functions in contracts you inherit, and any contracts that
    inherit from you will have the external functions defined in your contract. Public
    functions can be called externally as well as internally. Like external functions,
    they're inheritable, and you get a free getter function for variables defined
    as public. Internal functions can only be called internally and they're inheritable.
    And, finally, private functions can only be called internally, but remember, this
    doesn't mean the data is private, it just means that it can't be called or inherited;
    it's still viewable to an observer on the blockchain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数可以从外部调用。它们也可以使用`this`关键字在内部调用，但因为这有点绕过的方式，我没有选择内部调用；它们是可继承的，所以您可以在继承的合约中访问所有外部函数，并且任何从您继承的合约都将包含在您的合约中定义的外部函数。公共函数既可以从外部调用，也可以从内部调用。像外部函数一样，它们是可继承的，而且对于定义为公共的变量，您会得到一个免费的获取器函数。内部函数只能从内部调用，并且它们是可继承的。最后，私有函数只能从内部调用，但请记住，这并不意味着数据是私有的，这只是意味着它不能被调用或继承；在区块链上，它仍然是对观察者可见的。
- en: 'Let''s take a look at an external function. This is the `winOrLose` function
    from our game: it gets called by our React application to determine if a player
    has won or lost this round. It''s marked as external because we''ll be calling
    it from our UI, and it''s marked as payable because the player will include their
    wager with this function call. It executes this logic to determine if the player
    won or lost, then returns a boolean `true` if they want or boolean `false` if
    they lost. So, this function could have been marked public as well and retained
    the same functionality. In addition, we would have the ability to call the function
    internally from within the contract without using the `this` keyword. So, to call
    this function from within the contract we would just call `winOrLose,` but with
    it marked external, if we wanted to call it from within the contract we''d have
    to call this dot `winOrLose.` Since this function has no reason to be called from
    within the contract, I made the visibility `external`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个外部函数。这是我们游戏中的 `winOrLose` 函数：它由我们的 React 应用程序调用，以确定玩家是否赢得了本轮游戏。它被标记为外部，因为我们将从我们的
    UI 中调用它，并且它被标记为可支付，因为玩家将在此函数调用中包含他们的赌注。它执行此逻辑以确定玩家赢还是输，然后如果他们赢则返回布尔值 `true`，如果他们输则返回布尔值
    `false`。因此，此函数也可以标记为公共并保留相同的功能。此外，我们将能够从合约内部调用该函数，而无需使用 `this` 关键字。因此，要从合约内部调用该函数，我们只需调用
    `winOrLose`，但是由于它被标记为外部，如果我们想从合约内部调用它，我们将不得不调用 `this.winOrLose`。由于此函数没有理由从合约内部调用，我将可见性设置为
    `external`：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our mysteryNumber function is private. It gets called by our `winOrLose` function
    to generate the mystery number our player is wagering against. It only gets called
    from within the contract by the `winOrLose` function so it doesn''t need external
    or public visibility. Additionally, I don''t want inherited contracts to have
    access to this function, so it gets marked as `private.` There''s a new keyword
    here to `view.` Marking this function as `view` indicates that this function will
    not attempt to modify, create, or update the state:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `mysteryNumber` 函数是私有的。它由我们的 `winOrLose` 函数调用，用于生成玩家押注的神秘数字。它仅在合约内部被 `winOrLose`
    函数调用，因此不需要外部或公共可见性。另外，我不希望继承的合约能够访问这个函数，因此将其标记为 `private`。这里有一个新关键字 `view`。将此函数标记为
    `view` 表示该函数不会尝试修改、创建或更新状态：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: View functions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图函数
- en: 'In the following list, we can see the things that are considered to modify
    state meaning, and they aren''t allowed if your function is a view function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们可以看到被视为修改状态含义的事物，并且如果您的函数是视图函数，则不允许这些事物：
- en: Writing to state variables
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入状态变量
- en: Emitting events
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出事件
- en: Creating other contracts
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建其他合约
- en: Using self-destruct
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自毁
- en: Sending ether via calls
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用发送以太币
- en: Calling any other functions not marked as view or pure
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用任何未标记为视图或纯的其他函数
- en: Using low-level calls
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用低级别调用
- en: Using inline assembly that contains two op codes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含两个操作码的内联汇编
- en: Low-level calls and inline assembly op codes are beyond the scope of this course,
    so we're not going to be covering those here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 低级别调用和内联汇编操作码超出了本课程的范围，因此我们不会在此处涵盖它们。
- en: 'Finally, we have an internal function, our `determineWinner` function. This
    function evaluates the criteria for this round the mystery number, the number
    displayed to the player, and their guests of higher or lower. It has a return
    value of a boolean that gets returned to the `winOrLose` function when it''s called.
    There''s no reason for anything other than the `winOrLose` function to call this
    function, especially externally, so defining it as external or public is out of
    the question, and I don''t mind if someone who inherits my contracting uses this
    function, so I''ll mark it as `internal.` It''s also marked as `pure`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个内部函数，我们的 `determineWinner` 函数。此函数评估本轮的条件，即神秘数字、显示给玩家的数字以及他们猜测的高低。它的返回值是一个布尔值，当调用
    `winOrLose` 函数时返回给它。除了 `winOrLose` 函数以外，没有理由让其他任何函数调用此函数，尤其是外部调用，因此将其定义为外部或公共是不可能的，而且我不介意继承我的合约的人使用此函数，因此我将其标记为
    `internal`。它还被标记为 `pure`：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pure functions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: A pure function is much like a view function, in that it promises not to modify
    the state, but it goes one step further in promising to not even read the state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数非常类似于视图函数，因为它承诺不修改状态，但它更进一步承诺甚至不读取状态。
- en: 'Here''s a list of the things you can''t do if you mark your function as pure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将函数标记为纯函数，则不能执行以下操作：
- en: Reading state variables
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取状态变量
- en: Accessing an account balance
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问账户余额
- en: Accessing any member of block, tx, or message
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问任何块、tx 或消息的成员
- en: Calling any function not marked pure
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用任何未标记为纯函数的函数
- en: Using inline assembly that contains certain op codes
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含特定操作码的内联汇编
- en: In the next section, we're going to see how this all ties together to create
    the business logic of our application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将所有内容结合起来创建我们应用程序的业务逻辑。
- en: Using functions to execute business logic
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数执行业务逻辑
- en: 'So, we''ve gained some confidence with functions in how they work and how we
    create them, so now let''s put this into practical context and see how we use
    them to implement the business logic of our smart contract. And thinking back
    to our app, we''re going to display a random number to our player in our UI, and
    they''ll place a wager on whether they think the mystery number is going to be
    higher or lower. The displayed number and their wager are sent to our smart contract,
    where we execute the rules of the game using Solidity code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对函数如何工作以及如何创建它们有了一些信心，现在让我们将这些放入实际情境中，看看我们如何使用它们来实现智能合约的业务逻辑。回想一下我们的应用程序，我们将在UI中向玩家显示一个随机数，他们将对他们认为的神秘数字是更高还是更低下注。显示的数字和他们的赌注被发送到我们的智能合约，我们在其中使用Solidity代码执行游戏规则：
- en: '![](img/a5eeb381-c28e-488b-8705-548bd80f3ee8.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5eeb381-c28e-488b-8705-548bd80f3ee8.png)'
- en: Let's take a look at our `winOrLose` function once again. It's changed a little
    bit since we last saw it. When the player is ready to play around, they'll make
    their wager and the app will call this function. When it does, it will send along
    the number that was displayed to the player, the players guess, and their wager
    will be attached to this transaction as the special `msg.value` variable. Since
    this gets called from our UI, it has to be marked as external, and since it receives
    their wager in the form of ether, it has to be marked as payable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的`winOrLose`函数。自从上次看到它以来它有些变化。当玩家准备玩一轮时，他们会下注，应用程序将调用这个函数。当它这样做时，将发送给玩家显示的数字，玩家的猜测，以及他们的赌注作为特殊的`msg.value`变量附加到此交易。由于这是从我们的UI调用的，必须标记为external，而且由于它以以太形式收到他们的赌注，必须标记为payable。
- en: 'We define that it returns two objects: a boolean and an unsigned integer. The
    boolean indicates whether they won or lost, and the unsigned integer will return
    the `mysteryNumber_` that they were betting against. That''s going to allow us
    to show the player the `mysteryNumber_` when we tell them that they won or lost:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义返回两个对象：一个布尔值和一个无符号整数。布尔值表示他们赢了还是输了，无符号整数将返回他们下注对手的`mysteryNumber_`。这将允许我们在告诉玩家他们赢了或输了时显示`mysteryNumber_`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside our function, we have two require statements. I'm going to skip over
    those because we'll be covering them in detail in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数内部，我们有两个require语句。我会跳过这些，因为我们将在下一节详细介绍它们。
- en: 'We have an unsigned integer that gets its value from a function called `mysteryNumber`; that
    means our `mysteryNumber` function must return an unsigned integer – we declare
    that when we define the function – and since nothing outside of our contract needs
    to access this function we''ll mark it as private. Our function also doesn''t
    do anything to modify the state. It simply returns a number so we can mark it
    as a `view` function as well:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个无符号整数从名为`mysteryNumber`的函数获得其值；这意味着我们的`mysteryNumber`函数必须返回一个无符号整数 - 在定义函数时我们声明这一点
    - 而且由于我们的合约外部不需要访问这个函数，我们将其标记为私有。我们的函数也不对状态进行任何修改。它只是返回一个数字，因此我们也可以将其标记为`view`函数：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And now we have all the data we need to determine if the player won or lost
    this round. So, we declare a boolean called `isWinner` that''s going to get its
    value by sending all of the needed information to the `determineWinner` function,
    and that function looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有确定玩家本轮是否赢得或输掉所需的所有数据。因此，我们声明一个名为`isWinner`的布尔值，通过将所有所需信息发送到`determineWinner`函数来获取其值，该函数如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It has parameters to accept a mystery number, the displayed number, and the
    player's guess. Once again, there's no reason for anything outside of the contract
    to call this function, so it's marked as `internal`, and because it doesn't read
    or modify state, we mark it as `pure`. Next, we go through all the different combinations
    of winning and losing, and once we have enough information to determine whether
    this round was a win or a loss, we exit the function using `return`, and then
    `true` for a win or `false` for a loss. When that function returns, it leaves
    us right here, where we can evaluate the `isWinner` variable, then take the appropriate
    action based on a win or a loss, which includes emitting events to indicate the
    status of that round, sending any money won back to the player, and returning
    the result of that round for the player to see. Let's take a look at that visually
    to help cement the relationships. Our app calls the `winOrLose` function, which
    in turn gets a new mystery number from the `mysteryNumber_` function, then it
    sends the data over to the `determineWinner` function to see if the player won
    or lost, then it takes the appropriate actions, and finally notifies the player
    of the results. And next up, we're going to talk about modifiers. They're powerful
    functions that allow you to place constraints around when your function should
    and should not execute.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它有参数接受一个神秘数字，显示的数字和玩家的猜测。再次强调，合约之外没有任何原因调用这个函数，因此它被标记为`internal`，并且因为它不读取或修改状态，我们将其标记为`pure`。接下来，我们遍历所有不同的获胜和失败的组合，一旦我们有足够的信息来确定这一轮是赢还是输，我们使用`return`退出函数，然后`true`表示赢，`false`表示输。当函数返回时，它留下了我们在这里，我们可以评估`isWinner`变量，然后根据赢或输采取适当的行动，这包括发出事件表示该轮的状态，将赢得的任何钱返还给玩家，并返回玩家看到的结果。让我们用视觉来看这个来帮助巩固这些关系。我们的应用程序调用`winOrLose`函数，然后从`mysteryNumber_`函数获得一个新的神秘数字，然后将数据发送到`determineWinner`函数，以查看玩家是否赢了或输了，然后采取适当的行动，最后通知玩家结果。接下来，我们将讨论修饰符。它们是强大的函数，允许您在何时执行函数时放置约束。
- en: Understanding modifiers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解修饰符
- en: 'Well, modifiers are an important component in functions: they allow us to enforce
    rules and restrictions quickly and easily. Modifiers are used to change function
    behavior in a declarative way. This means we get a repeatable concise way to enforce
    rules. Modifiers are commonly used to check a condition prior to executing a function;
    this is important in blockchain development. We pay the miners to execute our
    functions in the form of gas, so if a function is going to fail a constraint,
    it''s in our best interest for it to fail as quickly as possible.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，修饰符是函数中的重要组成部分：它们允许我们快速轻松地强制执行规则和限制。修饰符用于以声明方式改变函数行为。这意味着我们获得了一种重复简洁的方式来强制执行规则。修饰符通常用于在执行函数之前检查条件；这在区块链开发中非常重要。我们支付矿工以气体形式执行我们的函数，所以如果函数将违反约束，最好尽快失败。
- en: There are also inheritable properties, meaning that a modifier defined in a
    contract is also available in any contracts derived from it. An important component
    of modifiers is a convenience function called **require**. So, before we dig deeper
    into modifiers, let's first understand the require function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可继承的属性，这意味着在合同中定义的修饰符也可在任何从中派生的合同中使用。修饰符的一个重要组成部分是一个方便的函数称为**require**。因此，在我们深入了解修饰符之前，让我们首先了解`require`函数。
- en: The require function
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: require函数
- en: Require's a convenience function that we can use in Solidity to handle errors.
    It's a state reverting exception, meaning that any changes to state made prior
    to the exception are automatically rolled back; this is a great feature because
    it ensures that all of our transaction completes, or none of it does, preventing
    a scenario where we have to guess which parts did complete. We commonly use `require`
    to ensure that valid conditions, such as inputs or contract state variables, are
    met. And, optionally, we can include a string message returned to the caller when
    a `require` statement fails, to let the caller know what happened. For me, though
    this stream message is optional, it's a requirement; I can't even guess how many
    hours I've spent before this feature existed troubleshooting why a function was
    failing, only later to learn it was due to a requirement that I'd put in the function.
    To define a require, we use the `require` keyword followed by the conditions in
    parentheses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`是我们在Solidity中可以使用的方便函数来处理错误。它是一个状态回滚异常，这意味着在异常发生之前对状态的任何更改都将自动回滚；这是一个很棒的功能，因为它确保我们的所有交易完成，或者都没有完成，从而防止我们不得不猜测哪些部分完成了的情况发生。我们通常使用`require`来确保满足有效条件，例如输入或合同状态变量。并且，可选地，当`require`语句失败时，我们可以包含一个返回给调用者的字符串消息，以告知调用者发生了什么。对我来说，虽然这个流消息是可选的，但它是一个要求；在这个特性存在之前，我甚至都无法猜测我花了多少小时去排除一个函数失败的原因，只是后来才了解到这是由于我在函数中放置的要求。要定义一个`require`，我们使用`require`关键字，后跟括号中的条件。'
- en: 'If you remember from our contract definition, we set a variable called `online`, then
    in the constructor set its value equal to `true,` so this statement checks to
    see if the `online` variable is still `true`. If not, the program execution stops
    here, and this is how we can effectively take our game offline:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们的合同定义，我们设置了一个名为`online`的变量，然后在构造函数中将其值设置为`true`，因此此语句检查`online`变量是否仍为`true`。如果不是，则程序执行停在此处，这是我们如何有效地使我们的游戏离线的方法：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Order also plays an important role in require statements. Typically, you want
    to place them at the top of the function so that the function can fail as quickly
    as possible if the condition isn't met. Here you can see two require statements,
    one to verify the game is online and a second to ensure that the player has enough
    funds to cover their wager, and that's it. Require statements are pretty straightforward.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序在`require`语句中也起着重要作用。通常，您希望将它们放在函数的顶部，以便如果条件不满足，函数能够尽快失败。在这里，您可以看到两个`require`语句，一个用于验证游戏是否在线，第二个用于确保玩家有足够的资金来支付他们的赌注，就是这样。`require`语句非常简单直接。
- en: 'And we can use require statements to build modifiers. A modifier is created
    using the modifier keyword, giving it a name and then optional parameters in parentheses.
    It''s very similar to a function. Inside the modifier, we add our conditions.
    Here, we''re requiring that the message sender is the same address as the one
    stored in the owner variable. This modifier has the effect of restricting any
    function using it to only be executed by the owner of the contract. The final
    piece of the modifier is this, the underscore, and its location is pretty important,
    as it determines when the code calling this modifier should be executed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`require`语句来构建修饰符。修饰符是使用`modifier`关键字创建的，给它一个名称，然后在括号中加上可选的参数。这与函数非常相似。在修饰符中，我们添加条件。在这里，我们要求消息发送者与存储在`owner`变量中的地址相同。这个修饰符的效果是限制使用它的任何函数只能由合同的所有者执行。修饰符的最后一部分是这个下划线，它的位置非常重要，因为它决定了调用此修饰符的代码何时应该执行：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let me show you an example to explain that further. This function allows the
    caller to withdraw the funds the contract has earned from the game. We use the
    `isOwner` modifier to ensure that only the owner of the contract can call it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我举个例子来进一步解释。这个函数允许调用者提取合同从游戏中赚取的资金。我们使用`isOwner`修饰符确保只有合同的所有者可以调用它：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s see where the underscore comes into play. There are two valid locations
    for the underscore:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看下划线的作用。下划线有两个有效的位置：
- en: '![](img/97be6c20-198b-48ac-ba4b-60105f99440e.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97be6c20-198b-48ac-ba4b-60105f99440e.png)'
- en: 'It can come at the beginning of the modifier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以出现在修饰符的开头：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or it can come at the end of the modifier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可以出现在修饰符的末尾：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference is when the code in the function runs. If you place the underscore
    at the beginning of the modifier, when the withdraw funds function executes it
    runs all of the code in its function, then calls the modifier. If the underscore
    is at the end, the modifier executes its logic first, then the function executes
    its logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于函数中的代码何时运行。如果你将下划线放在修饰器的开头，当提取资金函数执行时，它会运行其函数中的所有代码，然后调用修饰器。如果下划线在结尾，修饰器首先执行其逻辑，然后函数执行其逻辑。
- en: Another way of looking at this is the underscore represents the function itself.
    In this example, if we put the underscore first, the function executes first and
    withdraws all of the funds from the contract, then the modifier checks to see
    if it was the owner that did that. With the underscore last, the modifier first
    checks to see if the call is from the owner, then it executes the function if
    the modifier passes. That's a big difference in the desired outcome of this function,
    so pay close attention when using modifiers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是下划线代表函数本身。在这个例子中，如果我们先放置下划线，函数首先执行并从合同中提取所有资金，然后修饰器检查是否是所有者这样做了。将下划线放在最后，修饰器首先检查调用是否来自所有者，然后在修饰器通过时执行函数。这对于函数的期望结果有很大的区别，所以在使用修饰器时要特别注意。
- en: In the next section, we'll take a look at some practical examples using modifiers
    to get a better understanding of their capabilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一些使用修饰器的实际例子，以更好地理解它们的能力。
- en: 'In this section, we''ll take a look at some different use cases for modifiers.
    I really like modifiers because they allow a lot of control over executing a function,
    but they''re still very readable. Let''s take a look at our first example, a modifier
    called `onlyBy`. It will allow only functions calling it to execute if it''s called
    by the desired address:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些修饰器的不同用例。我非常喜欢修饰器，因为它们允许对执行函数进行很多控制，但它们仍然非常易读。让我们看看我们的第一个例子，一个名为`onlyBy`的修饰器。它将只允许调用它的函数在被所需地址调用时执行：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see it in action here in the `changeOwner` function. When `changeOwner`
    is called, the `onlyBy` modifier is used to ensure that only the current owner
    can specify a `newOwner` variable for the contract:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`changeOwner`函数中看到它的运作方式。当调用`changeOwner`时，`onlyBy`修饰器用于确保只有当前所有者才能为合同指定一个`newOwner`变量：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s another example that uses time constraints. If the current time is
    less than the time passed in as a parameter, the modifier throws an exception
    ending program execution. Putting it to use, we can see the `disown` function
    using the `onlyAfter` modifier to ensure that it can only be called 6 weeks after
    the creation time. This is a great example of using multiple modifiers to ensure
    that multiple conditions are met. To specify multiple modifiers, you simply list
    them one after another in your function declaration. You can do it with one on
    each line like this, or you can do it on the same line with a space separating
    each modifier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子，使用时间限制。如果当前时间小于作为参数传递的时间，修饰器将抛出异常结束程序执行。将其用于实践，我们可以看到`disown`函数使用`onlyAfter`修饰器确保只能在创建时间之后的6周内调用它。这是使用多个修饰器确保满足多个条件的绝佳示例。要指定多个修饰器，你只需在函数声明中依次列出它们。你可以像这样每行一个，或者在同一行用空格分隔每个修饰器：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s look at one more example. This modifier requires a certain fee to be
    paid with a function call, so now we can charge a fee for changing the owner.
    As long as the required 200 ether is included with this transaction the transaction
    will execute. There''s a caveat here, though: if the caller sends more than 200
    ether when the function exits normally any excess ether is returned to the caller.
    If we use a `return` explicitly, though, any excess ether won''t be returned:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更多的例子。这个修饰器要求在函数调用时支付一定的费用，所以现在我们可以收取更换所有者的费用。只要这个交易中包含所需的200以太币，交易就会执行。但这里有一个警告：如果调用者在函数正常退出时发送的以太币超过200，多余的以太币将返回给调用者。不过，如果我们明确使用`return`，多余的以太币就不会被返回：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alright, so we've covered functions and while there is much more that we can
    discuss, this represents the basics that you need to start building your smart
    contracts. In the next section, I'll go over today's homework with you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经讨论了函数，虽然我们还可以讨论更多，但这代表了你开始构建智能合约所需的基础知识。在下一节中，我将和你一起讨论今天的家庭作业。
- en: Assignment
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'Today''s assignment has a similar format as yesterdays. In it, you''ll write
    some code to make some tests pass, in the repository for the book. Doing so is
    going to allow you to put the knowledge you''ve gained today about functions to
    work. The first thing you want to do is the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的作业与昨天的格式类似。在其中，你将写一些代码来使一些测试通过，在书的存储库中。这样做将允许你把今天获得的关于函数的知识应用到实践中。你首先要做的事情是：
- en: Get your environment set up for today's homework.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为今天的作业搭建好你的环境。
- en: Open a Terminal and switch to the directory containing your application code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到包含你的应用程序代码的目录。
- en: Type the `git stash` command. This is going to stash any changes you've made
    to the application code to prevent any work you've done from interfering with
    the scenario I've set up for you.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`git stash`命令。这将把你对应用程序代码所做的任何更改都存储起来，以防你所做的工作干扰我为你设置的情景。
- en: After you stash your work, type `git checkout -b dayThree` to get the code for
    today's homework, and you'll also need Ganache running, so make sure you start
    it before beginning the assignment.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的工作存储起来后，输入`git checkout -b dayThree`来获取今天作业的代码，你还需要确保Ganache在运行，所以在开始作业前确保你已经启动它。
- en: 'Run `truffle test`, and you should see something similar to the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`truffle test`，你应该会看到类似于以下截图的内容：
- en: '![](img/c9f7923f-4199-4922-b25e-e1edc758ace8.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9f7923f-4199-4922-b25e-e1edc758ace8.png)'
- en: To get all those tests to pass, you'll need to do the following tasks – in the
    `determineWinner()` function, we're missing some logic. If the player guesses
    that the mystery number is going to be lower than the number displayed on their
    screen, they should win, but the function doesn't currently do that, so I need
    you to write the code to make that happen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要让所有这些测试通过，你需要做以下任务 - 在`determineWinner()`函数中，我们缺少一些逻辑。如果玩家猜测神秘数字将低于他们屏幕上显示的数字，他们就应该赢，但这个函数目前不会执行此操作，所以我需要你编写代码来实现这一点。
- en: 'Next, we''ll create two new events: one for `playerWon` and one for `playerLost`.
    The event should accept parameters for the player''s address, the amount they
    wagered, the mystery number they were betting against, and the number that was
    displayed to the player.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个新事件：一个是`playerWon`，另一个是`playerLost`。事件应该接受玩家的地址、他们押注的金额、他们所押注的神秘数字以及向玩家显示的数字的参数。
- en: Now that you have your event, we'll omit the correct event whenever the player
    wins or loses.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了你的事件，每当玩家赢了或输了，我们就会省略出正确的事件。
- en: And, finally, there's a mapping called `players` that maps the player's address
    to a `Player` struct, where we can store information about their wins and losses.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个名为`players`的映射，将玩家的地址映射到一个`Player`结构中，其中我们可以存储关于他们的胜利和失败的信息。
- en: We'll get the `Player` struct for the correct player from that mapping, and
    increment the win counter if they win, and the loss counter if they lose.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从该映射中获取正确玩家的`Player`结构，并且如果他们赢了，则增加赢的计数器，如果他们输了，则增加输的计数器。
- en: 'When you''re all done, you should end up with these six passing tests, which
    set the stage for [Chapter 4](dce47cf0-e672-43db-b320-08af2133d937.xhtml), *Day
    Four* - *Creating Tests*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成所有工作后，你应该会拥有这六个通过的测试，这些测试为[第四章](dce47cf0-e672-43db-b320-08af2133d937.xhtml)
    *第四天*—*创建测试*做好了铺垫。
- en: '![](img/666f127c-bacb-4b0b-9555-adf757bd93c0.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666f127c-bacb-4b0b-9555-adf757bd93c0.png)'
- en: And the cool part about this is that you've been relying on tests for the last
    couple of days to ensure your code is working correctly, so you may have some
    appreciation for how important they are and how they can help you write better
    code with fewer bugs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个很酷的地方，就是在过去的几天里，为了确保你的代码正常运行，你一直在依赖测试，所以你可能会对它们的重要性以及它们如何能够帮助你编写更少bug的更好的代码有所认识。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all about functions. We also also looked at how
    functions are created, how they work, and how they are used to make the smart
    contracts work. We started with learning about functions in Solidity, after which
    we saw how to add codes to those function. We then learned how to modify the function
    visibility. Then, we saw how to use the functions to execute business logic. And,
    finally, we learned how to use modifiers in the functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了有关函数的所有知识。我们还看了函数是如何创建的，它们是如何工作的，以及它们如何用于使智能合约生效。我们首先学习了Solidity中的函数，然后我们看到如何向这些函数中添加代码。然后，我们学习了如何修改函数的可见性。然后，我们看到了如何使用这些函数来执行业务逻辑。最后，我们学习了如何在函数中使用修饰符。
- en: In the next chapter, we will learn how to create tests that will help in debugging
    the code, so that the game functions without a glitch!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建测试，以帮助调试代码，使游戏功能无故障！
