- en: Getting Started with web3.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 web3.js 入门
- en: In the previous chapter, we learned how to write and deploy smart contracts
    using Solidity. In this chapter, we will learn about **web3.js** and how to import
    it, connect to geth, and use it in Node.js or client-side JavaScript. We will
    also learn how to build a web client using web3.js for the smart contract that
    we created in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Solidity 编写和部署智能合约。在本章中，我们将学习有关 **web3.js** 的知识，以及如何导入它，连接到
    geth，并在 Node.js 或客户端 JavaScript 中使用它。我们还将学习如何使用 web3.js 构建一个网络客户端，用于上一章中创建的智能合约。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importing web3.js in Node.js and client-side JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 和客户端 JavaScript 中导入 web3.js
- en: Connecting to geth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 geth
- en: Exploring web3.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 web3.js
- en: Discovering the most-used APIs of web3.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 web3.js 最常用的 API
- en: Building a Node.js application for an ownership contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有权合约构建 Node.js 应用程序
- en: This chapter is same as chapter present in author's previous book *Blockchain
    for Projects*. This is not a second edition book,it is used to explain fundamental
    concepts to the readers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与作者之前的书籍 *Blockchain for Projects* 中的章节相同。这不是第二版书籍，而是用于向读者解释基本概念。
- en: Introduction to web3.js
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: web3.js 简介
- en: web3.js provides us with JavaScript APIs to communicate with geth. It uses JSON-RPC
    internally to communicate with geth. web3.js can also communicate with any other
    kind of Ethereum node that supports JSON-RPC. It exposes all JSON-RPC APIs as
    JavaScript APIs. It doesn't just support all the Ethereum-related APIs, but also
    supports APIs related to **Whisper** and **Swarm**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 为我们提供了与 geth 通信的 JavaScript API。它在内部使用 JSON-RPC 与 geth 通信。web3.js 也可以与支持
    JSON-RPC 的任何其他类型的以太坊节点通信。它将所有 JSON-RPC API 公开为 JavaScript API。它不仅支持与以太坊相关的所有 API，还支持与
    **Whisper** 和 **Swarm** 相关的 API。
- en: As we build various projects, you will keep learning more about web3.js. For
    now, though, let's go through some of the most used APIs for web3.js. Later, we
    will build a frontend for our ownership smart contract using web3.js.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建各种项目，你将继续学习更多关于 web3.js 的知识。不过，现在让我们先了解一些 web3.js 最常用的 API。稍后，我们将使用 web3.js
    为我们在上一章中创建的所有权智能合约构建一个前端。
- en: At the time of writing, the latest version of web3.js is 1.0.0-beta.18\. We
    will learn everything using this version.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，web3.js 的最新版本是 1.0.0-beta.18。我们将使用此版本学习所有内容。
- en: web3.js is hosted at [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js)
    and the complete documentation is hosted at [https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 托管在 [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js)，完整文档托管在
    [https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API)。
- en: Importing web3.js
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入 web3.js
- en: Simply run `npm install web3` inside your project directory to use web3.js in
    Node.js. In the source code, you can import it using `require("web3");`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在项目目录中运行 `npm install web3` 即可在 Node.js 中使用 web3.js。在源代码中，可以使用 `require("web3");`
    进行导入。
- en: To use web3.js in client-side JavaScript, you can enqueue the `web3.js` file,
    which can be found inside the `dist` directory of the project source code. Now,
    the `web3` object will be available globally.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端 JavaScript 中使用 web3.js，可以将 `web3.js` 文件入队，该文件位于项目源代码的 `dist` 目录中。现在，`web3`
    对象将全局可用。
- en: Connecting to nodes
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到节点
- en: web3.js can communicate with nodes using HTTP or IPC, and allows us to connect
    with multiple nodes. We will use HTTP for our node communication. An instance
    of `web3` represents a connection with a node. The instance exposes the APIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 可以使用 HTTP 或 IPC 与节点通信，并允许我们连接多个节点。我们将使用 HTTP 进行节点通信。`web3` 的一个实例表示与节点的连接。该实例公开了
    API。
- en: When an app is running inside mist, it automatically makes an instance of `web3`
    available that is connected to the mist node. The variable name of the instance
    is `web3`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在 mist 中运行时，它会自动创建一个连接到 mist 节点的 `web3` 实例。实例的变量名为 `web3`。
- en: 'Here is the basic code to connect to a node:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接到节点的基本代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we verify whether the code is running inside mist by checking whether
    `web3` is `undefined` or not. If `web3` is defined, then we use the already available
    instance; otherwise, we create an instance by connecting to our custom node. You
    can remove the `if` condition from the preceding code if you want to connect to
    the custom node, regardless of whether or not the app is running inside mist.
    Here, we assume that our custom node is running locally on port number `8545`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查 `web3` 是否为 `undefined` 来验证代码是否在 mist 中运行。如果 `web3` 已定义，那么我们使用已有的实例；否则，我们通过连接到自定义节点来创建一个实例。如果你想无论应用是否在
    mist 中运行都连接到自定义节点，可以从上述代码中移除 `if` 条件。在这里，我们假设我们的自定义节点在本地的 `8545` 端口上运行。
- en: The `Web3.providers` object exposes constructors (called `providers` in this
    context) to establish a connection and transfer messages using various protocols.
    `Web3.providers.HttpProvider` lets us establish an HTTP connection, whereas `Web3.providers.IpcProvider`
    lets us establish an IPC connection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Web3.providers` 对象暴露了构造函数（在这个上下文中称为`providers`），用于建立连接并使用各种协议传输消息。`Web3.providers.HttpProvider`
    允许我们建立 HTTP 连接，而 `Web3.providers.IpcProvider` 允许我们建立 IPC 连接。'
- en: The `web3.currentProvider` property is automatically assigned to the current
    provider instance. After creating a `web3` instance, you can change its provider
    using the `web3.setProvider()` method. It takes one argument, that is, the instance
    of the new provider.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.currentProvider` 属性会自动分配给当前的提供者实例。在创建一个 `web3` 实例后，你可以使用 `web3.setProvider()`
    方法来更改它的提供者。它接受一个参数，即新提供者的实例。'
- en: Remember that geth has HTTP-RPC disabled by default. So enable it by passing
    the `--rpc` option while running geth. HTTP-RPC runs on port `8545` by default.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，geth 禁用了 HTTP-RPC。因此，在运行 geth 时通过传递 `--rpc` 选项来启用它。HTTP-RPC 默认运行在
    `8545` 端口上。
- en: '`web3` exposes an `isConnected()` method that can be used to check whether
    or not it''s connected to the node. It returns a `true` or `false` value depending
    on the connection status.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 暴露了一个 `isConnected()` 方法，用于检查是否连接到节点。根据连接状态，它返回一个 `true` 或 `false` 的值。'
- en: The API structure
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 结构
- en: '`web3` contains an `eth` object (`web3.eth`) specifically for Ethereum blockchain
    interactions and an `shh` object (`web3.shh`) for Whisper interaction. Most web3.js APIs
    are inside these two objects.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 包含一个专门用于以太坊区块链交互的 `eth` 对象（`web3.eth`）以及一个用于 Whisper 交互的 `shh` 对象（`web3.shh`）。大部分
    web3.js API 都在这两个对象内部。'
- en: All the APIs are synchronous by default. For an asynchronous request, you can
    pass an optional callback as the last parameter for most functions. All callbacks
    use an error-first callback style.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 API 默认情况下都是同步的。对于异步请求，你可以为大多数函数的最后一个参数传递一个可选的回调。所有回调都使用错误优先的回调风格。
- en: Some APIs have an alias for asynchronous requests. For example, `web3.eth.coinbase()`
    is synchronous, whereas `web3.eth.getCoinbase()` is asynchronous.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 对于异步请求有一个别名。例如，`web3.eth.coinbase()` 是同步的，而 `web3.eth.getCoinbase()`
    是异步的。
- en: 'Here is an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`getBlock` is used to get information on a block using its number or hash.
    Or, it can take a string such as `"earliest"` (the genesis block), `"latest"`
    (the top block of the blockchain), or `"pending"` (the block that''s being mined).
    If you don''t pass an argument, then the default is `web3.eth.defaultBlock`, which
    is assigned to `"latest"` by default.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBlock` 用于使用其编号或哈希获取块的信息。或者它可以接受字符串，例如 `"earliest"`（创世块）、`"latest"`（区块链的顶块）或
    `"pending"`（正在挖矿的块）。如果不传递参数，则默认为 `web3.eth.defaultBlock`，默认分配为 `"latest"`。'
- en: All of the APIs that need a block identification as an input can take a number,
    hash, or one of the readable strings. These APIs use `web3.eth.defaultBlock` by
    default if the value is not passed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要块标识作为输入的 API 默认情况下可以接受数字、哈希或可读字符串之一。如果未传递值，这些 API 默认使用 `web3.eth.defaultBlock`。
- en: BigNumber.js
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigNumber.js
- en: JavaScript is natively poor at handling big numbers. Therefore, for applications
    that require you to deal with big numbers and need perfect calculations, use the
    **BigNumber.js** library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在处理大数时表现很差。因此，对于需要处理大数并进行精确计算的应用程序，请使用 **BigNumber.js** 库。
- en: web3.js also depends on BigNumber.js and adds it automatically. web3.js always
    returns the `BigNumber` object for number values. It can take JavaScript numbers,
    number strings, and `BigNumber` instances as input.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 也依赖于 BigNumber.js，并自动添加它。web3.js 总是返回 `BigNumber` 对象作为数字值。它可以接受 JavaScript
    数字、数字字符串和 `BigNumber` 实例作为输入。
- en: 'Let''s demonstrate this, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来演示一下，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use the `web3.eth.getBalance()` method to get the balance of an address.
    This method returns a `BigNumber` object. We need to call `toString()` on a `BigNumber`
    object to convert it into a number string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `web3.eth.getBalance()` 方法获取地址的余额。此方法返回一个 `BigNumber` 对象。我们需要对 `BigNumber`
    对象调用 `toString()` 来将其转换为数字字符串。
- en: BigNumber.js fails to correctly handle numbers with more than 20 floating point
    digits. Therefore, it is recommended that you store the balance in a wei unit,
    and while it is displayed, convert it to other units. web3.js itself always returns
    and takes the balance in wei. For example, the `getBalance()` method returns the
    balance of the address in the wei unit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: BigNumber.js 无法正确处理具有超过 20 个浮点数字的数字。因此，建议您将余额存储在 wei 单位中，并在显示时将其转换为其他单位。web3.js
    本身总是以 wei 单位返回和接受余额。例如，`getBalance()` 方法返回以 wei 为单位的地址余额。
- en: Unit conversion
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位转换
- en: web3.js provides APIs to convert the wei balance into any other unit and vice
    versa.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 提供了将 wei 余额转换为任何其他单位以及反之的 API。
- en: 'The `web3.fromWei()` method converts a wei number into another unit, whereas
    the `web3.toWei()` method converts a number in any other unit into wei. Here is
    an example to demonstrate this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.fromWei()` 方法将 wei 数字转换为另一个单位，而 `web3.toWei()` 方法将任何其他单位的数字转换为 wei。以下是一个示例来演示这一点：'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first line, we convert wei into `ether`; in the second line, we convert
    `ether` into wei. The second argument in both methods can be one of these strings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们将 wei 转换为 `ether`；在第二行中，我们将 `ether` 转换为 wei。这两个方法中的第二个参数可以是以下字符串之一：
- en: '`kwei` or `ada`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwei` 或 `ada`'
- en: '`mwei` or `babbage`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mwei` 或 `babbage`'
- en: '`gwei` or `shannon`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gwei` 或 `shannon`'
- en: '`szabo`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`szabo`'
- en: '`finney`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finney`'
- en: '`ether`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ether`'
- en: '`kether` / `grand` / `einstein`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kether` / `grand` / `einstein`'
- en: '`mether`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mether`'
- en: '`gether`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gether`'
- en: '`tether`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tether`'
- en: Retrieving gas price, balance, and transaction details
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索 gas 价格、余额和交易详细信息
- en: 'Let''s take a look at the APIs to retrieve the gas price, the balance of an
    address, and information on a mined transaction:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下检索 gas 价格、地址余额以及已挖掘交易信息的 API：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be in this format:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将以此格式显示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is how the preceding method works:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述方法的工作原理：
- en: '`web3.eth.gasPrice()`: Determines the gas price by the *x* latest blocks''
    median gas price.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.gasPrice()`: 通过 *x* 最新区块的中位数 gas 价格确定 gas 价格。'
- en: '`web3.eth.getBalance()`: Returns the balance of any given address. All the
    hashes should be provided as hexadecimal strings (not hexadecimal literals) to
    the web3.js APIs. The input for the Solidity address type should also be in hexadecimal
    strings.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.getBalance()`: 返回给定地址的余额。所有的哈希都应该以十六进制字符串（而不是十六进制字面值）的形式提供给 web3.js
    API。对于 Solidity 地址类型的输入也应该是十六进制字符串。'
- en: '`web3.eth.getTransactionReceipt()`: This is used to get details about a transaction
    using its hash. It returns a transaction receipt object if the transaction was
    found in the blockchain; otherwise, it returns `null`. The transaction receipt
    object contains the following properties:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.getTransactionReceipt()`: 用于使用其哈希获取有关交易的详细信息。如果在区块链中找到了交易，则返回一个交易收据对象；否则返回
    `null`。交易收据对象包含以下属性：'
- en: '`blockHash`: The hash of the block where this transaction was located.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockHash`: 交易所在区块的哈希。'
- en: '`blockNumber`: The block number where this transaction was located.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockNumber`: 此交易所在的区块编号。'
- en: '`transactionHash`: The hash of the transaction.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionHash`: 交易的哈希。'
- en: '`transactionIndex`: The integer of the transactions'' index position in the
    block.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionIndex`: 交易在区块中的位置的整数。'
- en: '`from`: The address of the sender.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 发送者的地址。'
- en: '`to`: The address of the receiver; this is left as `null` when it''s a contract
    creation transaction.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 接收方的地址；当它是一个合约创建交易时，这个参数被设为 `null`。'
- en: '`cumulativeGasUsed`: The total amount of gas used when this transaction was
    executed in the block.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumulativeGasUsed`: 在该交易在区块中执行时使用的总 gas 量。'
- en: '`gasUsed`: The amount of gas used by this specific transaction alone.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasUsed`: 仅由此特定交易使用的 gas 量。'
- en: '`contractAddress`: The contract address created if the transaction was a contract
    creation. Otherwise, this is left as `null`.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contractAddress`: 如果交易是合约创建，则创建的合约地址。否则，这将被设为 `null`。'
- en: '`logs`: The array of log objects that this transaction generated.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`: 此交易生成的日志对象数组。'
- en: Sending ether
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 ether
- en: 'Let''s look at how to send `ether` to any address. To send `ether`, you need
    to use the `web3.eth.sendTransaction()` method. This method can be used to send
    any kind of transaction but is mostly used to send `ether`. This is because deploying
    a contract or calling a method of contract using this method is cumbersome as
    it requires you to manually generate the data of the transaction rather than automatically
    generating it. It takes a transaction object that has the following properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向任何地址发送`ether`。要发送`ether`，您需要使用`web3.eth.sendTransaction()`方法。此方法可用于发送任何类型的交易，但主要用于发送`ether`。这是因为使用此方法部署合约或调用合约的方法很麻烦，因为您需要手动生成交易数据而不是自动生成。它接受一个具有以下属性的交易对象：
- en: '`from`: The address for the sending account. This uses the `web3.eth.defaultAccount`
    property if not specified.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`：发送账户的地址。如果未指定，则使用`web3.eth.defaultAccount`属性。'
- en: '`to`: This is optional. It''s the destination address of the message and is
    left undefined for a contract-creation transaction.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：这是可选的。这是消息的目的地地址，对于合约创建交易则未定义。'
- en: '`value`: This is optional. The value of the transaction is transferred in wei
    as well as the endowment if it''s a contract-creation transaction.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是可选的。交易的价值以wei为单位进行转移，如果是合约创建交易，则还包括捐赠金。'
- en: '`gas`: This is optional. It''s the amount of gas to use for the transaction
    (unused gas is refunded). If this is not provided, then it''s automatically determined.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gas`：这是可选的。这是用于交易的燃气量（未使用的燃气将退还）。如果未提供，则会自动确定。'
- en: '`gasPrice`: This is optional. It''s the price of gas for this transaction in
    wei, and it defaults to the mean network gas price.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasPrice`：这是可选的。这是交易的燃气价格，以wei为单位，默认为平均网络燃气价格。'
- en: '`data`: This is optional. It''s either a byte string containing the associated
    data of the message or, in the case of a contract-creation transaction, the initialization
    code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是可选的。它要么是包含消息相关数据的字节字符串，要么在合约创建交易的情况下是初始化代码。'
- en: '`nonce`: This is optional. It''s an integer. Every transaction has `nonce`
    associated with it. `nonce` is a counter that indicates the number of transactions
    made by the sender. If it is not provided, it will be automatically determined.
    It helps prevent replay attacks. This `nonce` is not the `nonce` associated with
    a block. If we are using a `nonce` greater than the `nonce` that the transaction
    should have, then the transaction is put in a queue until the other transactions
    arrive. For example, if  `nonce` of the next transaction should be four and we
    set the `nonce` to ten, then geth will wait for the remaining six transactions
    before broadcasting this transaction. The transaction with `nonce` ten is called
    a **queued transaction**, and is not a pending transaction.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nonce`：这是可选的。这是一个整数。每个交易都与`nonce`相关联。`nonce`是一个计数器，表示发送者所做交易的数量。如果未提供，它将自动确定。它有助于防止重放攻击。此`nonce`不是与块相关联的`nonce`。如果我们使用的`nonce`大于交易应该具有的`nonce`，则该交易将放入队列，直到其他交易到达。例如，如果下一个交易的`nonce`应为四，而我们将`nonce`设置为十，则geth将等待其余的六个交易到达后再广播此交易。`nonce`为十的交易称为**排队的交易**，而不是待处理的交易。'
- en: 'Here''s an example of how to send `ether` to an address:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个发送`ether`到地址的示例：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we send one `ether` from account number `0` to account number `1`. We
    need to make sure that both the accounts are unlocked using the `unlock` option
    while running geth. The geth interactive console prompts for passwords, but the
    web3.js API outside of the interactive console will throw an error if the account
    is locked. This method returns the transaction hash of the transaction. You can
    then check whether the transaction is mined or not using the `getTransactionReceipt()`
    method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从账户编号`0`发送了一个`ether`到账户编号`1`。我们需要确保在运行geth时使用`unlock`选项来解锁两个账户。geth交互式控制台会提示输入密码，但是在交互式控制台之外使用的web3.js
    API如果账户被锁定，将会抛出错误。此方法返回交易的事务哈希。然后，您可以使用`getTransactionReceipt()`方法检查交易是否已被挖掘。
- en: You can also use `web3.personal.listAccounts()`, `web3.personal.unlockAccount(addr,
    pwd)`, and `web3.personal.newAccount(pwd)` APIs to manage accounts at runtime.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`web3.personal.listAccounts()`、`web3.personal.unlockAccount(addr, pwd)`和`web3.personal.newAccount(pwd)`
    API 在运行时管理账户。
- en: Working with contracts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与合约工作
- en: Let's learn how to deploy a new contract, get a reference to a deployed contract
    using its address, send `ether` to a contract, send a transaction to invoke a
    `contract` method, and estimate the gas of a method call.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何部署新合同，使用其地址获取已部署合同的引用，向合同发送`ether`，发送交易以调用`contract`方法，并估算方法调用的gas。
- en: To deploy a new contract or to get a reference to an already deployed contract,
    you need to first create a `contract` object using the `web3.eth.contract()` method.
    It takes the contract ABI as an argument and returns the `contract` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署新合同或获取对已部署合同的引用，您需要首先使用`web3.eth.contract()`方法创建一个`contract`对象。它以合同ABI作为参数，并返回`contract`对象。
- en: 'Here is the code to create a `contract` object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`contract`对象的代码：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have the contract, you can deploy it using the `new` method of the
    `contract` object or get a reference to an already deployed contract that matches
    the ABI using the `at` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了合同，您可以使用`contract`对象的`new`方法部署它，或者使用`at`方法获取与ABI匹配的已部署合同的引用。
- en: 'Let''s take a look at an example of how to deploy a new contract, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个部署新合同的示例，如下所示：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `new` method is called asynchronously, so the callback is fired twice
    if the transaction was created and broadcasted successfully. On the first occasion,
    it's called after the transaction is broadcasted, and on the second occasion,
    it's called after the transaction is mined. If you don't provide a callback, then
    the `proof` variable will have the `address` property set to `undefined`. Once `contract`
    is mined, the `address` property will be set.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`new`方法是异步调用的，因此如果交易成功创建并广播，则回调将被调用两次。第一次，在交易广播后调用，第二次，在交易挖掘后调用。如果您不提供回调函数，则`proof`变量的`address`属性将设置为`undefined`。一旦`contract`被挖掘，`address`属性将被设置。
- en: In the `proof` contract, there is no constructor, but if there is one, then
    the arguments for the constructor should be placed at the beginning of the `new`
    method. The object we passed contains the `from` address, the bytecode of the
    contract, and the maximum `gas` to use. These three properties must be present
    for the transaction to be created. This object can have the properties that are
    present in the object passed to the `sendTransaction()` method, but here, `data`
    is the contract bytecode and the `to` property is ignored.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`proof`合同中，没有构造函数，但如果有构造函数，则构造函数的参数应该放在`new`方法的开头。我们传递的对象包含`from`地址，合同的字节码和要使用的最大`gas`。这三个属性必须存在才能创建交易。此对象可以具有传递给`sendTransaction()`方法的对象中存在的属性，但在这里，`data`是合同的字节码，`to`属性被忽略。
- en: 'You can use the `at` method to get a reference to an already deployed contract.
    Here is the code to demonstrate this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`at`方法获取已部署合同的引用。以下是演示此操作的代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s take a look at sending a transaction to invoke a method of a contract.
    Here is an example to demonstrate this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下发送交易以调用合同方法的情况。以下是演示此操作的示例：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we call the `sendTransaction` method of the object for the namesake method.
    The object passed to this `sendTransaction` method has the same properties as
    `web3.eth.sendTransaction()`, except that the `data` and `to` properties are ignored.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为同名方法调用对象的`sendTransaction`方法。传递给此`sendTransaction`方法的对象具有与`web3.eth.sendTransaction()`相同的属性，只是忽略了`data`和`to`属性。
- en: 'If you want to invoke a method on the node itself, rather than creating a transaction
    and broadcasting it, then you can use `call` instead of `sendTransaction`. Here''s
    how:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想调用节点本身的方法，而不是创建交易并广播它，那么您可以使用`sendTransaction`而不是`sendTransaction`。如下所示：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sometimes, it is necessary to find out the amount of gas that would be required
    to invoke a method so that you can decide whether to invoke it. You can use `web3.eth.estimateGas` for
    this purpose. However, using `web3.eth.estimateGas()` requires you to directly
    generate the data of the transaction; therefore, we can use the `estimateGas()`
    method of the contract object. Here is an example to demonstrate this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要了解调用方法所需的gas量，以便您可以决定是否调用它。您可以使用`web3.eth.estimateGas`来实现此目的。然而，使用`web3.eth.estimateGas()`需要您直接生成交易的数据；因此，我们可以使用合同对象的`estimateGas()`方法。以下是演示此操作的示例：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To send some `ether` to a contract without invoking any method, you can simply
    use the `web3.eth.sendTransaction` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要向合同发送一些`ether`而不调用任何方法，您可以简单地使用`web3.eth.sendTransaction`方法。
- en: Retrieving and listening to contract events
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索和监听合约事件
- en: Watching for events is very important because the results of method invocations
    by transactions are usually returned by triggering events.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 监听事件非常重要，因为通常通过触发事件返回交易调用的方法结果。
- en: 'Before we get into how to retrieve and watch for events, we need to learn about
    indexed parameters of events. A maximum of three parameters for an event can have
    the `indexed` attribute. This attribute is used to signal the node to index it
    so that the app client can search for events with matching return values. If you
    don''t use the `indexed` attribute, then it will have to retrieve all the events
    from the node and filter the ones needed. For example, you can write the `logFileAddedStatus`
    event this way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何检索和监听事件之前，我们需要了解事件的索引参数。 事件的最多三个参数可以具有 `indexed` 属性。 此属性用于指示节点将其索引，以便应用客户端可以搜索具有匹配返回值的事件。
    如果不使用 `indexed` 属性，则必须从节点检索所有事件并过滤所需的事件。 例如，您可以这样编写 `logFileAddedStatus` 事件：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an example to demonstrate how to listen to contract events:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何监听合约事件：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the following is how the aforementioned code works:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的工作原理：
- en: 'First, we get the `event` object by calling the method of the event namesake
    on a contract instance. This method takes two objects as arguments, which are
    used to filter events:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们通过在合约实例上调用事件同名方法来获取 `event` 对象。 此方法接受两个对象作为参数，用于筛选事件：
- en: 'The first object is used to filter events by indexed return values, for example,
    `{''valueA'': 1, ''valueB'': [myFirstAddress, mySecondAddress]}`. All filter values
    are set to `null` by default.  This means that they will match any event of a
    given type sent from this contract.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一个对象用于通过索引返回值筛选事件，例如，`{''valueA'': 1, ''valueB'': [myFirstAddress, mySecondAddress]}`。
    所有筛选值默认设置为 `null`。 这意味着它们将匹配来自此合约的给定类型的任何事件。'
- en: 'The next object can contain three properties: `fromBlock` (the `"earliest"`
    block; by default, it is `"latest"`); `toBlock` (the `"latest"` block; by default,
    it is `"latest"`); and `address` (a list of addresses to only get logs from; by
    default, the contract address).'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个对象可以包含三个属性：`fromBlock`（“最早”的块；默认情况下为“latest”）；`toBlock`（“最新”的块；默认情况下为“latest”）；和
    `address`（仅从中获取日志的地址列表；默认情况下为合约地址）。
- en: 'The `event` object exposes three methods: `get`, `watch`, and `stopWatching`.
    `get` is used to get all the events in the block range. `watch` is similar to `get`,
    but it watches for changes after getting the events. `stopWatching` can be used
    to stop watching for changes.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event` 对象公开三种方法：`get`、`watch` 和 `stopWatching`。 `get` 用于获取区块范围内的所有事件。 `watch`
    类似于 `get`，但它在获取事件后监视更改。 `stopWatching` 可用于停止监视更改。'
- en: Then, we have the `allEvents` method of the contract instance. It is used to
    retrieve all the events of a contract.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有了合约实例的 `allEvents` 方法。 它用于检索合约的所有事件。
- en: 'Every event is represented by an object that contains the following properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都由一个对象表示，其中包含以下属性：
- en: '`args`: An object with the arguments from the event.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：包含事件参数的对象。'
- en: '`event`: A string representing the event name.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`：表示事件名称的字符串。'
- en: '`logIndex`: An integer representing the log index position in the block.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logIndex`：表示块中的日志索引位置的整数。'
- en: '`transactionIndex`: An integer representing the transactions that the index
    position log was created from.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionIndex`：表示创建此索引位置日志的事务的整数。'
- en: '`transactionHash`: A string representing the hash of the transactions that
    this log was created from.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionHash`：表示创建此日志的交易的哈希的字符串。'
- en: '`address`: A string representing the address from which this log originated.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：表示此日志来源地址的字符串。'
- en: '`blockHash`: A string representing the hash of the block where this log was
    located. This is left as `null` when it''s pending.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockHash`：表示包含此日志的块的哈希的字符串。 当处于待定状态时，此字段为 `null`。'
- en: '`blockNumber`: The block number this log was in. This is entered as `null`
    when it''s pending.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockNumber`：此日志所在的块号。 当处于待定状态时，此字段为 `null`。'
- en: web3.js provides a `web3.eth.filter` API to retrieve and watch for events. You
    can use this API, but the way of handling events in the earlier method  is much
    easier. You can learn more about it at [https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js提供了一个`web3.eth.filter` API来检索和监视事件。您可以使用这个API，但是在前一种方法中处理事件的方式要简单得多。您可以在[https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter)了解更多信息。
- en: Building a client for the ownership contract
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为所有权合约构建客户端
- en: In the previous chapter, we wrote Solidity code for the ownership contract.
    And in both the previous chapter and this one, we learned about web3.js and how
    to invoke the methods of the contract using web3.js. Now, it's time to build a
    client for our smart contract so that users can use it easily.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为所有权合约编写了Solidity代码。在上一章和本章中，我们学习了web3.js以及如何使用web3.js调用合约的方法。现在，是时候为我们的智能合约构建一个客户端，以便用户可以轻松地使用它。
- en: We will build a client where an enterprise's user selects a file, enters owner
    details, and then clicks on `Submit` to broadcast a transaction to invoke the
    contract's `set` method with the file hash and the owner's details. Once the transaction
    is successfully broadcasted, we will display the transaction hash. The user will
    also be able to select a file and get the owner's details from the smart contract.
    The client will also display the recent `set` transactions mined in real time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个客户端，企业用户选择文件，输入所有者细节，然后点击`提交`来广播一个交易来调用合约的`set`方法，使用文件哈希和所有者细节。一旦成功广播交易，我们将显示交易哈希。用户还可以选择一个文件，并从智能合约获取所有者的细节。客户端还将实时显示最近的`set`交易。
- en: We will use sha1.js to get the hash of the file on the frontend, jQuery for
    DOM manipulation, and Bootstrap 4 to create a responsive layout. We will use Express.js
    and web3.js on the backend. We will use `socket.io` so that the backend pushes
    recently mined transactions to the frontend without the frontend periodically
    requesting data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前端使用sha1.js来获取文件哈希，使用jQuery进行DOM操作，并使用Bootstrap 4来创建响应式布局。我们将在后端使用Express.js和web3.js。我们将使用`socket.io`，这样后端就可以将最近挖掘到的交易推送到前端，而无需前端周期性地请求数据。
- en: The project structure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'In the exercise files for this chapter, you will find two directories: `Final`
    and `Initial`. `Final` contains the final source code of the project, whereas
    `Initial` contains the empty source code files and libraries to allow you to get
    started on building the application quickly.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，您会找到两个目录：`Final`和`Initial`。`Final`包含项目的最终源代码，而`Initial`包含空白源代码文件和库，以便您快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and replace the hardcoded contract address in `app.js` with the contract address
    that you got after deploying the contract. Then, run the app using the `node app.js`
    command inside the `Final` directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Final`目录，您需要在其中运行`npm install`，并将`app.js`中的硬编码合约地址替换为部署合约后获得的合约地址。然后，使用`Final`目录内的`node
    app.js`命令运行应用程序。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. `package.json` contains the backend dependencies
    of our app, and `app.js` is where you will place the backend source code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Initial`目录中，您会找到一个`public`目录和两个名为`app.js`和`package.json`的文件。`package.json`包含我们应用的后端依赖，`app.js`是您放置后端源代码的地方。
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the Bootstrap library; inside `public/html`,
    you will find `index.html`, where you will place the HTML code of our app; and
    in the `public/js` directory, you will find JS files for jQuery, sha1, and socket.io.
    Inside `public/js`, you will also find a `main.js` file, where you will place
    the frontend JS code of our app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`目录包含与前端相关的文件。在`public/css`目录内，您会找到`bootstrap.min.css`，这是Bootstrap库；在`public/html`目录内，您会找到`index.html`，您将在其中放置应用程序的HTML代码；而在`public/js`目录内，您会找到用于jQuery、sha1和socket.io的JS文件。在`public/js`目录内，您还会找到一个`main.js`文件，您将在其中放置我们应用的前端JS代码。'
- en: Building the backend
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: First, run `npm install` inside the `Initial` directory to install the required
    dependencies for our backend. Before we get into coding the backend, make sure
    geth is running with `rpc` enabled. Finally, make sure that account `0` exists
    and is unlocked.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `Initial` 目录内运行 `npm install` 安装我们后端所需的依赖项。在开始编写后端之前，请确保 geth 正在运行，并启用了
    `rpc`。最后，请确保账户 `0` 存在并已解锁。
- en: One final thing you need to do before getting started with coding is to deploy
    the ownership contract using the code we saw in the previous chapter, and copy
    the contract address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，你需要做的最后一件事是使用我们在前一章中看到的代码部署所有权合同，并复制合同地址。
- en: 'Now let''s create a single server, which will serve the HTML to the browser
    and also accept `socket.io` connections:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个单独的服务器，该服务器将为浏览器提供 HTML，并接受 `socket.io` 连接：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are integrating both the `express` and `socket.io` servers into one
    server running on port `8080`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `express` 和 `socket.io` 服务器整合到一个运行在端口 `8080` 上的服务器中。
- en: 'Now let''s create the routes to serve the static files and also the home page
    of the app. Here is the code to do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来提供静态文件并为应用程序的主页创建路由。以下是执行此操作的代码：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are using the `express.static` middleware to serve static files. We
    are asking it to find static files in the `public` directory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `express.static` 中间件来提供静态文件服务。我们要求它在 `public` 目录中查找静态文件。
- en: 'Now let''s connect to the geth node and also get a reference to the deployed
    contract so that we can send transactions and watch for events. Here is the code
    to do this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接到 geth 节点，并获取已部署的合同的引用，以便我们可以发送交易并监听事件。以下是执行此操作的代码：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code is self-explanatory. Simply replace the contract address with the one
    that you got.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很直观。只需用你得到的合同地址替换原来的地址即可。
- en: 'Now let''s create routes to broadcast transactions and get information about
    a file. Here is the code to do this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来广播交易并获取有关文件的信息。以下是执行此操作的代码：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `/submit` route is used to create and broadcast transactions. Once
    we get the transaction hash, we send it to the client. We are not doing anything
    to wait for the transaction to mine. The `/getInfo` route calls the `get` method
    of the contract on the node itself, instead of creating a transaction. It simply
    sends back whatever response it gets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`/submit` 路由用于创建和广播交易。一旦我们获得了交易哈希，我们就将其发送给客户端。我们不会做任何等待交易挖矿的操作。`/getInfo`
    路由调用节点上合同的 `get` 方法，而不是创建一个交易。它只是简单地将收到的任何响应发送回去。
- en: 'Now let''s watch for the events from the contract and broadcast them to all
    the clients. Here is the code to do this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们监听来自合同的事件，并将它们广播给所有客户端。以下是执行此操作的代码：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we check whether `status` is `true`, and only if  it is `true` do we broadcast
    the event to all the connected `socket.io` clients.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查 `status` 是否为 `true`，只有当它为 `true` 时，我们才将事件广播到所有连接的 `socket.io` 客户端。
- en: Building the frontend
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: 'Let''s begin with the HTML of the app. Put this code in the `index.html` file,
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的 HTML 开始。将此代码放在 `index.html` 文件中，如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is how the code works:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: First, we display Bootstrap's file input field so that the user can select a
    file.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们显示 Bootstrap 的文件输入字段，以便用户可以选择文件。
- en: Then, we display a text field where the user can enter the owner's details.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们显示一个文本字段，用户可以输入所有者的详细信息。
- en: Then we have two buttons. The first one is to store the file hash and the owner's
    details in the contract, and the second button is to get information on the file
    from the contract. Clicking on the `Submit` button triggers the `submit()` method,
    and clicking on the `Get Info` button triggers the `getInfo()` method.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们有两个按钮。第一个按钮用于在合同中存储文件哈希和所有者的详细信息，第二个按钮用于从合同中获取文件的信息。点击 `Submit` 按钮会触发 `submit()`
    方法，点击 `Get Info` 按钮会触发 `getInfo()` 方法。
- en: Next, we have an alert box to display messages.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个警告框来显示消息。
- en: Finally, we display an ordered list to show the transactions of the contract
    that gets mined while the user is on the page.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们显示一个有序列表，以显示用户在页面上时挖矿的合同的交易。
- en: 'Now, let''s write the implementation for the `getInfo()` and `submit()` methods,
    establish  `socket.io` connect with the server, and listen for `socket.io` messages
    from the server. Place this code in the `main.js` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写 `getInfo()` 和 `submit()` 方法的实现，建立与服务器的 `socket.io` 连接，并监听来自服务器的 `socket.io`
    消息。将此代码放在 `main.js` 文件中：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how the preceding code works:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前述代码的工作原理：
- en: First, we define the `submit()` method. In the `submit()` method, we ensure
    that a file is selected and the text field is not empty. Then, we read the content
    of the file as an array buffer and pass the array buffer to the `sha1()` method
    exposed by sha1.js in order to get the hash of the content inside the array buffer.
    Once we have the hash, we use jQuery to make an AJAX request to the `/submit`
    route and then we display the transaction hash in the alert box.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义了`submit()`方法。在`submit()`方法中，我们确保选择了一个文件并且文本字段不为空。然后，我们将文件内容读取为一个数组缓冲区，并将数组缓冲区传递给sha1.js中暴露的`sha1()`方法，以便获得数组缓冲区内的内容的哈希值。一旦我们获得了哈希值，我们就使用jQuery向`/submit`路由发出AJAX请求，然后在警告框中显示事务哈希值。
- en: We define the `getInfo()` method next. It first makes sure that a file is selected.
    Then, it generates a hash like the one it generated earlier and makes a request
    to the `/getInfo` endpoint to get information about that file.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧接着我们定义了`getInfo()`方法。它首先确保选择了一个文件。然后，它生成像之前生成的那样的哈希，并请求`/getInfo`端点以获取有关该文件的信息。
- en: Finally, we establish a `socket.io` connection using the `io()` method exposed
    by the `socket.io` library. Then, we wait for the connect event to trigger, which
    indicates that a connection has been established. After the connection is established,
    we listen for messages from the server and display the details of the transactions
    to the user.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket.io`库提供的`io()`方法建立`socket.io`连接。然后，我们等待连接事件触发，这表示连接已经建立。连接建立后，我们监听来自服务器的消息，并显示交易的详细信息给用户。
- en: We aren't storing the file in the Ethereum blockchain. Storing files is very
    expensive, as it requires a lot of gas. In our case, we don't need to store files
    because nodes in the network will be able to see the file; therefore, if the users
    want to keep the file content secret, then they won't be able to. Our application's
    purpose is simply to prove ownership of a file, not to store and serve the file,
    as a cloud service does.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不把文件存储在以太坊区块链上。存储文件非常昂贵，因为需要很多gas。在我们的情况下，我们不需要存储文件，因为网络中的节点将能够看到文件；因此，如果用户想保持文件内容的机密性，那么他们将不能。我们应用的目的仅仅是证明文件的所有权，而不是像云服务一样存储和提供文件。
- en: Testing the client
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端
- en: 'Now run the `app.js` node to run the application server. Open your favorite
    browser and visit `http://localhost:8080/`. You will see this output in the browser:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`app.js`节点来运行应用程序服务器。打开你喜欢的浏览器，并访问`http://localhost:8080/`。你将在浏览器中看到这个输出：
- en: '![](img/c6e4f386-d737-4f54-9bff-fa79fc4a6008.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6e4f386-d737-4f54-9bff-fa79fc4a6008.png)'
- en: 'Now select a file, enter the owner''s name, and click on Submit. The browser
    window will change to this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择一个文件，输入所有者的姓名，然后点击提交。浏览器窗口将会变成这样：
- en: '![](img/515c0928-c6d2-4594-ab16-acd466dae3da.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/515c0928-c6d2-4594-ab16-acd466dae3da.png)'
- en: 'In the following diagram, you can see that the Transaction hash is displayed.
    Now wait until the transaction is mined. Once the transaction is mined, you will
    be able to see the transaction in the live transactions list. Here is how the
    browser window should look:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到交易哈希值已显示。现在等待直到交易被挖掘。一旦交易被挖掘，你将能够在实时交易列表中看到交易。浏览器窗口应该如下所示：
- en: '![](img/1b72320c-a109-451b-bdb9-6d709150107e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b72320c-a109-451b-bdb9-6d709150107e.png)'
- en: 'Now select the same file again and click on the Get Info button. You will see
    the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次选择相同的文件，然后点击获取信息按钮。你将会看到以下输出：
- en: '![](img/75dc8910-fba6-4301-961c-18528b442277.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75dc8910-fba6-4301-961c-18528b442277.png)'
- en: In the previous screenshot, you can see the Timestamp and the owner's details.
    Now we have finished building the client for our first DApp.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上个截图中，你可以看到时间戳和所有者的详细信息。现在我们已经完成了为我们的第一个DApp构建客户端。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about the fundamentals of web3.js and looked
    at some examples. We learned about connecting to a node, basic APIs, sending various
    kinds of transactions, and watching for events. Finally, we built a proper production
    use client for our ownership contract. Now you should be comfortable with writing
    smart contracts and building UI clients for them in order to ease their use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了web3.js的基础知识，并查看了一些示例。我们了解了连接到节点、基本API、发送各种类型的交易以及监听事件。最后，我们为我们的所有权合约构建了适当的生产用客户端。现在，您应该能够轻松编写智能合约并为其构建UI客户端，以便简化它们的使用。
- en: In the next chapter, we will learn about achieving privacy using a zero-knowledge
    security layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用零知识安全层实现隐私。
