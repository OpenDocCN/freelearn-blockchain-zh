- en: Development Tools and Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具和框架
- en: This chapter is an introduction to development tools, languages, and frameworks
    used for Ethereum smart contract development. We will examine different methods
    of developing smart contracts for the Ethereum blockchain. We will discuss various
    constructs of Solidity language in detail, which is currently the most popular
    development language for smart contract development on Ethereum.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于以太坊智能合约开发的开发工具、语言和框架。我们将研究开发以太坊区块链智能合约的不同方法。我们将详细讨论Solidity语言的各种结构，这是目前以太坊智能合约开发中最流行的开发语言。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Development tools, IDEs, and clients
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发工具、集成开发环境和客户端
- en: Remix
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix
- en: Ganache
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ganache
- en: EthereumJS
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EthereumJS
- en: TestRPC
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestRPC
- en: MetaMask
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MetaMask
- en: Truffle
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle
- en: Prerequisites
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先决条件
- en: Node
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node
- en: Node Package Manager (NPM)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node包管理器（NPM）
- en: Other tools and utilities
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具和实用程序
- en: 'There are a number of tools available for Ethereum development. The following
    diagram shows the taxonomy of various development tools, clients, IDEs, and development
    frameworks for Ethereum:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于以太坊开发。下图显示了用于以太坊的各种开发工具、客户端、集成开发环境和开发框架的分类：
- en: '![](img/7b00d90c-5e15-45a2-9d66-348e46e5aa28.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b00d90c-5e15-45a2-9d66-348e46e5aa28.jpg)'
- en: Taxonomy of Ethereum development ecosystem components
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊开发生态系统组件的分类
- en: The preceding taxonomy does not include all frameworks and tools that are out
    there for development on Ethereum. It shows most commonly used tools and frameworks
    and also the ones that we will use in our examples throughout this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述分类并未包括所有用于以太坊开发的框架和工具。它展示了最常用的工具和框架，也是我们在本章中将要用到的工具和框架。
- en: There are number of resources available related to development tools for Ethereum
    at the address [http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools](http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与以太坊开发工具相关的资源可在以下地址找到：[http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools](http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools)。
- en: In this chapter, the main focus will be on Geth, Remix IDE, Solidity, Ganache,
    MetaMask, solc, and Truffle. The rest of the elements such as prerequisites (Node)
    will also be discussed briefly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点将放在Geth、Remix IDE、Solidity、Ganache、MetaMask、solc和Truffle上。其他元素，如先决条件（Node），也将简要讨论。
- en: Languages
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言
- en: 'Smart contracts can be programmed in a variety of languages for Ethereum blockchain.
    There are five languages that can be used in order to write contracts:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的智能合约可以用多种语言编程。有五种语言可用于编写合同：
- en: '**Mutan**: This is a Go-style language, which was deprecated in early 2015
    and is no longer used.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mutan**：这是一种类似Go的语言，于2015年初被废弃，已不再使用。'
- en: '**LLL**: This is a **Low-level Lisp-like Language**, hence the name LLL. This
    is also not used anymore.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLL**：这是一种**低级别的Lisp式语言**，因此被命名为LLL。这也不再使用。'
- en: '**Serpent**: This is a simple and clean Python-like language. It is not used
    for contract development anymore and not supported by the community anymore.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serpent**：这是一种简单、清洁的类似Python的语言。它不再用于合同开发，并且不再得到社区支持。'
- en: '**Solidity**: This language has now become almost a standard for contract writing
    for Ethereum. This language is the focus of this chapter and is discussed in detail
    in later sections.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Solidity**：此语言现已成为几乎是以太坊合同编写的标准。本章将重点讨论这种语言，并在后续章节中进行详细讨论。'
- en: '**Vyper**: This language is a Python-like experimental language that is being
    developed to bring security, simplicity, and auditability to smart contract development.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vyper**：这种语言是一种类似Python的实验性语言，旨在为智能合约开发带来安全性、简单性和可审计性。'
- en: Compilers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器
- en: Compilers are used to convert high-level contract source code into the format
    that the Ethereum execution environment understands. The Solidity compiler is
    the most common one in use and is discussed here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器用于将高级合同源代码转换为以太坊执行环境能理解的格式。Solidity编译器是最常用的一个，并在此处讨论。
- en: Solidity compiler (solc)
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity编译器（solc）
- en: solc converts from a high-level solidity language into **Ethereum Virtual Machine**
    (**EVM**) bytecode so that it can be executed on the blockchain by EVM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: solc将高级Solidity语言转换为**以太坊虚拟机**（**EVM**）字节码，以便在区块链上由EVM执行。
- en: Installation on Linux
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'solc can be installed on a Linux Ubuntu operating system using the following
    commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: solc 可以在 Linux Ubuntu 操作系统上安装，使用以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If PPAs are not already installed, those can be installed by running the following
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PPA 尚未安装，可以通过运行以下命令来安装它们：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to verify the existing version of the solc and verify that it is installed,
    the following command can be used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 solc 的现有版本并验证其是否已安装，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installation on macOS
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: 'To install solc on macOS, execute the following commands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 上安装 solc，请执行以下命令：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'solc supports a variety of functions. A few examples are shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: solc 支持各种功能。一些示例如下所示：
- en: 'Display contract in a binary format:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以二进制格式显示合约：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will produce an output similar to the following. This shows the
    binary translation of the
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将生成类似以下的输出。这显示了二进制翻译的内容。
- en: '`Addition.sol` contract code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Addition.sol` 合约代码：'
- en: '![](img/626c8c00-4fc7-4468-9733-8e8901efd663.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/626c8c00-4fc7-4468-9733-8e8901efd663.png)'
- en: Solidity compiler binary output
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 编译器的二进制输出
- en: 'Estimate gas:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算 gas：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will give the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f0d9ee29-bdc2-4111-8d4c-b1a49d65a050.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0d9ee29-bdc2-4111-8d4c-b1a49d65a050.png)'
- en: Gas estimation using solc
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 solc 估算 gas
- en: 'Generate ABI:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 ABI：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following are the contents of `Addition.abi`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `Addition.abi` 的内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compilation:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译：
- en: 'Another useful command to compile and produce a binary compiled file along
    with an ABI is shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令，用于编译并生成一个二进制编译文件以及一个 ABI，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will produce two files in the output directory `bin`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在输出目录 `bin` 中产生两个文件：
- en: '`Addition.abi`: This contains the Application Binary Interface of the smart
    contract in JSON format'
  id: totrans-61
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Addition.abi`：这包含智能合约的 Application Binary Interface，以 JSON 格式表示'
- en: '`Addition.bin`: This contains the hex representation of binary of the smart
    contract code'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Addition.bin`：这包含智能合约代码的二进制表示'
- en: 'The output of both files is shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 两个文件的输出显示在以下截图中：
- en: '![](img/c9f46d19-29ea-4048-8c2a-69f28fb91516.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9f46d19-29ea-4048-8c2a-69f28fb91516.png)'
- en: ABI and binary output of solidity compiler
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 编译器的 ABI 和二进制输出
- en: '**ABI** is the abbreviation of **Application Binary Interface**. ABI encodes
    information about smart contract''s functions and events. It acts as an interface
    between EVM level bytecode and high level smart contract program code. To interact
    with a smart contract deployed on the Ethereum blockchain, external programs require
    ABI and address of the smart contract.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**ABI** 是 **Application Binary Interface** 的缩写。ABI 对智能合约的函数和事件的信息进行编码。它充当 EVM
    级字节码和高级智能合约程序代码之间的接口。要与部署在以太坊区块链上的智能合约进行交互，外部程序需要 ABI 和智能合约的地址。'
- en: solc is a very powerful command and further options can be explored using `--
    help` flag which will display detailed options. However, the preceding commands
    used for compilation, ABI generation and gas estimation should be sufficient for
    most development and deployment requirements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: solc 是一个非常强大的命令，可以使用 `--help` 标志来探索更多选项，该选项将显示详细选项。但是，用于编译、ABI 生成和 gas 估算的前述命令应该对大多数开发和部署需求足够了。
- en: Integrated Development Environments (IDEs)
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）
- en: There are various IDEs available for Solidity development. Most of the IDEs
    are available online and are presented via web interfaces. Remix (formerly browser
    Solidity) is the most commonly used IDE for building and debugging smart contracts.
    It is discussed here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的 IDE 可用于 Solidity 开发。大多数 IDE 都可以在线使用，并通过 web 界面呈现。Remix（曾用名为浏览器 Solidity）是构建和调试智能合约最常用的
    IDE。在此讨论它。
- en: Remix
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remix
- en: Remix is the web-based environment for the development and testing of contracts
    using Solidity. It is a feature-rich IDE which does not run on live blockchain;
    in fact, it is a simulated environment in which contracts can be deployed, tested,
    and debugged.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是基于 web 的环境，用于使用 Solidity 开发和测试合约。它是一个功能丰富的 IDE，不在实时区块链上运行；实际上，它是一个模拟环境，合约可以在其中部署、测试和调试。
- en: It is available at [https://remix.ethereum.org](https://remix.ethereum.org).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可在 [https://remix.ethereum.org](https://remix.ethereum.org) 找到。
- en: 'An example interface is shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例接口如下所示：
- en: '![](img/af2b57aa-d1dc-452e-8647-4e63c648147e.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af2b57aa-d1dc-452e-8647-4e63c648147e.png)'
- en: Remix IDE
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Remix IDE
- en: On the left-hand side, there is a code editor with syntax highlighting and code
    formatting, and on the right-hand side, there are a number of tools available
    that can be used to deploy, debug, test, and interact with the contract.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，有一个带有语法高亮和代码格式化的代码编辑器，右侧有许多可用于部署、调试、测试和与合约交互的工具。
- en: Various features, such as transaction interaction, options to connect to JavaScript
    VM, configuration of execution environment, debugger, formal verification, and
    static analysis, are available. They can be configured to connect to execution
    environments such as JavaScript VM, injected Web3—where Mist, MetaMask, or a similar
    environment has provided the execution environment—or Web3 provider, which allows
    connection to the locally running Ethereum client (for example, `geth`) via IPC
    or RPC over HTTP (Web3 provider endpoint).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种功能，例如交易交互，连接到 JavaScript VM 的选项，执行环境的配置，调试器，形式验证和静态分析。它们可以配置为连接到执行环境，例如
    JavaScript VM，注入的 Web3——Mist、MetaMask 或类似环境提供了执行环境——或者 Web3 提供程序，它允许通过 IPC 或 RPC
    over HTTP（Web3 提供程序端点）连接到本地运行的以太坊客户端（例如 `geth`）。
- en: 'Remix also has a debugger for EVM which is very powerful and can be used to
    perform detailed level tracing and analysis of the EVM bytecode. An example is
    shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 还具有针对 EVM 的调试器，非常强大，可用于执行详细级别的跟踪和分析 EVM 字节码。下面是一个示例：
- en: '![](img/a19dcf11-192c-4187-a770-816be44951e2.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a19dcf11-192c-4187-a770-816be44951e2.png)'
- en: Remix IDE, debugging
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Remix IDE，调试
- en: The preceding screenshot shows different elements of the Remix IDE. On the top
    left-hand side, the source code is shown. Below that is the output log which shows
    informational messages and data related to compilation and execution of the contract.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了 Remix IDE 的不同元素。左上角显示了源代码。下面是输出日志，显示了与合约的编译和执行相关的信息消息和数据。
- en: 'The following screenshot shown shows the Remix debugger in more detail. It
    has the source code decoded into EVM instructions. The user can step through the
    instructions one by one and can examine what the source code does when executed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 Remix 调试器的更多细节。它将源代码解码为 EVM 指令。用户可以逐步执行每个指令，并且可以检查当执行时源代码的作用：
- en: '![](img/4fb8ca55-767d-497a-b30d-3a3c7f61a4e7.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb8ca55-767d-497a-b30d-3a3c7f61a4e7.png)'
- en: Remix Debugger
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 调试器
- en: Tools and libraries
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具和库
- en: There are various tools and libraries available for Ethereum. The most common
    ones are discussed here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种工具和库可用于以太坊。最常见的是在这里讨论的。
- en: In this section, we will first install prerequisites that are required for developing
    applications for Ethereum. First requirement is Node, which will see next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先安装开发以太坊应用程序所需的先决条件。首先要求是 Node，接下来将看到。
- en: Node version 7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 版本 7
- en: 'As Node is required for most of the tools and libraries, it can be installed
    using the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数工具和库都需要 Node，可以使用以下命令安装它：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: EthereumJS
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EthereumJS
- en: At times, it is not possible to test on the testnet and mainnet is obviously
    not a place to test the contracts. Private net can be time-consuming to set up
    at times. EthereumJS' TestRPC comes in handy when quick testing is required and
    no proper testnet is available. It uses EthereumJS to simulate the Ethereum `geth`
    client behavior and allows for faster development testing. TestRPC is available
    via `npm` as a Node package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在测试网上测试不可能，并且主网显然不是测试合约的地方。私有网有时候设置起来可能很耗时。当需要快速测试而又没有合适的测试网时，EthereumJS
    的 TestRPC 就非常方便了。它使用 EthereumJS 模拟 Ethereum `geth` 客户端的行为，并允许进行更快的开发测试。TestRPC
    可以通过`npm`作为一个 Node 软件包获得。
- en: Before installing TestRPC, Node should already have been installed and the `npm`
    package manager should also be available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 TestRPC 之前，Node 应该已经被安装，并且`npm`软件包管理器也应该可用。
- en: 'TestRPC can be installed using this command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用此命令安装 TestRPC：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to start `testrpc`, simply issue this command and keep it running
    in the background and open another Terminal to work on contracts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 `testrpc`，只需发出此命令并使其在后台运行，然后打开另一个终端以处理合约：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When TestRPC runs, it will display the output similar to the one shown in the
    following screenshot. It will automatically generate ten accounts and private
    keys, along with HD wallet. It will start to listen for incoming connection on
    TCP port `8545`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TestRPC 运行时，它将显示类似于以下截图所示的输出。它将自动生成十个帐户和私钥，以及 HD 钱包。它将开始监听 TCP 端口`8545`上的传入连接。
- en: '![](img/be20a349-f79f-4a24-981f-dcaa1860bafc.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be20a349-f79f-4a24-981f-dcaa1860bafc.png)'
- en: TestRPC
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TestRPC
- en: Ganache
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ganache
- en: Ganache is the latest addition to the plethora of development tools and libraries
    developed for Ethereum. This is, in a way a replacement of TestRPC and uses a
    user-friendly graphical user interface to see transaction and blocks and relevant
    details. This is fully working Byzantium enabled personal blockchain which is
    used to provide a local testing environment for blockchains.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache是为以太坊开发的众多开发工具和库的最新增加。这在某种程度上是TestRPC的替代品，使用用户友好的图形用户界面来查看交易和块以及相关细节。这是一个完全工作的启用了Byzantium的个人区块链，用于为区块链提供本地测试环境。
- en: Ganache is based on a JavaScript implementation of the Ethereum blockchain,
    with built-in block explorer and mining, making testing locally on the system
    very easy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache基于以太坊区块链的JavaScript实现，内置区块浏览器和挖矿功能，使在系统上进行本地测试非常容易。
- en: 'As shown in the following screenshot you can view transaction, blocks, and
    addresses in detail on the frontend:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，您可以在前端详细查看交易、块和地址：
- en: '![](img/ec0a456d-3a09-4120-b277-e10f15826df0.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec0a456d-3a09-4120-b277-e10f15826df0.png)'
- en: Ganache, A personal Ethereum blockchain
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache，一个个人以太坊区块链
- en: Ganache can be downloaded from [http://truffleframework.com/ganache/](http://truffleframework.com/ganache/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache可以从[http://truffleframework.com/ganache/](http://truffleframework.com/ganache/)下载。
- en: MetaMask
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MetaMask
- en: MetaMask allows interaction with Ethereum blockchain via Firefox and Chrome
    browsers. It injects a `web3` object within the running websites' JavaScript context
    which allows immediate interface capability for DApps. This *injection* allows
    DApps to interact directly with the blockchain.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask允许通过Firefox和Chrome浏览器与以太坊区块链交互。它会在运行网站的JavaScript环境中注入一个`web3`对象，从而实现对DApps的即时接口功能。这种*注入*允许DApps直接与区块链交互。
- en: It is available at [https://metamask.io/](https://metamask.io/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在[https://metamask.io/](https://metamask.io/)获得。
- en: MetaMask also allows account management. This acts as a verification method
    before any transaction is executed on the blockchain. The user is shown a secure
    interface to review the transaction for approval or rejection before it can reach
    the target blockchain.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask也允许账户管理。这在任何交易在区块链上执行之前充当验证方法。用户会看到一个安全界面来审查交易，然后批准或拒绝它，才能到达目标区块链。
- en: It is available at [https://github.com/MetaMask/metamask-plugin](https://github.com/MetaMask/metamask-plugin).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在[https://github.com/MetaMask/metamask-plugin](https://github.com/MetaMask/metamask-plugin)获得。
- en: '![](img/1c536ff7-2b23-4dbf-9474-f9aeb29f09d8.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c536ff7-2b23-4dbf-9474-f9aeb29f09d8.png)'
- en: MetaMask
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask
- en: 'It allows connectivity with various Ethereum networks as shown in the following
    screenshot. This is the screenshot of the MetaMask, where it allows users to select
    the network of their choice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许与各种以太坊网络连接，如下截图所示。这是MetaMask的截图，它允许用户选择他们喜欢的网络：
- en: '![](img/a1581e34-a3cd-4571-a01c-ffaeb0bcf86b.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1581e34-a3cd-4571-a01c-ffaeb0bcf86b.png)'
- en: MetaMask networks as shown in the MetaMask user interface
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask网络如MetaMask用户界面所示
- en: An interesting feature to note is that MetaMask can connect to any custom RPC
    too which allows you to run your own blockchain, such as private nets locally
    or even remotely and allows your browser to connect to it. It can also be used
    to connect to a locally running blockchain like Ganache and TestRPC.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一个有趣功能是MetaMask也可以连接到任何自定义的RPC，这允许您运行自己的区块链，例如本地或远程的私有网络，并允许您的浏览器连接到它。它还可以用于连接到本地运行的区块链，如Ganache和TestRPC。
- en: 'MetaMask allows account management and also records all transactions for these
    accounts. This is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask允许账户管理，并记录所有这些账户的交易。这在下面的截图中显示：
- en: '![](img/1cda9989-6659-4674-988f-79575bb1e8c5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cda9989-6659-4674-988f-79575bb1e8c5.png)'
- en: MetaMask accounts and transactions view
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask账户和交易视图
- en: Truffle
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle
- en: Truffle (available at [http://truffleframework.com/](http://truffleframework.com/))
    is a development environment that makes it easier and simpler to test and deploy
    Ethereum contracts. Truffle provides contract compilation and linking along with
    an automated testing framework using Mocha and Chai. It also makes it easier to
    deploy the contracts to any private net, public, or testnet Ethereum blockchain.
    Also, asset pipeline is provided, which makes it easier for all JavaScript files
    to be processed, making them ready for use by a browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle（在 [http://truffleframework.com/](http://truffleframework.com/) 上可用）是一个开发环境，使得测试和部署以太坊合约更加容易和简单。Truffle
    提供合约编译和链接以及使用 Mocha 和 Chai 的自动化测试框架。它还使得更容易将合约部署到任何私有网络、公共网络或测试网络以太坊区块链中。此外，提供了资产管道，使所有
    JavaScript 文件都可以被处理，使其可以被浏览器使用。
- en: Installation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Before installation, it is assumed that `node` is available, which can be queried
    as shown here. If the `node` is not available, then the installation of `node`
    is required first in order to install `truffle`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装之前，假设`node`可用，可以像下面显示的那样查询。如果`node`不可用，则首先需要安装`node`才能安装`truffle`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The installation of `truffle` is very simple and can be done using the following
    command via **Node Package Manager** (**npm**):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`truffle`非常简单，可以使用以下命令通过**Node Package Manager**（**npm**）完成：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will take a few minutes; once it is installed, the `truffle` command can
    be used to display help information and verify that it is installed correctly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将花费几分钟的时间；安装完成后，可以使用`truffle`命令显示帮助信息并验证它是否正确安装：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Type `truffle` at Terminal to display usage help:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端输入`truffle`以显示使用帮助：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will display the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![](img/ea6b7207-c57b-498d-be6b-eb633cfb690f.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea6b7207-c57b-498d-be6b-eb633cfb690f.png)'
- en: Truffle help
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 帮助
- en: 'Alternatively, the repository is available at [https://github.com/ConsenSys/truffle](https://github.com/ConsenSys/truffle),
    which can be cloned locally to install `truffle`. **Git** can be used to clone
    the repository using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，存储库可在 [https://github.com/ConsenSys/truffle](https://github.com/ConsenSys/truffle)
    上找到，可以将其克隆到本地以安装`truffle`。可以使用以下命令使用 Git 克隆存储库：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Contract development and deployment
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合约开发和部署
- en: 'There are various steps that need to be taken in order to develop and deploy
    the contracts. Broadly, these can be divided into four steps: writing, testing,
    verification and deployment. After deployment, the next optional step is to create
    the user interface and present it to the end users via a web server. Web interface
    is sometimes not needed in the contracts where no human input or monitoring is
    required, but usually there is a requirement to create web interface to interact
    with the contract.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和部署合约需要采取各种步骤。广义上来说，这些可以分为四个步骤：编写、测试、验证和部署。部署后，下一个可选步骤是创建用户界面并通过 Web 服务器向最终用户呈现。在不需要人类输入或监视的合约中，有时不需要
    Web 界面，但通常需要创建 Web 界面来与合约交互。
- en: Writing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写作
- en: The writing step is concerned with writing the contract source code in Solidity.
    This can be done in any text editor. There are various plugins and add-ons available
    for Vim in Linux, Atom, and other editors that provide syntax highlighting and
    formatting for Solidity source code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 写作步骤涉及在 Solidity 中编写合约源代码。这可以在任何文本编辑器中完成。对于 Vim、Atom 和其他编辑器，有各种插件和附加组件可用于提供
    Solidity 合约源代码的语法高亮和格式化。
- en: Visual studio code has become quite popular and is used commonly for Solidity
    development. There is a Solidity plugin available that allows syntax highlighting,
    formatting, and intelligence. It can be installed via Extensions option in Visual
    Studio Code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Visual studio code 已经变得非常流行，并且通常用于 Solidity 开发。有一个 Solidity 插件可供使用，可以实现语法高亮、格式化和智能。可以通过
    Visual Studio Code 中的扩展选项进行安装。
- en: '![](img/01077efd-9e90-432a-ac8f-62087ad3c89e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01077efd-9e90-432a-ac8f-62087ad3c89e.png)'
- en: Visual studio code
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Visual studio code
- en: Testing
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is usually performed by automated means. Earlier in the chapter, you
    were introduced to Truffle, which uses the Mocha framework to test contracts.
    However, manual functional testing can be performed as well by using Remix and
    running functions manually and validating results.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常是通过自动化手段进行的。在本章的前面，您已经了解了 Truffle，它使用 Mocha 框架来测试合约。但是，也可以通过使用 Remix 手动运行函数并验证结果来执行手动功能测试。
- en: In the next section, you will be introduced to language Solidity. This is a
    brief introduction to Solidity, which should provide the base knowledge required
    in order to write the contracts. The syntax is very similar to C and JavaScript,
    and it is quite easy to program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将会被介绍到 Solidity 语言。这是对 Solidity 的简要介绍，应提供编写合约所需的基本知识。其语法与 C 和 JavaScript
    非常相似，编程起来相当容易。
- en: Solidity language
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 语言
- en: Solidity is a domain-specific language of choice for programming contracts in
    Ethereum. There are, however, other languages that can be used, such as Serpent,
    Mutan, and LLL but Solidity is the most popular at the time of writing this. Its
    syntax is closer to both JavaScript and C.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是以太坊编写合约的领域特定语言的首选。然而，还有其他可用的语言，比如 Serpent、Mutan 和 LLL，但在撰写本文时，Solidity
    是最流行的。它的语法更接近 JavaScript 和 C。
- en: Solidity has evolved into a mature language over the last few years and is quite
    easy to use, but it still has a long way to go before it can become advanced,
    standardized, and feature-rich like other well-established languages such as Java,
    C or C Sharp. Nevertheless, this is the most widely used language available for
    programming contracts currently.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 在过去几年中发展成为一种成熟的语言，非常容易使用，但在成为像 Java、C 或 C Sharp 等其他成熟语言一样先进、标准化和功能丰富之前，还有很长的路要走。尽管如此，这仍然是目前编写合约最广泛使用的语言。
- en: It is a statically typed language, which means that variable type checking in
    Solidity is carried out at compile time. Each variable, either state or local,
    must be specified with a type at compile time. This is beneficial in the sense
    that any validation and checking is completed at compile time and certain types
    of bugs, such as interpretation of data types, can be caught earlier in the development
    cycle instead of at runtime, which could be costly, especially in the case of
    the blockchain / smart contracts paradigm. Other features of the language include
    inheritance, libraries, and the ability to define composite data types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一种静态类型语言，这意味着在 Solidity 中，变量类型检查是在编译时进行的。每个变量，无论是状态变量还是局部变量，都必须在编译时指定一个类型。这在某种意义上是有益的，因为任何验证和检查都是在编译时完成的，某些类型的错误，比如数据类型的解释，可以在开发周期的早期被捕获，而不是在运行时，这可能是昂贵的，特别是在区块链/智能合约范式的情况下。语言的其他特性包括继承、库和定义复合数据类型的能力。
- en: Solidity is also called a contract-oriented language. In Solidity, contracts
    are equivalent to the concept of classes in other object-oriented programming
    languages.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 也被称为面向合约的语言。在 Solidity 中，合约相当于其他面向对象编程语言中的类的概念。
- en: Types
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Solidity has two categories of data types: **value types** and **reference
    types**.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 有两类数据类型：**值类型** 和 **引用类型**。
- en: Value types
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: 'These are explained in detail here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在这里详细解释：
- en: Boolean
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔
- en: 'This data type has two possible values, `true` or `false`, for example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据类型有两个可能的值，`true` 或 `false`，例如：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This statement assigns the value `true` to `v`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句将值 `true` 分配给 `v`。
- en: Integers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'This data type represents integers. The following table shows various keywords
    used to declare integer data types:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据类型表示整数。以下表格显示了用于声明整数数据类型的各种关键字：
- en: '| **Keyword** | **Types** | **Details** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **类型** | **详情** |'
- en: '| `int` | Signed integer | `int8` to `int256`, which means that keywords are
    available from `int8` up to `int256` in increments of 8, for example, `int8`,
    `int16`, `int24`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 有符号整数 | `int8` 到 `int256`，这意味着关键字从 `int8` 增加到 `int256`，例如，`int8`、`int16`、`int24`。
    |'
- en: '| `uint` | Unsigned integer | `uint8`, `uint16`, ... to `uint256`, unsigned
    integer from 8 bits to 256 bits. The usage is dependent on the requirements that
    how many bits are required to be stored in the variable. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | 无符号整数 | `uint8`、`uint16`、... 到 `uint256`，表示从 8 位到 256 位的无符号整数。变量的存储需求取决于需要存储多少位。'
- en: 'For example, in this code, note that `uint` is an alias for `uint256`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这段代码中，注意 `uint` 是 `uint256` 的别名：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These types can also be declared with the `constant` keyword, which means that
    no storage slot will be reserved by the compiler for these variables. In this
    case, each occurrence will be replaced with the actual value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型也可以用 `constant` 关键字声明，这意味着编译器不会为这些变量保留存储槽。在这种情况下，每次出现都将被实际值替换：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: State variables are declared outside the body of a function, and they remain
    available throughout the contract depending on the accessibility assigned to them
    and as long as the contract persists.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变量在函数体外声明，并且根据分配给它们的可访问性和合约的持续时间保持可用。
- en: Address
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址
- en: 'This data type holds a 160-bit long (20 byte) value. This type has several
    members that can be used to interact with and query the contracts. These members
    are described here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据类型持有 160 位长（20 字节）的值。该类型具有几个成员，可用于与合约交互和查询。这些成员在这里描述：
- en: '**Balance**: The `balance` member returns the balance of the address in Wei.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**余额**：`balance` 成员返回地址的 Wei 余额。'
- en: '**Send**: This member is used to send an amount of ether to an address (Ethereum''s
    160-bit address) and returns `true` or `false` depending on the result of the
    transaction, for example, the following:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送**：此成员用于向地址（以太坊的 160 位地址）发送一定数量的以太，并根据交易结果返回`true`或`false`，例如：'
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Call functions**: The `call`, `callcode`, and `delegatecall` calls are provided
    in order to interact with functions that do not have ABI. These functions should
    be used with caution as they are not safe to use due to the impact on type safety
    and security of the contracts.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用函数**：`call`、`callcode` 和 `delegatecall` 用于与没有 ABI 的函数交互。由于对合约的类型安全性和安全性的影响，应谨慎使用这些函数。'
- en: '**Array value types (ﬁxed size and dynamically sized byte arrays)**: Solidity
    has fixed size and dynamically sized byte arrays. Fixed size keywords range from
    `bytes1` to `bytes32`, whereas dynamically sized keywords include `bytes` and
    `string`. The `bytes` keyword is used for raw byte data and `string` is used for
    strings encoded in UTF-8\. As these arrays are returned by the value, calling
    them will incur gas cost. `length` is a member of array value types and returns
    the length of the byte array.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组值类型（固定大小和动态大小的字节数组）**：Solidity 具有固定大小和动态大小的字节数组。固定大小关键字从 `bytes1` 到 `bytes32`，而动态大小关键字包括
    `bytes` 和 `string`。`bytes` 关键字用于原始字节数据，`string` 用于以 UTF-8 编码的字符串。由于这些数组是按值返回的，调用它们将产生
    gas 成本。`length` 是数组值类型的一个成员，并返回字节数组的长度。'
- en: 'An example of a static (fixed size) array is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态（固定大小）数组的示例如下：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An example of a dynamically sized array is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 动态大小数组的示例如下：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Get length of trades by using the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码获取交易长度：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Literals
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量
- en: These used to represent a fixed value. There are different types of literals
    that are described in the following subsections.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于表示固定值。下面的小节描述了不同类型的字面量。
- en: Integer literals
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数字面量
- en: 'Integer literals are a sequence of decimal numbers in the range of 0-9\. An
    example is shown as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量是一系列范围在 0-9 的十进制数字。示例如下：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: String literals
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'String literals specify a set of characters written with double or single quotes.
    An example is shown as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量指定用双引号或单引号编写的一组字符。示例如下：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hexadecimal literals
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十六进制字面量
- en: 'Hexadecimal literals are prefixed with the keyword `hex` and specified within
    double or single quotation marks. An example is shown as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字面量以关键字 `hex` 为前缀，并在双引号或单引号内指定。示例如下：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Enums
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'This allows the creation of user-defined types. An example is shown as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许创建用户定义的类型。示例如下：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Explicit conversion to and from all integer types is allowed with enums.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型允许对所有整数类型进行显式转换。
- en: Function types
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'There are two function types: internal and external functions.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种函数类型：内部函数和外部函数。
- en: Internal functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部函数
- en: These can be used only within the context of the current contract.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只能在当前合约的上下文中使用。
- en: External functions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部函数
- en: External functions can be called via external function calls.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数可以通过外部函数调用来调用。
- en: A **function** in solidity can be marked as a constant. Constant functions cannot
    change anything in the contract; they only return values when they are invoked
    and do not cost any gas. This is the practical implementation of the concept of
    *call.*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中，**函数** 可以标记为常量。常量函数不能更改合约中的任何内容；只有在调用时返回值，而且不消耗任何 gas。这是对 *call*
    概念的实际实现。
- en: 'The syntax to declare a function is shown as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数的语法如下所示：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Reference types
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: As the name suggests, these types are passed by reference and are discussed
    in the following section. These are also called **complex types**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这些类型是按引用传递的，并在以下部分讨论。这些也被称为**复杂类型**。
- en: Arrays
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays represent a contiguous set of elements of the same size and type laid
    out at a memory location. The concept is the same as any other programming language.
    Arrays have two members named `length` and `push`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数组表示内存位置处以相同大小和类型排列的一系列连续元素。该概念与任何其他编程语言相同。数组有两个成员名为`length`和`push`：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Structs
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'These constructs can be used to group a set of dissimilar data types under
    a logical group. These can be used to define new types, as shown in the following
    example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构可用于将一组不同类型的数据分组到一个逻辑组中。这些可以用于定义新类型，如下例所示：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Data location
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据位置
- en: Data location specifies where a particular complex data type will be stored.
    Depending on the default or annotation specified, the location can be storage
    or memory. This is applicable to arrays and structs and can be specified using
    the `storage` or `memory` keywords.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数据位置指定特定复杂数据类型将存储在何处。根据默认值或指定的注释，位置可以是存储或内存。这适用于数组和结构体，并可以使用`storage`或`memory`关键字指定。
- en: As copying between memory and storage can be quite expensive, specifying a location
    can be helpful to control the gas expenditure at times. **Calldata** is another
    memory location that is used to store function arguments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在内存和存储之间进行复制可能相当昂贵，因此有时指定位置可以帮助控制燃气消耗。**调用数据**是另一个内存位置，用于存储函数参数。
- en: Parameters of external functions use **calldata** memory. By default, parameters
    of functions are stored in **memory**, whereas all other local variables make
    use of **storage**. State variables, on the other hand, are required to use storage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数的参数使用**调用数据**内存。默认情况下，函数的参数存储在**内存**中，而所有其他局部变量都使用**存储**。另一方面，状态变量需要使用存储。
- en: Mappings
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Mappings are used for a key to value mapping. This is a way to associate a
    value with a key. All values in this map are already initialized with all zeroes,
    for example, the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 映射用于键值映射。这是一种将值与键关联的方法。此映射中的所有值都已初始化为零，例如以下内容：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This example shows that offers is declared as a mapping. Another example makes
    this clearer:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示 offers 被声明为映射。另一个示例使此更清晰：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is basically a dictionary or a hash table where string values are mapped
    to integer values. The mapping named `bids` has string `packt` mapped to value
    `10`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个字典或哈希表，其中字符串值映射到整数值。名为`bids`的映射将字符串`packt`映射到值`10`。
- en: Global variables
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: Solidity provides a number of global variables that are always available in
    the global namespace. These variables provide information about blocks and transactions.
    Additionally, cryptographic functions and address-related variables are available
    as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 提供了一些始终可用于全局命名空间的全局变量。这些变量提供有关块和交易的信息。此外，加密函数和与地址相关的变量也可用。
- en: 'A subset of available functions and variables is shown as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的可用函数和变量子集如下所示：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function is used to compute the Keccak-256 hash of the argument provided
    to the function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于计算提供给函数的参数的 Keccak-256 哈希值：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function returns the associated address of the public key from the elliptic
    curve signature:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回椭圆曲线签名的公钥关联地址：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This returns the current block number.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回当前块编号。
- en: Control structures
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Control structures available in solidity language are `if...else`, `do`, `while`,
    `for`, `break`, `continue`, and `return`. They work exactly the same as other
    languages such as C-language or JavaScript.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 语言中可用的控制结构是`if...else`、`do`、`while`、`for`、`break`、`continue`和`return`。它们的工作方式与其他语言（如
    C 语言或 JavaScript）完全相同。
- en: 'Some examples are shown here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例显示在这里：
- en: '**if**: If `x` is equal to `0` then assign value `0` to `y` else assign `1`
    to `z`:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if**：如果`x`等于`0`，则将值`0`赋给`y`，否则将`1`赋给`z`：'
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**do**: Increment `x` while `z` is greater than `1`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**do**：在`z`大于`1`时递增`x`：'
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**while**: Increment `z` while `x` is greater than `0`:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while**：在`x`大于`0`时递增`z`：'
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**for, break, and continue**: Perform some work until `x` is less than or equal
    to `10`. This `for` loop will run `10` times, if `z` is `5` then break the `for`
    loop:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for、break 和 continue**：执行一些工作，直到`x`小于或等于`10`。如果`z`是`5`，那么这个`for`循环将运行`10`次，然后中断：'
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It will continue the work similarly, but when the condition is met, the loop
    will start again.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续类似的工作，但在条件满足时，循环将重新开始。
- en: '**return**: Return is used to stop the execution of a function and returns
    an optional value. For example:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**return**：Return 用于停止函数的执行并返回一个可选值。例如：'
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It will stop the execution and return value of `0`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它将停止执行并返回值`0`。
- en: Events
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Events in Solidity can be used to log certain events in EVM logs. These are
    quite useful when external interfaces are required to be notified of any change
    or event in the contract. These logs are stored on the blockchain in transaction
    logs. Logs cannot be accessed from the contracts but are used as a mechanism to
    notify change of state or the occurrence of an event (meeting a condition) in
    the contract.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的事件可用于记录EVM日志中的某些事件。当需要通知外部接口发生变化或事件发生时，这些事件非常有用。这些日志存储在区块链中的交易日志中。合约无法访问日志，但它们用作通知合约状态变化或事件发生（满足条件）的机制。
- en: 'In a simple example here, the `valueEvent` event will return `true` if the
    `x` parameter passed to function `Matcher` is equal to or greater than `10`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个简单示例中，`valueEvent`事件将在函数`Matcher`传递的`x`参数等于或大于`10`时返回`true`：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inheritance
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is supported in Solidity. The `is` keyword is used to derive a
    contract from another contract. In the following example, `valueChecker2` is derived
    from the `valueChecker` contract. The derived contract has access to all non-private
    members of the parent contract:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity支持继承。`is`关键字用于从另一个合约派生合约。在下面的示例中，`valueChecker2`是从`valueChecker`合约派生出来的。派生合约具有对父合约的所有非私有成员的访问权限：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, if the `uint8 price = 20` is changed to `uint8 private
    price = 20`, then it will not be accessible by the `valueChecker2` contract. This
    is because now the member is declared as private, it is not allowed to be accessed
    by any other contract. The error message that you will see in Remix is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果将 `uint8 price = 20` 更改为 `uint8 private price = 20`，那么`valueChecker2`合约将无法访问它。这是因为现在该成员被声明为私有，不允许任何其他合约访问。在Remix中您将看到的错误信息为
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Libraries
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'Libraries are deployed only once at a specific address and their code is called
    via `CALLCODE` or `DELEGATECALL` opcode of the EVM. The key idea behind libraries
    is code reusability. They are similar to contracts and act as base contracts to
    the calling contracts. A library can be declared as shown in the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 库只在特定地址部署一次，它们的代码通过 EVM 的 `CALLCODE` 或 `DELEGATECALL` 操作码调用。库背后的关键思想是代码的重复使用性。它们类似于合约，并作为调用合约的基础合约。一个库可以声明如下：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This library can then be called in the contract, as shown here. First, it needs
    to be imported and then it can be used anywhere in the code. A simple example
    is shown as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以在合约中调用此库，如下所示。首先需要导入它，然后可以在代码的任何地方使用它。一个简单的示例如下所示：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a few limitations with libraries; for example, they cannot have state
    variables and cannot inherit or be inherited. Moreover, they cannot receive Ether
    either; this is in contrast to contracts that can receive Ether.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 库存在一些限制；例如，它们不能拥有状态变量，也不能继承或被继承。此外，它们也不能接收以太币；这与合约相反，合约可以接收以太币。
- en: Functions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions in Solidity are modules of code that are associated with a contract.
    Functions are declared with a name, optional parameters, access modifier, optional
    `constant` keyword, and optional return type. This is shown in the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的函数是与合约关联的代码模块。函数声明包括名称、可选参数、访问修饰符、可选`constant`关键字和可选返回类型。如下例所示：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, `function` is the keyword used to declare the function.
    `orderMatcher` is the function name, `uint x` is an optional parameter, `private`
    is the **access modifier** or **specifier** that controls access to the function
    from external contracts, `constant` is an optional keyword used to specify that
    this function does not change anything in the contract but is used only to retrieve
    values from the contract and `returns (bool return value)` is the optional return
    type of the function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`function`是声明函数所使用的关键字。`orderMatcher`是函数名，`uint x`是一个可选参数，`private`是控制外部合约访问该函数的**访问修饰符**或**说明符**，`constant`是一个可选关键字，用于指定该函数不会改变合约中的任何内容，而仅用于从合约中检索值，`returns
    (bool return value)`是函数的可选返回类型。
- en: '**How to define a function**: The syntax of defining a function is shown as
    follows:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何定义函数**：定义函数的语法如下所示：'
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Function signature**: Functions in Solidity are identified by its signature,
    which is the first four bytes of the Keccak-256 hash of its full signature string.
    This is also visible in Remix IDE, as shown in the following screenshot. `f9d55e21` is
    the first four bytes of 32-byte Keccak-256 hash of the function named `Matcher`.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数签名**：Solidity 中的函数由其签名标识，即其完整签名字符串的 Keccak-256 哈希的前四个字节。这也可以在 Remix IDE
    中看到，如下面的屏幕截图所示。`f9d55e21` 是名为 `Matcher` 的函数的 32 字节 Keccak-256 哈希的前四个字节。'
- en: '![](img/e48d5da8-756e-473a-a94c-ac2065bba59b.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e48d5da8-756e-473a-a94c-ac2065bba59b.png)'
- en: Function hash as shown in Remix IDE
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix IDE 中显示的函数哈希
- en: In this example function, `Matcher` has the signature hash of `d99c89cb`. This
    information is useful in order to build interfaces.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例函数中，`Matcher` 的签名哈希为 `d99c89cb`。这些信息对于构建接口是有用的。
- en: '**Input parameters of a function**: Input parameters of a function are declared
    in the form of `<data type> <parameter name>`. This example clarifies the concept
    where `uint x` and `uint y` are input parameters of the `checkValues` function:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的输入参数**：函数的输入参数以 `<数据类型> <参数名>` 的形式声明。这个例子阐明了 `checkValues` 函数的输入参数 `uint
    x` 和 `uint y` 的概念：'
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Output parameters of a function**: Output parameters of a function are declared
    in the form of `<data type> <parameter name>`. This example shows a simple function
    returning a `uint` value:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的输出参数**：函数的输出参数以 `<数据类型> <参数名>` 的形式声明。这个例子显示了一个简单的返回 `uint` 值的函数：'
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A function can return multiple values. In the preceding example function, `getValue`
    only returns one value, but a function can return up to 14 values of different
    data types. The names of the unused return parameters can be omitted optionally.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以返回多个值。在前面的示例函数中，`getValue` 只返回一个值，但一个函数最多可以返回 14 个不同数据类型的值。未使用的返回参数的名称可以选择性地省略。
- en: '**Internal function calls**: Functions within the context of the current contract
    can be called internally in a direct manner. These calls are made to call the
    functions that exist within the same contract. These calls result in simple `JUMP`
    calls at the EVM bytecode level.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部函数调用**：在当前合约的上下文中，可以直接调用当前合约中的函数。这些调用导致 EVM 字节码级别的简单 `JUMP` 调用。'
- en: '**External function calls**: External function calls are made via message calls
    from a contract to another contract. In this case, all function parameters are
    copied to the memory. If a call to an internal function is made using the `this`
    keyword, it is also considered an external call. The `this` variable is a pointer
    that refers to the current contract. It is explicitly convertible to an address
    and all members for a contract are inherited from the address.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部函数调用**：外部函数调用是通过合约从一个合约向另一个合约发送消息调用的。在这种情况下，所有函数参数都会被复制到内存中。如果使用 `this`
    关键字调用内部函数，它也被视为外部调用。`this` 变量是一个指针，指向当前合约。它可以显式转换为地址，并且所有合约的成员都是从地址继承的。'
- en: '**Fallback functions**: This is an unnamed function in a contract with no arguments
    and return data. This function executes every time Ether is received. It is required
    to be implemented within a contract if the contract is intended to receive Ether;
    otherwise, an exception will be thrown and Ether will be returned. This function
    also executes if no other function signatures match in the contract. If the contract
    is expected to receive Ether, then the fallback function should be declared with
    the payable **modifier**. The payable is required; otherwise, this function will
    not be able to receive any Ether. This function can be called using the `address.call()`
    method as, for example, in the following:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退函数**：这是一个没有参数和返回数据的合约中的未命名函数。每当接收到以太时，此函数都会执行。如果合约打算接收以太，则必须在合约内实现此函数；否则，将抛出异常并返回以太。如果合约中没有其他函数签名匹配，此函数也会执行。如果合约预期接收以太，则回退函数应该用可支付的
    **修饰符** 声明。这个修饰符是必需的；否则，此函数将无法接收任何以太。此函数可以使用 `address.call()` 方法调用，例如：'
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, if the fallback function is called according to the conditions
    described earlier; it will call `throw`, which will roll back the state to what
    it was before making the call. It can also be some other construct than `throw`;
    for example, it can log an event that can be used as an alert to feed back the
    outcome of the call to the calling application.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果根据前述条件调用了回退函数，则会调用 `throw`，这将使状态回滚到调用前的状态。它也可以是除 `throw` 之外的其他构造，例如，它可以记录一个事件，该事件可以作为反馈调用结果给调用应用程序的警报。
- en: '**Modifier functions**: These functions are used to change the behavior of
    a function and can be called before other functions. Usually, they are used to
    check some conditions or verification before executing the function. `_` (underscore)
    is used in the modifier functions that will be replaced with the actual body of
    the function when the modifier is called. Basically, it symbolizes the function
    that needs to be *guarded*. This concept is similar to guard functions in other
    languages.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改器函数**：这些函数用于改变函数的行为，并且可以在其他函数之前调用。通常，它们用于在执行函数之前检查某些条件或验证。在修改器函数中使用 `_`（下划线），当调用修改器时将其替换为实际函数体。基本上，它象征着需要被*守护*的函数。这个概念类似于其他语言中的守护函数。'
- en: '**Constructor function**: This is an optional function that has the same name
    as the contract and is executed once a contract is created. Constructor functions
    cannot be called later on by users, and there is only one constructor allowed
    in a contract. This implies that no overloading functionality is available.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：这是一个可选函数，其名称与合约相同，并且在创建合约时执行。构造函数不能由用户后来调用，一个合约中只允许一个构造函数。这意味着没有重载功能可用。'
- en: '**Function visibility specifiers (access modifiers)**: Functions can be defined
    with four access specifiers as follows:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数可见性修饰符（访问修饰符）**：函数可以用四个访问修饰符来定义，如下所示：'
- en: '**External**: These functions are accessible from other contracts and transactions.
    They cannot be called internally unless the `this` keyword is used.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：这些函数可以从其他合约和交易中访问。除非使用 `this` 关键字，否则不能在内部调用它们。'
- en: '**Public**: By default, functions are public. They can be called either internally
    or using messages.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：默认情况下，函数是公共的。它们可以在内部调用，也可以通过消息调用。'
- en: '**Internal**: Internal functions are visible to other derived contracts from
    the parent contract.'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：内部函数对来自父合约的其他派生合约可见。'
- en: '**Private**: Private functions are only visible to the same contract they are
    declared in.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：私有函数只对声明它们的同一合约可见。'
- en: '**Function Modifiers:**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数修改器**：'
- en: '**pure**: This modifier prohibits access or modification to state'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯净**：此修饰符禁止对状态进行访问或修改'
- en: '**view**: This modifier disables any modification to state'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：此修饰符禁止对状态进行任何修改'
- en: '**payable**: This modifier allows payment of ether with a call'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可支付的**：此修饰符允许通过调用支付以太币'
- en: '**constant**: This modifier disallows access or modification to state'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：此修饰符不允许对状态进行访问或修改'
- en: '**Other important keywords/functions throw**: `throw` is used to stop execution.
    As a result, all state changes are reverted. In this case, no gas is returned
    to the transaction originator because all the remaining gas is consumed.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他重要关键字/函数 throw**：`throw` 用于停止执行。因此，所有状态更改都将被还原。在这种情况下，没有气体返回给交易发起者，因为所有剩余的气体都被消耗掉了。'
- en: Layout of a Solidity source code ﬁle
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 源代码文件的布局
- en: In the following subsections we will look at the components of a Solidity source
    code file.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将看看 Solidity 源代码文件的组成部分。
- en: Version pragma
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本声明
- en: 'In order to address compatibility issues that may arise from future versions
    of the solc version, `pragma` can be used to specify the version of the compatible
    compiler as, for example, in the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决未来版本的 solc 版本可能出现的兼容性问题，`pragma` 可以用来指定兼容编译器的版本，例如：
- en: '[PRE51]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will ensure that the source file does not compile with versions smaller
    than 0.5.0 and versions starting from 0.6.0.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保源文件不会与小于 0.5.0 的版本以及从 0.6.0 开始的版本编译。
- en: Import
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'Import in Solidity allows the importing of symbols from the existing Solidity
    files into the current global scope. This is similar to `import` statements available
    in JavaScript, as for example, in the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中，`import` 允许将现有 Solidity 文件中的符号导入到当前的全局范围。这类似于 JavaScript 中可用的 `import`
    语句，例如：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Comments
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Comments can be added in the Solidity source code file in a manner similar to
    C-language. Multiple line comments are enclosed in `/*` and `*/`, whereas single
    line comments start with `//`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以以类似于 C 语言的方式添加在 Solidity 源代码文件中。多行注释用 `/*` 和 `*/` 括起来，而单行注释以 `//` 开头。
- en: 'An example Solidity program is as follows, showing the use of `pragma`, `import`,
    and comments:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Solidity 程序示例，展示了`pragma`、`import`和注释的用法：
- en: '![](img/b80ab420-b712-4008-9cf9-7d0263d1de7b.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b80ab420-b712-4008-9cf9-7d0263d1de7b.png)'
- en: Sample Solidity program as shown in Remix IDE
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix IDE 中显示的 Solidity 程序示例
- en: This completes a brief introduction to the Solidity language. The language is
    very rich and under constant improvement. Detailed documentation and coding guidelines
    are available online at [http://solidity.readthedocs.io/en/latest/](http://solidity.readthedocs.io/en/latest/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对 Solidity 语言的简要介绍。该语言非常丰富并在不断改进中。详细文档和编码指南可在网上查看：[http://solidity.readthedocs.io/en/latest/](http://solidity.readthedocs.io/en/latest/)。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started with the introduction of development tools for Ethereum
    such as Remix IDE. Then we discussed some frameworks such as Truffle along with
    local blockchain solutions for development and testing such as Ganache, EthereumJS
    and TestRPC. Other tools such as MetaMask were also explored. Installation of
    Node was also introduced, as most of the tools are JavaScript and Node based.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从介绍以太坊的开发工具开始，如 Remix IDE。然后我们讨论了一些框架，比如 Truffle，还有用于开发和测试的本地区块链解决方案，例如 Ganache、EthereumJS
    和 TestRPC。还探讨了其他工具，比如 MetaMask。引入了 Node 的安装，因为大多数工具都是基于 JavaScript 和 Node 的。
