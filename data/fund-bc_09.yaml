- en: Blockchain Optimizations and Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链优化和增强
- en: Scalability is a crucial factor that is being talked about even before an application
    has been created. Yet, even after the application is deployed, the application
    will be required to be updated frequently to scale based on the application load.
    While scalability has been one of the concerns even in the blockchain space, it
    wasn't the first priority when the technology was first proposed. However, over
    time and due to the increased interest in the technology, people are now working
    toward the improvement of every aspect of blockchain technology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性是一个在创建应用程序之前甚至被谈论的关键因素。然而，即使应用程序部署后，应用程序也需要根据应用程序负载频繁更新以实现扩展。虽然可伸缩性一直是区块链领域的关注点之一，但在技术首次提出时并不是第一优先级。然而，随着时间的推移，由于对技术的增加兴趣，人们现在正在努力改进区块链技术的每个方面。
- en: In this chapter, we will explore various optimizations that can be implemented
    to help you achieve better performance or plan for scalability. We will also cover
    a few of the enhancements on the existing blockchain applications to add interesting
    functionalities. Most of the optimizations and enhancements discussed in this
    chapter are either already implemented in some blockchain projects, or are in
    the initial phase of implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可以实施的各种优化，以帮助您实现更好的性能或规划可扩展性。我们还将涵盖一些对现有区块链应用程序进行增强的功能。本章中讨论的大多数优化和增强已经在一些区块链项目中实施，或者正处于实施的初期阶段。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'Blockchain optimizations:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链优化：
- en: Transaction exchange
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易交换
- en: Off-chain transactions
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线交易
- en: Block size improvements
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块大小改进
- en: 'Blockchain enhancements:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链增强：
- en: Sharding
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片
- en: Consensus algorithms – PoS, PoA, BFT, and PoET
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识算法- PoS、PoA、BFT和PoET
- en: Cross-chain network
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨链网络
- en: Privacy enhancement
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私增强
- en: Since the original implementation of Bitcoin in 2009, it has improved tremendously
    in order to withstand any attacks in the trustless public network. Bitcoin undergoes
    improvements through a standard procedure by proposing the features through a
    design document called **Bitcoin Improvement Proposals** (**BIP**), which was
    first proposed in 2011 within the Bitcoin community. Bitcoin has nearly 200 improvement
    proposals ([https://github.com/bitcoin/bips](https://github.com/bitcoin/bips)),
    and these proposals are responsible for its resilience in the network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自2009年比特币的原始实施以来，它已经通过提出特性的标准程序进行了巨大改进，这些特性通过名为**比特币改进提案**（**BIP**）的设计文档提出，这是在比特币社区中于2011年首次提出的。比特币有近200个改进提案（[https://github.com/bitcoin/bips](https://github.com/bitcoin/bips)），这些提案是其在网络中的韧性的原因。
- en: We have come across several blockchain-based projects that evolved from Bitcoin's
    concepts. Many other projects had to undergo huge implementation changes to shape
    the application for their requirements. Most of the projects improved and enhanced
    the existing implementation to address some of the challenges, such as scalability,
    security, and adaptability. The enterprises are keen on taking advantage of this
    technology to decentralize their existing architecture. They have been creating
    Proof of Concept to overcome all the existing challenges before adopting the technology.
    In this chapter, we'll be looking into some of the proposed optimizations and
    enhancements in the technology that will eradicate the challenges faced by the
    technology.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个基于比特币概念发展而来的基于区块链的项目。许多其他项目必须经历巨大的实施变化，以满足其要求。大多数项目改进和增强了现有的实施，以解决一些挑战，如可伸缩性、安全性和适应性。企业都热衷于利用这项技术来去中心化其现有架构。他们一直在创建概念验证来克服采用该技术之前所面临的所有现有挑战。在本章中，我们将研究技术中一些提出的优化和增强，这将消除技术所面临的挑战。
- en: Blockchain optimizations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链优化
- en: Due to the decentralized nature of the blockchain applications, it is difficult
    to make huge changes to the blockchain protocols of the functioning applications.
    The existing protocols need to be optimized carefully to achieve improvements.
    In this upcoming section, we will discuss a few of the possible optimizations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链应用程序的去中心化性质，对运行中的应用程序的区块链协议进行重大变更是困难的。现有协议需要经过精心优化才能实现改进。在接下来的部分中，我们将讨论一些可能的优化方式。
- en: Transaction exchange
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易交换
- en: Communicating and exchanging data is the essence of a decentralized P2P network.
    In a blockchain network, transactions are the main data that is exchanged between
    nodes. Optimizing the exchange of transactions could be achieved by making use
    of protocols that are suitable for transaction data. A few optimization techniques
    are described in the following sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通信和数据交换是去中心化P2P网络的本质。在区块链网络中，交易是节点之间交换的主要数据。通过利用适合交易数据的协议，可以优化交易的交换。一些优化技术在以下部分有描述。
- en: Blockchain relay networks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链中继网络
- en: Although the nodes in the blockchain network are equal, the nodes could opt
    to perform a variety of roles. A few nodes might function as fullnodes, maintaining
    the entire blockchain, whereas a few others function as lightweight nodes by maintaining
    only the required transactions. In addition to this, the nodes that are willing
    to create new blocks will perform mining operations. When all these nodes communicate
    with each other in a P2P fashion, there will be a network latency involved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然区块链网络中的节点是平等的，但节点可以选择执行各种角色。一些节点可能作为全节点，维护整个区块链，而另一些节点可能作为轻量级节点，只维护所需的交易。此外，愿意创建新区块的节点将执行挖矿操作。当所有这些节点以P2P方式相互通信时，将涉及网络延迟。
- en: The mining nodes need to keep latency to a minimum since they are involved in
    time-sensitive operations. Even during a critical financial transaction, a decentralized
    system needs to keep latency as minimal as possible so that clients and merchants
    can receive notifications quickly. The Bitcoin network uses a relay network to
    minimize the latency during block exchange between peers, especially with mining
    nodes that are competing to construct the next block.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 挖矿节点需要尽量将延迟降到最低，因为它们涉及时间敏感的操作。即使在关键的金融交易过程中，去中心化系统也需要尽量保持延迟最小化，以便客户和商家能够快速收到通知。比特币网络使用中继网络来在节点之间交换区块时尽量减少延迟，尤其是在竞争构建下一个区块的挖矿节点之间。
- en: Relay nodes don't fully verify data before relaying the block/transaction to
    the network. Although the relay nodes are quick at relaying most of the transactions,
    they may not be accurate in delivering every transaction of the system. A Bitcoin
    Core developer called Matt Corallo created a UDP-based relay network called **Fast
    Internet Bitcoin Relay Engine** (**FIBRE**). It uses a compression technique provided
    by the compact block, which was developed by Bitcoin Core. Since the FIBRE code
    base is an extension to the Bitcoin Core, FIBRE nodes could be set up just like
    the Bitcoin core nodes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 中继节点在将区块/交易传递到网络之前并不完全验证数据。虽然中继节点很快地中继了大部分交易，但它们可能无法准确地交付系统中的每一笔交易。比特币核心开发者Matt
    Corallo创建了一个基于UDP的中继网络，名为**快速互联网比特币中继引擎**（**FIBRE**）。它使用由比特币核心开发的紧凑区块提供的压缩技术。由于FIBRE代码库是比特币核心的一个扩展，FIBRE节点可以像比特币核心节点一样设置。
- en: More information about the protocol and node setup can be found at [http://bitcoinfibre.org](http://bitcoinfibre.org).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于协议和节点设置的更多信息可以在[http://bitcoinfibre.org](http://bitcoinfibre.org)找到。
- en: Another relay network, called **Falcon**, uses application-level cut-through
    routing for faster block propagation. The optimized topology claims it is faster
    than compression-based relay networks. These relay networks not only guarantee
    that network nodes will achieve higher throughput but also promise future scalability
    for the decentralized P2P network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为**Falcon**的中继网络使用应用级切换路由来实现更快的区块传播。优化后的拓扑结构声称它比基于压缩的中继网络更快。这些中继网络不仅保证网络节点将实现更高的吞吐量，还承诺为去中心化P2P网络的未来扩展性提供支持。
- en: More details about the Falcon relay nodes can be found at [https://www.falcon-net.org](https://www.falcon-net.org).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Falcon中继节点的更多详细信息可以在[https://www.falcon-net.org](https://www.falcon-net.org)找到。
- en: Invertible bloom lookup tables
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可逆布隆查找表
- en: Invertible bloom lookup tables can be used to efficiently find the difference
    between the two datasets. This concept has been implemented in Bitcoin to achieve
    lower transaction exchange latency between peers. Without any mechanism to find
    the difference between two sets, each Bitcoin node had to keep transferring its
    own transaction set to the network and expect other nodes to reply with transactions
    that did not exist in the transaction set. This mechanism consumed a lot of Bitcoin
    network bandwidth and time due to the large set of transactions in each node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可逆布隆查找表可用于有效地找到两个数据集之间的差异。这个概念已经在比特币中实现，以实现节点之间较低的事务交换延迟。如果没有找到两个集合之间的差异的任何机制，每个比特币节点都必须不断地将自己的交易集转移到网络上，并期望其他节点用不存在于交易集中的交易来回复。由于每个节点中存在大量的交易，这种机制消耗了大量的比特币网络带宽和时间。
- en: A solution is to transfer information that could be used to find the difference
    between datasets efficiently. Invertible bloom lookup tables solve this by creating
    smaller lookup tables that can find the transactional differences between the
    two sets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是传输可用于有效找到数据集之间差异的信息。可逆布隆查找表通过创建可以找到两个集合之间的交易差异的较小查找表来解决这个问题。
- en: Invertible bloom lookup tables are a variant of bloom filters. They provide
    a successful lookup of the key-value pairs with high probability. Unlike the bloom
    filters, they not only allow you to look up a particular key but also list the
    inserted key/value pairs. Lookup tables are a probabilistic data structure, and
    the probability of successful lookup increases with the size of the lookup table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可逆布隆查找表是布隆过滤器的一种变体。它们以高概率提供键-值对的成功查找。与布隆过滤器不同，它们不仅允许您查找特定键，而且可以列出插入的键/值对。查找表是一种概率性数据结构，成功查找的概率随查找表的大小而增加。
- en: A bloom filter is a probabilistic data structure that is used to check the existence
    of an element in a set. Although non-existence of the element is never predicted
    incorrectly (false negative), existence can be falsely predicted sometimes (false
    positive). Bloom filters are used in Bitcoin's special kind of node, called a
    lightweight or **Simple Payment Verification** (**SPV**) node that is used to
    verify the existence of a particular transaction in a block without downloading
    the entire block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器是一种用于检查集合中元素存在性的概率性数据结构。虽然元素不存在永远不会被错误地预测（假阴性），但有时可能会错误地预测存在性（假阳性）。布隆过滤器被用于比特币的一种特殊节点，称为轻量级或**简单支付验证**（**SPV**）节点，该节点用于在不下载整个块的情况下验证块中特定交易的存在性。
- en: Each node on the network will broadcast a lookup table for the transaction pool,
    which will be recognized by the other nodes in the network. The nodes in the network
    will only exchange the required transactions and thus reduce redundant communication.
    Transactions in the pool can be synchronized quickly and securely with the help
    of these lookup tables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的每个节点将广播一个用于交易池的查找表，该表将被网络中的其他节点识别。网络中的节点将仅交换所需的交易，从而减少冗余通信。借助这些查找表，可以快速且安全地同步池中的交易。
- en: Off-chain transactions
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链下交易
- en: A set of transactions that can be performed outside the blockchain is referred
    to as off-chain transactions. Off-chain transactions rely on several methods of
    validation that are different from the one used in the main blockchain. Although
    the main motive of the off-chain transaction is to achieve increased transaction
    speed, it also should provide basic security by making sure that the transactions
    cannot be reversed by any participant.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可在区块链之外执行的一组交易称为链下交易。链下交易依赖于与主要区块链中使用的验证方法不同的几种验证方法。尽管链下交易的主要动机是实现增加的交易速度，但它也应通过确保交易不能被任何参与者撤销来提供基本安全性。
- en: '**Off-chain state channels** and **sidechains** are the popular off-chain solutions.
    We will have a look at both of these off-chain transaction solutions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**链下状态通道**和**侧链**是流行的链下解决方案。我们将研究这两种链下交易解决方案。'
- en: Off-chain state channels
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链下状态通道
- en: A state channel is a two-way communication between the members of a system that
    enables the members to perform a series of transactions without committing them
    to the blockchain. Off-chain transactions tremendously increase the throughput
    by avoiding blockchain confirmation for every transaction.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道是系统成员之间的双向通信，使成员能够执行一系列交易，而不将其提交到区块链。离链交易通过避免每笔交易都进行区块链确认来极大地增加吞吐量。
- en: Off-chain channels are ideal for micro-transactions where two parties communicate
    their transactions by setting up a payment channel that is independent of the
    blockchain state. The state channel can be closed once the transactions between
    the parties are concluded. The final state of the channel is then sent to the
    blockchain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 离链通道非常适合微支付，双方通过建立一个独立于区块链状态的支付通道来通信他们的交易。一旦双方的交易结束，状态通道可以关闭。通道的最终状态然后发送到区块链。
- en: '*Figure 9.1* shows a payment channel that is created between Alice and Bob.
    Alice and Bob will then perform a series of transactions whose state is written
    to the blockchain only after the state channel is closed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1*显示了一个在Alice和Bob之间创建的支付通道。然后，Alice和Bob将执行一系列交易，其状态仅在状态通道关闭后写入区块链：'
- en: '![](img/92ffb869-33ac-41fa-8c15-a044ab975514.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92ffb869-33ac-41fa-8c15-a044ab975514.png)'
- en: 'Figure 9.1: State channel transactions between two users'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：两个用户之间的状态通道交易
- en: The Lightning Network
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪电网络
- en: The Lightning Network is a second-layer payment protocol that operates on top
    of the Bitcoin blockchain. At the time of writing, the implementation of this
    protocol is running in beta mode on Bitcoin's mainnet. It is a routed bidirectional
    network that was proposed to solve the Bitcoin transaction scalability problem.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 闪电网络是一个第二层支付协议，运行在比特币区块链之上。在撰写本文时，该协议的实现正在比特币的主网上以测试模式运行。这是一个双向路由网络，旨在解决比特币交易可扩展性问题。
- en: '**Design**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**'
- en: The Lightning Network creates a routed payment channel network where communication
    between the nodes is bidirectional. The design has been implemented by several
    open source communities by following a set of standards.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 闪电网络创建了一个路由的支付通道网络，其中节点之间的通信是双向的。该设计已经由几个开源社区实施，遵循一套标准。
- en: 'A simple design of the Lightning Network involves the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 闪电网络的简单设计包括以下步骤：
- en: Create a payment channel by committing the channel with the initial funds from
    the parties
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用双方的初始资金来承诺通道创建一个支付通道
- en: Perform micropayment transactions and update the created funds of the channel
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行微支付交易并更新通道创建的资金
- en: Close the payment channel and broadcast the final state of the channel's funds
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭支付通道并广播通道资金的最终状态
- en: '**An example of a Lightning Network**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**闪电网络的一个例子**'
- en: Let's consider an example where Alice wants to perform several Bitcoin payment
    transactions with Bob. Alice and Bob decide to open a payment channel using the
    Lightning Network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，Alice想要与Bob执行几个比特币支付交易。Alice和Bob决定使用闪电网络开放一个支付通道。
- en: Alice and Bob both create a channel, initially funding it with 2 bitcoins each.
    The funds can be kept in a multi-signature address account, which will ensure
    that both parties need to agree on the finalized fund distribution. A balance
    sheet will be maintained, which will update the balances of Alice and Bob after
    each transaction. The balance sheet is similar to the concept of keeping tabs
    in a restaurant or bar; instead of paying for each order, a tab is maintained
    that can be used to pay for all the orders together.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob都创建了一个通道，最初各自投入了2比特币的资金。资金可以存放在一个多重签名地址账户中，这将确保双方需要同意最终资金分配。将维护一个资产负债表，该表将在每笔交易后更新Alice和Bob的余额。该资产负债表类似于在餐厅或酒吧中记账的概念；而不是为每个订单付款，而是维护一个可以用来一起支付所有订单的标签。
- en: 'Alice wants to send 0.5 bitcoins to Bob, so she will create a transaction that
    pays 0.5 bitcoins to Bob. Instead of appending this transaction to the blockchain,
    the payment channel will update the balance sheet. Now the channel fund will reflect
    1.5 bitcoins as Alice''s balance and 2.5 bitcoins as Bob''s balance:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Alice想要向Bob发送0.5比特币，所以她将创建一个支付0.5比特币给Bob的交易。而不是将此交易附加到区块链上，支付通道将更新资金余额表。现在通道基金将反映1.5比特币作为Alice的余额和2.5比特币作为Bob的余额：
- en: '![](img/021d71fe-5d3a-4240-88f6-b382d39aed9b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/021d71fe-5d3a-4240-88f6-b382d39aed9b.png)'
- en: 'Figure 9.2: Lightning Network payment channel between Alice and Bob'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Alice和Bob之间的闪电网络支付通道
- en: Alice and Bob can perform any number of transactions without waiting for the
    state of the transaction because the payment channel is independent of the blockchain
    state. The payment channel can be closed when there are no more transactions to
    be performed on the created channel. The final state of the channel is then broadcasted
    to the blockchain network so that it gets included in the blockchain in a single
    transaction. The Lightning Network implementation, which securely performs off-chain
    transactions, increases the total transaction throughput of the blockchain network.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob可以执行任意数量的交易，而无需等待交易状态，因为支付通道独立于区块链状态。当在创建的通道上没有更多的交易需要执行时，可以关闭支付通道。然后，该通道的最终状态将被广播到区块链网络中，以便在单个交易中包含在区块链中。安全执行链下交易的闪电网络实现增加了区块链网络的总交易吞吐量。
- en: Routed payment network
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由支付网络
- en: 'A user in the Lightning Network doesn''t need to set up a direct payment channel
    with every user to perform a transaction. A user can find several connected payment
    channels to connect to the other user in order to set up a routed payment network.
    Consider an example where Alice wants to set up a micro-payment channel with Carol.
    Alice has earlier set up a channel with Bob. She also finds out that Bob has an
    active channel with Carol. So, instead of setting up a new payment channel, Alice
    decides to create a routing payment channel with Carol via Bob, as shown in *Figure
    9.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在闪电网络中，用户不需要与每个用户建立直接支付通道来执行交易。用户可以找到几个连接的支付通道，以连接到其他用户，从而建立路由支付网络。考虑这样一个例子，Alice想要与Carol建立微支付通道。Alice之前已经与Bob建立了一个通道。她还发现Bob与Carol有一个活跃的通道。因此，Alice决定通过Bob创建一个路由支付通道与Carol进行支付，如*图9.3*所示：
- en: '![](img/262fd814-8085-449d-9289-e88552ddfcf2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/262fd814-8085-449d-9289-e88552ddfcf2.png)'
- en: 'Figure 9.3: Routed payment network between Alice and Carol via Bob'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：Alice通过Bob与Carol之间的路由支付网络
- en: Routed payment channels are established between a number of trustless nodes,
    and a node will not have information about the next hop in the route. Any payment
    channel in the network might be invalidated at any time due to faulty behavior.
    To tolerate faults in the network, there has to be an escrow set up for each channel
    in the network. Time-based script extensions (smart contracts) such as **Hash
    Time Lock Contract** (**HTLC**) can be used to set up an escrow in the payment
    channel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 路由支付通道是在许多不信任的节点之间建立的，并且节点将不会知道路由中的下一个跳跃的信息。网络中的任何支付通道都可能因故障行为而随时无效。为了容忍网络中的故障，必须为网络中的每个通道设置一个托管。时间为基础的脚本扩展（智能合约），例如**哈希时间锁合约**（**HTLC**）可用于在支付通道中设置托管。
- en: '**Hash time lock contracts**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希时间锁合约**'
- en: HTLCs are a special type of smart contract that can be created using Bitcoin's
    basic programming language (Script). The participants in the network will commit
    their funds during a transaction with a secret that will be shared once the escrow
    is set up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HTLC是一种特殊类型的智能合约，可以使用比特币的基本编程语言（脚本）创建。网络中的参与者在设置托管后，会在交易中锁定他们的资金并共享一个密钥。
- en: HTLC is similar to the locking script created during transaction creation, where
    a secret key generated with asymmetric cryptography is used to unlock funds. Instead
    of using a permanent secret key, HTLC uses a randomly generated secret that is
    destroyed in each transaction. The receiver of the fund will initially create
    a random secret, *R*, that is hashed using a one-way function such as SHA256\.
    The computed hash, *H*, of the secret can then be shared with all the participants
    involved in the transaction to create HTLC scripts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTLC类似于交易创建期间创建的锁定脚本，其中使用用于解锁资金的使用非对称加密生成的秘密密钥。 HTLC使用的是每次交易中销毁的随机生成的秘密，而不是使用永久性秘密密钥。资金的接收方最初将创建一个随机秘密，*R*，该秘密将使用诸如SHA256之类的单向函数进行散列。计算出的秘密哈希，*H*，然后可以与参与交易的所有参与者共享，以创建HTLC脚本。
- en: Although the fund committed to the HTLC script is redeemable by providing the
    secret, R, it also has a time lock, which requires the secret owner to claim the
    fund within a specified time. The time factor can also be specified in the number
    of blocks. Bitcoin uses the `CheckLockTimeVerify` extension to time-lock a contract.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过提供秘密R可以赎回HTLC脚本中承诺的资金，但它也有一个时间锁定，需要秘密所有者在指定时间内索取资金。时间因素也可以用区块数指定。比特币使用`CheckLockTimeVerify`扩展来对合同进行时间锁定。
- en: The final HTLC script is prepared by combining the hashing and the time-lock
    conditions. Any node in the network that owns the secret could claim the fund
    committed to the HTLC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的HTLC脚本是通过组合哈希和时间锁定条件准备的。网络中拥有秘密的任何节点都可以索赔HTLC中承诺的资金。
- en: '**Routed payment example**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由支付示例**'
- en: Let's consider a scenario by building on our previous example, where Alice wants
    to send 1 bitcoin to Carol instead of Bob. Since there is no active channel between
    Alice and Carol, Alice and Bob create a payment channel via Bob, as discussed
    before. Now, Carol creates a random secret, *S*, for the session. She creates
    a hash of secret *S* and shares it with Alice, but the secret is protected without
    disclosing it to anyone.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑通过构建前面示例的情景，Alice想将1比特币发送给Carol而不是Bob。由于Alice和Carol之间没有活动通道，Alice和Bob通过Bob创建了一个支付通道，如前所述。现在，Carol为会话创建一个随机秘密*S*。她为秘密*S*创建了一个哈希并与Alice分享，但秘密受到保护，没有向任何人透露。
- en: The payment channel between Alice and Bob is funded with 4 bitcoins. Similarly,
    the channel between Bob and Carol is also funded with 4 bitcoins. Bob has a share
    of 2 bitcoins on each of the payment channels. Alice begins the transaction by
    creating an HTLC commitment with a value of 1.1 bitcoins, payable to Bob. The
    additional 0.1 bitcoin is a transaction fee paid to Bob as brokerage. Bob will
    not be able to claim the commitment as he doesn't own the secret. Bob is now instructed
    to create a new transaction on the other channel. He creates an HTLC commitment
    with a value of 1 bitcoin, payable to Carol. As Carol owns the secret key, she
    claims the bitcoin and passes the key to Bob. Now Bob will be able to claim the
    bitcoin in the HTLC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob之间的支付通道以4比特币资助。同样，Bob和Carol之间的通道也以4比特币资助。 Bob在每个支付通道上都有2比特币的份额。 Alice通过创建价值为1.1比特币的HTLC承诺来开始交易，可支付给Bob。额外的0.1比特币是支付给Bob的经纪人作为交易费用。由于他不拥有秘密，Bob将无法索赔承诺。现在，Bob被指示在另一个通道上创建一个新交易。他创建了一个价值为1比特币的HTLC承诺，可支付给Carol。由于Carol拥有秘密密钥，她索取了比特币并将密钥传递给了Bob。现在，Bob将能够索赔HTLC中的比特币。
- en: 'All the actors claim their assets without trusting the other nodes in the payment
    network. The final balance of the payment channel can then be written to the blockchain
    when any of the channels are closed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参与者都可以在不信任支付网络中的其他节点的情况下声称其资产。当任何一个通道关闭时，支付通道的最终余额可以写入区块链：
- en: '![](img/64f667a0-6e33-48db-8b71-17765b8beea3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f667a0-6e33-48db-8b71-17765b8beea3.png)'
- en: 'Figure 9.4: Routed payment network between Alice and Carol via Bob'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：通过Bob在Alice和Carol之间的路由支付网络
- en: Each node will perform route discovery whenever a transaction needs to be created.
    The information for the route discovery is collected from all the nodes in the
    network through the P2P networking model. Once a node has all the information,
    the optimal path is constructed by the sender node. After the route is discovered
    by the sender, each node involved in the discovered path will not be aware of
    all the nodes. Each node will be informed only about the node with whom they have
    set up a payment channel. This is achieved by implementing an onion routing protocol-based
    system to preserve the privacy of the transaction.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点在需要创建交易时都将执行路由发现。路由发现的信息通过P2P网络模型从网络中的所有节点收集。一旦节点收集到所有信息，发送节点将构建最佳路径。在发送方发现路由之后，涉及到的每个节点都不会意识到所有节点。每个节点只会被告知与其建立支付通道的节点。这是通过实施基于洋葱路由协议的系统来保护交易的隐私实现的。
- en: Sidechains
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧链
- en: A sidechain is a blockchain that runs parallel to the main blockchain and is
    attached to the main blockchain (also referred to as the main chain) using two-way
    peg. Similar to the state channels, sidechains are a layer 2 solution to scale
    the existing blockchain network.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链是与主区块链并行运行并通过双向钉住与主区块链（也称为主链）连接的区块链。与状态通道类似，侧链是用于扩展现有区块链网络的第2层解决方案。
- en: Any number of transactions on a set of assets can be performed on the sidechain
    before committing the state to the main chain. Unlike the state channel, the sidechain
    is a permanent chain that functions alongside the main chain. Any time an asset
    needs to be sent to the sidechain, the same asset needs to be locked in the main
    chain by transferring it to a special address. Once the asset has been locked
    in the main chain, the same asset can be released to the sidechain. The sidechain
    can then perform transactions on the asset as long as the asset is locked in the
    main chain. A special group called **federation** serves as an intermediary between
    the main chain and the sidechain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交状态到主链之前，可以在侧链上执行一组资产上的任意数量的交易。与状态通道不同，侧链是与主链并行运行的永久链。每当需要将资产发送到侧链时，同一资产就需要在主链上锁定，方法是将其转移到一个特殊地址。一旦在主链上锁定了资产，就可以将相同的资产释放到侧链。只要资产在主链上被锁定，侧链就可以对该资产执行交易。一个称为**联邦**的特殊群体充当主链和侧链之间的中介。
- en: There are several existing implementations of sidechains. Rootstock has created
    a sidechain that has a two-way peg with the Bitcoin blockchain. Loom ([https://loomx.io/](https://loomx.io/))
    has created a Proof of Stake based sidechain for the Ethereum network. Matic networks
    ([https://matic.network/](https://matic.network/)) is another service that has
    created a Proof of Stake side chain with an adapted version of the Plasma framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前已经有几种现有的侧链实现。Rootstock已经创建了一个与比特币区块链双向锚定的侧链。Loom ([https://loomx.io/](https://loomx.io/))
    已经为以太坊网络创建了一个基于权益证明的侧链。Matic网络 ([https://matic.network/](https://matic.network/))
    是另一个服务，使用Plasma框架的改进版本创建了一个基于权益证明的侧链。
- en: Block size improvements
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块大小改进
- en: A block of transactions is the basic component of any decentralized blockchain-based
    application. Every blockchain-based implementation will define its own structure
    of blocks. The Bitcoin block has a header and body section with a set of fields
    defined. Few of the fields have a fixed limit, and so does the block size. Bitcoin's
    block size is 1 MB, which was introduced in 2010\. This restricts the number of
    transactions that can be included in a block.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的基本组件是一组交易，它是任何去中心化的基于区块链的应用程序的基本组成部分。每个基于区块链的实现都将定义其自己的区块结构。比特币区块由头部和主体部分组成，并具有一组定义的字段。其中一些字段有固定限制，区块大小也是如此。比特币的区块大小为1
    MB，这是在2010年引入的。这限制了可以包含在一个区块中的交易数量。
- en: 'As the amount of activity in the Bitcoin network increased due to its popularity,
    more transactions were created in each block. *Figure 9.5* shows how the average
    number of transactions per block has grown over the years. From last year, most
    Bitcoin blocks reached their threshold for the number of transactions in each
    block. We can conclude from the graph that the average number of transactions
    per block in recent years is around 2,500\. Since Bitcoin has a fixed block interval
    of 10 minutes, the average transaction throughput that Bitcoin could achieve is
    about 4-5 transactions per second, which is significantly less than PayPal or
    Visa transactions, whose transaction throughputs are around 200 and 1,600 transactions
    per second respectively:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着比特币网络中活动量的增加，由于其受欢迎程度，每个区块中创建的交易也越来越多。*图9.5*展示了每个区块平均交易数量随年份增长的情况。从去年开始，大多数比特币区块达到了每个区块中交易数量的阈值。我们可以从图表中得出结论，近年来每个区块的平均交易数量约为2,500。由于比特币的区块间隔固定为10分钟，比特币可以实现的平均交易吞吐量约为每秒4-5笔，远低于PayPal或Visa的交易吞吐量，它们的交易吞吐量分别约为每秒200和1,600笔：
- en: '![](img/e006273c-7531-4340-bf51-262996a815ca.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e006273c-7531-4340-bf51-262996a815ca.png)'
- en: 'Figure 9.5: Average Bitcoin transactions per block (source: www.blockchain.info)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：每个比特币区块的平均交易量（来源：www.blockchain.info）
- en: 'A straightforward solution to increase the throughput of transactions is to
    make full use of the block size. But, according to the graph in *Figure 9.6*,
    Bitcoin blocks have recently been utilizing their entire 1 MB space for transactions.
    Due to the increased number of recently mined blocks, there have been talks and
    proposals regarding an increase in the block size at several occasions. Though
    there was a lot of interests in the community, it failed to gain the majority
    required to implement the updated protocol for blocks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 增加交易吞吐量的直接解决方案是充分利用区块大小。但是，根据*图9.6*中的图表显示，比特币区块最近已经利用其整个1 MB的空间进行交易。由于最近挖出的区块数量增加，有关增加区块大小的讨论和提案也有所增加。尽管社区表现出了很大的兴趣，但未能获得实施更新区块协议所需的大多数支持：
- en: Some blocks in recent years have exceeded the limit of 1 MB, and this is due
    to the protocol upgrade called **Segregated Witness**, which we will discuss in
    a later section, *Proposed solutions*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来有些区块超出了1 MB的限制，这是由于所谓的**隔离见证**协议升级引起的，我们将在接下来的*拟议解决方案*部分进行讨论。
- en: '![](img/553c0ec9-ea2e-451b-af84-ed2ff6ca6d6c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/553c0ec9-ea2e-451b-af84-ed2ff6ca6d6c.png)'
- en: 'Figure 9.6: Average block size representation of Bitcoin (source: www.blockchain.info)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '图9.6: 比特币平均区块大小的表现（来源：www.blockchain.info）'
- en: Motivations to increase the block size
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加区块大小的动机
- en: 'Increasing the block size is an obvious approach to achieve higher transaction
    throughput. But there are several other factors that could motivate an increase
    in block size:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 增加区块大小是实现更高交易吞吐量的明显途径。但还有一些其他因素可能推动增加区块大小：
- en: Increased transaction activity may result in a bottleneck and thus clog the
    blockchain network. Some transactions might get delayed or lost forever.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加的交易活跃度可能导致瓶颈，从而堵塞区块链网络。一些交易可能会延迟或永久丢失。
- en: Increased waiting time for micro-payments would stop the innovation of the technology.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微支付的等待时间增加会阻碍技术创新。
- en: Currently, users are forced to pay higher transaction fees to prioritize transactions.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，用户被迫支付更高的交易费以优先处理交易。
- en: Concerns on increasing the block size
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加区块大小的担忧
- en: 'Although increasing the block size is an intuitive approach to increase the
    transaction throughput, there are some concerns with this approach. Here are some
    of them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管增加区块大小是增加交易吞吐量的一种直观方法，但这种方法存在一些问题。以下是其中一些问题:'
- en: Exchanging block data will become more difficult because of the increased size
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于增加的大小，交换区块数据将变得更加困难
- en: Increasing the block size is an immediate solution but not a permanent one
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加区块大小是一个即时的解决方案，但不是一个永久性的解决方案。
- en: Changing the block size will result in a hard fork and may risk consensus failures
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变区块大小将导致硬分叉，并可能导致共识失败。
- en: Larger blocks will require higher bandwidth to exchange data, which may not
    excite ordinary full node users and may no longer maintain the full blockchain
    due to the increased maintenance cost
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的区块将需要更高的带宽来交换数据，这可能不会激励普通完整节点用户，并且由于维护成本增加，可能不再能够维护整个区块链。
- en: Proposed solutions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟议解决方案
- en: From the very beginning of 2010, there have been attempts to increase the block
    size with different proposals. There are even a number of **Bitcoin Improvement
    Proposals** (**BIP**) that keep track of this issue. Some of them are BIP 100
    - 103 and BIP 109, and all of them are either in a draft or a rejected state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从2010年初开始，已经有人尝试通过不同的提案来增加区块大小。甚至有一些名为**比特币改进建议**（**BIP**）的提案来跟踪这个问题。其中一些是BIP
    100 - 103和BIP 109，它们都处于草案或被拒绝的状态。
- en: One of the initial proposals, BIP 101 by Gavin Andreson, one of the initial
    developers of the Bitcoin core, suggested increasing the block size to 8 MB and
    doubling the limit every two years, with the size growing linearly during the
    two years. Although the proposal gained support from a majority of the miners,
    it failed to gain an economic majority as it required a hard fork. An alternate
    Bitcoin client called **Bitcoin XT** implemented BIP 101 in 2015, but it failed
    to gain consensus to implement BIP 101\. The BIP implementation was later removed
    from Bitcoin XT.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的一个提案之一，由比特币核心的最初开发人员之一Gavin Andreson提出的BIP 101建议将区块大小增加到8 MB，并且每两年将限制加倍，大小在两年内呈线性增长。尽管该提案得到了大多数矿工的支持，但由于需要硬分叉，由于没有获得经济上的多数，该提案未能获得一致意见。一个名为**比特币XT**的替代比特币客户端在2015年实施了BIP
    101，但未能获得实施BIP 101的共识。后来，BIP实施被从比特币XT中移除。
- en: Despite many proposed solutions, Bitcoin failed to gain a majority for new block
    size approval. But a solution was proposed to increase the block capacity and
    protect from transaction malleability in the shape of a protocol upgrade called
    Segregated Witness. Segregated Witness defines a new structure called a witness
    where all the signature information of the transaction is stored, separating it
    from the transaction information in the block. The transaction's validity can
    be verified from the information present in the witness structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多提出的解决方案，比特币未能获得新区块大小批准的多数票。但是提出了一种解决方案，以增加区块容量并保护免受交易可塑性的影响，这就是所谓的隔离见证协议升级。隔离见证定义了一个称为见证的新结构，其中存储了交易的所有签名信息，将其与区块中的交易信息分开。可以从见证结构中的信息验证交易的有效性。
- en: Segregated Witness defined a new weight unit and permitted the creation of up
    to 4 million units. 1 byte in the new witness structure was considered as 1 unit,
    but 1-byte data in the old block zone was considered as 4 units. This allowed
    the old blocks to have a limit of 1 MB, whereas the blocks created with the upgraded
    protocol were not bound to the 1 MB limit. One of the biggest advantages of this
    proposal was that it did not require a hard fork of the blockchain to reach a
    consensus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离见证定义了一个新的权重单位，并允许创建多达400万个单位。在新的见证结构中，1个字节被视为1个单位，但在旧的区块区域中，1个字节的数据被视为4个单位。这使得旧的区块的限制为1
    MB，而使用升级后的协议创建的区块则不受1 MB限制的约束。这个提案最大的优势之一是它不需要对区块链进行硬分叉以达成共识。
- en: Block size improvements are only a short-term solution for the scalability issue
    of blockchain. The Bitcoin community continuously proposes better solutions so
    that they can address the network scalability issue in the long run.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 区块大小改进只是区块链可扩展性问题的短期解决方案。比特币社区不断提出更好的解决方案，以便从长远来看解决网络可扩展性问题。
- en: Blockchain enhancements
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链增强
- en: Numerous enhancements have been built on top of the existing blockchain protocols
    to function more efficiently or make the blockchain application suitable to implement
    the desired functionality. We will discuss a few of the enhancements that require
    major protocol modifications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多改进措施已经建立在现有的区块链协议之上，以更高效地运行或使区块链应用程序适合实现所需的功能。我们将讨论一些需要进行重大协议修改的改进措施。
- en: Sharding
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片
- en: One of the critical issues that Bitcoin and other existing blockchain platforms
    face is scaling the applications in the blockchain network. Storage is the main
    factor that is slowing down the scalability of decentralized applications. Every
    full node in the blockchain stores the entire blockchain history to verify the
    transaction. Instead of storing redundant data on every node, data can be distributed
    cleverly on the network so that it will help to achieve scalability as well as
    decentralization. Ethereum proposed a sharding mechanism to implement a distributed
    behavior that could achieve scalability. We will discuss a few of the key concepts
    of sharding proposed by Ethereum in this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币和其他现有的区块链平台面临的一个关键问题是扩展区块链网络中的应用程序。存储是减慢去中心化应用可扩展性的主要因素。区块链中的每个完整节点都存储整个区块链历史记录以验证交易。数据可以被巧妙地分布在网络上，而不是在每个节点上存储冗余数据，这将有助于实现可扩展性以及去中心化。以太坊提出了一种分片机制来实现分布式行为，以实现可扩展性。在本节中，我们将讨论以太坊提出的一些分片关键概念。
- en: More details about the Ethereum's sharding roadmap can be found at [https://github.com/ethereum/wiki/wiki/Sharding-roadmap](https://github.com/ethereum/wiki/wiki/Sharding-roadmap).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关以太坊分片路线图的更多详细信息，请访问[https://github.com/ethereum/wiki/wiki/Sharding-roadmap](https://github.com/ethereum/wiki/wiki/Sharding-roadmap)。
- en: The motivation for database sharding
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库分片的动机
- en: Sharding involves partitioning data to distribute it across multiple devices.
    Sharding is not a new concept to achieve a distribution of computing resources.
    It has been used to achieve scalability in databases. Database shards are created
    by horizontally partitioning tables. Each partition, or shard, is often held in
    a physically separated server to balance the load.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分片涉及将数据分区以将其分布到多个设备中。分片并不是实现计算资源分布的新概念。它已被用于数据库中实现可扩展性。数据库分片通过水平分区表来创建。通常，每个分区或分片都存储在物理上分离的服务器上以平衡负载。
- en: Partitioning the database table horizontally into shards will reduce the number
    of rows and thus reduce the index size, which would optimize searching. If the
    database partitioning is performed on real-world data segmentation, such as storing
    data related to different countries on different shards, it would be easy to query
    only the relevant shards.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库表水平划分为分片将减少行数，从而减少索引大小，从而优化搜索。如果数据库分区是基于真实世界的数据分段执行的，比如将与不同国家相关的数据存储在不同的分片上，那么只查询相关分片将变得容易。
- en: '*Figure 9.7* shows how a database table that stores user details initially
    in a global database can be partitioned:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.7* 显示了一个最初将用户详细信息存储在全局数据库中的数据库表如何被分区：'
- en: '![](img/8e056145-b075-4ded-9e88-cf572dfbdbc9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e056145-b075-4ded-9e88-cf572dfbdbc9.png)'
- en: 'Figure 9.7: Database sharding based on physical location'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：基于物理位置的数据库分片
- en: The database table is horizontally sharded into two different tables, each maintaining
    the subset of the total rows in the original table. The tables are partitioned
    on the basis that the first table contains details of users from Asia, and the
    second table contains details of users from North America. Partitioning database
    tables in this way will improve the performance of querying. The database tables
    can also be partitioned and distributed across multiple servers by using a special
    type of hashing known as **consistent hashing**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表被水平划分成两个不同的表，每个表维护原始表中的一部分行。这些表的分区基于第一个表包含来自亚洲的用户的详细信息，而第二个表包含来自北美的用户的详细信息。以这种方式对数据库表进行分区将提高查询性能。数据库表也可以通过使用一种特殊的哈希方式（称为**一致性哈希**）将其分区并分布到多个服务器上。
- en: When a hash table of *N* slots is resized, a majority of the keys (K) need to
    remapped to the slots. Consistent hashing is a special type of hashing where a
    change in the number of slots requires only *K/N* keys to be remapped.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有 *N* 个槽位的哈希表被调整大小时，大多数的键（K）需要重新映射到这些槽位上。一致性哈希是一种特殊的哈希方式，其中槽位数的变化只需要重新映射
    *K/N* 个键。
- en: Sharding in blockchain
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链中的分片
- en: A decentralized blockchain network consists of a number of nodes in order to
    achieve the highest possible level of decentralization. The security of the network
    increases with the number of nodes added to the network. But the population of
    nodes doesn't contribute to the scalability of the network. In fact, it is difficult
    to scale with an increased number of nodes. Ethereum proposed a sharding technique
    where the entire blockchain and its state is split into partitions called shards.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现尽可能高的去中心化级别，分散的区块链网络由许多节点组成。网络的安全性随着添加到网络中的节点数量而增加。但节点的数量并不会增加网络的可伸缩性。事实上，随着节点数量的增加，扩展变得困难。以太坊提出了一种分片技术，其中整个区块链及其状态被分割成称为分片的分区。
- en: The sharding scheme in Ethereum can be partitioned into any number of shards
    that maintain their own history and state. Let's consider a scheme where a blockchain
    is partitioned into *K* shards based on some criteria. An example criterion for
    sharding could be assets, where transactions belonging to different assets are
    maintained on different shards. Since each shard maintains its own state, the
    effect of the transaction created in a shard is limited to the state of that shard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中的分片方案可以分为任意数量的分片，每个分片都维护自己的历史和状态。让我们考虑一种方案，根据某些标准将区块链分为 *K* 个分片的情况。分片的一个示例标准可以是资产，其中属于不同资产的交易被维护在不同的分片上。由于每个分片维护自己的状态，因此在分片中创建的交易的影响仅限于该分片的状态。
- en: Components in a shard
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片中的组件
- en: 'Each shard maintains data in a collation, which is analogous to the blocks
    in the main blockchain. Each collation contains a collection of data in the form
    of blobs. Each collator contains a header and body, similar to the blocks in the
    main chain. *Figure 9.8* depicts how the blobs are transformed into chunks, and
    then a Merkle proof is created for those chunks by building a Merkle tree that
    consists of chunks as its leaves. A chain of collations is created, which is a
    blockchain of the shard. The main chain still exists, which is processed by everyone,
    but they only store the collation headers of the shards. The longest chain of
    a shard is called canonical chain, and its headers will reside in the main chain:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分片在一个整理中维护数据，这类似于主区块链中的块。每个整理包含一组以 blob 形式的数据。每个整理者都包含一个头部和主体，类似于主链中的块。*图
    9.8*描述了 blob 如何被转换为块，然后通过构建由块作为叶子的 Merkle 树为这些块创建 Merkle 证明。创建了一系列整理，这是分片的区块链。主链仍然存在，由每个人处理，但他们只存储分片的整理头。分片的最长链称为规范链，其头部将驻留在主链上：
- en: '![](img/ea71ac2e-aabf-438f-adcd-41d05d2ff432.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea71ac2e-aabf-438f-adcd-41d05d2ff432.png)'
- en: 'Figure 9.8: Collations and blobs in a shard'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：分片中的整理和 blob
- en: There are nodes in the shard called **proposers**. These nodes can either choose
    shards or select them randomly. The proposers are responsible for accepting the
    blobs and creating the collation. Thus they also function as collators. The **notaries**
    are the entities that download and verify the collations. They are assigned to
    the shards and randomly shuffled to a new shard every period via a random beacon
    chain (using some verifiable random function). They will also vote on the availability
    of the collation data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分片中有称为**提议者**的节点。这些节点可以选择分片或随机选择它们。提议者负责接受 blob 并创建整理。因此他们也充当整理者。**公证人**是下载和验证整理的实体。它们被分配到分片，并通过随机信标链（使用一些可验证的随机函数）在每个时期随机洗牌到新的分片。他们还将就整理数据的可用性进行投票。
- en: A **committee** will check the votes and decide whether to include a collation
    header in the main chain. The collation header will establish a link to the collation
    data residing in the shards.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**委员会**将检查投票，并决定是否将整理头包含在主链中。整理头将建立与驻留在分片中的整理数据的链接。
- en: Design of a sharded blockchain
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片区块链的设计
- en: Partitioning a blockchain and distributing it across different shards needs
    a variety of actors, as described in the previous section. All these actors in
    the network will make sure that the collation data of every shard is linked to
    the main chain. The sharding architecture has several security concerns due to
    the distributed shards and several types of actors in the decentralized network.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对区块链进行分区并将其分布到不同的分片需要各种参与者，正如前一节所述。网络中的所有这些参与者将确保每个分片的整理数据与主链相连。分片架构由于分布式分片和去中心化网络中的多种类型的参与者而存在几个安全问题。
- en: The design of the blockchain is said to be secure if it can maintain an honest
    majority where more than 50 percent of the validators follow the protocol honestly.
    The value can be lower if there is an uncoordinated majority.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果区块链的设计能够保持诚实多数，其中超过50%的验证者遵循协议的诚实行为，则该设计被认为是安全的。如果存在无协调的多数，则该值可以较低。
- en: An uncoordinated majority is an act of achieving a majority, but one where no
    more than 50% (often between 20 to 50 percent) of validators are capable of coordinating
    an action.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 无协调的多数是一种实现多数的行为，但其中不超过50%（通常在20%到50%之间）的验证者能够协调行动。
- en: The design of a sharded blockchain isolates the transactions of one shard from
    the rest of the shards in the network. If a node needs to perform a transaction
    with a node present on the other shard, it is not as straightforward as the classic
    blockchain design. Ethereum sharding uses a concept called receipt to perform
    cross-shard communication.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 分片区块链的设计将网络中一个分片的交易与其他分片隔离开来。如果一个节点需要与其他分片上的节点执行交易，那么这并不像经典区块链设计那样简单。以太坊分片使用了一个称为
    receipt 的概念来执行跨分片通信。
- en: Cross-shard communication
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨分片通信
- en: 'There might be a scenario when a transaction needs to be shared between two
    or more shards. Ethereum uses receipts created by nodes in one shard to confirm
    the transaction. Let''s consider a scenario in which user *A* present in shard
    *M* wants to send 100 coins to user *B* of shard *N*. Cross-shard communication
    can be established with the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现一种情况，即一笔交易需要在两个或多个分片之间共享。以太坊使用由一个分片中的节点创建的收据来确认交易。让我们考虑这样一个场景，即位于分片*M*中的用户*A*想要将100枚硬币发送给分片*N*中的用户*B*。跨分片通信可以通过以下步骤建立：
- en: Create a transaction on shard *M* for deducting the coins.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分片*M*上创建一笔用于扣除硬币的交易。
- en: Create a receipt for the transaction of 100 coins from user *A* to *B*. The
    transaction won't be saved on the state, but the existence of the receipt can
    be verified by the users in shard *N*.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户*A*到*B*之间的100枚硬币的交易创建一个收据。这笔交易不会保存在状态上，但是收据的存在可以由分片*N*中的用户验证。
- en: Create and send a transaction on shard *N* that includes the Merkle proof of
    the receipt. This transaction also confirms that the receipt is unspent. The balance
    of user *B* is increased by 100 coins in shard *N*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分片*N*上创建并发送一笔包含收据默克尔证明的交易。该交易还确认了收据未被使用。用户*B*在分片*N*上的余额增加了100枚硬币。
- en: Some complex scenarios might result in communication across multiple shards
    to query data from the state of other shards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些复杂的情况可能会导致跨多个分片进行通信，以从其他分片的状态中查询数据。
- en: Evolution of the consensus algorithm
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法的演进
- en: We have come across Bitcoin's **Proof of Work** (**PoW**) consensus algorithm
    in several sections of this book. The PoW algorithm is the backbone of the decentralized
    networking protocol. Although Bitcoin's consensus algorithm has been proven to
    be effective to achieve consensus in a trustless network, it is still not very
    efficient in terms of cost due to the computational resources spent during the
    mining process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的几个章节中接触了比特币的**工作证明**（**PoW**）共识算法。 PoW算法是去中心化网络协议的支柱。尽管比特币的共识算法已被证明在无信任网络中实现共识是有效的，但由于挖矿过程中花费的计算资源而导致的成本效率仍然不高。
- en: A number of alternative consensus algorithms have been developed and implemented
    to attain the same amount of confidence in decentralization without incurring
    too much expense.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发并实施了许多替代共识算法，以在不产生过多开销的情况下达到相同程度的去中心化信任。
- en: Proof of Stake (PoS)
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股权证明（PoS）
- en: The PoS algorithm eradicates most of the issues of PoW by not depending on computational
    resources to achieve consensus. **PoS** uses validators, which are in contrast
    to the miners in PoW in that they don't perform any work to contribute to the
    decentralization. The contribution of the PoS validators depends on their share
    of the cryptocurrency coins from the total in circulation in the system. A validator
    with three coins is three times more likely to contribute to the validation than
    a validator owning a single coin. There are other factors that randomize the process
    to avoid one validator with a major stake monopolizing the validation process.
    Peercoin was the first to adopt PoS, followed by Nxt and BlackCoin. Ethereum is
    currently using PoW, but PoS is in active development, and it has planned to implement
    PoS in the mainnet in the near future.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PoS算法通过不依赖计算资源来实现共识，消除了PoW的大部分问题。PoS使用验证者，与PoW中的矿工相反，它们不执行任何工作来促进去中心化。 PoS验证者的贡献取决于他们在系统中流通的加密货币硬币的份额。持有三枚硬币的验证者比持有一枚硬币的验证者更有可能对验证做出贡献。还有其他因素会随机化该过程，以避免持有主要利益的一个验证者垄断验证过程。Peercoin是第一个采用PoS的，随后是Nxt和BlackCoin。以太坊目前正在使用PoW，但PoS正在积极开发中，并计划在不久的将来在主网上实施PoS。
- en: Along with its wide-ranging benefits, it has its own set of issues in the implementation.
    A white paper on PoS versus PoW ([https://bitfury.com/content/downloads/pos-vs-pow-
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其广泛的益处外，在实施过程中也存在一些问题。有关PoS与PoW的白皮书（[https://bitfury.com/content/downloads/pos-vs-pow-
- en: 1.0.2.pdf](https://bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf)) published
    by the BitFury group lists a few of the possible attacks, such as the long-range
    attack, bribe attack, coin age accumulation attack, and precomputing attack. Ensuring
    complete security in a public decentralized network isn't a picnic. Even the resilient
    PoW is theoretically vulnerable to the 51% attack, which can result in double
    spends (we will cover the security concerns of PoW in [Chapter 10](53dc28ad-de3d-463a-8244-e48d0d19d616.xhtml),
    *Blockchain Security*). The PoS algorithm prevents validators from attacks by
    penalizing the nodes upon bad behavior. Ethereum requires each node to possess
    a minimum stake of 1,250 ethers to participate in validation. The minimum stake
    deposit by the validators prevents them from being dishonest in the network.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由BitFury团队发布的[1.0.2.pdf](https://bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf)列出了一些可能的攻击，例如长期攻击，贿赂攻击，硬币年龄累积攻击和预计算攻击。
    在公共分散网络中确保完全安全并不容易。 即使弹性的PoW从理论上也容易受到51％攻击的威胁，这可能导致双重花费（我们将在[第10章](53dc28ad-de3d-463a-8244-e48d0d19d616.xhtml)中介绍PoW的安全问题，*区块链安全*）。
    PoS算法通过对节点进行惩罚防止攻击。 以太坊要求每个节点拥有至少1250个以太来参与验证。 验证者的最低押金防止它们在网络中不诚实。
- en: Proof of Activity (PoA)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动证明（PoA）
- en: Most cryptocurrencies and blockchain platforms that use PoW have a limited supply
    of tokens. For example, Bitcoin will only mint 21 million coins, and the final
    coin will be minted sometime during the year 2140\. Miners will have to solely
    depend on transaction fees as their incentives when all the coins are minted.
    According to the current difficulty level of Bitcoin, it would reach a level when
    it may not be economical for miners to participate in the mining process. The
    existing miners may try and perform dishonest acts and spoil the blockchain system
    with invalid transactions for their own benefit. PoA was proposed as an alternative
    consensus algorithm that could be adopted by Bitcoin. It is a hybrid approach
    that combines PoW and PoS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用PoW的加密货币和区块链平台的代币供应有限。 例如，比特币只会铸造2100万个硬币，最后一个硬币将在2140年左右铸造。 当所有硬币被铸造后，矿工将不得不完全依赖交易费用作为他们的激励。
    根据比特币当前的难度水平，它可能达到一个水平，使得矿工参与挖矿过程可能不经济。 现有的矿工可能会尝试执行不诚实的行为，并通过无效的交易破坏区块链系统以获取自己的利益。
    PoA被提议作为比特币可以采用的替代共识算法。 它是一种混合方法，结合了PoW和PoS。
- en: During block creation, the mining nodes perform PoW by solving the hash puzzle
    with computational resources. The PoW process will not add any transactions; instead,
    they only create the block header with the miner's details. PoS is used to further
    process the block by randomly selecting the validators based on the block header
    information. This phase of consensus is handled in a similar way to PoS-based
    systems. If not all the validators selected were able to sign the block, the next
    best block is selected, and the same process of PoS validation is applied. After
    each block has been included in the blockchain, both the PoW and PoS miners will
    receive their incentives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块创建期间，挖矿节点利用计算资源通过解决哈希难题执行PoW。 PoW过程不会添加任何交易； 相反，它们只创建带有矿工详细信息的块头。 PoS用于根据块头信息随机选择验证者来进一步处理块。
    这个共识阶段的处理方式与基于PoS的系统类似。 如果选择的验证者无法对块进行签名，则选择下一个最佳块，并应用相同的PoS验证过程。 每个块被包含在区块链中后，PoW和PoS矿工都会收到他们的激励。
- en: Decred is a cryptocurrency that was launched in February 2016 and makes use
    of PoA to achieve the consensus in the network.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Decred是一种加密货币，于2016年2月推出，并利用PoA来实现网络中的共识。
- en: Byzantine Fault Tolerance (BFT) consensus models
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拜占庭容错（BFT）共识模型
- en: Consensus algorithms were designed in distributed systems to tolerate Byzantine
    faults relating to the Byzantine generals' problem (refer to [Chapter 1](5ed0d7a8-0fa3-4f99-9d68-5ef2025ecd65.xhtml),
    *Introduction*, for a definition of the Byzantine generals' problem). Though PoW
    and PoS have tolerance to Byzantine faults, it comes at a cost. Several variants
    of **Byzantine Fault Tolerance** (**BFT**) consensus models have been proposed
    as solutions to this problem in untrusted distributed networks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法设计在分布式系统中以容忍与拜占庭将军问题相关的拜占庭故障（有关拜占庭将军问题的定义，请参阅[第1章](5ed0d7a8-0fa3-4f99-9d68-5ef2025ecd65.xhtml)，*介绍*）。
    尽管PoW和PoS对拜占庭故障有容忍度，但是要付出代价。 几种变体的**拜占庭容错**（**BFT**）共识模型已被提出作为在不受信任的分布式网络中解决此问题的解决方案。
- en: Practical Byzantine Fault Tolerance (PBFT)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Practical Byzantine Fault Tolerance (PBFT)
- en: The PBFT consensus algorithm was proposed by Miguel Castro and Barbara Liskov
    as a practical solution to the Byzantine generals' problem in distributed systems.
    It achieves consensus among nodes with a voting mechanism if the state changes.
    This algorithm requires at least *3f+1* nodes in a system of *f* failing nodes.
    PBFT poses an overall overhead of about 3% to the system, which is a great improvement
    on the PoW consensus-based systems. Scaling PBFT in terms of nodes is still a
    challenge, as it will result in a greater overhead as the number of nodes increases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT共识算法由Miguel Castro和Barbara Liskov提出，作为分布式系统中拜占庭将军问题的实际解决方案。如果状态发生变化，它通过投票机制在节点之间达成共识。该算法在*3f+1*个节点中至少需要*f*个失败节点。PBFT对系统总体的开销约为3%，这是对基于PoW共识的系统的巨大改进。就节点规模而言，PBFT仍然是一个挑战，因为随着节点数量的增加，开销会增加。
- en: The Hyperledger Fabric project uses the PBFT protocol to achieve high transaction
    throughput in a permissioned blockchain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric项目使用PBFT协议在许可区块链中实现高交易吞吐量。
- en: Federated Byzantine Fault Tolerance (FBFT)
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦拜占庭容错（FBFT）
- en: FBFT is a variant of the BFT algorithm that has been implemented in payment-protocol-based
    blockchain platforms such as Ripple and Stellar. Both of these platforms perform
    critical transactions, such as cross-border payment, by dealing with fiat currencies.
    Due to their criticality, the consensus model should be fault resistant to avoid
    any attacks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: FBFT是BFT算法的一种变体，已在基于支付协议的区块链平台（如Ripple和Stellar）中实现。这些平台都执行关键交易，如跨境支付，涉及法定货币。由于它们的关键性，共识模型应具有容错性，以避免任何攻击。
- en: '**Ripple consensus protocol**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ripple共识协议**'
- en: An overview of the Ripple consensus protocol was covered in the previous chapter,
    along with its platform's architecture. Each node implements the FBFT consensus
    model by voting on the transactions. Each node in the network maintains a list
    called a **Unique Node List** (**UNL**), comprising trusted Ripple nodes. Each
    node broadcasts a set of transactions called a candidate set to its nodes in the
    UNL. Each node will validate the transactions and broadcast their votes for each
    transaction. Each node refines the candidate set based on the votes received for
    each transaction. When a particular candidate set receives 80% of votes from all
    the nodes in the UNL, all the transactions in the candidate set are confirmed
    by adding it into the blockchain ledger. The Ripple ledger goes to a closed state,
    and all the unconfirmed transactions will be carried over to the next round of
    voting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple共识协议的概述在上一章中进行了介绍，以及其平台的架构。每个节点通过对交易进行投票来实现FBFT共识模型。网络中的每个节点都维护一个称为**Unique
    Node List**（**UNL**）的列表，其中包含受信任的Ripple节点。每个节点向其UNL中的节点广播一组称为候选集的交易。每个节点将验证交易并为每个交易广播其投票。根据收到的每个交易的投票，每个节点调整候选集。当特定候选集收到来自UNL中所有节点80%的投票时，所有候选集中的交易都通过将其添加到区块链分类帐中进行确认。Ripple分类帐进入封闭状态，并且所有未确认的交易将在下一轮投票中继续进行。
- en: Ripple performs a voting mechanism in rounds to achieve minimum consensus from
    all the nodes before the transactions are committed. FBFT achieves higher transaction
    rates even than a permissionless network. Hence it can be implemented in critical
    financial systems that need higher scalability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple通过轮次进行投票机制，以从所有节点中获得最小共识，然后才能提交交易。FBFT甚至比无权限网络实现更高的交易速率。因此，它可以应用于需要更高可伸缩性的关键金融系统中。
- en: Proof of Elapsed Time (PoET)
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间证明（PoET）
- en: PoET is a consensus algorithm designed to solve the performance issues faced
    by existing consensus protocols. It solves the Byzantine Generals' problem using
    the trusted execution environment. Due to its trusted execution model, it is only
    suitable for a permissioned blockchain network. PoET consensus has been implemented
    in Hyperledger's Sawtooth, which is a permissioned blockchain project backed by
    Intel. The **trusted execution environment** (**TEE**) in the network is achieved
    by Intel's **Software Guard Extensions** (**SGX**), which are instruction sets
    that allow user code to allocate private memory regions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PoET是一种旨在解决现有共识协议面临的性能问题的共识算法。它使用受信任的执行环境解决拜占庭将军问题。由于其受信任的执行模型，它仅适用于许可区块链网络。PoET共识已在由Intel支持的许可区块链项目Hyperledger
    Sawtooth中实现。网络中的受信任执行环境是通过Intel的**软件保护扩展**（**SGX**）实现的，这是一组指令集，允许用户代码分配私有内存区域。
- en: 'Similar to the PoS algorithm, PoET elects a random peer to construct the next
    block with the exception that there is no staking involved. Instead, peers wait
    for a random amount of time before they can participate in the block creation
    process. Since each peer will have a random wait time, the first peer to finish
    the wait time will create the block. Each peer has to prove a couple of things
    to the network to qualify itself as the elected node:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于PoS算法，PoET选举一个随机的节点来构建下一个块，但不涉及质押。相反，节点需要在参与块创建过程之前等待随机的时间量。由于每个节点都会有一个随机的等待时间，第一个完成等待时间的节点将创建块。每个节点都必须向网络证明几件事情，以使自己有资格成为被选举的节点：
- en: Prove that the node has chosen a random wait time
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明节点已经选择了随机等待时间
- en: Prove that the node has waited for the chosen random wait time
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明节点已经等待了选择的随机等待时间
- en: Each node satisfies these requirements by running the trusted code in a protected
    environment with the help of Intel's SGX instruction set. The node participating
    in the election obtains a wait time from a trusted function. The node with the
    shortest time will be the leader for the next block to be created. A function,
    say, `CreateTimer`, will set the timer and another function, say, `CheckTimer`,
    will create an attestation when the timer expires. This attestation proves that
    the node has waited for a specified wait time before creating the block. Every
    node on the network will use this attestation to validate the block.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点通过在受保护环境中运行受信任的代码来满足这些要求，借助英特尔的SGX指令集。参与选举的节点从受信任的函数中获取等待时间。等待时间最短的节点将成为下一个要创建的块的领导者。一个函数，比如说，`CreateTimer`，会设置计时器，另一个函数，比如说，`CheckTimer`，会在计时器到期时创建一个证明。这个证明证明了节点在创建块之前等待了指定的等待时间。网络上的每个节点都将使用这个证明来验证块。
- en: Every node in the network will download the trusted code and perform an initial
    handshake to set up a trusted network. As a part of the handshake, the nodes will
    create a key pair for the trusted code and publish its public key to the entire
    network.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的每个节点都将下载受信任的代码，并执行初始握手以建立受信任的网络。作为握手的一部分，节点将为受信任的代码创建一对密钥，并将其公钥发布到整个网络。
- en: PoET promises higher performance with its time-based election mechanism to achieve
    consensus, and it is ideal for private enterprise blockchain networks. But the
    permissioned model isn't practical for a public network due to its requirement
    for specialized hardware to create a protected execution environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: PoET 承诺通过其基于时间的选举机制实现共识的更高性能，并且对于私有企业区块链网络而言是理想的。但是，由于需要专门的硬件来创建受保护的执行环境，权限模型对于公共网络来说并不实用。
- en: Cross-chain protocol
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨链协议
- en: A distributed blockchain ledger is an evolving space, and many applications
    are implemented frequently. Just like any computer technology, which requires
    updates from time to time, existing blockchain systems need to be updated to evolve
    with the growing technology. Unlike other centralized systems, extensive changes
    to an existing blockchain will lead to a hard fork due to the decentralization
    of nodes. Existing blockchain systems suffer from restricted innovation or integration
    with evolved protocols.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式区块链账本是一个不断发展的领域，许多应用程序经常被实现。就像任何计算机技术一样，需要定期更新一样，现有的区块链系统需要更新以跟上不断发展的技术。与其他集中式系统不同，对现有区块链的广泛更改将导致硬分叉，因为节点的去中心化。现有的区块链系统受到受限的创新或与发展的协议集成的限制。
- en: The cross-chain protocol was developed to integrate existing blockchain applications
    with the newly evolved systems and enable multiple blockchain networks to communicate
    with each other. The cross-chain communication protocol also helps to scale blockchain
    networks by integrating multiple ledgers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 跨链协议的开发是为了将现有的区块链应用与新发展的系统集成，并使多个区块链网络能够相互通信。跨链通信协议还有助于通过集成多个账本来扩展区块链网络。
- en: Several projects have been working toward the implementation of the cross-chain
    protocol. *Cosmos*, *Polkadot*, and *Interledger* are some of the projects implementing
    the cross-chain protocol in their own way. Cosmos and Polkadot have their own
    blockchain ecosystem with several components that can communicate with other independent
    blockchain systems. Interledger is a protocol for making payments across payment
    systems. In the following section, we will analyze the cross-chain protocol implementation
    in payment systems using Interledger.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 几个项目一直致力于实施跨链协议。*Cosmos*、*Polkadot* 和 *Interledger* 是一些以自己的方式实施跨链协议的项目。Cosmos
    和 Polkadot 拥有自己的区块链生态系统，具有几个组件可以与其他独立的区块链系统进行通信。Interledger 是一个用于在支付系统之间进行支付的协议。在接下来的部分中，我们将分析使用
    Interledger 在支付系统中实现跨链协议。
- en: Interledger protocol (ILP)
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Interledger 协议（ILP）
- en: All the payment systems across the world are built to function in a single payment
    network, and all the assets and transaction details are maintained by a single
    ledger. Even digital currencies such as Bitcoin maintain all their transactions
    in a single public ledger, even though copies of the ledger are distributed throughout
    the network. The transactions can be easily maintained in a single ledger, but
    it would be difficult to vertically scale such a ledger. We have analyzed the
    scalability of a single ledger in the *Sharding* section of this chapter. In addition
    to this, the diverse payment systems will never agree on a single distributed
    ledger or its corresponding consensus mechanism. A protocol that can connect multiple
    payment systems and perform inexpensive transactions across the network would
    be a great solution to the vertical scaling of existing ledgers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 全球范围内的所有支付系统都建立在单一的支付网络中运行，并且所有资产和交易细节都由单一的分类帐维护。即使是比特币等数字货币也将所有交易记录在单一的公共分类帐中，尽管分类帐的副本分布在整个网络中。在单一分类帐中可以轻松维护交易，但要垂直扩展这样的分类帐将会很困难。我们在本章的*分片*部分分析了单一分类帐的可扩展性。除此之外，各种不同的支付系统永远不会就单一的分布式分类帐或其相应的共识机制达成一致。能够连接多个支付系统并在网络中执行低成本交易的协议将是现有分类帐垂直扩展的一个很好的解决方案。
- en: 'The Interledger protocol provides a system to securely transfer value across
    different ledgers, and it is also often used with other payment systems. Interledger
    appoints connectors between the ledgers of the participants to perform transactions.
    Unlike any existing payment gateway services, participants don''t need to trust
    these connectors due to the escrow provided by the ledgers. The protocol not only
    enables value transfer between the blockchain-based ledgers but can also create
    connections with traditional payment systems such as PayPal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Interledger 协议提供了一种安全地在不同分类帐之间转移价值的系统，它也经常与其他支付系统一起使用。Interledger 在参与者的分类帐之间指定连接器来执行交易。与任何现有的支付网关服务不同，由于分类帐提供的托管，参与者无需信任这些连接器。该协议不仅可以在基于区块链的分类帐之间实现价值转移，还可以与传统支付系统（如
    PayPal）建立连接：
- en: '![](img/d8931552-e534-4f23-822b-5b9e413c62ed.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8931552-e534-4f23-822b-5b9e413c62ed.png)'
- en: 'Figure 9.9: Interledger protocol (ILP) use case'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：Interledger 协议（ILP）用例
- en: Interledger components
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Interledger 组件
- en: '**Senders** send assets to the known receivers. They will initiate the payment
    by selecting the connectors.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送者** 将资产发送给已知的接收者。他们将通过选择连接器来启动付款。'
- en: '**Receivers** will expect assets from particular senders. They need to be the
    part of Interledger payment network.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收者** 将期望从特定发送者处收到资产。他们需要成为 Interledger 付款网络的一部分。'
- en: '**Connectors** link senders with receivers to make ILP payments possible. Connectors
    also link up with other connectors. This is done to connect as many senders with
    receivers as possible, through chains of connectors that are built for each payment.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接器** 将发送者与接收者连接起来，使 ILP 付款成为可能。连接器还会与其他连接器建立连接。这是为了通过为每笔付款建立的连接器链将尽可能多的发送者连接到接收者。'
- en: '**Ledgers** perform bookkeeping of the asset information of every participant
    in the network:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类帐** 对网络中每个参与者的资产信息进行簿记：'
- en: '![](img/45ab231b-4824-4694-bc78-aee244a69498.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ab231b-4824-4694-bc78-aee244a69498.png)'
- en: 'Figure 9.10: Interledger components'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：Interledger 组件
- en: Design of Interledger
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Interledger 设计
- en: 'Current payment systems provide a way to transfer value between different ledgers
    in the form of payment gateways. They act as an intermediary between the payment
    banks. The main concerns of existing systems are security and speed. The gateways
    are managed by the third parties, and users need to rely on those entities to
    ensure security. Transaction settlement in such a payment network is slower since
    the gateway has to deal with multiple payment banks. Interledger introduces connectors
    between the ledgers, which establish links between senders and receivers. The
    ledger in this system creates an escrow, which is the cryptographic conditions
    that will secure the funds when transacting across the ledgers. The cryptographic
    conditions created by ledgers that act as an escrow guarantee the fund transfer
    to connectors only after acknowledgment from the receiver:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的支付系统提供了一种在不同账本之间转移价值的方式，即支付网关。它们充当支付银行之间的中介。现有系统的主要关注点是安全性和速度。这些网关由第三方管理，用户需要依赖这些实体来确保安全。在这样的支付网络中，交易结算较慢，因为网关必须处理多个支付银行。Interledger引入了账本之间的连接器，建立了发送者和接收者之间的联系。该系统中的账本创建了一个托管机制，这是在账本之间进行交易时将资金锁定的密码条件。账本创建的密码条件作为托管机制保证只有在接收者确认后才将资金转移到连接器：
- en: '![](img/d94f6719-eb41-483c-bc2b-0c19f7ae7c5f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d94f6719-eb41-483c-bc2b-0c19f7ae7c5f.png)'
- en: 'Figure 9.11: Transferring the funds to the connector (source: https://interledger.org)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：将资金转移给连接器（来源：https://interledger.org）
- en: A decentralized network suffers from the threat of faulty or bad actors. The
    conditioned escrow of the funds is a major security feature that ensures that
    the funds are transferred only after an acknowledgment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式网络受到错误或恶意行为者的威胁。条件托管的资金是一个重要的安全功能，可以确保资金只有在收到确认后才会转移。
- en: Ledger escrows use cryptographic signatures. Anyone can then validate the signature
    to check whether the condition has been met.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 账本托管使用密码签名。任何人都可以验证签名以检查条件是否已满足。
- en: The payment process can be performed using two models in Interledger. These
    are atomic payments and universal payments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 支付过程可以使用Interledger中的两种模型来执行。这些是原子支付和通用支付。
- en: '**Atomic payments**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子支付**'
- en: Interledger payments guarantee that the transfer is either executed or aborted.
    It uses a commitment protocol, where the readiness of the system is identified
    before deciding on the execution or abortion of the transaction. The commitment
    protocol in a decentralized system uses a set of transaction managers called notaries.
    These notaries are used to achieve consensus among the untrusted Byzantine nodes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Interledger支付保证了转移要么执行要么中止。它使用一种承诺协议，在决定是否执行或中止交易之前，会先确定系统的准备情况。分布式系统中的承诺协议使用一组被称为记账人的交易管理器。这些记账人用于在不受信任的拜占庭节点之间达成共识。
- en: 'When a payment network is created before the transactions, there might be more
    than one connector involved between the sender and the recipient. The number of
    connectors depends on the selected route between the participants, which is based
    on the hop or the fee involved. *Figure 9.12* shows that there are `n-2` connectors
    between `n-1` ledgers while transacting between nodes **p[1]** and **p[n]**:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当交易发生之前，支付网络中可能涉及多个连接器在发送者和接收者之间。连接器的数量取决于参与者之间的选择路线，这取决于跳数或涉及的费用。*图9.12*显示，在节点**p[1]**和**p[n]**之间进行交易时，有`n-1`个账本之间有`n-2`个连接器：
- en: '![](img/e1a76d17-54a4-4ea2-8bcd-146f973c15a8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1a76d17-54a4-4ea2-8bcd-146f973c15a8.png)'
- en: 'Figure 9.12: Payment route with multiple connectors (source: https://interledger.org)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：具有多个连接器的支付路线（来源：https://interledger.org）
- en: All the connectors in the payment network are Byzantine nodes that could exhibit
    faulty behavior during the transaction. The elected group of notaries, *N*, need
    to achieve consensus among the Byzantine nodes. The trustless notaries need to
    be fault-tolerant in order to create an atomic transaction. The network should
    make sure that there are no more than *f* faulty notary nodes among the *3f+1*
    nodes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 支付网络中的所有连接器都是可能在交易过程中表现出错误行为的拜占庭节点。选定的记账人* N *需要在拜占庭节点之间达成共识。不可信的记账人需要具有容错能力，以创建原子交易。网络应确保在*3f+1*个节点中，不超过*f*个故障的记账人节点。
- en: 'Before a sender can begin a transfer, a path of connectors has to be selected
    after considering their fees and exchange rate. Once the optimal path has been
    selected, the following stages can be observed during the transaction:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送方可以开始转账之前，必须选择连接器路径，考虑到它们的费用和汇率。一旦选择了最佳路径，在交易过程中可以观察到以下阶段：
- en: A group of notaries is elected by the participants. The election should make
    sure that the number of faulty notaries should be less than *f* out of a total
    of *3f+1* notaries.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参与者选举了一组公证人。选举应确保故障公证人的数量应少于 *3f+1* 个公证人中的 *f* 个。
- en: The payment sender proposes a transfer request to each connector. All the connectors
    will verify whether the rate matches their exchange rate. The sender will start
    the preparation for the transfer once all the connectors confirm their approval
    of the proposal.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 付款发送方向每个连接器提出转账请求。所有连接器都将验证汇率是否与其汇率匹配。一旦所有连接器确认批准提案，发送方将开始准备转账。
- en: The sender prepares the transfer from the ledger to the connector and requests
    the connector to prepare for the transfer from the next ledger to its adjacent
    connector in the path. Each connector will prepare for the transfer as soon as
    it gets confirmation that the funds have been escrowed.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送方准备从总账向连接器进行转账，并请求连接器准备好从路径中相邻连接器到下一个总账的转账。每个连接器在确认资金已经托管后将准备好进行转账。
- en: The final receiver of the fund will sign the receipt once funds at each ledger
    have been escrowed. If the notary receives the receipt on time, then the notary
    will forward the execute message to all the all the participants in the transaction.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资金的最终接收方在每个总账的资金被托管后将签署收据。如果公证人及时收到收据，则公证人将向交易中的所有参与者转发执行消息。
- en: '**Universal payments**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用支付**'
- en: Unlike the atomic payment model, there are no notaries that act as transaction
    managers in this model. It uses the participants inside the network to achieve
    consensus. Although it removes interaction with the external coordinators, it
    can ensure safety to only non-faulty participants in a known environment. Practical
    consideration of universal payments is not straightforward due to the untrusted
    participants of the network who display faulty behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与原子支付模型不同，此模型中没有充当交易管理器的公证人。它使用网络内部的参与者来达成共识。尽管它消除了与外部协调器的交互，但它可以确保在已知环境中只对非故障参与者进行安全保障。由于网络的不信任参与者显示出故障行为，通用支付的实际考虑并不简单。
- en: Other than providing a connection between multiple ledgers, Interledger doesn't
    rely on any other system, so it provides the freedom to scale the system as required.
    It also maintains the privacy of the transaction details. So, the cross-ledger
    payment protocol provided by Interledger greatly eases the communication between
    financial systems. More implementation details of the Interledger project can
    be found at [https://github.com/interledger](https://github.com/interledger).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供多个总账之间的连接外，Interledger 不依赖于任何其他系统，因此可以根据需要自由扩展系统。它还保护交易详情的隐私。因此，Interledger
    提供的跨总账支付协议极大地简化了金融系统之间的通信。Interledger 项目的更多实现细节可以在 [https://github.com/interledger](https://github.com/interledger)
    找到。
- en: Privacy enhancement
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐私增强
- en: As we all know, Bitcoin maintains a history of the funds owned by accounts in
    transactions stored in blocks. Each transaction contains sensitive information,
    such as the sender's address, the recipient's address, and the value. All the
    data is used by every node in the network to verify the transaction before the
    block can be included in the blockchain. Bitcoin's decentralized verification
    forces the transparency of the transaction as there is no central authority.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，比特币在区块中存储了交易中账户拥有的资金历史。每个交易包含诸如发送方地址、接收方地址和价值等敏感信息。所有数据都被网络中的每个节点用于在区块可以包含在区块链之前验证交易。比特币的去中心化验证强制交易透明，因为没有中央机构。
- en: Bitcoin's blockchain provides security against tampering with transactions even
    though they are visible to everyone. Although the blockchain secures the transactions
    from many attacks, it does not guarantee complete privacy to the account holders
    like other payment services. Anyone on the Bitcoin network can trace a transaction's
    history without performing any authentication. Disclosing a transaction's history
    could expose sensitive information about a particular account, such as recent
    transactions or the account balance. The limited privacy on the Bitcoin network
    has been one of the core concerns for the users. Since most blockchain projects
    evolved from Bitcoin, they followed a similar transparency model. The pseudo-anonymity
    feature of most blockchain applications provides some level of privacy to its
    users.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的区块链提供了安全性，防止交易被篡改，尽管它们对所有人都是可见的。尽管区块链保护了交易免受许多攻击，但它并不像其他支付服务那样向账户持有者提供完整的隐私保护。比特币网络上的任何人都可以追踪交易的历史，而无需进行任何身份验证。披露交易历史可能会暴露特定账户的敏感信息，如最近的交易或账户余额。比特币网络上的有限隐私一直是用户的主要关注点之一。由于大多数区块链项目都是从比特币发展而来的，它们遵循了类似的透明度模型。大多数区块链应用程序的伪匿名特性为其用户提供了一定程度的隐私。
- en: Pseudo-anonymity (Pseudonymity) is the identity of an individual or a group
    that does not disclose its true identity. Bitcoin users are identified by their
    public address, which doesn't reveal their real identity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 伪匿名（伪匿名）是一个个人或团体的身份，它不披露其真实身份。比特币用户通过其公共地址进行标识，而不会透露其真实身份。
- en: An anonymous cryptocurrency called Zerocoin was proposed by researchers from
    Hopkins University. Zerocoin used zero-knowledge proofs to provide an extension
    to Bitcoin that enhanced its privacy by creating anonymous transactions. An improved
    protocol called Zerocash was later introduced, which was an independent cryptocurrency
    that utilized a special kind of zero-knowledge proofs called **zk-SNARKs**. Zerocash
    was later developed into a fully-fledged digital cryptocurrency called **Zcash**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为 Zerocoin 的匿名加密货币是由约翰斯·霍普金斯大学的研究人员提出的。Zerocoin 使用零知识证明来为比特币提供一个扩展，通过创建匿名交易来增强其隐私。后来提出了一种改进的协议，称为
    Zerocash，它是一种使用一种特殊类型的零知识证明称为 **zk-SNARKs** 的独立加密货币。Zerocash 后来发展成了一种名为 **Zcash**
    的完整数字加密货币。
- en: Since the invention of Zcash, several applications were developed to provide
    privacy by implementing a similar protocol. Monero, Dash, Verge, and even a fork
    of Bitcoin called Bitcoin Private are some privacy-based cryptocurrencies that
    were introduced later. We will explore Zcash in more detail, along with the underlying
    protocol used to ensure the privacy of its transactions in this section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Zcash 发明以来，已经开发了几种应用程序，通过实现类似的协议来提供隐私保护。Monero、Dash、Verge，甚至是比特币的一个分叉称为 Bitcoin
    Private 都是一些后来推出的基于隐私的加密货币。在本节中，我们将更详细地探讨 Zcash，以及用于确保其交易隐私的基础协议。
- en: Zero-knowledge proof
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零知识证明
- en: 'A zero-knowledge proof is an important cryptographic primitive used to achieve
    anonymity in the implementation of Zcash. It is a method where one party, say,
    Alice, who owns some secret information, can prove to the other party, Bob, that
    she owns the information without actually revealing it. Every zero-knowledge proof
    will have two parties, a prover, and a verifier. The prover will always possess
    knowledge that is kept secret, and the verifier will verify the statement of the
    prover. The prover should always make use of the secret knowledge while creating
    the proof, which implies that the verifier should not be able to reproduce the
    proof to other parties without the secret knowledge. Whenever a prover creates
    a zero-knowledge proof, it should satisfy the following properties:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识证明是实现 Zcash 中的匿名性的重要密码原语。这是一种方法，其中一方，比如说，Alice，拥有一些秘密信息，可以向另一方，Bob，证明她拥有这些信息，而不实际披露它。每个零知识证明都会涉及两个当事人，一个证明者和一个验证者。证明者始终拥有被保密的知识，而验证者将验证证明者的陈述。证明者应该在创建证明时始终利用秘密知识，这意味着验证者不应该能够在没有秘密知识的情况下向其他方复制证明。每当证明者创建零知识证明时，它应该满足以下属性：
- en: '**Completeness**: If the statement is true, an honest verifier should be convinced
    by the statement of an honest prover.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：如果一个陈述是真实的，那么一个诚实的验证者应该被一个诚实的证明者的陈述所说服。'
- en: '**Soundness**: If the statement is false, no dishonest prover can convince
    the verifier that it is true. There might be a few exceptional cases that can
    be neglected.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明的正确性**：如果陈述是错误的，没有不诚实的证明者可以说服验证者它是真的。可能有一些可以忽略的特例。'
- en: '**Zero knowledge**: If the statement is true, the verifier doesn''t learn anything
    other than the statement itself.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零知识**：如果陈述为真，验证者除了陈述本身之外不会学到任何东西。'
- en: Zero-knowledge proofs are probabilistic proofs. There is a small probability
    of a soundness error, where a dishonest prover can convince the verifier of a
    false statement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识证明是概率证明。存在着声明错误的小概率，其中不诚实的证明者可以说服验证者一个错误的陈述。
- en: General examples
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的例子
- en: Let's look at the zero-knowledge proof system with few examples.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些零知识证明系统的示例。
- en: '**A card trickster**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**一名扑克魔术师**'
- en: Let's consider an example of a card trickster who claims that they know a trick
    where they can predict any card that was guessed by the spectator. In this example,
    the trickster is the prover, the spectator is the verifier, and the magic trick
    is the secret knowledge. The only way to prove that they know the trick is by
    performing the act. The trickster asks the spectator to think of a card. After
    the spectator thinks of a card, the trickster waves the magic wand and takes out
    a card. The spectator confirms that it was the chosen card, and they now believes
    that the trickster knows the trick. If the spectator still needs to confirm it,
    they can ask the trickster to perform the trick again.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个扑克魔术师的例子，他声称自己知道一种魔术，可以预测观众所猜的任意一张牌。在这个例子中，魔术师是证明者，观众是验证者，魔术是秘密知识。证明他们知道这个魔术的唯一方法是进行表演。魔术师要求观众想一张牌。观众想好一张牌后，魔术师挥动魔棒，拿出一张牌。观众确认这正是选中的牌，他们现在相信魔术师知道这个魔术。如果观众仍需确认，他们可以要求魔术师再次表演魔术。
- en: The example simulates the zero-knowledge proof system. The trickster is the
    prover, and the spectator is the verifier. The trickster proves that they know
    the trick without actually revealing the trick, which satisfies zero knowledge.
    If the trickster knows the trick, they will be always able to perform the act,
    thus proving the completeness. If the trickster falsely claims to know the trick,
    performing the trick would reveal their false claim. There is a small probability,
    though, that the trickster will predict the card without knowing the trick. The
    probability is 1/52 (as there are 52 cards in a deck). This probability is small,
    and it would be vanishingly small if the trick was performed multiple times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子模拟了零知识证明系统。魔术师是证明者，观众是验证者。魔术师证明他们知道这个魔术，而不实际透露魔术，这符合零知识要求。如果魔术师知道这个魔术，他们将永远能够表演，从而证明了完备性。如果魔术师虚假声称知道这个魔术，表演魔术将揭露他们的虚假声明。尽管有很小的可能性，魔术师会在不知道魔术的情况下预测对卡，概率是1/52（因为一副牌中有52张卡）。这个概率很小，如果多次进行魔术表演，这个概率将变得微乎其微。
- en: zk-SNARKs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zk-SNARKs
- en: '**zk-SNARK** stands for **Zero-Knowledge Succinct Non-Interactive Argument
    of Knowledge**. As the name suggests, it is a variant of zero-knowledge proofs
    in which you can prove the possession of secret information without the interaction
    between the prover and the verifier.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**zk-SNARK** 代表 **Zero-Knowledge Succinct Non-Interactive Argument of Knowledge**。正如其名，这是零知识证明的一个变种，其中你可以证明拥有秘密信息，而无需证明者和验证者之间的互动。'
- en: Many zero-knowledge proofs required the prover and verifier to communicate continuously
    by setting up a channel in order to prove the knowledge. Even the example considered
    earlier required the continuous participation of the prover and verifier. zk-SNARK
    has an initial setup phase where a common string called the public parameter is
    shared between the prover and verifier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 许多零知识证明需要证明者和验证者通过建立一个通道进行持续通信以证明知识。即使之前考虑的例子也需要证明者和验证者的持续参与。zk-SNARK 有一个初始设置阶段，在这个阶段中，证明者和验证者之间共享一个称为公共参数的公共字符串。
- en: Zcash uses a forked implementation ([https://github.com/zcash/libsnark](https://github.com/zcash/libsnark))
    of the `libsnarks` (implemented in C++) library to perform zk-SNARK operations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Zcash 使用了一个分叉的实现（[https://github.com/zcash/libsnark](https://github.com/zcash/libsnark)）的`libsnarks`（用C++实现）库来执行zk-SNARK操作。
- en: 'The zk-SNARK allows us to verify the correctness of the executed program without
    having to learn what was executed. Although the concept might sound simple, the
    internal working of the zk-SNARKs can be tricky to understand in the first glance.
    We will break down the implementation of zk-SNARKs into four main ingredients
    as suggested in the Ethereum blog:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: zk-SNARK允许我们在不必了解执行了什么的情况下验证已执行程序的正确性。虽然这个概念听起来很简单，但zk-SNARK的内部工作在第一眼看起来可能会很棘手。我们将根据以太坊博客的建议，将zk-SNARK的实现分解为四个主要因素：
- en: '**Construction of quadratic arithmetic programs** (**QAPs**): The validation
    performed by zk-SNARK on a transaction should return true or false without revealing
    any of the information. This is achieved by transforming the logic of the transaction
    into quadratic polynomial equations that can be evaluated without revealing sensitive
    information.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二次算术程序的构建**（**QAPs**）: zk-SNARK在交易上执行的验证应该返回true或false，而不泄露任何信息。这是通过将交易的逻辑转换为可以在不泄露敏感信息的情况下进行评估的二次多项式方程来实现的。'
- en: '**Evaluation at a random point to achieve succinctness**: The polynomials used
    in the equations can be quite large. Therefore, the polynomials are evaluated
    by the verifier at a randomly chosen point. The random point chosen by the verifier
    should be kept as secret. The prover might generate an invalid polynomial that
    will satisfy only the selected point if the random point is disclosed.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在随机点进行评估以实现简洁性**: 方程中使用的多项式可能相当大。因此，验证者会在随机选择的点上对多项式进行评估。验证者选择的随机点应保持秘密。如果泄露了随机点，则证明者可能会生成一个无效的多项式，该多项式仅在所选点上满足。'
- en: '**Homomorphic encryption**: zk-SNARK also uses homomorphic encryption techniques
    to evaluate the polynomials without knowing the secret point. Homomorphic encryption
    technique ensures that performing an operation on the polynomial is the same as
    performing on the secret point.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同态加密**: zk-SNARK还使用同态加密技术来评估多项式，而不知道秘密点。同态加密技术确保对多项式执行的操作与对秘密点执行的操作相同。'
- en: '**Zero knowledge**: The prover has to make sure that zero-knowledge is achieved
    so that the sensitive information is not revealed and, at the same time, the transaction
    can be evaluated.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零知识**: 证明者必须确保实现了零知识，以便不泄露敏感信息，同时可以评估交易。'
- en: Zcash transactions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zcash交易
- en: 'Zcash transactions involve senders and receivers, who can either have shielded
    or transparent addresses. A transaction can have any combination of addresses.
    A transaction with both transparent addresses is a public transaction, whereas
    a transaction with shielded addresses is private. In some cases, either the sender
    or receiver address can be shielded. If either end of the transaction was shielded,
    it requires the generation of a zero-knowledge proof:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Zcash交易涉及发送者和接收者，他们可以具有盲签或透明地址。交易可以具有任何地址组合。具有透明地址的交易是公开交易，而具有盲签地址的交易是私人交易。在某些情况下，发送者或接收者地址可以是盲签的。如果交易的任一端都是盲签的，则需要生成零知识证明：
- en: '![](img/c5778a5c-b152-4503-bd2d-f2d4de0bf6e5.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5778a5c-b152-4503-bd2d-f2d4de0bf6e5.png)'
- en: 'Figure 9.13: Zcash transaction with different types of address'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '图9.13: 具有不同类型地址的Zcash交易'
- en: If a user performs a transaction with a transparent address, all the unspent
    transaction outputs are visible to the public. A single shielded transaction address
    between any number of transactions involving transparent addresses can break the
    chain of the transaction. Thus it will be difficult to trace any transaction value
    back to the actual source. Even a small number of shielded addresses could result
    in a great deal of privacy in the blockchain network. Currently, Zcash has less
    than 5% of shielded transactions in their network, which still provides a good
    deal of privacy to its users.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户使用透明地址执行交易，则所有未花费的交易输出对公众可见。在涉及透明地址的任意数量的交易中间的单个盲签交易地址可以打破交易链。因此，将任何交易价值追溯到实际来源将变得困难。即使有少量的盲签地址，也可能在区块链网络中提供大量的隐私。目前，Zcash网络中不到5%的交易是盲签交易，这仍然为其用户提供了相当多的隐私。
- en: Since a transaction with shielded addresses needs to create a zero-knowledge
    proof, it requires more resources and time (up to 40 seconds). But the verification
    time is negligible, which is ideal for decentralization since every node performs
    verification. The resource and time cost for creating shielded transactions is
    negligible compared to the improved privacy provided by it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有隐蔽地址的交易需要创建零知识证明，因此需要更多的资源和时间（最长 40 秒）。但验证时间可以忽略不计，这对于分散化来说是理想的，因为每个节点都进行验证。与其提供的改进隐私相比，创建隐蔽交易所需的资源和时间成本可以忽略不计。
- en: Private transactions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私人交易
- en: 'The main intention of zero-knowledge proofs and its variant, zk-SNARK, is to
    make transactions private. In a plain transaction such as in Bitcoin, a transaction
    value is claimed with unspent outputs (UTXOs). Each UTXO is described by the public
    address of the owner and the value. Let''s consider that Alice has `1` bitcoin,
    which is represented by `UTXO[1]`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识证明及其变体 zk-SNARK 的主要目的是使交易私密化。在诸如比特币的普通交易中，通过未花费的输出（UTXOs）声明交易价值。每个UTXO由所有者的公共地址和价值描述。让我们假设Alice有`1`比特币，用`UTXO[1]`表示：
- en: '[PRE0]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`PK[1]` is the public key of Alice. A random number is also stored along with
    each UTXO, which is later used by Alice to maintain privacy:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`PK[1]`是Alice的公钥。每个UTXO后面还存储了一个随机数，后来Alice用这个随机数来保持隐私：'
- en: '[PRE1]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s now store the UTXOs in hashes for better privacy:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将UTXOs存储为哈希以获得更好的隐私：
- en: '[PRE2]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These hash values are stored on each node, even after they have been spent.
    So, to distinguish between spent and UTXOs, a separate list called a nullifier
    set is maintained.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哈希值在每个节点上都会被存储，即使已经花费。所以，为了区分已花费和UTXOs之间的区别，需要维护一个称为 nullifier set 的单独列表。
- en: 'Alice wants to transfer 1 bitcoin to Bob, whose public key is `PK[2]`. Alice
    creates a new UTXO addressed to Bob after spending `UTXO[1]`, which has a value
    of 1 bitcoin:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Alice想将1比特币转给公钥为`PK[2]`的Bob。在花费了`UTXO[1]`后，Alice为Bob创建了一个新的UTXO，其价值为1比特币：
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alice creates a nullifier to spend `UTXO[1]`, `nf[1] = HASH (r[1])`. She also
    creates a hash of the `UTXO[2]` and forwards it to all the public nodes (Carol
    in *Figure 9.14*), along with the nullifier, `nf[1]`. She also forwards the newly
    created `UTXO[2]` solely to Bob in a private channel as shown in *Figure 9.14*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 创建一个 nullifier 来花费 `UTXO[1]`，`nf[1] = HASH (r[1])`。她还创建了`UTXO[2]`的哈希值，并将其与
    nullifier `nf[1]` 一起转发给所有公共节点（卡罗尔在*图9.14*中）。她还根据*图9.14*将新创建的`UTXO[2]`仅发送给Bob的私人渠道：
- en: '![](img/d0bc9035-fc07-49c0-89f4-ff8fb02a2598.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0bc9035-fc07-49c0-89f4-ff8fb02a2598.png)'
- en: 'Figure 9.14: Exchanging transactions in Zcash'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '图9.14: Zcash中的交易交换'
- en: When Bob receives the hash of **UTXO[2]** and the nullifier, **nf[1]**, he makes
    sure that **UTXO[2]** hasn't already been spent by checking his local nullifier
    set. He adds **nf[1]** to the nullifier set if it doesn't already exist. Although
    Bob has verified that **UTXO[2]** is legitimate, he cannot be sure that it actually
    belongs to Alice. The only way to make sure that the UTXO actually belongs to
    Alice without revealing the secret key is with the help of zero-knowledge proof.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当Bob收到**UTXO[2]**的哈希值和 nullifier **nf[1]** 时，他通过检查本地的 nullifier set 来确保**UTXO[2]**尚未被花费。如果其不存在，他就将
    **nf[1]** 添加到 nullifier set 中。虽然Bob已经验证了**UTXO[2]**的合法性，但他无法确定**UTXO[2]**是否真的属于Alice。唯一能够确认UTXO实际属于Alice而不暴露密钥的方法，就是借助零知识证明。
- en: In addition to information forwarded by Alice, as shown in *Figure 9.14*, a
    zero-knowledge proof string, *π*, is also published to convince all the nodes
    that she knows about **PK[1]**, **sk[1]**, and **r[1]**, where **sk[1]** is the
    private key corresponding to **PK[1]**. Though the *π* string proves the knowledge,
    it will not reveal any of the secret information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Alice转发的信息之外，*图9.14*中还发布了一个零知识证明字符串*π*，以说服所有节点她知道关于**PK[1]**、**sk[1]**和**r[1]**的信息，其中**sk[1]**是与**PK[1]**对应的私钥。虽然*π*字符串证明了知识，但不会透露任何机密信息。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have investigated most of the optimization and enhancement
    techniques of blockchain for improving the scope of this technology. We began
    with the basic scalability issues of Bitcoin and proposed some solutions. We covered
    issues and proposed solutions for networking, consensus, and the application layer
    of the blockchain applications. Blockchain enhancement ideas were discussed later
    on in the chapter to explore future possibilities in the blockchain technology.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经调查了大多数优化和增强区块链技术的技术，以改进这项技术的范围。我们从比特币的基本可扩展性问题开始，并提出了一些解决方案。我们涵盖了区块链应用的网络、共识和应用层的问题，并提出了解决方案。本章后面还讨论了区块链技术的未来可能性，以探索区块链的增强想法。
- en: In the coming chapter, we will be discussing the security aspect of the blockchain
    technology in depth.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入讨论区块链技术的安全方面。
