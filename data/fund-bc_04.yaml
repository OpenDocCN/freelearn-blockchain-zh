- en: Networking in Blockchain
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链中的网络
- en: In the previous chapters, we covered the cryptography concepts that are essential
    for blockchain to function in a trustless network. But we haven't discussed what
    a trustless network is. A decentralized network facilitates a trustless environment.
    In this chapter, we will explore how blockchain achieves decentralization with
    **peer-to-peer** (**P2P**) networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了区块链在无信任网络中运行所必需的加密概念。但是我们还没有讨论无信任网络是什么。去中心化网络促进了无信任环境的形成。在本章中，我们将探讨区块链如何通过**点对点**（**P2P**）网络实现去中心化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: P2P networking
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2P网络
- en: Network discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络发现
- en: Block synchronization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块同步
- en: Building a simple blockchain in a P2P network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在P2P网络中构建简单的区块链
- en: We know that blockchain was created to remove the trust in a single central
    authority by building a trustless network that decentralizes all the tasks that
    are otherwise centralized in a single entity. P2P networking is an architecture
    style used to achieve this decentralization in blockchain applications. We'll
    begin this chapter by exploring the definition, history, and architecture of P2P
    networking.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道区块链是为了消除对单一中央机构的信任而创建的，它通过构建一个去中心化的网络来分散所有在其他情况下集中在单一实体中的任务。P2P网络是一种用于在区块链应用中实现这种去中心化的架构风格。我们将从探讨P2P网络的定义、历史和架构开始这一章节。
- en: Peer-to-peer (P2P) networking
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对点（P2P）网络
- en: The basic definition of a P2P network is a network where groups of independent
    computers called nodes are interconnected, sharing data without the assistance
    of any centralized servers. It is an architecture on top of the internet. Participants
    or nodes in this type of network are called peers because they are all equal and
    have equal responsibility within the network. Since there are no special nodes
    in a P2P network, each peer is both a service provider and a consumer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络的基本定义是一种网络，其中称为节点的独立计算机组成的群体相互连接，共享数据而无需任何集中式服务器的帮助。它是建立在互联网之上的架构。在这种类型的网络中，参与者或节点被称为对等方，因为它们都是平等的，在网络中具有平等的责任。由于在P2P网络中没有特殊节点，因此每个对等方既是服务提供者又是消费者。
- en: History of P2P network
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P2P网络的历史
- en: The early vision of the World Wide Web was aligned with the concept of P2P networking,
    where each user would be an active editor of and contributor to the network. USENET,
    first developed in 1979, enforced a decentralized model in which USENET servers
    communicated with each other to share news articles.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的万维网愿景与P2P网络的概念一致，其中每个用户都将成为网络的积极编辑和贡献者。USENET于1979年首次开发，强制执行了一种分散式模型，其中USENET服务器彼此通信以共享新闻文章。
- en: Although the P2P model was used in the early days of the internet, its most
    common use came about when it was implemented in file-sharing services. P2P in
    filesharing was popularized by the music-sharing application Napster. However,
    a number of music services followed that had a similar P2P filesharing model.
    Although Napster was the pioneer, filesharing in P2P has gained a lot of attention
    due to the BitTorrent protocol, which allows the filesharing of any digital media.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管P2P模型在互联网的早期阶段被使用，但它最常见的用途是在文件共享服务中实现。P2P在文件共享中的应用由音乐共享应用Napster推广开来。然而，许多音乐服务都采用了类似的P2P文件共享模型。尽管Napster是先驱，但P2P中的文件共享由于BitTorrent协议而受到了很多关注，该协议允许任何数字媒体的文件共享。
- en: P2P networking architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P2P网络架构
- en: P2P networking is an architecture where each peer acts as a server and a client
    simultaneously. Since a blockchain network is often implemented on a public network,
    it is difficult to create a physical topology that is suitable for P2P networking.
    To create this kind of architecture, a virtual or logical network overlay has
    to be constructed over the actual physical network topology. A logical network
    is created to achieve a convenient index of resources and peer discovery in a
    public network. Although an overlay is formed, data will be exchanged over the
    TCP/IP network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络是一种架构，其中每个对等方同时充当服务器和客户端。由于区块链网络通常在公共网络上实现，因此很难创建适合P2P网络的物理拓扑结构。为了创建这种架构，必须在实际物理网络拓扑结构上构建虚拟或逻辑网络覆盖。创建逻辑网络以在公共网络中实现资源索引和对等方发现的便利。虽然形成了覆盖网络，但数据将在TCP/IP网络上交换。
- en: 'Although the underlying physical network could follow any networking topology,
    the logical network in a P2P architecture will form a mesh-like topology in order
    to achieve better communication between the peers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管底层物理网络可以遵循任何网络拓扑，但P2P架构中的逻辑网络将形成网状拓扑，以实现对等方之间更好的通信：
- en: '![](img/7d365af3-ab3a-4f6b-b4a8-9b5abda893cd.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d365af3-ab3a-4f6b-b4a8-9b5abda893cd.png)'
- en: 'Figure 4.1: Partial physical mesh topology'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：部分物理网状拓扑
- en: In a physical mesh topology, each node can establish communication with any
    other peer, either directly or through some intermediate nodes. Each node will
    be able to communicate directly if the topology is a full mesh, where each node
    is linked to all the peers in the network. A partial mesh configuration is always
    preferable because constructing a full-mesh topology is expensive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理网状拓扑中，每个节点都可以与任何其他对等方建立通信，无论是直接还是通过一些中间节点。如果拓扑是全网状拓扑，那么每个节点都将能够直接通信，其中每个节点都连接到网络中的所有对等方。偏好部分网状配置，因为构建全网状拓扑是昂贵的。
- en: 'There are two main classifications of a P2P network, based on how the nodes
    are linked: **unstructured** and **structured P2P networks**.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的P2P网络分类，基于节点如何连接：**非结构化**和**结构化P2P网络**。
- en: In an unstructured network, the peers aren't linked to each other in an organized
    way. Each node is randomly connected to the peers, forming a logical mesh. It
    is easy to build unstructured networks, and they are very robust due to the redundant
    distribution of nodes. However, these networks have drawbacks, such as the possibility
    of request flooding, an effect caused by a lack of knowledge about the distribution
    of resources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在非结构化网络中，对等方之间没有以有组织的方式相连。每个节点是随机连接到对等方，形成一个逻辑网状。建立非结构化网络很容易，由于节点的冗余分布，它们非常健壮。然而，这些网络也有缺点，例如可能导致请求泛滥，这是由于对资源分布的缺乏知识引起的。
- en: A structured P2P network overlay is formed by following a specific network topology
    to make sure that nodes can efficiently perform activities on the network. Creating
    a structured network ensures that a resource can be fetched from somewhere on
    the network in a certain time. A **distributed hash table** (**DHT**) is a widely
    used structured network implementation that provides decentralized lookup service.
    Resource information in a DHT can be retrieved from hash tables using the key
    of a key/value pair stored in the table. The value associated with the key provides
    information about the peer that owns the resource. DHTs are also used in the BitTorrent
    filesharing protocol as a substitute for centralized lookup services, such as
    trackers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化P2P网络叠加是按照特定的网络拓扑形式形成的，以确保节点能够高效地在网络上执行活动。创建结构化网络可以确保资源可以在网络的某个地方在一定时间内被获取。**分布式哈希表**（**DHT**）是一个广泛使用的结构化网络实现，提供分散式查找服务。DHT中的资源信息可以使用哈希表从表中存储的键/值对的键来检索。与键相关联的值提供了拥有资源的节点的信息。DHT也被用于BitTorrent文件共享协议，作为对中心化查找服务（如跟踪器）的替代。
- en: DHT is a lookup service that is maintained in a distributed system. Nodes in
    a distributed system are responsible for maintaining the mapping from the keys
    to the values, which provide resource information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: DHT是在分布式系统中维护的查找服务。分布式系统中的节点负责维护从键到值的映射，提供资源信息。
- en: Now that we have an overview of the P2P networking architecture, let's dive
    into some of the concepts of blockchain technology that are used in P2P networks
    to form a decentralized blockchain network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了P2P网络架构的概述，让我们深入了解一些在P2P网络中用于构建分散式区块链网络的区块链技术概念。
- en: Network discovery
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络发现
- en: Network discovery in a P2P network is crucial. No network is defined when a
    new node boots up. The new node must detect at least one blockchain node to be
    a part of the network. There are several ways in which a node can identify peers
    and thus discover a network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络中的网络发现至关重要。当新节点启动时，没有定义网络。新节点必须检测到至少一个区块链节点才能成为网络的一部分。节点可以通过多种方式确定对等方，从而发现网络。
- en: Different blockchain frameworks use their own protocols to perform peer discovery
    and efficient routing. We're going to start by exploring basic P2P network discovery
    by taking a look at Bitcoin's original implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的区块链框架使用自己的协议进行对等发现和高效路由。我们将从探索比特币的原始实现开始，以了解基本的P2P网络发现。
- en: The simplest way to find the list of peers to connect to is by hardcoding a
    few of the well-known peers. Using a central server that maintains a list of peers
    is another approach. Bitcoin holds information about DNS seeds, which provide
    a high level of reliability when a node is initially set up, and will respond
    with a list of the IP addresses of the Bitcoin nodes. Once a seed node is detected,
    the node will establish a TCP connection to perform a handshake with that node.
    The handshake validates the node by sending the version, the address, local blockchain
    information, and any other relevant information.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找要连接的节点列表的最简单方式是在几个众所周知的节点中硬编码。使用维护节点列表的中央服务器是另一种方法。比特币保存了关于DNS种子的信息，这提供了节点在最初设置时的高可靠性，并且会以比特币节点的IP地址列表作为响应。一旦检测到种子节点，节点将建立TCP连接以与该节点握手。握手通过发送版本、地址、本地区块链信息和其他相关信息来验证节点。
- en: Once a connection is set up between peers that have been discovered by the node,
    the node can query for information about other nodes that are connected to its
    peer. Similarly, the node can broadcast its own address information to the connected
    peers to improve its reachability. Each node also makes sure to maintain a threshold
    for the number of active connections in order to avoid unnecessary bandwidth usage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点与被其发现的节点建立连接，节点就可以查询关于连接到其对等节点的其他节点的信息。同样地，节点可以将自己的地址信息广播给连接的对等节点，以提高其可达性。每个节点还确保保持一定数量的活动连接的阈值，以避免不必要的带宽使用。
- en: Some blockchain platforms, such as Ethereum, use a cryptographic P2P networking
    protocol suite called RLPx, which provides a general-purpose transport and interface
    for applications to communicate via a P2P network. RLPx utilizes a Kademlia-like
    routing to ensure uniform network formation. After the initial node handshake,
    packets are encapsulated as frames, which are then encrypted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些区块链平台，比如以太坊，使用了一个名为RLPx的密码P2P网络协议套件，它提供了一个通用的传输和接口，用于通过P2P网络进行应用程序通信。RLPx利用类似Kademlia的路由来确保网络的均衡形成。在初始节点握手后，数据包被封装为帧，然后进行加密。
- en: Block synchronization
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块同步
- en: Each node that joins the blockchain network needs to update its local copy of
    the blockchain to synchronize its state with the global state of the rest of the
    network. This is achieved by block synchronization. A node that needs to update
    its blockchain sends a message consisting of blockchain height information. Any
    peer that has a longer blockchain sends an inventory consisting of metadata about
    the fixed number of blocks that needs to be added to the host node. Now the node
    makes a request to all its peers to fetch individual blocks by referring to the
    inventory it received. The node should make sure not to flood the network with
    block requests by maintaining a cap on the number of block requests it sends.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 加入区块链网络的每个节点都需要更新其区块链的本地副本，以将其状态与网络其他部分的全局状态同步。这是通过区块同步实现的。需要更新其区块链的节点会发送一个包含区块高度信息的消息。任何拥有更长区块链的节点都会发送一个包含关于需要添加到主机节点的固定数量区块的元数据清单。现在节点通过引用收到的清单向所有对等节点发起请求，以获取单独的区块。节点应该确保在发送区块请求时不要让网络被大量区块请求所淹没。
- en: Block synchronization is a long process for a newly-joined node. However, once
    all the blocks are up to date, it can verify the information in the block, such
    as the transactions on assets. The block synchronization process can be reinitialized
    whenever the node comes online after being inactive.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 区块同步是对于新加入节点来说一个漫长的过程。然而，一旦所有的区块都更新到最新状态，它就能验证区块中的信息，比如资产上的交易。只要节点重新连接网络后变得活跃，区块同步过程就可以重新初始化。
- en: Building a simple blockchain in a P2P network
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在P2P网络中构建简单的区块链
- en: In [Chapter 3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml), *Cryptography in
    Blockchain*, we explored how a consensus can be achieved in a decentralized network
    with the help of algorithms such as proof-of-work. Since consensus algorithms
    ensure that the Byzantine failure problem can be solved, a global truth can be
    maintained in a decentralized network in which there is no trust between the peers.
    Although consensus algorithms provide a convenient way to maintain a public ledger,
    each node has to perform a set of operations to maintain the ledger in a distributed
    network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml)中，《区块链中的加密》，我们探讨了如何利用诸如工作证明等算法在去中心化网络中实现共识。由于共识算法确保了拜占庭失败问题可以得到解决，因此可以在对等方之间没有信任的去中心化网络中保持全局真相。尽管共识算法提供了一种方便的方法来维护公共分类帐，但每个节点都必须执行一组操作来在分布式网络中维护分类帐。
- en: We have already created a simple blockchain application that can continuously
    enlarge its records whenever we have new data to be inserted. Because our blockchain
    application was deployed and the blocks were created in a single system, we have
    not yet added any mechanisms to validate the blocks. But when we deploy the blockchain
    as a public ledger, blocks need to be verified at each node whenever they arrive
    from the node's peers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个简单的区块链应用程序，可以在有新数据需要插入时连续扩展其记录。因为我们的区块链应用程序是部署在单个系统中的，并且区块是在其中创建的，所以我们还没有添加任何验证区块的机制。但是当我们将区块链部署为公共分类帐时，每个节点在接收到来自节点对等方的区块时都需要对其进行验证。
- en: 'Each node has to perform the following processes in order to achieve a consensus
    in the network:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点必须执行以下过程以在网络中达成共识：
- en: Validate each incoming block for integrity so that it can be appended to the
    local blockchain
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证每个传入的区块以确保其完整性，以便将其附加到本地区块链中。
- en: Select the longest valid chain published by a peer in the decentralized network
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择去中心化网络中一个对等方发布的最长有效链。
- en: Create a valid block whenever there is some data that needs to be inserted into
    the public ledger
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当有一些数据需要插入公共分类帐时，就创建一个有效的区块。
- en: We're going to build a simple blockchain application that deploys the blockchain
    in a P2P network. This application is a reference implementation that will help
    us to understand the decentralization of the blockchain network. Although this
    application performs network discovery, block synchronization, and block validation,
    it doesn't follow all the required protocols for simplicity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个简单的区块链应用程序，将区块链部署在P2P网络中。该应用程序是一个参考实现，将帮助我们理解区块链网络的去中心化。尽管此应用程序执行网络发现、区块同步和区块验证，但为简单起见，它并未遵循所有必需的协议。
- en: Let's now explore a few of the design considerations we need to think about
    in order to build the application before we dive into its implementation. The
    following sections cover validation, block synchronization, and the basic interface
    design used in this application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在深入实施之前探讨一下构建应用程序时需要考虑的一些设计考虑因素。以下各节涵盖了在此应用程序中使用的验证、区块同步和基本接口设计。
- en: Validating a new block
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证新区块。
- en: Although blocks are created by a miner node after validating all the previous
    blocks in the chain, it is the responsibility of each node in the network to perform
    a block validation to ensure that the block can be appended to the local copy
    of the blockchain. Block validation is a simple process of checking whether the
    latest block has a pointer or hash reference pointing to the previous block. When
    a block includes complex data, such as a set of transactions, independent transactions
    have to be verified to validate the block. Since we will not be dealing with any
    complex data inside the block, verifying transactions is beyond the scope of this
    chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区块是由矿工节点在验证链中的所有先前区块后创建的，但每个网络中的节点都有责任执行区块验证，以确保该区块可以附加到本地区块链的副本中。区块验证是一个简单的过程，检查最新的区块是否具有指向上一个区块的指针或哈希引用。当一个区块包含复杂数据，例如一组交易时，必须验证独立的交易以验证该区块。由于我们将不处理区块内的任何复杂数据，因此验证交易超出了本章的范围。
- en: Selecting the longest chain
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最长的链。
- en: Finding a global truth in the decentralized network is a strenuous task, and
    a variety of consensus algorithms help to achieve it. The proof-of-work algorithm,
    discussed in the previous chapter, is the first and one of the best solutions.
    It ensures that the longest chain created has the most work contributed to it
    by legitimate nodes in the network. No consensus algorithm will be included in
    this application for the sake of simplicity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在分散网络中找到全局真相是一项艰巨的任务，各种共识算法有助于实现这一目标。在上一章中讨论的工作量证明算法是第一个也是最好的解决方案。它确保由网络中合法节点贡献的工作量最多的链被创建为最长链。出于简单起见，本应用将不包含任何共识算法。
- en: Conflict resolution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲突解决
- en: Although selecting a block may seem an obvious task, there will be situations
    when two or more nodes create a block at the same time that has different identities
    due to the different content included in its block. When a node receives different
    versions of a block of the same height, it will add one of them to the blockchain
    based on the order of arrival and either rejects the other or keeps it in a memory
    pool. Due to this, nodes in the network might end up with different versions of
    the blockchain. This is called a temporary fork or a soft fork.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管选择一个区块可能看起来是一个明显的任务，但会出现两个或更多节点同时创建一个由于其区块中包含的不同内容而具有不同标识的区块的情况。当一个节点接收到相同高度的不同版本的区块时，它将根据到达的顺序将其中一个添加到区块链中，然后拒绝另一个或将其保留在内存池中。由于这个原因，网络中的节点可能会拥有不同版本的区块链。这称为临时分叉或软分叉。
- en: A soft fork is a type of fork in a blockchain where two or more different versions
    of the blockchain are created due to simultaneous block creation, or some malfunction.
    This fork is temporary and is rectified as soon as a longer blockchain propagates
    through the network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 软分叉是区块链中创建两个或更多不同版本的区块链的一种类型，原因是由于同时创建区块或某些故障。这种分叉是暂时的，并在较长的区块链通过网络传播后立即纠正。
- en: '![](img/08049e4a-ed85-4f68-a274-443311d1c912.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08049e4a-ed85-4f68-a274-443311d1c912.png)'
- en: 'Figure 4.2: A block conflict caused by simultaneous block creation'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：由同时创建区块引起的区块冲突
- en: '*Figure 4.2* shows how two blockchains have been created due to the simultaneous
    creation of blocks of the same height. Both the blockchains have the same height
    and the same blocks, up to index **11**. But there are two different versions
    of block **12**. As we can see in the figure, one of the blocks has a hash that
    ends with **...bfa9779618ff**, and the other hash ends with **...bce8564de9a8**.
    Both blocks are valid because their previous hash value matches with the previous
    block''s hash, **...ea758a8134b1**. At this stage, one of the blocks will be inserted
    into the main chain, and the other will be rejected.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 展示了由于同时创建相同高度的区块而创建了两个区块链的情况。这两个区块链具有相同的高度和相同的区块，直到索引**11**。但是有两个不同版本的区块**12**。正如我们在图中所见，其中一个区块的哈希以**...bfa9779618ff**结尾，另一个哈希以**...bce8564de9a8**结尾。这两个区块都是有效的，因为它们的上一个哈希值与上一个区块的哈希值**...ea758a8134b1**相匹配。在这个阶段，其中一个区块将被插入到主链中，另一个将被拒绝。'
- en: Although the conflict has been resolved on one node, there will be no global
    truth of the blockchain throughout the network because other nodes may have decided
    to accept a different block. This will create a temporary fork in the blockchain,
    because some nodes have one version of the blockchain, and some have the other
    version.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个节点上的冲突已经解决，但是在整个网络中不会有区块链的全局真相，因为其他节点可能已经决定接受不同的区块。这将在区块链中创建一个临时分叉，因为一些节点拥有一个版本的区块链，而另一些节点拥有另一个版本。
- en: '![](img/c416e6ca-9e67-40a2-a294-5380c15bcfe2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c416e6ca-9e67-40a2-a294-5380c15bcfe2.png)'
- en: 'Figure 4.3: Resolving the conflict by accepting the longer chain'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：通过接受更长链解决冲突
- en: This temporary fork will not survive for a long time. As soon as a longer blockchain
    is created, and when a new block is appended to one of the chains, every node
    will reject the smaller blockchain and replace their blockchain with the longer
    one. *Figure 4.3* shows how the blockchain with the hash value **...bce8564de9a8**
    at index **12** will be accepted as it has increased its blockchain with an additional
    block, thus forming a longer chain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种临时分叉不会长时间存在。一旦创建了一个更长的区块链，并且当一个新的区块被附加到其中一个链上时，每个节点都将拒绝较小的区块链，并用更长的区块链替换自己的区块链。*图
    4.3*展示了在索引**12**处具有哈希值为**...bce8564de9a8**的区块链将被接受，因为它通过添加额外的区块增加了自己的区块链，从而形成了更长的链。
- en: Block exchange between peers
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点之间的区块交换
- en: Block exchange in this application is performed using both broadcasting query
    messages and blocks. A newly-joined node goes through an initial block synchronization
    process to update its local copy of the blockchain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本应用程序中，区块交换使用广播查询消息和区块来执行。新加入的节点经历一个初始块同步过程来更新其本地区块链的副本。
- en: Initial block synchronization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始块同步
- en: When a new node joins a network, it connects to one of the available peers in
    the network; it then tries to exchange its block information with the peer, and
    updates the local blockchain, if required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新节点加入网络时，它会连接到网络中的一个可用对等节点；然后尝试与对等节点交换其区块信息，并在需要时更新本地区块链。
- en: '![](img/549c5734-6e17-455a-a03a-3a76236875f1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/549c5734-6e17-455a-a03a-3a76236875f1.png)'
- en: 'Figure 4.4: Initial block synchronization'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：初始块同步
- en: The node sends a chain length or last block query message after connecting to
    the peer. Requesting the chain length is equivalent to requesting the last block
    to identify its index. If the received block cannot be appended to the local blockchain
    due the hash mismatch, then the node sends a message to its peer asking it to
    send all the blocks. The node can also broadcast a message requesting all the
    blocks to ensure that it receives the longest chain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 节点在连接到对等节点后发送链长度或最后一个块查询消息。请求链长度等同于请求最后一个区块以确定其索引。如果接收的区块由于哈希不匹配而无法附加到本地区块链中，则节点会向其对等节点发送消息，要求其发送所有区块。节点也可以广播一条消息，请求所有区块，以确保其接收到最长的链。
- en: Broadcasting scenarios
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播情景
- en: Nodes communicate with each other in a P2P network by setting up multiple one-to-one
    connections, because there is no single peer that is completely trustable. Maintaining
    multiple connections forces each node to broadcast any information to its connected
    peers in order to distribute data to the entire network and maintain the global
    truth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 节点通过建立多个一对一连接在P2P网络中相互通信，因为没有一个单一的对等节点是完全可信的。保持多个连接强制每个节点向其连接的对等节点广播任何信息，以便将数据分发到整个网络并保持全局真相。
- en: 'In our application, we will be broadcasting information for several scenarios,
    as shown in the state transition diagram depicted in *Figure 4.5*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将在图4.5中所示的状态转换图中展示的几种情况下广播信息：
- en: '![](img/a4c938a6-17a6-4aa1-9c78-bb07bd7a3db2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c938a6-17a6-4aa1-9c78-bb07bd7a3db2.png)'
- en: 'Figure 4.5: State transition diagram for broadcasting'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：广播的状态转换图
- en: 'A node in the network performs broadcasting in the following scenarios:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的节点在以下情况下执行广播：
- en: When a node creates a new block, it has to broadcast it to all its connected
    peers in order to spread the block's information
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个节点创建一个新区块时，它必须将其广播到其所有连接的对等节点，以传播区块的信息
- en: When a node receives a new block from its peer, it has to broadcast it in order
    to propagate the block in the P2P network
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当节点从其对等节点接收到一个新区块时，它必须广播该区块，以便在P2P网络中传播该区块
- en: When a node receives a block that doesn't fit with the current blockchain, it
    sends a query message to all its peers in order to find the longest chain
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当节点接收到一个与当前区块链不匹配的区块时，它会向其所有对等节点发送查询消息，以找到最长的链
- en: Application interfaces
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序接口
- en: 'The application provides two user interfaces: an HTTP API interface to access
    and manipulate blockchain information, and a WebSocket interface at all the nodes
    to achieve bidirectional communication by creating a long-lived channel:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序提供两个用户接口：一个HTTP API接口用于访问和操作区块链信息，以及在所有节点上使用WebSocket接口以创建一个长期的双向通信通道：
- en: '![](img/f7727fad-9068-4bae-b1f8-9ca76ae3fd74.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7727fad-9068-4bae-b1f8-9ca76ae3fd74.png)'
- en: 'Figure 4.6: Interfaces of the application'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：应用程序的接口
- en: Diving into the code
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: There are three different classes that form three separate parts of the application.
    The first one is `Server`, which will be dealing with the P2P communication on
    the blockchain network. The other two classes are `Blockchain` and `Block`, which
    were covered in the previous chapter and perform basic blockchain operations.
    The `Blockchain` class also performs enhanced functions in order to validate the
    blocks received from the peers, as discussed in the application architecture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序由三个不同的类组成，分别是`Server`，它将处理区块链网络上的P2P通信。另外两个类是`Blockchain`和`Block`，它们在上一章节中有所涉及，并执行基本的区块链操作。`Blockchain`类还执行增强功能以验证从对等节点接收的区块，如应用程序架构中所讨论的。
- en: The server interface
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器接口
- en: 'The server interface is created using a Python web server framework called
    `Sanic`, which helps to code the web server logic in an asynchronous way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接口是使用名为`Sanic`的Python Web服务器框架创建的，该框架有助于以异步方式编写Web服务器逻辑：
- en: 'Background: Sanic is a lightweight web server framework that can be used to
    build a high-speed web server. It supports asynchronous programming by supporting
    Shiny async request handlers. It makes use of an event loop called `uvloop` to
    achieve better performance.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 背景：Sanic是一个轻量级的Web服务器框架，可用于构建高速Web服务器。它支持通过支持Shiny异步请求处理程序来进行异步编程。它利用名为`uvloop`的事件循环来实现更好的性能。
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet of the `Server` class creates four REST API interfaces
    for displaying the blocks, mining (creating) a new block, displaying the node's
    current peers, and adding a new peer. We will be using endpoints created using
    the `add_route` methods to interact with our node.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server`类的上述代码片段创建了四个用于显示区块、挖掘（创建）新区块、显示节点当前对等体以及添加新对等体的REST API接口。我们将使用使用`add_route`方法创建的端点与我们的节点交互。'
- en: We will be using the WebSocket protocol to perform P2P communication between
    the nodes because it allows bidirectional communication between the connected
    nodes and maintains an active connection without creating too much load on the
    web server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用WebSocket协议在节点之间执行P2P通信，因为它允许连接节点之间的双向通信，同时保持活动连接而不会对Web服务器造成过大的负载。
- en: WebSocket is a communication protocol on top of TCP that provides a bidirectional
    communication channel, unlike HTTP. It can be used in P2P communication because
    both ends can send and receive messages simultaneously.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是建立在TCP之上的通信协议，提供了双向通信通道，不同于HTTP。因为双方都可以同时发送和接收消息，所以可以用于P2P通信。
- en: 'All the API interfaces defined in the preceding snippet invoke the following
    methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中定义的所有API接口都会调用以下方法：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding method implements the functionality required to generate a new
    block to append. Since it is an HTTP POST method, it accepts a parameter called
    `data`, which was sent in the HTTP request body. This data is used to create the
    new block. This method will broadcast the newly created block, as mentioned earlier
    in the application design section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法实现了生成用于追加新块所需的功能。由于它是一个HTTP POST方法，它接受一个称为`data`的参数，该参数在HTTP请求正文中发送。这些数据用于创建新块。如前所述，在应用程序设计部分，该方法将广播新创建的块。
- en: 'Blocks present in the local blockchain are formatted and returned by this method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本地区块链中存在的区块将通过此方法格式化并返回：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Whenever the user wants to add a peer explicitly, they will use the following
    interface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户想要显式添加一个对等体时，他们将使用以下接口：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method adds an asynchronous `connect_to_peers` task to the event loop of
    the web server. All the socket information of the connected peers are maintained
    for future broadcasting.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将一个异步的`connect_to_peers`任务添加到Web服务器的事件循环中。所有连接对等体的套接字信息都会被维护以供未来广播使用。
- en: 'The following implementation fetches address and port information from socket
    objects from all the peers that are maintained by the node after the initial connection:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的实现从节点在初始连接后维护的所有对等体的套接字对象中提取地址和端口信息：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `connect_to_peers` method initializes WebSocket connections with all known
    peers. This method is also invoked when a new peer is added using the HTTP interface.
    Initial block synchronization is performed using the `init_connection` function. `p2p-handler`
    is a WebSocket handler that listens to the connection. It creates a socket and
    performs block synchronization using `init_connection`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect_to_peers` 方法初始化与所有已知对等体的WebSocket连接。这个方法也在使用HTTP接口添加新对等体时被调用。使用`init_connection`函数执行初始块同步。`p2p-handler`是一个WebSocket处理程序，负责侦听连接。它创建一个套接字并使用`init_connection`执行块同步：'
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Socket information is removed when a peer gets disconnected:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当对等体断开连接时，套接字信息将被移除：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Block synchronization is performed by the `init_connection` method by sending
    a query message requesting the last block of the peer''s blockchain. It also adds
    a message handler that continuously listens to the messages from its peers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`init_connection`方法执行块同步，通过发送请求对等体的区块链最后一个块的查询消息。它还添加了一个消息处理程序，不断侦听来自对等体的消息：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The message handler on each node listens for three types of message. Two of
    them are query messages to which the node responds by querying the local blockchain.
    The `RESPONSE_BLOCKCHAIN` message is a response received from the query made by
    the local node. This message will be further processed by `handle_blockchain_response`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点上的消息处理程序监听三种类型的消息。其中两种是查询消息，节点会通过查询本地区块链来响应。`RESPONSE_BLOCKCHAIN` 消息是本地节点发出的查询的响应。
    这条消息将由 `handle_blockchain_response` 进一步处理：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following methods serialize the response data to be sent to the peer for
    its query message requests:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将响应数据序列化为要发送给对等节点的查询消息请求：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The entire blockchain is sent to the connected peer when it queries the blockchain:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当对等节点查询区块链时，整个区块链将被发送给连接的对等节点：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code snippet fetches the last block from the blockchain and formats
    it into JSON so it can be sent via the socket channel:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段从区块链中获取最后一个区块，并将其格式化为 JSON，以便通过套接字通道发送：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code snippets are the query request messages used to query connected
    peers for the blockchain:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是用于查询连接的对等节点以获取区块链的查询请求消息：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following method is invoked in the message handler that is continuously
    listening to the peer''s requests and responses. This method is invoked to process
    the blockchain information sent by the peers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在持续监听对等节点的请求和响应的消息处理程序中被调用。此方法被调用以处理对等节点发送的区块链信息：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the last index of the block is not greater than the local blockchain''s
    last index, it will be rejected because the node is only interested in the longest
    chain:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果区块的最后索引不大于本地区块链的最后索引，则会被拒绝，因为节点只对最长的链感兴趣：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last block received is appended to the local blockchain if it satisfies
    the hash conditions. If it is satisfied, then it''s broadcasted to all the peers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后接收的区块满足哈希条件，则将其附加到本地区块链。如果满足条件，则将其广播到所有节点：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the last block doesn't satisfy the hash condition, then the local blockchain
    may be behind by more than one block. The local copy will then be replaced with
    the received blockchain if it is a full chain. Otherwise, a message is broadcasted
    to query the entire blockchain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个区块不满足哈希条件，那么本地区块链可能落后一个以上区块。如果是完整的链，则本地副本将被接收的区块链替换。否则，将广播一条消息来查询整个区块链。
- en: 'When a node receives a blockchain that is longer than the current local copy,
    it will validate the entire blockchain and then replace the entire local blockchain:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点接收到比当前本地副本更长的区块链时，它将验证整个区块链，然后替换整个本地区块链：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `broadcast` method then sends all the requests and responses to every peer
    connected to the node through the established socket connection:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcast` 方法将所有请求和响应通过建立的套接字连接发送给与节点连接的所有对等节点：'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Block and blockchain interface
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块和区块链接口
- en: The `Block` and `Blockchain` class methods are similar to those used in the
    previous chapter to build a simple blockchain, with the only enhancement being
    the validation methods used to validate the received blocks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Block` 和 `Blockchain` 类方法与上一章中用于构建简单区块链的方法类似，唯一的增强功能是用于验证接收的区块的验证方法。'
- en: 'The following method is invoked to verify that every block is linked to its
    previous block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法被调用以验证每个区块是否链接到其前一个区块：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following condition validates the index of the new block:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件验证了新区块的索引：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This condition performs hash validation by comparing the hash values of the
    blocks:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件通过比较区块的哈希值来执行哈希验证：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This condition checks the integrity of the newly added block by calculating
    its digest:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件检查了新添加区块的完整性，通过计算其摘要：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following method is used to validate the entire blockchain when the node
    wants to replace the local blockchain with the one retrieved from its peer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点希望使用从对等节点检索的区块链替换本地区块链时，将使用以下方法来验证整个区块链：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This condition validates the hardcoded genesis block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件验证了硬编码的起源块：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Every block of the received blockchain is validated iteratively by invoking
    `is_valid_new_block`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `is_valid_new_block` 迭代验证收到的每个区块：
- en: Running the blockchain nodes
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行区块链节点
- en: 'Although each node has two handlers, one each for the HTTP and WebSocket interfaces.
    A single web server application instance is sufficient to serve both of them.
    *Sanic* uses `uvloop` as a scheduler. It asynchronously handles the requests:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个节点都有两个处理程序，一个用于HTTP接口，一个用于WebSocket接口。一个Web服务器应用程序实例足以为它们提供服务。*Sanic*使用`uvloop`作为调度程序。它异步处理请求：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The server application is instantiated, and a task is created to connect the
    node to `initialPeers`, which is hardcoded by each node. The application will
    use the default port to create a web server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序被实例化，并创建了一个任务来连接节点到`initialPeers`，这是每个节点硬编码的。应用程序将使用默认端口创建一个Web服务器。
- en: Each node will run the server application to join the network. As soon as the
    node connects to one of the peers, its blockchain syncs with the updated blockchain
    of the network.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都将运行服务器应用程序以加入网络。一旦节点连接到其中一个对等方，其区块链就会与网络的更新后的区块链同步。
- en: 'We''re now going to run the application by creating three node instances: node1,
    node2, and node3\. Node2 has node1 as its initial peer, and node3 has node2 as
    its initial peer. When we run all three node instances, they form a ring-like
    network.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过创建三个节点实例来运行该应用程序：node1、node2和node3。Node2将node1作为其初始对等方，而node3将node2作为其初始对等方。当我们运行所有三个节点实例时，它们将形成一个类似环形的网络。
- en: 'Let''s check the peer information of each node by calling the HTTP API endpoint
    `/peers` for each node:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用每个节点的HTTP API端点`/peers`，让我们检查每个节点的对等信息：
- en: '**Node1**: ["127.0.0.1:51160"]'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点1**：["127.0.0.1:51160"]'
- en: '**Node2**: ["127.0.0.1:3001","127.0.0.1:35982"]'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点2**：["127.0.0.1:3001","127.0.0.1:35982"]'
- en: '**Node3**: ["127.0.0.1:3002"]'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点3**：["127.0.0.1:3002"]'
- en: '`3001` is the port number assigned to node1\. Node2 has port number `3002`,
    and node3 has port number `3003`. The random port number is the port number of
    the peer that tried to communicate with the node2\. The preceding information
    clearly shows that node2 has added node1 as its peer and node3 has added node2
    as its peer.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`3001`是分配给node1的端口号。Node2的端口号是`3002`，node3的端口号是`3003`。随机端口号是试图与node2通信的对等方的端口号。前述信息清楚地显示，node2已将node1添加为其对等方，而node3已将node2添加为其对等方。'
- en: 'All the nodes return the following result when we invoke the `/blocks` HTTP
    API endpoint:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`/blocks` HTTP API端点时，所有节点都返回以下结果：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s mine a new block at node2 by using the `/mineBlock` HTTP API endpoint
    by sending a POST request with the payload `{"data": "created at node2"}`. Since
    all the nodes are interconnected, forming a mesh, each node will receive the newly
    broadcasted block and will update its local blockchain ledger. Now, each node
    reflects the following blockchain:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用`/mineBlock` HTTP API端点，通过发送带有载荷`{"data": "created at node2"}`的POST请求，在node2处挖掘一个新的区块。由于所有节点都相互连接，形成一个网格，每个节点都将接收到新广播的区块，并更新其本地区块链账本。现在，每个节点反映以下区块链：'
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Following this example: The entire P2P blockchain application can be found
    in the book''s GitHub repository. It has a configuration that can be used to set
    up a Docker cluster using Docker Compose. This will help you to set up any number
    of blockchain nodes on a single machine.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个示例：可以在该书的GitHub存储库中找到整个P2P区块链应用程序。它具有可用于使用Docker Compose设置Docker集群的配置。这将帮助您在单台机器上设置任意数量的区块链节点。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered the aspects of P2P networking that are used in blockchain
    applications by building a simple P2P application with basic functionalities.
    The basic architectural knowledge that you've gained from this chapter will help
    you to understand the advanced networking concepts used in some blockchain platforms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在区块链应用中使用的P2P网络方面，通过构建具有基本功能的简单P2P应用程序。本章获得的基本架构知识将帮助您理解一些区块链平台中使用的高级网络概念。
- en: Now that we have a strong background of the blockchain technology after covering
    several cryptography and networking concepts, we will get introduced to the original
    and one of the strongest use cases of blockchain technology – Cryptocurrency.
    In the next chapter, we will apply most of the concepts introduced till now to
    understand and implement the cryptocurrency use case.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在涵盖了几个密码学和网络概念之后对区块链技术有了扎实的背景，我们将介绍区块链技术的原始和最强大的用例之一 - 加密货币。在下一章中，我们将应用到目前为止介绍的大部分概念，以理解和实现加密货币的用例。
