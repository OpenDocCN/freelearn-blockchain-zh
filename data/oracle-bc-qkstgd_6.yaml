- en: Developing Solutions on Oracle Blockchain Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Oracle区块链平台上开发解决方案
- en: The previous chapter allowed you to experiment with doing rather than reading
    about doing, as it effectively demonstrated developing the samples. The preceding
    chapter offered in-depth facts on the **Oracle Blockchain Platform** (**OBP**)
    and taught the practicalities of translating network topology on OBP, creating
    network stakeholders, and configuring OBP instances. This concluding chapter delves
    into chaincode and covers details of chaincode development, including the language
    section, development tools, and development environment setup. This chapter also
    focuses on mapping asset models, operations, and developing chaincode functions
    and interfaces. It details the full life cycle of chaincode, from development
    to updates, including installation, initiation, testing, and versioning. It also
    demonstrates the full chaincode with a code base build on Go and Node.js. Endorsement
    policy, private data collections, and their functioning in concert with chaincode
    are also illustrated. This chapter also demonstrates chaincode testing via shim
    and REST endpoints and integrating client apps with business networks using SDK,
    REST, and events. Finally, it concludes with insights into chaincode, transactions,
    and channels by experimenting with the monitoring of business via chaincode logs
    and channel logs. The chapter covers topics such as setting up chaincode development,
    chaincode development, chaincode deployment, testing chaincode, and integrating
    client applications with blockchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章让您有机会实践而不是仅仅阅读，因为它有效地演示了开发示例。前面的章节提供了关于**Oracle 区块链平台**（**OBP**）的深入信息，并教授了在OBP上转换网络拓扑、创建网络利益相关者和配置OBP实例的实用性。本章探讨了链码，并包括链码开发的详细信息，包括语言部分、开发工具和开发环境设置。本章还着重于映射资产模型、操作以及开发链码的功能和接口。它详细描述了链码的完整生命周期，从开发到更新，包括安装、初始化、测试和版本控制。它还演示了基于Go和Node.js构建的完整链码代码库。背书政策、私有数据集以及它们与链码协作的工作也得到了阐述。本章还演示了通过shim和REST终点进行链码测试，并使用SDK、REST和事件将客户端应用程序与业务网络集成。最后，它通过实验监控链码日志和通道日志来总结了对链码、交易和通道的见解。该章涵盖了设置链码开发、链码开发、链码部署、测试链码以及将客户应用程序与区块链集成的主题。
- en: Setting up chaincode development
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置链码开发
- en: In this section, you will learn how to develop chaincode for the university
    use case that we used in previous chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习如何为我们在前几章中使用的大学场景开发链码。
- en: Choosing the language for development (GO, Node.js, or Java)
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择开发语言（GO、Node.js 或 Java）
- en: Programming skills are very much required to write chaincode. As blockchain
    has a distributed ledger, only the Go language was supported in the initial versions
    of **Hyperledger Fabric** (**HLF**). However, with the evolution of HLF, it now
    supports multiple languages and plans to add more in the future. As of Fabric
    version 1.3, it supports writing chaincode in Go, Node.js, and Java. To explore
    each of these, you can download samples from under the **Developer tools** tab
    in the OBP instance console.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编程技能对于编写链码非常重要。由于区块链具有分布式账本，因此在**Hyperledger Fabric**（**HLF**）的初始版本中仅支持Go语言。然而，随着HLF的发展，它现在支持多种语言，并计划在将来添加更多语言。在Fabric版本1.3中，它支持使用Go、Node.js和Java编写链码。要探索其中的每一种，您可以在OBP实例控制台的**开发工具**选项卡下下载示例文件。
- en: Tools for OBP solution development
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OBP解决方案开发工具
- en: This section equips you with the development tools and development environment
    details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分为您提供了开发工具和开发环境的详细信息。
- en: Development environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发环境
- en: OBP leverages HLF as its foundation, hence use the HLF documentation for help
    with writing valid chaincode. All the chaincode files should be packaged in a
    ZIP file and installed on OBP. If the chaincode is developed in the Go language
    and it has only one file, which is `.go`, then the packaging is optional. A standalone
    file can be installed on OBP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OBP以HLF作为其基础，因此在编写有效的链码时使用HLF文档进行帮助。所有的链码文件都应打包成ZIP文件并安装在OBP上。如果链码是用Go语言开发的，并且只有一个名为`.go`的文件，那么打包是可选的。一个独立的文件可以安装在OBP上。
- en: Development tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: There are no specific recommended tools from either HLF or OBP. A developer
    can use any tools, such as a text editor or an IDE such as NetBeans, VS Code,
    and so on. The choice of tool depends on the interest of the developer and the
    language selected for the chaincode development. It is always good to use an IDE
    for the development to avoid syntax errors, to format the code to be easy to read,
    and to make development easy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从HLF或OBP都没有具体推荐的工具。开发者可以使用任何工具，例如文本编辑器或IDE，如NetBeans、VS Code等。工具的选择取决于开发者的兴趣和为链码开发选择的语言。最好使用IDE进行开发，以避免语法错误，将代码格式化为易于阅读的形式，并使开发变得轻松。
- en: Chaincode development, for the sample use case in this book, is performed using
    **VS Code** (short for **Visual Studio Code**). VS Code is a source code editor
    from Microsoft, available for Windows, Linux, and macOS. It includes support for
    development, debugging, versioning, syntax highlighting, intelligent code completion,
    and code refactoring.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 针对本书中示例用例的链码开发是使用**VS Code**（简称**Visual Studio Code**）进行的。VS Code是微软推出的一款源代码编辑器，适用于Windows、Linux和macOS。它包括开发、调试、版本控制、语法高亮、智能代码补全和重构等功能支持。
- en: 'The following are a few screenshots of the chaincode file in VS Code for reference:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在VS Code中链码文件的一些截图供参考：
- en: 'Here is the source code window:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是源代码窗口：
- en: '![](img/31465fa1-bc10-4c9e-b61d-443f6374c27e.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31465fa1-bc10-4c9e-b61d-443f6374c27e.png)'
- en: VS Code source code window
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code源代码窗口
- en: 'Direct installations of plugins required:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要直接安装的插件：
- en: '![](img/b91022a8-4bb7-4155-8189-7d899e4ea208.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b91022a8-4bb7-4155-8189-7d899e4ea208.png)'
- en: VS Code Plugins direct installation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code插件直接安装
- en: 'There are multiple plugins available to install on VS Code for the selected
    language:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code上有多个可安装的插件供选择的语言：
- en: '![](img/4591fb21-7398-4367-884f-43e8988002fa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4591fb21-7398-4367-884f-43e8988002fa.png)'
- en: 'VS Code: plugins'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code：插件
- en: Mapping the asset model
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产模型映射
- en: 'Chaincode results in the creation of assets (key-value pairs) on the ledger,
    as HLF represents assets as key-value pairs. Assets state changes are recorded
    as transactions on the channel''s ledger. There are few ways to represent assets—in
    binary or JSON form. For the university use case in this book, two assets are
    defined:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 链码导致在账本上创建资产（键值对），因为HLF将资产表示为键值对。资产状态变化记录为通道账本上的交易。有几种表示资产的方式——二进制或JSON形式。对于本书中的大学用例，定义了两种资产：
- en: One for student information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于学生信息
- en: Another for the certificate generated
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个用于生成的证书
- en: This chapter includes the creation of basic assets and chaincode to enable quick
    learning of the development process. The inclusion of more assets and a comprehensive
    set of operations might lead to the investment of time in the modeling of the
    use case itself. Later, when you've experimented more with the use case, you can
    add more complexity to it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括创建基本资产和链码，以便快速学习开发过程。随着用例模型本身的建模，更多资产和全面的操作集的包含可能会导致时间投入增加。稍后，当您对用例进行更多实验时，可以为其增加更多复杂性。
- en: 'Using the Go language, the following are the definitions of the two assets:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go语言，以下是两种资产的定义：
- en: 'An asset to define a certificate receiver:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义证书接收者的资产：
- en: '| **Parameter** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `assetType` | The type of asset, for example, a receiver |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `assetType` | 资产类型，例如，接收者 |'
- en: '| `receiver_id` | The ID of a receiver/student |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `receiver_id` | 接收者/学生的ID |'
- en: '| `receiver_name` | The name of the receiver/student |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `receiver_name` | 接收者/学生的名称 |'
- en: '| `upload_org` | The organization/department of the certificate uploaded |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `upload_org` | 上传证书的组织/部门 |'
- en: 'An asset to define a certificate:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义证书的资产：
- en: '| **Parameter** | **Description** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `assetType` | The type of asset, for example, a certificate. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `assetType` | 资产类型，例如，证书。 |'
- en: '| `Cert_id` | The ID of the certificate. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_id` | 证书的ID。 |'
- en: '| `Cert_no` | The number of the certificate. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_no` | 证书的编号。 |'
- en: '| `Cert_name` | The name of the certificate. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_name` | 证书的名称。 |'
- en: '| `Cert_receiver` | The receiver of the certificate. This will be fetched from
    the ledger by the given `Cert_receiver_id` parameter. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_receiver` | 证书的接收者。这将根据给定的`Cert_receiver_id`参数从分类帐中获取。 |'
- en: '| `Cert_receiver_id` | The ID of the receiver/student to whom this certificate
    is assigned. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_receiver_id` | 被分配此证书的接收者/学生的ID。 |'
- en: '| `Cert_issuer` | The issuer of the certificate. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_issuer` | 证书的颁发者。 |'
- en: '| `Cert_industry` | The industry/department of the certificate. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_industry` | 证书所属行业/部门。 |'
- en: '| `Cert_create_time` | The time the certificate was created at. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_create_time` | 证书创建时间。 |'
- en: '| `Cert_update_time` | The time the certificate was changed if any changes
    are made. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_update_time` | 如果有任何更改，证书的更改时间。 |'
- en: '| `Cert_remark` | Remarks or comments on the certificate, if any. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_remark` | 证书的备注或注释，如果有的话。 |'
- en: '| `Cert_url_image` | The certificate image URL. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_url_image` | 证书图片 URL。 |'
- en: '| `Cert_learning_processing` | Certificate learning proceeding. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_learning_processing` | 证书学习进行中。 |'
- en: '| `Cert_status` | The status of the certificate. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Cert_status` | 证书的状态。 |'
- en: Chaincode is a software program (a group of smart contracts) or business logic
    that defines an asset and allows modifications to an asset (aka state changes).
    Any transaction (as allowed by chaincode) will result in a new set of an asset's
    key-value pair or the modification of an asset's key-value pair, or the deletion
    of an asset's key-value pair.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 链码是定义资产并允许对资产进行修改（也称状态变更）的软件程序（一组智能合约）或业务逻辑。任何交易（按照链码允许的）都会导致一组新的资产键值对的形成，或者修改资产的键值对，或者删除资产的键值对。
- en: Mapping operations
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射操作
- en: Chaincode (smart contracts) generates transactions that are distributed to every
    peer node in a network. Upon consensus, they are immutably recorded in the local
    copy of the ledger. Users use a client application or a dApp to invoke such transactions
    (aka operations). [Chapter 3](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml), *Delving
    into Hyperledger Fabric*, covers transactions in detail and also showcases examples
    of transaction flows. Notice that there are two types of transactions—deploy transactions
    and invoke transactions. A deploy transaction creates a new chaincode and results
    in the installation of chaincode on the blockchain business network, whereas an
    invoke transaction performs an operation on the installed and initiated chaincode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 链码（智能合约）生成的交易会分发到网络中的每个对等节点。经过共识后，它们将被不可变地记录在分类账的本地副本中。用户使用客户端应用程序或 dApp 调用这类交易（又称操作）。
- en: 'This table concentrates on the implementation of the invoke operations/transactions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格集中讨论调用操作/交易的实现：
- en: '| **Operation** | **Description** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '**操作** | **描述** |'
- en: '| `initReceiver` | Creates an entry of the certificate receiver (student) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `initReceiver` | 创建证书接收者（学生）的条目 |'
- en: '| `queryReceiverById` | Fetches the receiver details by the given receiver
    ID |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `queryReceiverById` | 通过给定的接收者 ID 获取接收者详情 |'
- en: '| `insertCertificateInfo` | Creates an entry for the certificate |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `insertCertificateInfo` | 创建证书条目 |'
- en: '| `queryCertificateBytId` | Fetches the certificate details by the given certificate
    ID |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `queryCertificateBytId` | 通过给定的证书 ID 获取证书详情 |'
- en: '| `getHistoryForRecord` | Gets a history of the receiver (student) information
    or certificate changes |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `getHistoryForRecord` | 获取接收者（学生）信息或证书变更的历史记录 |'
- en: '| `queryAllCertificates` | Fetches all certificates |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `queryAllCertificates` | 获取所有证书 |'
- en: '| `approveCertificate` | Changes the status of a certificate |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `approveCertificate` | 更改证书的状态 |'
- en: '| `del` | Marks delete on a receiver or certificate |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `del` | 在接收者或证书上进行标记删除 |'
- en: Take a look at [Chapter 3](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml), *Delving
    into Hyperledger Fabric*, to learn about more interesting aspects, such as concurrency
    checks, types of transactions (such as *ledger-query* and *ledger-update* transactions),
    transaction flow, and various other components involved in transactions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[第三章](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml)，“深入了解 Hyperledger Fabric”，了解更多有趣的方面，例如并发检查、交易类型（如*分类账查询*和*分类账更新*交易）、交易流程以及交易涉及的各种其他组件。
- en: Demystifying the craft of chaincode development
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密链码开发的技艺
- en: 'With HLF, chaincode must implement the chaincode interface in any of these
    languages: Go, Node.js, or Java. A chaincode developer can select any of these
    programming languages to develop in. Fabric''s shim package ([github.com/hyperledger/fabric/core/chaincode/shim](https://github.com/hyperledger/fabric/tree/release-1.4/core/chaincode/shim))
    is paramount in chaincode development.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLF中，链码必须使用以下任一种语言实现链码接口：Go、Node.js或Java。链码开发人员可以选择其中任何一种编程语言进行开发。Fabric的shim包（[github.com/hyperledger/fabric/core/chaincode/shim](https://github.com/hyperledger/fabric/tree/release-1.4/core/chaincode/shim)）在链码开发中至关重要。
- en: It provides support for all earlier languages. This package has two interfaces,
    which play a key role in the chaincode. The syntax of these interfaces and their
    methods may change, depending on the language, but their purpose is the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持以前的所有语言。该包有两个接口，在链码中发挥着关键作用。这些接口及其方法的语法可能会根据语言的不同而发生变化，但它们的目的是相同的。
- en: Essentially, when a transaction is received, these chaincode interfaces are
    called. Firstly, when a chaincode receives a transaction request, the `Init` method
    is invoked. This allows for the initialization of the application state. Subsequently,
    the `Invoke` methods are called when an invoke transaction is received to process
    any transaction proposals. Other interfaces that are used to modify the ledger,
    allowing invocations between chaincode, include the chaincode shim API called
    `ChaincodeStubInterface`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到交易时，这些链码接口被调用。首先，当链码接收到交易请求时，`Init`方法被调用。这允许初始化应用程序状态。随后，当接收到调用事务时，将调用`Invoke`方法来处理任何交易提案。用于修改分类帐的其他接口，允许链码之间的调用，包括称为`ChaincodeStubInterface`的链码shim
    API。
- en: Chaincode interfaces
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码接口
- en: 'Chaincode interface is mandatory to implement chaincode that has two methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 链码接口是实现具有两个方法的链码的必备条件：
- en: '`Init()`: This method will be invoked only once in the life of the chaincode,
    when the chaincode is instantiated or upgraded. This method helps to set up the
    initial state of the ledger, such as initializing any serial numbers. It expects
    the `ChaincodeStubInterface` object as input and returns the `peer.Response` object.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init()`:此方法在链码的生命周期中仅被调用一次，即在链码被实例化或升级时。此方法有助于设置分类帐的初始状态，例如初始化任何序列号。它期望将`ChaincodeStubInterface`对象作为输入，并返回`peer.Response`对象。'
- en: 'Syntax: `Init(stub ChaincodeStubInterface)`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`Init(stub ChaincodeStubInterface)`
- en: '`Invoke()`: This method will help to invoke the user transaction. You may have
    several operations in your code, but when a client sends a request to chaincode,
    it only comes to the `Invoke()` method and, from here, this method will dispatch
    to the corresponding transaction. This method also takes the input of the `ChaincodeStubInterface`
    object and returns the `peer.Response` object.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke()`:此方法将帮助调用用户事务。您的代码中可能有多个操作，但当客户端发送请求到链码时，它只会到达`Invoke()`方法，从这里，此方法将派发到相应的事务。此方法还接受`ChaincodeStubInterface`对象的输入，并返回`peer.Response`对象。'
- en: 'Syntax: `Invoke(stub ChaincodeStubInterface)`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`Invoke(stub ChaincodeStubInterface)`
- en: ChaincodeStubInterface
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码存根接口
- en: Interface to stub provides functions to access history and the state of the
    ledger via calls to peers. The `Invoke()` method is called for each transaction
    and it passes the function and the parameters as a `stub` input requested by the
    client. This interface facilitates many functions to interact with the ledger
    and makes chaincode development easy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Stub接口提供了通过对对等体的调用来访问历史和分类帐状态的函数。每个事务都会调用`Invoke()`方法，并将函数和参数作为客户端请求的`stub`输入传递。这个接口促进了许多与分类帐交互的功能，并使链码开发变得简单。
- en: Chaincode functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码函数
- en: '`ChaincodeStub` is implemented by the `fabric-shim` library. It is supplied
    to `ChaincodeInterface` and encapsulates the APIs between the chaincode implementation
    and the Fabric peer.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaincodeStub`由`fabric-shim`库实现。它提供给`ChaincodeInterface`，并封装了链码实现和Fabric对等体之间的API。'
- en: 'Although `stub` has many functions, this section lists a few of them that are
    frequently used:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`stub`有许多函数，但本节列出了一些经常使用的函数：
- en: '`getFunctionAndParameters() (string, []string)`: This method helps to get the
    function and the parameters from the `stub`. This method returns two values: the
    name of the function as a string and the parameters as a string array.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFunctionAndParameters() (string, []string)`:此方法有助于从`stub`中获取函数和参数。此方法返回两个值：作为字符串的函数名称和作为字符串数组的参数。'
- en: '`getState(key string) ([]byte, error)`: This method fetches data from the state
    ledger by the given key. It doesn''t read data from the ledger that has not been
    committed. It returns data as a byte array and error information if there is any.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState(key string) ([]byte, error)`: 此方法通过给定的键从状态分类帐中获取数据。它不会读取尚未提交的分类帐中的数据。如果有任何错误，它将返回数据作为字节数组和错误信息。'
- en: '`putState(key string, value []byte) (error)`: This method will put the given
    value in a transaction''s write set as a proposal. This doesn''t affect the ledger
    until the transaction is valid and successfully committed. This decision will
    be taken by Orderer. All the transaction data in the ledger is stored as a key-value
    pair only. This method takes two parameters: key—a unique string value for data,
    and value—a byte array of data to be stored in the ledger. This method returns
    the error parameter if there are any errors while executing. The same method can
    be used for both *insert* and *update*.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putState(key string, value []byte) (error)`: 此方法将给定值放入交易的写入集作为提案。直到交易有效且成功提交之前，它不会影响分类帐。这个决定将由Orderer做出。分类帐中的所有交易数据都仅存储为键值对。此方法接受两个参数：key——用于数据的唯一字符串值，value——要存储在分类帐中的数据的字节数组。如果在执行过程中出现任何错误，则此方法返回错误参数。相同的方法可以用于*插入*和*更新*。'
- en: '`delState(key string) error`: This method deletes the value of the given key
    from the ledger. As the data in the blockchain ledger cannot be deleted permanently,
    this method marks the data deleted and the block remains in the ledger. The input
    for this method is a key and it returns an error if there is one.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delState(key string) error`: 此方法从分类帐中删除给定键的值。由于区块链分类帐中的数据不能永久删除，因此此方法标记数据已删除，区块仍然保留在分类帐中。此方法的输入是一个键，如果有错误则返回错误。'
- en: '`getHistoryForKey(key string) (HistoryQueryIteratorInterface, error)`: This
    is a read-only method to fetch the history of committed transactions of the given
    key in the ledger along with the transaction ID and timestamp. This method takes
    the key as input and returns an iterator of the history records and errors if
    there were any.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHistoryForKey(key string) (HistoryQueryIteratorInterface, error)`: 这是一个只读方法，用于获取分类帐中给定键的已提交交易的历史记录，以及交易ID和时间戳。此方法以键作为输入，并返回历史记录和错误的迭代器，如果有的话。'
- en: '`getQueryResult(query string) (StateQueryIteratorInterface, error)`: This method
    executes a `rich` query against a state database. It is only supported for state
    databases that support rich queries, such as Oracle, ATP, or ADW. The input for
    this method is a query string in the native syntax of the underlying state database.
    This method returns an iterator of the result and errors if there were any.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueryResult(query string) (StateQueryIteratorInterface, error)`: 此方法针对状态数据库执行一个`丰富`查询。仅支持支持丰富查询的状态数据库，例如Oracle、ATP或ADW。此方法的输入是基础状态数据库的本机语法中的查询字符串。如果有任何错误，则此方法返回结果和错误的迭代器。'
- en: '`setEvent(name string, payload []byte) error`: This sets an event as a proposal
    on the response to be included in a transaction. Regardless of the validity of
    the transaction, the event will be available within the committed transaction
    block.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setEvent(name string, payload []byte) error`: 这将事件设置为要包含在交易中的响应中的提案。无论交易的有效性如何，事件都将在已提交的交易块中可用。'
- en: 'Along with the earlier important and highly used methods in the chaincode,
    the stub also has the following methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了链码中早期重要且常用的方法外，存根还具有以下方法：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Developing chaincode
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发链码
- en: This section covers the implementation in Golang. The following chaincode is
    developed in the Go language for the operations/transactions described in the
    preceding section, mapping operations using the assets mentioned in the preceding
    section's mapping asset model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分涵盖了在Golang中的实现。以下链码是使用Go语言开发的，用于在上一节中描述的操作/交易，使用上一节中的映射资产模型映射操作。
- en: Chaincode in Go
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言中的链码
- en: 'Let''s look at chaincode development in the Go language for the use case discussed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Go语言中用于讨论的用例的链码开发：
- en: '`import`: This section imports the required libraries:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import`: 此部分导入所需的库：'
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`type`: This will define the required asset structures:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`type`: 这将定义所需的资产结构：'
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`main`: This is the `main` method to start execution:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`: 这是`main`方法开始执行的地方：'
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Init`: This method is for initializing of chaincode while instantiating the
    chaincode:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Init`: 此方法用于初始化链码，同时实例化链码：'
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Invoke`: This method is for bypassing or executing the user transaction:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke`: 此方法用于绕过或执行用户事务：'
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`insertReceiver`: This method is for creating/inserting a student or receiver
    of the certificate into the chaincode state:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insertReceiver`：此方法用于将学生或证书接收者插入链码状态：'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`queryReceiverById`: This method fetches the receiver record by the given ID:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryReceiverById`：此方法通过给定的 ID 获取接收者记录：'
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`insertCertificate`: This method is for inserting new certificate information
    into the ledger state:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insertCertificate`：此方法用于将新证书信息插入账本状态：'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`queryCertificateById`: This method fetches the certificate details from the
    ledger state by the given certificate ID:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryCertificateById`：此方法通过给定的证书 ID 从账本状态中获取证书详细信息：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`approveCertificate`: This method is used for approving a certificate by an
    authority:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`approveCertificate`：此方法用于由授权机构批准证书：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`queryAllCertificates`: This method is used to query all certificates from
    the ledger state:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryAllCertificates`：此方法用于从账本状态查询所有证书：'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`getRecordHistory`: This method fetches the historical state transitions for
    a given key of a record:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getRecordHistory`：此方法获取给定记录的关键状态转换的历史记录：'
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`getQueryResultForQueryString`: This method executes the given `rich` query
    on the ledger state if required:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getQueryResultForQueryString`：如果需要，此方法在账本状态上执行给定的`rich`查询：'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`deleteRecord`: This method will mark the record deleted by the given key:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deleteRecord`：此方法将以给定的键标记记录为已删除：'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding chaincode can also be downloaded from the GitHub repository referenced
    in this book. The filename is `education.go`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书引用的 GitHub 存储库中也可以下载前述链码。文件名为`education.go`。
- en: Chaincode in Node.js
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 中的链码
- en: 'Let''s look at the procedure for developing chaincode in Node.js:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用 Node.js 开发链码的流程：
- en: Create a Node.js file using the `fabric-shim` package
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fabric-shim`包创建一个 Node.js 文件
- en: Create a `package.json` file with the details of the Node.js file and dependencies,
    if any
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含 Node.js 文件和依赖项详情的`package.json`文件（如果有的话）
- en: Package all the files in a ZIP file including `package.json`, the main Node.js
    file, and other JavaScript or config files or dependencies, if any
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有文件打包到一个 ZIP 文件中，包括`package.json`、主 Node.js 文件以及其他 JavaScript 或配置文件或依赖项（如果有的话）
- en: Deploy the package under the **Chaincode** tab in OBP (refer to the *Chaincode
    deployment* section)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OBP 的**Chaincode**选项卡下部署该包（参考*链码部署*部分）
- en: 'Note: You are only required to create a `package.json` file; there''s no need
    to run `npm` commands to install `node_modules`, as the OBP does this for you
    internally.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您只需创建一个`package.json`文件；无需运行`npm`命令来安装`node_modules`，因为 OBP 会在内部为您执行此操作。
- en: Sample Node.js file named `education.js`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`education.js`的示例 Node.js 文件。
- en: 'Create a Node.js file using the `fabric-shim` package:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fabric-shim`包创建一个 Node.js 文件：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sample JSON file named `package.json`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`package.json`的示例 JSON 文件。
- en: 'Create a `package.json` file with the details of the Node.js file and dependencies,
    if any:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含 Node.js 文件和依赖项详情的`package.json`文件（如果有的话）：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This sample Node.js code with the `package.json` file can be downloaded from
    the GitHub repository referenced in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从本书引用的 GitHub 存储库中下载带有`package.json`文件的示例 Node.js 代码。
- en: Adding events to chaincode
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向链码添加事件
- en: Chaincode can also post events to notify a subscribing application to process
    further client actions. For example, after purchase orders, invoices, and delivery
    records have been matched by chaincode, it can post an event so that a subscribing
    application can process related payments and update an internal ERP system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 链码还可以发布事件，以通知订阅应用程序进一步处理客户端操作。例如，在链码匹配采购订单、发票和交货记录后，它可以发布事件，以便订阅应用程序可以处理相关付款并更新内部
    ERP 系统。
- en: 'OBP supports the following types of events, which can be subscribed via a REST
    proxy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: OBP 支持以下类型的事件，可以通过 REST 代理订阅：
- en: '`transaction`: Events for a transaction ID'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction`：事务 ID 的事件'
- en: '`txOnChannel`: Events for every new transaction on a channel'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`txOnChannel`：通道上每个新事务的事件'
- en: '`txOnNetwork`: Events for every new transaction in the entire network'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`txOnNetwork`：整个网络中每个新事务的事件'
- en: '`blockOnChannel`: Events for every block on a particular channel'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockOnChannel`：特定通道上每个区块的事件'
- en: '`blockOnNetwork`: Events for the creation of a new block in the entire network'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockOnNetwork`：整个网络中新区块的事件'
- en: '`chaincodeEvent`: Custom events emitted by chaincode logic'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chaincodeEvent`：链码逻辑发出的自定义事件'
- en: Publishing events
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布事件
- en: 'Here, we''ll see how to trigger events from chaincode. Using the `SetEvent()`
    method of `ChaincodeStubInterface`, events can be triggered by chaincode. Add
    the following code in the `approveCertificate()` method to emit the event after
    the certificate status is changed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何从链码触发事件。使用 `ChaincodeStubInterface` 的 `SetEvent()` 方法，链码可以触发事件。在
    `approveCertificate()` 方法中添加以下代码以在证书状态更改后发出事件：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Subscribing to events
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅事件
- en: 'Events can be subscribed to via a REST proxy or HLF SDKs. The following is
    the procedure to subscribe via a REST proxy:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过 REST 代理或 HLF SDK 进行订阅。以下是通过 REST 代理订阅的步骤：
- en: 'REST endpoint: `<host name>:<port>/<REST proxy>/bcsgw/rest/v1/event/subscribe`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 端点：`<主机名>:<端口>/<REST 代理>/bcsgw/rest/v1/event/subscribe`
- en: 'REST method: `POST`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 方法：`POST`
- en: 'Headers:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头：
- en: '**Content-Type**: `application/json`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容类型**：`application/json`'
- en: '**Authorization**: `<Basic authorization>`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：`<基本授权>`'
- en: '**Accept-Charset**: `UTF-8`:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受字符集**：`UTF-8`：'
- en: '![](img/c80da958-6cf8-4012-8bc8-9352f6c0b2b4.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c80da958-6cf8-4012-8bc8-9352f6c0b2b4.png)'
- en: 'The JSON input to be passed to the REST API:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 REST API 的 JSON 输入：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It responds with `subid`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应为 `subid`。
- en: Unsubscribe from events
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅事件
- en: 'Events can also be unsubscribed. To do this, follow the same procedure as for
    subscription but replacing the endpoint and the input as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事件也可以取消订阅。要执行此操作，请按照订阅的相同步骤操作，但将端点和输入替换为以下内容：
- en: 'REST endpoint: `<host name>:<port>/<REST proxy>/bcsgw/rest/v1/event/unsubscribe`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 端点：`<主机名>:<端口>/<REST 代理>/bcsgw/rest/v1/event/unsubscribe`
- en: 'JSON input:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 输入：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Chaincode deployment
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码部署
- en: Chaincode deployment is a multistep process. It includes chaincode deployment
    (quick or advanced methods), chaincode instantiation, enabling chaincode in a
    REST proxy, and upgrading chaincode. Prerequisites to chaincode deployment on
    OBP include having administrative access to the OBP instance to deploy the chaincode.
    Chaincode can be installed and instantiated from any instance by either a founder
    or a participant of a channel. Once it is instantiated, other instances of the
    channel just need to install the chaincode. The instantiation will be applied
    automatically on those instances. In this section, we will deploy the chaincode
    from the founder instance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 链码部署是一个多步骤的过程。它包括链码部署（快速或高级方法）、链码实例化、在 REST 代理中启用链码以及升级链码。在 OBP 上部署链码的先决条件包括具有部署链码的
    OBP 实例的管理访问权限。链码可以由通道的创建者或参与者从任何实例安装和实例化。一旦它被实例化，通道的其他实例只需要安装链码。该实例化将自动应用于这些实例。在本节中，我们将从创建者实例部署链码。
- en: Deploying chaincode
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署链码
- en: OBP offers two different deployment options. A quick deployment option for one-step
    chaincode deployment and advanced deployment options. The quickstart deployment
    option is recommended for chaincode testing, while the advanced deployment option
    allows you to specify various advanced deployment settings such as choosing the
    peers on which the chaincode will be installed, the endorsement policy to use,
    and so on. This section shows both deployment options.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: OBP 提供了两种不同的部署选项。一种是一步链码部署的快速部署选项，另一种是高级部署选项。快速启动部署选项推荐用于链码测试，而高级部署选项允许您指定各种高级部署设置，例如选择要安装链码的对等方、要使用的背书策略等。本节展示了两种部署选项。
- en: 'The following is the procedure for deploying the chaincode:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 部署链码的步骤如下：
- en: 'Navigate to the **Chaincodes** tab:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **链码** 选项卡：
- en: '![](img/4db4164f-0975-4d0b-88a0-81649a32b905.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4db4164f-0975-4d0b-88a0-81649a32b905.png)'
- en: Chaincode deployment
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 链码部署
- en: 'Click on the **Deploy a New Chaincode** button. The following screen will be
    opened with two deployment options:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 **部署新链码** 按钮。将打开以下屏幕，其中包含两个部署选项：
- en: '![](img/311623f8-1794-49ca-873e-8500a598bd8c.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/311623f8-1794-49ca-873e-8500a598bd8c.png)'
- en: Chaincode deployment options
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 链码部署选项
- en: '**Quick Deployment**: The one-step chaincode deployment option uses default
    settings and is enabled in the selected REST proxies. However, we''ll use the **Advanced
    Deployment** option to deploy our chaincode in this section. The following is
    the screen for you to refer to for **Quick Deployment**:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快速部署**：一步链码部署选项使用默认设置，并在所选的 REST 代理中启用。然而，我们将在本节中使用 **高级部署** 选项来部署我们的链码。以下是您可以参考的 **快速部署** 屏幕：'
- en: '![](img/73cf994e-589a-4486-b2bf-cf0d4e5c91fd.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73cf994e-589a-4486-b2bf-cf0d4e5c91fd.png)'
- en: Quick chaincode deployment
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 快速链码部署
- en: '**Advanced Deployment** provides a multi-step wizard to install, instantiate,
    and enable the REST proxy for chaincode. Select this option from the **Deploy
    Chaincode** menu. The step-by-step wizard will be opened and the first step follows,
    where you provide details of the chaincode such as the chaincode name, version,
    target peers on which the chaincode should be deployed, and the actual chaincode
    package. (If it is a single `.go` file, then there''s no need for a package. The
    single file can be selected, but if it has multiple files or the code is written
    in Node.js or Java, then package all the files in a ZIP file.) Fill in the fields
    shown in the following screenshot and click on **Next**. Remember, none of these
    values can be altered after installing the chaincode:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高级部署**提供了一个多步骤向导，用于安装、实例化和启用链码的REST代理。从**部署链码**菜单中选择此选项。将打开逐步向导，第一步如下，您将提供链码的详细信息，如链码名称、版本、应部署链码的目标对等方以及实际链码包。
    （如果是单个`.go`文件，则不需要包。可以选择单个文件，但如果有多个文件或代码是用Node.js或Java编写的，则将所有文件打包成ZIP文件。）填写以下屏幕截图中显示的字段，然后单击**下一步**。请记住，安装链码后不能更改这些值：'
- en: '![](img/653905e5-68fa-4c08-8644-251267e4774b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/653905e5-68fa-4c08-8644-251267e4774b.png)'
- en: Details page
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 详细页面
- en: 'When the **Install** process is successful, the wizard will show step 2, which
    is **Instantiate**. The chaincode will be instantiated only once per channel per
    version. In this step, you specify which channel the chaincode should be applied
    to; the peers to participate; the array of the initial parameters if any, are
    to be passed to the `Init()` method in the chaincode; the endorsement policy,
    if any (see the next section for details on the endorsement policy); and the private
    data collection (see the next section for the details). Fill the form as follows
    and click **Next**; it may take a while to go to the next step:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**Install**过程成功后，向导将显示第二步，即**Instantiate**。每个通道每个版本只会实例化一次链码。在此步骤中，您指定应将链码应用于哪个通道；参与的对等方；初始参数数组（如果有）要传递给链码中的`Init()`方法；背书策略（如果有的话，请参阅下一节以了解背书策略的详细信息）；以及私有数据集合（请参阅下一节以了解详细信息）。填写表单如下并单击**下一步**；可能需要一段时间才能进入下一步：
- en: '![](img/42ed9ed8-59e2-44f2-9db1-80cdd361e2af.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42ed9ed8-59e2-44f2-9db1-80cdd361e2af.png)'
- en: Advance chaincode deployment
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 高级链码部署
- en: 'After the chaincode is instantiated successfully, the wizard will show step
    3, which is to enable the chaincode in a REST proxy. OBP provides multiple REST
    proxies. You can choose more than one REST proxy to enable the chaincode. Fill
    in the fields as follows and click **Next**:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链码成功实例化后，向导将显示第3步，即在REST代理中启用链码。OBP提供多个REST代理。您可以选择多个REST代理以启用链码。按照以下字段填写并单击**下一步**：
- en: '![](img/21abf370-14e6-4090-9b8c-ec5999f8c903.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21abf370-14e6-4090-9b8c-ec5999f8c903.png)'
- en: REST proxy
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: REST代理
- en: 'After completing all of the steps in the wizard, finally, you will see this
    success screen. Click on **Close**:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的所有步骤完成之后，最后，您将看到此成功屏幕。单击**关闭**：
- en: '![](img/ff21a041-da3e-495c-bc74-3c33246ff46a.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff21a041-da3e-495c-bc74-3c33246ff46a.png)'
- en: Deployment completion message
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成消息
- en: So far, you have deployed the chaincode in the founder instance. You need to
    deploy the chaincode in all the participant instances. Repeat the deployment process
    as we just saw; however, you just need to deploy the chaincode—instantiation will
    be applied automatically as it is done from the founder of the channel. So, in
    the **Advanced Deployment** wizard, after step 1 installation is done, in the
    step 2 screen, click on the **Close** button.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您已在创建者实例中部署了链码。您需要在所有参与者实例中部署链码。重复我们刚刚看到的部署过程；但是，您只需要部署链码——实例化将自动应用，因为它是从通道的创建者中完成的。因此，在**高级部署**向导中，在第1步安装完成后，在第2步屏幕上，单击**关闭**按钮。
- en: Go to the **Channels** tab. You will find that the chaincode is instantiated.
    Look at the following references.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**通道**选项卡。您将发现链码已实例化。请查看以下参考资料。
- en: 'The following is the channel before chaincode installation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安装链码前的通道：
- en: '![](img/2ae1b8ae-7227-4ee5-a4c5-1f6cce1889e7.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae1b8ae-7227-4ee5-a4c5-1f6cce1889e7.png)'
- en: Channel before chaincode installation
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 安装链码前通道
- en: 'The following screenshot is the channel after chaincode installation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了安装链码后的通道：
- en: '![](img/c3cc1db1-cb56-489a-9f62-a66e5eb628ff.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3cc1db1-cb56-489a-9f62-a66e5eb628ff.png)'
- en: Channel after chaincode installation
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装链码后通道
- en: Multiple chaincodes can be installed on a channel. Also, a chaincode can be
    enabled on multiple REST proxies.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通道上可以安装多个链码。此外，一个链码可以在多个REST代理上启用。
- en: Updating chaincode
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新链码
- en: HLF supports chaincode versioning and upgrading. You can update chaincode when
    a smart contract needs to be altered, the business logic is changed, or any changes
    are required in the chaincode. Chaincode can be upgraded to a new version, as
    long as you maintain the same name of the chaincode, else it will be considered
    different chaincode.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: HLF支持链码版本控制和升级。当智能合约需要更改、业务逻辑发生变化或链码需要任何更改时，您可以更新链码。只要保持相同的链码名称，就可以将链码升级到新版本，否则将被视为不同的链码。
- en: An update is a transaction on the blockchain network and it results in the binding
    of the new version of the chaincode to the channel. What happens to the old version
    of the chaincode? All of the other channels that are binding to the previous (old)
    version of the chaincode can continue to execute the older version. You submit
    the chaincode *upgrade* transaction to a channel. Hence, only one channel is affected,
    on which you have executed the upgrade transaction. All other channels, on which
    upgrade transaction is not executed, will continue to run the older version. When
    invoking chaincode, it's always the case that only the latest instantiated version
    will be executed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 更新是区块链网络上的一个交易，它导致将链码的新版本绑定到通道上。旧版本的链码会发生什么情况？绑定到以前（旧）版本链码的所有其他通道可以继续执行旧版本。您向通道提交链码*升级*交易。因此，只有一个通道受到影响，您已经执行了升级交易的通道。所有其他通道，在这些通道上未执行升级交易的情况下，将继续运行旧版本。调用链码时，只会执行最新实例化的版本。
- en: 'The procedure for updating the chaincode follows here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 更新链码的过程如下所示：
- en: Go to the **Chaincodes** tab.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**链码**选项卡。
- en: Select the **Upgrade** option under **More Actions** for the chaincode. A multi-step
    wizard will open.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对链码选择**升级**选项，位于**更多操作**下。将打开一个多步向导。
- en: 'In **Step 1 of 2: Select a version**, choose a target peers and browse the
    chaincode source package. Then click on **Next**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**第1步：选择版本**中，选择目标对等方并浏览链码源包。然后点击**下一步**：
- en: '![](img/091033ba-d8b9-4e70-a6dd-c6ebe5479676.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/091033ba-d8b9-4e70-a6dd-c6ebe5479676.png)'
- en: Upgrade chaincode—select version
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 升级链码-选择版本
- en: 'In **Step 2 of 2: Upgrade**, provide the channel name, the peers, the initial
    parameters, if any, and an endorsement policy, if any. Click on **Next**:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**第2步：升级**中，提供通道名称、对等方、初始参数（如果有）和背书策略（如果有）。然后点击**下一步**：
- en: '![](img/fa3ac110-2682-4566-97e0-cb4ab4e2dfd3.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa3ac110-2682-4566-97e0-cb4ab4e2dfd3.png)'
- en: Upgrade chaincode—instantiate information
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 升级链码-实例化信息
- en: 'After the chaincode is upgraded successfully, you will see the following screen.
    Click on **Close** and repeat the same procedure for other participants:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链码成功升级后，您将看到以下屏幕。点击**关闭**，然后为其他参与方重复相同的过程：
- en: '![](img/f8c86bdd-2424-4bfb-97f3-bcce5a68aca0.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8c86bdd-2424-4bfb-97f3-bcce5a68aca0.png)'
- en: Chaincode upgrade
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 链码升级
- en: Endorsement policy
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背书策略
- en: An endorsement policy specifies the organizations with peers that must properly
    approve or endorse a chaincode transaction before it's added to a block and submitted
    to the ledger. You can add an endorsement policy in OBP when you instantiate chaincode,
    which is step 2 in the chaincode deployment process. Endorsement guarantees the
    legitimacy of a transaction. If no endorsement policy is specified, then the default
    endorsement policy is used, which gets an endorsement from any peer on the network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 背书策略指定了必须在链码交易被添加到块并提交到账本之前正确批准或背书链码交易的具有对等方的组织。您可以在链码部署过程中的第2步实例化链码时在OBP中添加背书策略。背书保证交易的合法性。如果未指定背书策略，则使用默认背书策略，该策略从网络上的任何对等方获取背书。
- en: An organization's endorsing peer must have read-write permissions on the channel.
    When a transaction is processed, each endorsing peer returns a read-write set,
    then the client bundles these endorsing peers with their signatures and sends
    everything to the ordering service, which orders and commits the transactions
    into blocks and then to the ledger.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的背书对等方必须在通道上拥有读写权限。当处理交易时，每个背书对等方都返回一个读写集，然后客户端将这些背书对等方与它们的签名捆绑在一起，并将所有内容发送到排序服务，排序并提交交易到区块，然后到账本。
- en: 'In the following screenshot, you can see the endorsement policy configuration
    while instantiating the chaincode. You can simply specify in the Signed by field
    how many have to participate in the endorsement, or by selecting Advanced, you
    can specify this through an expression too. In our use case, we are using the
    default endorsement policy:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以在实例化链码时看到背书策略配置。您可以简单地在 Signed by 字段中指定有多少人必须参与背书，或者通过选择高级选项，也可以通过表达式指定这一点。在我们的用例中，我们正在使用默认的背书策略：
- en: '![](img/e8885b6c-0bf1-49e6-a4b9-57c399e5c2ab.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8885b6c-0bf1-49e6-a4b9-57c399e5c2ab.png)'
- en: Endorsement policy
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 背书策略
- en: Private data collection
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有数据集合
- en: OBP version 19.1.3 and later has a feature for specifying subsets of organizations
    that endorse, commit, or query private data on a channel—private data collections.
    Private data collections are useful if you want a group of organizations on the
    channel to share data and to prevent the other organizations on the channel from
    seeing the data. One or more private data collections can be associated when the
    chaincode is instantiated, shown as follows. Also, you should specify a transient
    map to pass the private data from the client to the peers for endorsement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: OBP 版本 19.1.3 及更高版本具有用于指定背书、提交或在通道上查询私有数据的组织子集的功能——私有数据集合。私有数据集合对于希望在通道上共享数据并防止通道上的其他组织看到数据的组织组是有用的。在链码实例化时可以关联一个或多个私有数据集合，如下所示。此外，您应该指定一个瞬态映射，以将客户端的私有数据传递给节点以进行背书。
- en: 'The following screenshot shows the **Private Data Collection** while instantiation
    of the chaincode:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了**私有数据集合**在链码实例化时的情况：
- en: '![](img/c0ef2f48-e729-4d89-94f8-7e3f4bf25d34.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0ef2f48-e729-4d89-94f8-7e3f4bf25d34.png)'
- en: Testing chaincode
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试链码
- en: 'A chaincode can be tested locally, without installing it on OBP. There are
    two ways to test chaincode: using mock shim and using REST endpoints.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 OBP 上本地测试链码，而无需安装它。有两种测试链码的方式：使用模拟的 shim 和使用 REST 端点。
- en: Testing chaincode using the shim
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 shim 测试链码
- en: 'Let''s see how to test the earlier chaincode developed locally in the Go language.
    Before that, here are some key points to note:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在本地开发的 Go 语言中测试之前的链码。在此之前，请注意以下要点：
- en: Install the Go language locally on your machine.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地计算机上安装 Go 语言。
- en: This test filename should take this form: `<Go file name>_test.go`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此测试文件名应采用此形式：`<Go file name>_test.go`。
- en: 'For example: if the chaincode name is `education.go`, then this test filename
    should be `education_test.go`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：如果链码名称为`education.go`，那么此测试文件名应为`education_test.go`。
- en: Keep both files in the same folder.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个文件放在同一个文件夹中。
- en: Set `GOPATH` to the folder.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `GOPATH` 设置为该文件夹。
- en: Install the dependent packages used in the chaincode if they can't be found.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到链码中使用的依赖包，请安装它们。
- en: 'For example: `go get github.com/hyperledger/fabric/protos/peer`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`go get github.com/hyperledger/fabric/protos/peer`
- en: '`go get github.com/hyperledger/fabric/core/chaincode/shim`.C'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get github.com/hyperledger/fabric/core/chaincode/shim`.C'
- en: 'Code snippet file `education_test.go` at the GIT repository ([https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide](https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide)),
    is a test case with an explanation for only one method: `initReceiver()`. Similarly,
    you can write test cases to all other methods.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码片段文件 `education_test.go` 位于 GIT 存储库 ([https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide](https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide))，是一个仅包含一个方法`initReceiver()`的测试用例，附带解释。同样，您可以为所有其他方法编写测试用例。
- en: Each test case should be prefixed with `Test<function name>`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试用例都应以`Test<function name>`为前缀。
- en: 'For example: `TestInitReceiver`.'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`TestInitReceiver`。
- en: 'After the test cases are ready, test them using the following command:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例准备好后，使用以下命令进行测试：
- en: '`go test -run <<function name>>`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test -run <<function name>>`'
- en: 'For example: `go test -run Education`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`go test -run Education`。
- en: Here, `Education` is the test case name.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Education`是测试用例名称。
- en: To test a function, create a stub using `NewMockStub()`. The stub has a `MockInvoke()`
    function, which invokes an actual function of chaincode.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个函数，使用 `NewMockStub()` 创建一个存根。该存根有一个`MockInvoke()`函数，它调用链码的实际函数。
- en: For example, `stub.MockInvoke("001",[][]byte{[]byte("insertReceiver "), []byte(key),[]byte("Anand
    Yerrapati"), []byte("Blockchain")})`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`stub.MockInvoke("001",[][]byte{[]byte("insertReceiver "), []byte(key),[]byte("Anand
    Yerrapati"), []byte("Blockchain")})`。
- en: Here, `001` is a transaction ID to be returned upon the success of this test
    and `insertReceiver` is a function to be invoked in the `education.go` file. The
    remaining are the parameters to be passed to the `insertReceiver` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`001` 是要在测试成功后返回的交易 ID，`insertReceiver` 是要在 `education.go` 文件中调用的函数。其余参数是要传递给
    `insertReceiver` 函数的参数。
- en: Refer file 'education_test.go' at the GIT repository "https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide-".
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 GIT 仓库中的文件 'education_test.go'，GIT 仓库网址为 "https://github.com/PacktPublishing/Oracle-Blockchain-Quick-Start-Guide-"。
- en: Test filename to test the chaincode (education.go), is test file "education_test.go".
    This file is referred in this section for testing chaincode using the shim.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试链码的测试文件名为 (education.go)，测试文件名为 "education_test.go"。在本节中，此文件用于通过 shim 测试链码。
- en: 'This test case is consolidated for flow, from inserting a receiver, querying
    the receiver, inserting a certificate, verifying the certificate, approving the
    certificate, and querying the certificate again, to verifying the changes. The
    following are the results of the earlier test case after executing the `go test
    -run Education` command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试案例是为了测试流程，从插入接收方、查询接收方、插入证书、验证证书、批准证书，再查询证书，最后验证更改。在执行 `go test -run Education`
    命令后，以下是早前测试案例的结果：
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mock stub doesn't support every function. You can't implement the `GetQueryResult`
    and `GetHistoryForKey` methods.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟存根不支持每个功能。无法实现 `GetQueryResult` 和 `GetHistoryForKey` 方法。
- en: Testing chaincode from REST endpoints
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 REST 端点测试链码
- en: OBP provides a REST proxy to connect chaincode via REST endpoints. Whichever
    chaincode you want to be executed via REST services should be configured on the
    respective REST proxy. This configuration can be seen in the *C**haincode deployment*
    section in this chapter. In this section, we see how to invoke the REST endpoints,
    how to connect to the required functions, and how to pass the parameters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: OBP 提供一个 REST 代理以通过 REST 端点连接链码。希望通过 REST 服务执行的任何链码应配置在相应的 REST 代理上。可以在本章 *链码部署*
    部分中查看此配置。在本节中，我们将看到如何调用 REST 端点，如何连接到所需的函数，以及如何传递参数。
- en: 'There are two REST endpoints available:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个可用的 REST 端点：
- en: '**Query**: To execute any function to query data from the ledger:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：执行从分类帐查询数据的任何功能：'
- en: 'Syntax: `<host name>:<port>/<restproxy>/bcsgw/rest/v1/transaction/query`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`<主机名>:<端口>/<restproxy>/bcsgw/rest/v1/transaction/query`
- en: '**Invocation**: To execute any function to save data to the ledger or query
    data from the ledger. The query could also be done from this endpoint, however,
    the execution would be slow to fetch and return the data. So, it is recommended
    to use the query endpoint in cases where you are fetching data from the ledger:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用**：执行保存数据到分类帐或从分类帐查询数据的任何功能。也可以从此端点执行查询，不过，获取和返回数据的速度会较慢。因此，在从分类帐提取数据时建议使用查询端点：'
- en: 'Syntax: `<host name>:<port>/<restproxy>/bcsgw/rest/v1/transaction/invocation`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`<主机名>:<端口>/<restproxy>/bcsgw/rest/v1/transaction/invocation`
- en: 'For both these endpoints, the request input is the same, which is a JSON request and
    the following is the typical structure of a JSON request:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个端点，请求输入相同，即为一个 JSON 请求，以下是一个典型的 JSON 请求结构：
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Multiple chaincodes can be configured in a single REST proxy. So, the **channel**
    and **chaincode** parameters in the input JSON help to dispatch the request to
    the corresponding chaincode. Both the endpoints are **POST** calls. Two headers,
    **Authorization** and **Content-Type**, should be passed in every call.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个 REST 代理中配置多个链码。因此，输入 JSON 中的 **通道** 和 **链码** 参数有助于将请求分发到相应的链码。两个端点都是 **POST**
    调用。每次调用都应传递两个标头，**授权** 和 **内容类型**。
- en: 'We are using the OBP SDK, which has a default username and password: `customertenant@oracle.com/`
    and `Welcome1`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 OBP SDK，其具有默认的用户名和密码：`customertenant@oracle.com/` 和 `Welcome1`。
- en: 'The header should look as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 标头应如下所示：
- en: '**Authorization** : `Basic Y3VzdG9tZXJ0ZW5hbnRAb3JhY2xlLmNvbTpXZWxjb21lMSA=`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：`Basic Y3VzdG9tZXJ0ZW5hbnRAb3JhY2xlLmNvbTpXZWxjb21lMSA=`'
- en: '**Content-Type**: `application/json`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容类型**：`application/json`'
- en: '**Target endpoint**: `https://<host name>:<port>/<restproxy>/bcsgw/rest/v1/transaction/<invocation
    or query>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标端点**：`https://<主机名>:<端口>/<restproxy>/bcsgw/rest/v1/transaction/<invocation
    或 query>`'
- en: These are references to test the earlier chaincode from Postman (you can use
    any REST client here for testing). The following are target endpoint invocation
    input -
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于从 Postman 测试早期链码的参考（您可以在此处使用任何 REST 客户端进行测试）。以下是目标端点调用的输入 -
- en: 'Target endpoint – invocation to insert receiver:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 插入接收方的调用：
- en: 'Target endpoint: `/invocation`'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/invocation`
- en: 'Target method: `insertReceiver`'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`insertReceiver`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"insertReceiver","args":["std123",
    "Anand Yerrapati", "Blockchain"]}`'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"insertReceiver","args":["std123",
    "Anand Yerrapati", "Blockchain"]}`
- en: '![](img/8ee13f0c-47bd-4e05-bee4-c6a2a8ccef02.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ee13f0c-47bd-4e05-bee4-c6a2a8ccef02.png)'
- en: 'Target endpoint—query to query by receiver ID:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 查询按接收者ID查询：
- en: 'Target endpoint: `/query`'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/query`
- en: 'Target method: `queryReceiverById`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`queryReceiverById`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"queryReceiverById","args":["std123"]}`'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"queryReceiverById","args":["std123"]}`
- en: '![](img/7c48fa8d-44a1-4dad-8695-b922b57835b5.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c48fa8d-44a1-4dad-8695-b922b57835b5.png)'
- en: 'Target endpoint – invocation to insert certificate:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 插入证书的调用：
- en: 'Target endpoint: `/invocation`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/invocation`
- en: 'Target method: `insertCertificate`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`insertCertificate`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"insertCertificate","args":["cert1234","1234","ORU
    Blockchain Certificate","std123","ORU","IT","6/5/2019","","Blockchain Course Completed","","","Issued"]}`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"insertCertificate","args":["cert1234","1234","ORU
    Blockchain Certificate","std123","ORU","IT","6/5/2019","","Blockchain Course Completed","","","Issued"]}`
- en: '![](img/963ddb92-910d-4a07-9397-188f6bcb979a.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/963ddb92-910d-4a07-9397-188f6bcb979a.png)'
- en: 'Target endpoint – invocation to query certificate by ID:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 通过ID查询证书的调用：
- en: 'Target endpoint: `/query`'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/query`
- en: 'Target method: `queryCertificateById`'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`queryCertificateById`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"queryCertificateById","args":["cert1234"]}`'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"queryCertificateById","args":["cert1234"]}`
- en: '![](img/5ed4b05f-82c6-4f84-bc6e-d16be147637d.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ed4b05f-82c6-4f84-bc6e-d16be147637d.png)'
- en: 'Target endpoint – invocation to approve certificate:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 批准证书的调用：
- en: 'Target Endpoint: `/invocation`'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/invocation`
- en: 'Target method: `approveCertificate`'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`approveCertificate`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"approveCertificate","args":["cert1234","Approved","6/5/2019
    05:04:45 PM"]}`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"approveCertificate","args":["cert1234","Approved","6/5/2019
    05:04:45 PM"]}`
- en: '![](img/42e52fa9-cc0e-4655-844c-049107a198cf.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42e52fa9-cc0e-4655-844c-049107a198cf.png)'
- en: 'Target endpoint – invocation to query certificate by ID:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 通过ID查询证书的调用：
- en: 'Target endpoint: `/query`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/query`
- en: 'Target method: `queryCertificateById`'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`queryCertificateById`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"queryCertificateById","args":["cert1234"]}`'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"queryCertificateById","args":["cert1234"]}`
- en: '![](img/31f5a98b-f1c6-4dce-a5aa-f552b3ecce0a.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31f5a98b-f1c6-4dce-a5aa-f552b3ecce0a.png)'
- en: 'Target endpoint – invocation to query all certificates:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 查询所有证书的调用：
- en: 'Target endpoint: `/query`'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/query`
- en: 'Target method: ``queryAllCertificates``'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：``queryAllCertificates``
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"queryAllCertificates","args":[]}`'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"queryAllCertificates","args":[]}`
- en: '![](img/1551a71e-38cc-460b-a5ee-9f3efb67391c.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1551a71e-38cc-460b-a5ee-9f3efb67391c.png)'
- en: 'Target endpoint – invocation to query endpoint to get record history:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点 - 查询端点以获取记录历史的调用：
- en: 'Target endpoint: `/query`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标终点：`/query`
- en: 'Target method: `getRecordHistory`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方法：`getRecordHistory`
- en: 'Input JSON: `{"channel":"channeleducation","chaincode":"cceducation","method":"getRecordHistory","args":["cert1234"]}`'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入JSON：`{"channel":"channeleducation","chaincode":"cceducation","method":"getRecordHistory","args":["cert1234"]}`
- en: '![](img/438a98d4-24b1-4550-8b7f-53910e01dce4.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/438a98d4-24b1-4550-8b7f-53910e01dce4.png)'
- en: 'The following is the response of `getRecordHistory`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`getRecordHistory`的响应：
- en: '![](img/9f5ddc22-576a-47fa-9fde-287f0ab8dad1.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f5ddc22-576a-47fa-9fde-287f0ab8dad1.png)'
- en: Response message
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 响应消息
- en: Chaincode logs
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链代码日志
- en: 'Logs are available for the system generated print statements given in chaincode.
    In OBP, these logs can be downloaded or viewed inline. Also, we can choose logs
    for the selected peer or the logs for a selected chaincode version. You can access
    the log files for a chaincode execution on the peer on which the chaincode is
    deployed. The following is the procedure to open the log files:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 链码中给出的系统生成的打印语句的日志可供查看。在OBP中，这些日志可以下载或内联查看。此外，我们可以选择所选对等方的日志或所选链码版本的日志。您可以访问部署了链码的对等方上的链码执行的日志文件。以下是打开日志文件的步骤：
- en: Go to the **Chaincodes** tab and locate the chaincode that you want to view
    the log of
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**链码**选项卡并找到您想要查看日志的链码。
- en: Expand the chaincode
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开链码。
- en: Click on the chaincode version that you want—the version information will be
    displayed
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击您想要的链码版本 - 将显示版本信息
- en: On the **Installed on Peers** tab, locate the peer
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**已安装在对等方**选项卡上，找到对等方
- en: Click on the **Log** link and the **View Chaincode Log** dialog will be opened
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**日志**链接，将打开**查看链码日志**对话框
- en: 'You can also open log files by selecting the **Logs** tab of a specified peer
    under the **Nodes** tab, as shown in the following screenshot:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过选择**节点**选项卡下指定对等方的**日志**选项卡来打开日志文件，如下图所示：
- en: '![](img/87d995f6-55a5-48e6-bb1d-70ba9065832f.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87d995f6-55a5-48e6-bb1d-70ba9065832f.png)'
- en: Chaincode logs
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 链码日志
- en: Channel ledger
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道账本
- en: The **ledger** is the ultimate storage for all of the transaction blocks of
    the blockchain network. Each channel has its own ledger which is common to all
    of the organizations in the channel. Organizations can have read, write, or both
    permissions on the ledger to handle transactions. The ledger can be queried or
    updated only through chaincode. OBP has an option in its console to view the blocks
    on the ledger of a channel. Each block on the ledger stores the transaction ID,
    the chaincode name, the status, the function name, the initiator of the transaction,
    the endorser, and the list of arguments. You can also see the total number of
    blocks and the count of the total user transactions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**账本**是区块链网络所有交易区块的最终存储。每个通道都有自己的账本，对通道中的所有组织都是公共的。组织可以对账本拥有读取、写入或两者权限来处理交易。账本只能通过链码进行查询或更新。OBP在其控制台中提供了一个选项，可以查看通道上的账本上的区块。账本上的每个区块都存储了交易ID、链码名称、状态、函数名称、交易的发起者、背书人和参数列表。您还可以看到总区块数和总用户交易数的计数。'
- en: 'By following this procedure, you can see the data on the ledger of a channel:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照这个步骤，您可以查看通道账本上的数据：
- en: Go to the **Channels** tab
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**通道**选项卡。
- en: Locate the channel you want and click on the channel name
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位您想要的通道并单击通道名称。
- en: Under the **Ledger** tab, you can see all the block transactions of the channel
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**账本**选项卡下，您可以查看通道的所有区块交易。
- en: 'Select any transaction to see its details, as shown in the following screenshot:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何交易以查看其详细信息，如下面的屏幕截图所示：
- en: '![](img/2b4e5788-4d50-472f-b68c-feffbfbbf3c1.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b4e5788-4d50-472f-b68c-feffbfbbf3c1.png)'
- en: Integrating client applications with blockchain
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将客户端应用程序与区块链集成
- en: 'So far, we have explored OBP and experimented with the development, deployment,
    and testing of chaincode on OBP. This section is a recap of the *Integration architecture* section
    of [Chapter 3](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml), *Delving into Hyperledger
    Fabric*. The following integration architecture diagram highlights three integration
    options with OBP: REST, SDK, and events.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了OBP并对在OBP上开发、部署和测试链码进行了实验。本节是[第3章](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml)中*深入探讨
    Hyperledger Fabric*节的复习，以下集成架构图突出了与OBP的三种集成选项：REST、SDK和事件。
- en: 'When building and integrating a client with OBP using REST APIs—refer to the *Testing
    chaincode from REST endpoints* section*—*ithelps to understand the use of REST
    endpoints to invoke chaincode transactions. REST endpoints can be integrated with
    the client applications and can execute them by passing the respective headers,
    such as authorization, Content-Type, and the input JSON, including the mandatory
    channel name and chaincode name fields and the required arguments. The response
    is also a REST JSON, which should be handled in the client application. For connecting
    blockchain using client SDK, REST APIs are provided by OBP. REST APIs allows flexibility
    to invoke, query, and view the status of a transaction. However, if much more
    fine-grained operations are required in applications, then the HLF SDK is an alternative
    approach:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 REST API 与 OBP 构建和集成客户端时——参考*从 REST 端点测试链码*部分*——了解使用 REST 端点调用链码事务的用途是很有帮助的。REST
    端点可以与客户端应用程序集成，并通过传递相应的头部（例如授权、内容类型以及包括强制性频道名称和链码名称字段以及所需参数在内的输入 JSON）来执行它们。响应也是
    REST JSON，应该在客户端应用程序中处理。对于使用客户端 SDK 连接区块链，OBP 提供了 REST API。REST API 允许灵活地调用、查询和查看交易的状态。但是，如果应用程序需要更加精细的操作，那么
    HLF SDK 是一种替代方法：
- en: '![](img/9d397ccf-7bb3-4d6d-941b-f35b870f70c0.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d397ccf-7bb3-4d6d-941b-f35b870f70c0.png)'
- en: Integration architecture
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 集成架构
- en: Refer to the *Integration architecture* section of [Chapter 3](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml), *Delving
    into Hyperledger Fabric,* for a sample-based integration strategy for applications
    with blockchain.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第 3 章](6aaa9b0a-84b6-4fca-82c3-864e22d616b0.xhtml)的*深入研究 Hyperledger Fabric*中的*集成架构*部分，了解应用程序与区块链的基于样本的集成策略。
- en: Running an end-to-end flow
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行端到端流程
- en: 'This section is a quick recap of the learning in this chapter:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是本章学习的快速回顾：
- en: '![](img/5d6720f7-ae87-432a-a1eb-50302d4123ad.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d6720f7-ae87-432a-a1eb-50302d4123ad.png)'
- en: End-to-end flow
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端流程
- en: 'The following is a list of the steps executed so far while exploring the university
    use case and engaging with OBP to experiment with the development process on OBP:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在探索大学用例并与 OBP 合作尝试在 OBP 上开发流程中执行的步骤列表：
- en: Identified who is a founder of the blockchain network (in our case, it is OEU)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定了区块链网络的创始人（在我们的案例中，是 OEU）
- en: Found the participant organizations of the network (in our case, it is CVS and
    ORS)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现了网络的参与者组织（在我们的案例中是 CVS 和 ORS）
- en: Created a founder and two participant instances in OBP
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OBP 中创建了一个创始人和两个参与者实例
- en: Exported the Orderer certificate of the founder
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出了创始人的 Orderer 证书
- en: Imported the Orderer certificate to the network tab of both participant organizations
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Orderer 证书导入到两个参与者组织的网络选项卡中
- en: Exported the network certificate of each participant organization
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出了每个参与者组织的网络证书
- en: Added both the organizations' certificates to the founder network
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个组织的证书添加到创始人网络中
- en: 'Created a channel, `channeleducation`, in the founder for all three organizations:
    the founder and the two participants'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创始人中为所有三个组织创建了一个通道，`channeleducation`。
- en: Joined peers to the channel in the founder as well as in the participants
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创始人和参与者中的通道中加入了对等体
- en: Exported the peers of each participant and imported them to the founder (this
    may require you to see the consolidated topological view of all the peers of a
    network; however, this step is required for the organizations participating in
    endorsement)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出了每个参与者的对等体，并将其导入到创始人中（这可能需要您查看网络所有对等体的综合拓扑视图；然而，此步骤对于参与背书的组织是必需的）
- en: 'Installed and instantiated chaincode (chaincode name: `cceducation`) in the
    founder'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创始人中安装和实例化链码（链码名称：`cceducation`）
- en: Installed the chaincode in other participants
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他参与者中安装了链码
- en: Enabled/configured REST proxies to the chaincode in all of the organizations
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用/配置 REST 代理以访问所有组织的链码
- en: Used the respective organization's REST endpoints to connect to client applications
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各自组织的 REST 端点连接到客户端应用程序
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered details about chaincode development such as the language
    section, development tools, and development environment setup. It detailed the
    full life cycle of chaincode, from development to updates, which included installation,
    initiation, testing, and versioning. It demonstrated the full chaincode with a
    code base built on Go and Node.js. It illustrated endorsement policies and private
    data collections and their functioning in concert with chaincode. It covered chaincode
    testing via shim and REST endpoints and integrating client apps with a business
    network using an SDK, REST, and events. Finally, it concluded with insights into
    chaincode, transactions, and channels by experimenting with the monitoring of
    a business via chaincode logs and channel logs.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了链码开发的详细信息，如语言部分、开发工具和开发环境设置。它详细描述了链码的完整生命周期，从开发到更新，其中包括安装、初始化、测试和版本控制。它展示了基于
    Go 和 Node.js 构建的完整链码代码库。它说明了背书策略和私有数据集以及它们与链码协同运作的方式。它通过 shim 和 REST 端点对链码进行了测试，并使用
    SDK、REST 和事件将客户端应用程序与业务网络集成。最后，通过实验监控业务的链码日志和通道日志，对链码、交易和通道进行了深入的洞察。
- en: This ledger of knowledge was created with the belief that, together, we will
    positively contribute to the evolution of blockchain technologies and continually
    inspire others to share their experience and further influence others to do so.
    Hence, the torch is with you, to continue influence by sharing, as sharing is
    caring, and together we contribute to creating a smarter world.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这本知识总账的创建是基于这样一个信念，即我们共同将积极地促进区块链技术的发展，并不断地激励他人分享他们的经验，并进一步影响其他人这样做。因此，火炬传递给了你，通过分享继续影响，因为分享就是关怀，而我们共同致力于创造一个更智慧的世界。
