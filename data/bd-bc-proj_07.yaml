- en: Building a Betting App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个投注应用
- en: Sometimes, it is necessary for smart contracts to access data from other dapps
    or from the World Wide Web. But it's really complicated to let smart contracts
    access outside data due to technical and consensus challenges. Therefore, currently,
    Ethereum smart contracts don't have native support to access outside data. But
    there are third-party solutions for Ethereum smart contracts to access data from
    some popular dapps and from the World Wide Web. In this chapter, we will learn
    how to use Oraclize to make HTTP requests from Ethereum smart contracts to access
    data from the World Wide Web. We will also learn how to access files stored in
    IPFS, use the strings library to work with strings, and so on. We will learn all
    this by building a football-betting smart contract and a client for it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，智能合约需要访问其他 DApp 或来自万维网的数据是必要的。但是由于技术和共识方面的挑战，让智能合约访问外部数据确实非常复杂。因此，目前，以太坊智能合约没有原生支持访问外部数据。但是有第三方解决方案供以太坊智能合约访问一些流行的
    DApp 和来自万维网的数据。在本章中，我们将学习如何使用 Oraclize 从以太坊智能合约中发出 HTTP 请求，以访问来自万维网的数据。我们还将学习如何访问存储在
    IPFS 中的文件，使用 strings 库来处理字符串等等。我们将通过构建一个足球投注智能合约和其客户端来学习所有这些。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How does Oraclize work?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oraclize 是如何工作的？
- en: What are Oraclize's various data sources and how do each of them work?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oraclize 有哪些不同的数据源，它们每一个是如何工作的？
- en: How does consensus work in Oraclize?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oraclize 中的共识是如何工作的？
- en: Integrating Oraclize in Ethereum smart contracts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Oraclize 集成到以太坊智能合约中
- en: Using strings the `Solidity` library to make it easy to work with strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Solidity 库中的字符串库使字符串处理变得更加简单
- en: Building a football betting app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个足球投注应用
- en: Introduction to Oraclize
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Oraclize
- en: Oraclize is a service that aims to enable smart contracts to access data from
    other blockchains and the World Wide Web. This service is currently live on bitcoin
    and Ethereum's testnet and mainnet. What makes Oraclize so special is that you
    don't need to trust it because it provides proof of authenticity of all data it
    provides to smart contracts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize 是一个旨在使智能合约能够从其他区块链和万维网获取数据的服务。该服务目前在比特币和以太坊的测试网和主网上运行。Oraclize 的特殊之处在于，你无需信任它，因为它提供给智能合约的所有数据都有真实性证明。
- en: In this chapter, our aim is to learn how Ethereum smart contracts can use the
    Oraclize service to fetch data from the World Wide Web.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标是学习以太坊智能合约如何使用 Oraclize 服务从万维网获取数据。
- en: How does it work?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Let's look at the process by which an Ethereum smart contract can fetch data
    from other blockchains and the World Wide Web using Oraclize.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以太坊智能合约如何使用 Oraclize 从其他区块链和万维网获取数据的过程。
- en: To fetch data that exists outside of the Ethereum blockchain, an Ethereum smart
    contract needs to send a query to Oraclize, mentioning the data source (representing
    where to fetch the data from) and the input for the data source (representing
    what to fetch).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取存在于以太坊区块链之外的数据，以太坊智能合约需要向 Oraclize 发送查询，提及数据源（表示从何处获取数据）和数据源的输入（表示要获取的内容）。
- en: Sending a query to Oraclize Oraclize means sending a contract call (that is,
    an internal transaction) to the Oraclize contract present in the Ethereum blockchain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发送查询到 Oraclize 意味着向存在于以太坊区块链中的 Oraclize 合约发送合约调用（即，内部交易）。
- en: The Oraclize server keeps looking for new incoming queries to its smart contract.
    Whenever it sees a new query, it fetches the result and sends it back to your
    contract by calling the `_callback` method of your contract.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize 服务器不断查找其智能合约的新进入查询。每当它看到一个新的查询时，它就会获取结果并通过调用您合约的 `_callback` 方法将其发送回您的合约。
- en: Data sources
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据源
- en: 'Here is a list of sources from which Oraclize lets smart contracts fetch data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Oraclize 允许智能合约获取数据的源列表：
- en: 'URL: The URL data source provides you with the ability to make an HTTP GET
    or POST request, that is, fetch data from the WWW.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'URL: URL 数据源使您能够进行 HTTP GET 或 POST 请求，即从万维网获取数据。'
- en: '`WolframAlpha`: The `WolframAlpha` data source provides you with the ability
    to submit a query to the `WolframAlpha` knowledge engine and get the answer.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WolframAlpha`: `WolframAlpha` 数据源使您能够向 `WolframAlpha` 知识引擎提交查询并获得答案。'
- en: '`Blockchain`: The `blockchain` data source provides you with ability to access
    data from other `blockchains`. Possible queries that can be submitted to the `blockchain`
    data source are `bitcoin blockchain height`, `litecoin hashrate`, `bitcoin difficulty`,
    `1NPFRDJuEdyqEn2nmLNaWMfojNksFjbL4S balance`, and so on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blockchain`：`blockchain` 数据源提供了从其他`区块链`访问数据的能力。可以提交给`blockchain`数据源的可能查询包括`bitcoin
    blockchain height`、`litecoin hashrate`、`bitcoin difficulty`、`1NPFRDJuEdyqEn2nmLNaWMfojNksFjbL4S
    balance`等。'
- en: '`IPFS`: The `IPFS` data source provides you with the ability to fetch the content
    of a file stored in `IPFS`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPFS`：`IPFS` 数据源提供了获取存储在`IPFS`中文件内容的能力。'
- en: '`Nested`: The `nested` data source is a metadata source; it does not provide
    access to additional services. It was designed to provide a simple aggregation
    logic, enabling a single query to leverage sub-queries based on any available
    data source and producing a single string as a result; for example:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nested`：`nested` 数据源是一个元数据源；它不提供对额外服务的访问。它的设计是为了提供一种简单的聚合逻辑，使单个查询能够利用基于任何可用数据源的子查询，并产生单个字符串作为结果；例如：'
- en: '`[WolframAlpha] temperature in ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`[WolframAlpha] ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}`中的温度。'
- en: '`Computation`: The `computation` data source enables the auditable execution
    of a given application into a secure off-chain context; that is, it lets us fetch
    the result of an off-chain execution of an application. This application has to
    print the query result on the last line (on the standard output) before its quits.
    The execution context has to be described by a Dockerfile, where building and
    running it should start your main application straight away. The Dockerfile initialization
    plus your application execution should terminate as soon as possible: the maximum
    execution timeout is 5 minutes on an `AWS t2.micro` instance. Here, we are considering
    an `AWS t2.micro` instance because that''s what Oraclize will use to execute the
    application. As the input for the data source is the IPFS multihash of a ZIP archive
    containing such files (Dockerfile plus any external file dependencies, and the
    Dockerfile has to be placed in the archive root), you should take care of preparing
    this archive and pushing it to IPFS beforehand.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Computation`：`computation` 数据源使给定应用程序在安全的链下环境中可审计地执行；也就是说，它让我们获取应用程序链下执行的结果。这个应用程序必须在退出前在最后一行（标准输出上）打印查询结果。执行环境必须由
    Dockerfile 描述，其中构建和运行应用程序应立即启动您的主应用程序。Dockerfile 初始化加上您的应用程序执行应尽快终止：在`AWS t2.micro`实例上的最大执行超时为
    5 分钟。在这里，我们考虑的是`AWS t2.micro`实例，因为这是 Oraclize 将用来执行该应用程序的实例。由于数据源的输入是包含这些文件的 ZIP
    存档的 IPFS 多哈希值（Dockerfile 加上任何外部文件依赖项，且 Dockerfile 必须放在存档根目录中），您应该注意准备这个存档并预先将其推送到
    IPFS。'
- en: These data sources are available at the time of writing this book. But many
    more data sources are likely to be available in the future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据源在编写本书时可用。但未来可能会有更多的数据源可用。
- en: Proof of authenticity
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实性证明
- en: Although Oraclize is a trusted service, you may still want to check whether
    the data returned by Oraclize is authentic or not, that is, whether it was manipulated
    by Oraclize or someone else in transit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Oraclize 是一个值得信赖的服务，但你可能仍然想要检查 Oraclize 返回的数据是否真实，即它是否在传输过程中被 Oraclize 或其他人篡改。
- en: Optionally, Oraclize provides the TLSNotary proof of result that's returned
    from the URL, blockchain, and nested and computation data sources. This proof
    is not available for `WolframAlpha` and `IPFS` data sources. Currently, Oraclize
    only supports the TLSNotary proof, but in the future, they may support some other
    ways to authenticate. Currently, the TLSNotary proof needs to be validated manually,
    but Oraclize is already working on on-chain proof verification; that is, your
    smart contract code can verify the TLSNotary proof on its own while receiving
    the data from Oraclize so that this data is discarded if the proof turns out to
    be invalid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，Oraclize 提供了从 URL、区块链、嵌套和计算数据源返回的 TLSNotary 结果证明。对于`WolframAlpha`和`IPFS`数据源，这种证明是不可用的。目前，Oraclize
    仅支持 TLSNotary 证明，但在将来，他们可能会支持其他一些身份验证方式。目前，TLSNotary 证明需要手动验证，但 Oraclize 已经在进行链上证明验证；也就是说，你的智能合约代码可以在从
    Oraclize 接收数据时自行验证 TLSNotary 证明，以便在证明无效时丢弃这些数据。
- en: This tool ([https://github.com/Oraclize/proof-verification-tool](https://github.com/oraclize/proof-verification-tool))
    is an open source tool provided by Oraclize to validate the TLSNotary proof in
    case you want to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具（[https://github.com/Oraclize/proof-verification-tool](https://github.com/oraclize/proof-verification-tool)）是由
    Oraclize 提供的开源工具，用于验证 TLSNotary 证明，如果你想要的话。
- en: Understanding how TLSNotary works is not required to use Oraclize or to verify
    the proof. The tool to validate the TLSNotary proof is open source; therefore,
    if it contains any malicious code, then it can easily be caught, so this tool
    can be trusted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 TLSNotary 如何工作并不是使用 Oraclize 或验证证明所必需的。验证 TLSNotary 证明的工具是开源的；因此，如果它包含任何恶意代码，那么它很容易被发现，因此这个工具是可信的。
- en: Let's look at a high-level overview of how TLSNotary works. To understand how
    TLSNotary works, you need to first understand how TLS works. The TLS protocol
    provides a way for the client and server to create an encrypted session so that
    no one else can read or manipulate what is transferred between the client and
    server. The server first sends its certificate (issued to the domain owner by
    a trusted CA) to the client. The certificate will contain the public key of the
    server. The client uses the CA's public key to decrypt the certificate so that
    it can verify that the certificate is actually issued by the CA and get the server's
    public key. Then, the client generates a symmetric encryption key and a MAC key
    and encrypts them using the server's public key and sends it to the server. The
    server can only decrypt this message as it has the private key to decrypt it.
    Now the client and server share the same symmetric and MAC keys and no one else
    knows about these keys and they can start sending and receiving data from each
    other. The symmetric key is used to encrypt and decrypt the data where the MAC
    key and the symmetric key together are used to generate a signature for the encrypted
    message so that in case the message is modified by an attacker, the other party
    can know about it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 TLSNotary 如何工作的概述。要理解 TLSNotary 的工作原理，首先需要了解 TLS 的工作原理。TLS 协议提供了一种方法，让客户端和服务器创建一个加密会话，这样其他人就无法阅读或篡改客户端和服务器之间传输的内容。服务器首先将其证书（由受信任的
    CA 颁发给域所有者）发送给客户端。证书将包含服务器的公钥。客户端使用 CA 的公钥解密证书，以便可以验证证书实际上是由 CA 颁发的，并获取服务器的公钥。然后，客户端生成一个对称加密密钥和一个
    MAC 密钥，并使用服务器的公钥对它们进行加密，然后将其发送给服务器。服务器只能解密此消息，因为它有解密它的私钥。现在客户端和服务器共享相同的对称和 MAC
    密钥，除了它们以外，没有其他人知道这些密钥，它们可以开始相互发送和接收数据。对称密钥用于加密和解密数据，其中 MAC 密钥和对称密钥一起用于为加密消息生成签名，以便在消息被攻击者修改时，另一方可以知道它。
- en: TLSNotary is a modification of TLS, which is used by Oraclize to provide cryptography
    proof showing that the data they provided to your smart contract was really the
    one the data source gave to Oraclize at a specific time. Actually the TLSNotary
    protocol is an open source technology, developed and used by the PageSigner project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TLSNotary 是 TLS 的修改版，Oraclize 使用它来提供密码学证明，证明它们提供给您的智能合约的数据确实是数据源在特定时间提供给 Oraclize
    的数据。实际上，TLSNotary 协议是 PageSigner 项目开发和使用的开源技术。
- en: TLSNotary works by splitting the symmetric key and the MAC key among three parties,
    that is, the server, an auditee, and an auditor. The basic idea of TLSNotary is
    that the auditee can prove to the auditor that a particular result was returned
    by the server at a given time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TLSNotary 的工作原理是将对称密钥和 MAC 密钥分配给三个参与方，即服务器、被审计者和审计员。TLSNotary 的基本思想是被审计者可以向审计员证明特定结果是服务器在特定时间返回的。
- en: So here is an overview of how exactly TLSNotary lets us achieve this. The auditor
    calculates the symmetric key and MAC key and gives only the symmetric key to the
    auditee. The MAC key is not needed by the auditee as the MAC signature check ensures
    that the TLS data from the server was not modified in transit. With the symmetric
    encryption key, the auditee can now decrypt data from the server. Because all
    messages are "signed" by the bank using the MAC key and only the server and the
    auditor know the MAC key, a correct MAC signature can serve as proof that certain
    messages came from the bank and were not spoofed by the auditee.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是TLSNotary如何实现这一点的概述。审计员计算对称密钥和MAC密钥，然后仅将对称密钥提供给受审者。由于MAC签名检查确保了服务器传输的TLS数据未被修改，因此受审者不需要MAC密钥。有了对称加密密钥，受审者现在可以解密服务器的数据。因为所有消息都是由银行使用MAC密钥“签名”的，而且只有服务器和审计员知道MAC密钥，正确的MAC签名可以作为证明某些消息来自银行且未被受审者伪造的证据。
- en: In the case of the Oraclize service, Oraclize is the auditee, while a locked-down
    AWS instance of a specially designed, open source Amazon machine image acts as
    the auditor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oraclize服务的情况下，Oraclize是受审者，而一个特制的、开源的Amazon机器映像的受限AWS实例充当审计员。
- en: The proof data they provide are the signed attestations of this AWS instance
    that a proper TLSnotary proof did occur. They also provide some additional proof
    regarding the software running in the AWS instance, that is, whether it has been
    modified since being initialized.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供的证据数据是此AWS实例的签名证明，证明了一个正确的TLSnotary证明确实发生了。他们还提供了一些关于在AWS实例中运行的软件的额外证据，即它是否自初始化以来已被修改。
- en: Pricing
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价
- en: The first Oraclize query call coming from any Ethereum address is completely
    free of charge. Oraclize calls are free when used on testnets! This works for
    moderate usage in test environments only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以太坊地址发起的第一个Oraclize查询调用完全免费。在测试网络上使用Oraclize调用是免费的！这仅适用于测试环境中的适度使用。
- en: From the second call onward, you have to pay in ether for queries. While sending
    a query to Oraclize (that is, while making an internal transaction call), a fee
    is deducted by transferring ether from the calling contract to the Oraclize contract.
    The amount of ether to deduct depends on the data source and proof type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二次调用开始，你必须支付以太币来进行查询。当向Oraclize发送查询（即进行内部交易调用）时，通过将以太币从调用合约转移到Oraclize合约来扣除费用。要扣除的以太币数量取决于数据源和证明类型。
- en: 'Here is a table that shows the number of ether that is deducted while sending
    a query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了发送查询时扣除的以太币数量：
- en: '| **Data source** | **Without proof** | **With TLSNotary proof** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **数据源** | **无证明** | **使用TLSNotary证明** |'
- en: '| URL | $0.01 | $0.05 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| URL | $0.01 | $0.05 |'
- en: '| Blockchain | $0.01 | $0.05 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 区块链 | $0.01 | $0.05 |'
- en: '| WolframAlpha | $0.03 | $0.03 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| WolframAlpha | $0.03 | $0.03 |'
- en: '| IPFS | $0.01 | $0.01 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| IPFS | $0.01 | $0.01 |'
- en: So if you are making a HTTP request and you want the TLSNotary proof too, then
    the calling contract must have an ether worth of $0.05; otherwise, an exception
    is thrown.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在发起一个HTTP请求，并且想要TLSNotary证明，那么调用的合约必须有价值$0.05的以太币；否则，将抛出异常。
- en: Getting started with the Oraclize API
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Oraclize API入门
- en: For a contract to use the Oraclize service, it needs to inherit the `usingOraclize`
    contract. You can find this contract at [https://github.com/Oraclize/Ethereum-api](https://github.com/oraclize/ethereum-api).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使合约使用Oraclize服务，需要继承`usingOraclize`合约。你可以在[https://github.com/oraclize/ethereum-api](https://github.com/oraclize/ethereum-api)找到这个合约。
- en: The `usingOraclize` contract acts as the proxy for the `OraclizeI` and `OraclizeAddrResolverI`
    contracts. Actually, `usingOraclize` makes it easy to make calls to the `OraclizeI`
    and `OraclizeAddrResolverI` contracts, that is, it provides simpler APIs. You
    can also directly make calls to the `OraclizeI` and `OraclizeAddrResolverI` contracts
    if you feel comfortable. You can go through the source code of these contracts
    to find all the available APIs. We will only learn the most necessary ones.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`usingOraclize`合约充当`OraclizeI`和`OraclizeAddrResolverI`合约的代理。实际上，`usingOraclize`使调用`OraclizeI`和`OraclizeAddrResolverI`合约变得容易，也就是说，它提供了更简单的API。如果你感觉自如，你也可以直接调用`OraclizeI`和`OraclizeAddrResolverI`合约。你可以查看这些合约的源代码，找到所有可用的API。我们只会学习最必要的API。'
- en: Let's look at how to set proof type, set proof storage location, make queries,
    find the cost of a query, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置证明类型、设置证明存储位置、进行查询、找到查询的成本等等。
- en: Setting the proof type and storage location
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置证明类型和存储位置
- en: Whether you need the TLSNotary proof from Oraclize or not, you have to specify
    the proof type and proof storage location before making queries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否需要来自 Oraclize 的 TLSNotary 证明，你都必须在发出查询之前指定证明类型和证明存储位置。
- en: 'If you don''t want proof, then put this code in your contract:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要证明，那么将这段代码放入你的合约中：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you want proof, then put this code in your contract:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要证明，那么将这段代码放入你的合约中：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Currently, `proofStorage_IPFS` is the only proof storage location available;
    that is, TLSNotary proof is only stored in `IPFS`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`proofStorage_IPFS`是唯一可用的证明存储位置；也就是说，TLSNotary 证明只存储在`IPFS`中。
- en: You may execute any of these methods just once, for instance, in the constructor
    or at any other time if, for instance, you need the proof for certain queries
    only.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以仅执行这些方法之一，例如，在构造函数中或在其他任何时候，例如，如果你只需要某些查询的证明。
- en: Sending queries
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送查询
- en: To send a query to Oraclize, you will need to call the `oraclize_query` function.
    This function expects at least two arguments, that is, the data source and the
    input for the given data source. The data source argument is not case-sensitive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 Oraclize 发送查询，你需要调用`oraclize_query`函数。该函数至少需要两个参数，即数据源和给定数据源的输入。数据源参数不区分大小写。
- en: 'Here are some basic examples of the `oraclize_query` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`oraclize_query`函数的一些基本示例：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how the preceding code works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的工作原理：
- en: If the first argument is a string, it is assumed to be the data source and the
    second argument is assumed to be the input for the data source. In the first call,
    the data source is `WolframAlpha` and the search query we sent to it was `random
    number between 0 and 100`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数是一个字符串，则假定它是数据源，第二个参数则假定是数据源的输入。在第一次调用中，数据源是`WolframAlpha`，我们发送给它的搜索查询是`random
    number between 0 and 100`。
- en: In the second call, we make an `HTTP GET` request to the `URL` present in the
    second argument.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次调用中，我们向第二个参数中的`URL`发出一个`HTTP GET`请求。
- en: In the third call, we fetch the content of the `QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU` file
    from `IPFS`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三次调用中，我们从`IPFS`中获取`QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU`文件的内容。
- en: If two consecutive arguments after the data source are strings, then it's assumed
    to be a POST request. In the last call, we make an `HTTP POST` request to `https://xyz.io/makePayment`
    and the `POST` request body content is the string in the third argument. Oraclize
    is intelligent enough to detect the content-type header based on the string format.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据源之后的两个连续参数都是字符串，则假定它是一个 POST 请求。在最后一次调用中，我们向`https://xyz.io/makePayment`发出一个`HTTP
    POST`请求，而`POST`请求主体内容是第三个参数中的字符串。Oraclize 能够根据字符串格式检测到内容类型头部。
- en: Scheduling queries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时查询
- en: If you want Oraclize to execute your query at a scheduled future time, just
    specify the delay (in seconds) from the current time as the first argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 Oraclize 在将来的某个预定时间执行你的查询，只需将延迟时间（以秒为单位）从当前时间作为第一个参数指定。
- en: 'Here is an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding query will be executed by Oraclize `60` seconds after it's been
    seen. So if the first argument is a number, then it's assumed that we are scheduling
    a query.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将在被看到后的 60 秒内由 Oraclize 执行。因此，如果第一个参数是一个数字，则假定我们正在安排一个查询。
- en: Custom gas
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义燃气
- en: The transaction originating from Oraclize to your `__callback` function costs
    gas, just like any other transaction. You need to pay Oraclize the gas cost. The
    ether oraclize_query charges to make a query are also used to provide gas while
    calling the `__callback` function. By default, Oraclize provides 200,000 gas while
    calling the `__callback` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Oraclize 到你的`__callback`函数的交易需要燃气，就像任何其他交易一样。你需要支付给 Oraclize 燃气成本。oraclize_query
    收取用于发出查询的以太币，同时也用于在调用`__callback`函数时提供燃气。默认情况下，Oraclize 在调用`__callback`函数时提供 200,000
    gas。
- en: This return gas cost is actually in your control since you write the code in
    the `__callback` method and as such, can estimate it. So, when placing a query
    with Oraclize, you can also specify how much the `gasLimit` should be on the `__callback`
    transaction. Note, however, that since Oraclize sends the transaction, any unspent
    gas is returned to Oraclize, not you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的燃气成本实际上是由你控制的，因为你在`__callback`方法中编写代码，因此可以估算出来。因此，当向 Oraclize 发出查询时，你还可以指定`__callback`交易的`gasLimit`应该是多少。然而，请注意，由于
    Oraclize 发送交易，任何未使用的 gas 都会退还给 Oraclize，而不是你。
- en: 'If the default, and minimum, value of 200,000 gas is not enough, you can increase
    it by specifying a different `gasLimit` in this way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认值和最小值的 200,000 gas 不够用，你可以通过以下方式增加它：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, you can see that if the last argument is a number, then it's assumed to
    be the custom gas. In the preceding code, Oraclize will use a 500k `gasLimit`
    for the callback transaction instead of 200k. Because we are asking Oraclize to
    provide more gas, Oraclize will deduct more ether (depending on how much gas is
    required) while calling `oraclize_query`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到如果最后一个参数是一个数字，那么就假设它是自定义 gas。在前面的代码中，Oraclize 将为回调交易使用 500k 的 `gasLimit`
    而不是 200k。因为我们要求 Oraclize 提供更多的 gas，所以在调用 `oraclize_query` 时，Oraclize 将扣除更多的以太币（取决于需要多少
    gas）。
- en: Note that if you offer too low a `gasLimit`, and your `__callback` method is
    long, you may never see a callback. Also note that the custom gas has to be more
    than 200k.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你提供的 `gasLimit` 太低，并且你的 `__callback` 方法很长，你可能永远不会看到回调。另请注意，自定义 gas 必须大于
    200k。
- en: Callback functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: 'Once your result is ready, Oraclize will send a transaction back to your contract
    address and invoke one of these three methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的结果准备好了，Oraclize 将会发送一个交易回到你的合约地址并调用以下三种方法之一：
- en: either `__callback(bytes32 myid, string result)`. `Myid` is a unique ID for
    every query. This ID is returned by the `oraclize_query` method. If you have multiple
    `oraclize_query` calls in your contract, then this is used to match the query
    this result is for.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者 `__callback(bytes32 myid, string result)`。`Myid` 是每个查询的唯一 ID。这个 ID 是由 `oraclize_query`
    方法返回的。如果你的合约中有多个 `oraclize_query` 调用，那么这个 ID 就用于匹配此结果所属的查询。
- en: 'If you requested for the TLS Notary proof, this is the result: `__callback(bytes32
    myid, string result, bytes proof)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你请求了 TLS Notary 证明，这就是结果：`__callback(bytes32 myid, string result, bytes proof)`
- en: As a last resort, if the other methods are absent, the fallback function is
    `function()`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的手段，如果其他方法都不存在，回退函数是 `function()`
- en: 'Here is an example of the `__callback` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `__callback` 函数的一个例子：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Parsing helpers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析辅助函数
- en: The result returned from an HTTP request can be HTML, JSON, XML, binary, and
    so on. In Solidity, it is difficult and expensive to parse the result. Due to
    this, Oraclize provides parsing helpers to let it handle the parsing on its servers,
    and you get only the part of the result that you need.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从 HTTP 请求返回的结果可以是 HTML、JSON、XML、二进制等。在 Solidity 中，解析结果是困难且昂贵的。因此，Oraclize 提供了解析辅助函数，让它在其服务器上处理解析，并且你只获取你需要的结果的一部分。
- en: 'To ask Oraclize to parse the result, you need to wrap the URL with one of these
    parsing helpers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要求 Oraclize 解析结果，你需要使用以下解析辅助函数包装 URL：
- en: '`xml(..)` and `json(..)` helpers let you ask Oraclize to only return part of
    the JSON or XML-parsed response; for example, take a look at the following:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xml(..)` 和 `json(..)` 辅助函数让你可以要求 Oraclize 只返回 JSON 或 XML 解析后的响应的一部分；例如，看一下以下示例：'
- en: In order to get the whole response back, you use the `URL` data source with
    the `api.kraken.com/0/public/Ticker?pair=ETHUSD` URL argument
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取整个响应，你可以使用 `URL` 数据源和 `api.kraken.com/0/public/Ticker?pair=ETHUSD` URL 参数
- en: If all you want is the last-price field, you need to use the JSON parsing call
    as `json(api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想获取最后价格字段，你需要使用 JSON 解析调用，如 `json(api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0`
- en: 'The `html(..).xpath(..)` helper is useful for HTML scraping. Just specify the
    XPATH you want as the `xpath(..)` argument; for example, take a look at the following:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html(..).xpath(..)` 辅助函数对于 HTML 抓取非常有用。只需将你想要的 XPATH 指定为 `xpath(..)` 参数；例如，看一下以下示例：'
- en: To fetch the text of a specific tweet, use `html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class,
    'tweet-text')]/text())`.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取特定推文的文本，使用 `html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class,
    'tweet-text')]/text())`。
- en: 'The `binary(..)` helper is useful in getting binary files such as certificate
    files:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binary(..)` 辅助函数对于获取二进制文件（例如证书文件）非常有用：'
- en: To fetch only a portion of the binary file, you can use `slice(offset,length)`;
    the first parameter is the offset, while the second one is the length of the slice
    you want back (both in bytes).
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅获取二进制文件的一部分，你可以使用 `slice(offset,length)`；第一个参数是偏移量，而第二个参数是你希望返回的切片的长度（都以字节为单位）。
- en: 'Example: Fetch only the first 300 bytes from a binary CRL, `binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)`.
    The binary helper must be used with the slice option, and only binary files (not
    encoded) are accepted.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：仅从二进制 CRL 中获取前 300 个字节，`binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)`。二进制辅助程序必须与切片选项一起使用，只接受二进制文件（未编码）。
- en: If and when the server is not responding or is unreachable, we will send you
    an empty response. You can test queries using [http://app.Oraclize.it/home/test_query](http://app.oraclize.it/home/test_query).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器无响应或无法访问，我们将发送空响应。您可以使用[http://app.Oraclize.it/home/test_query](http://app.oraclize.it/home/test_query)测试查询。
- en: Getting the query price
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取查询价格
- en: If you would like to know how much a query would cost before making the actual
    query, then you can use the `Oraclize.getPrice()` function to get the amount of
    wei required. The first argument it takes is the data source, and the second argument
    is optional, which is the custom gas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在实际查询之前知道查询的费用，那么您可以使用`Oraclize.getPrice()`函数来获取所需的wei数量。它接受的第一个参数是数据源，第二个参数是可选的，即自定义的gas。
- en: One popular use case of this is to notify the client to add ether to the contract
    if there isn't enough to make the query.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的一个流行用例是通知客户如果合同中没有足够的以太币来进行查询，则添加以太币。
- en: Encrypting queries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密查询
- en: 'Sometimes, you may not want to reveal the data source and/or the input for
    the data source. For example: you may not want to reveal the API key in the URL
    if there is any. Therefore, Oraclize provides a way to store queries encrypted
    in the smart contract and only Oraclize''s server has the key to decrypt it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能不希望揭示数据源和/或数据源的输入。例如：如果有的话，您可能不希望在URL中揭示API密钥。因此，Oraclize提供了一种将查询加密存储在智能合约中，并且只有Oraclize的服务器有解密密钥的方法。
- en: Oraclize provides a Python tool ([https://github.com/Oraclize/encrypted-queries](https://github.com/oraclize/encrypted-queries)),
    which can be used to encrypt the data source and/or the data input. It generates
    a non-deterministic encrypted string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize提供了一个Python工具（[https://github.com/Oraclize/encrypted-queries](https://github.com/oraclize/encrypted-queries)），可用于加密数据源和/或数据输入。它生成一个非确定性的加密字符串。
- en: 'The CLI command to encrypt an arbitrary string of text is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 加密任意文本字符串的CLI命令如下：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The long hexadecimal string you see is the public key of Oraclize's server.
    Now you can use the output of the preceding command in place of the data source
    and/or the input for the data source.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的长十六进制字符串是Oraclize服务器的公钥。现在您可以使用前述命令的输出来替代数据源和/或数据源的输入。
- en: In order to prevent the misuse of encrypted queries (that is, replay attacks)
    the first contract querying Oraclize with a specific encrypted query becomes its
    rightful owner. Any other contract reusing the exact same string will not be allowed
    to use it and will receive an empty result. As a consequence, remember to always
    generate a newly encrypted string when redeploying contracts using encrypted queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止加密查询的滥用（即重放攻击），使用特定加密查询的第一个与Oraclize查询的合同将成为其合法所有者。任何其他重用完全相同字符串的合同将不被允许使用它，并将收到空结果。因此，请记住在重新部署使用加密查询的合同时始终生成新的加密字符串。
- en: Decrypting the data source
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密数据源
- en: There is another data source called decrypt. It is used to decrypt an encrypted
    string. But this data source doesn't return any result; otherwise, anyone would
    have the ability to decrypt the data source and input for the data source.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个名为解密的数据源。它用于解密加密的字符串。但是这个数据源不返回任何结果；否则，任何人都将有能力解密数据源和数据源的输入。
- en: It was specifically designed to be used within the nested data source to enable
    partial query encryption. It is its only use case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它专门设计用于在嵌套数据源内部使用，以实现部分查询加密。这是它唯一的用例。
- en: Oraclize web IDE
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oraclize Web IDE
- en: Oraclize provides a web IDE, using which you can write, compile, and test Oraclize-based
    applications. You can find it at [http://dapps.Oraclize.it/browser-Solidity/](http://dapps.oraclize.it/browser-solidity/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize提供了一个Web IDE，您可以在其中编写、编译和测试基于Oraclize的应用程序。您可以在[http://dapps.Oraclize.it/browser-Solidity/](http://dapps.oraclize.it/browser-solidity/)找到它。
- en: If you visit the link, then you will notice that it looks exactly the same as
    browser Solidity. And it's actually browser Solidity with one extra feature. To
    understand what that feature is, we need to understand browser Solidity more in
    depth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问链接，那么您会注意到它看起来与浏览器Solidity完全相同。实际上，它就是带有一个额外功能的浏览器Solidity。要理解这个功能是什么，我们需要更深入地了解浏览器Solidity。
- en: Browser Solidity not only lets us write, compile, and generate web3.js code
    for our contracts, but it also lets us test those contracts there itself. Until
    now, in order to test our contract, we were setting up an Ethereum node and sending
    transactions to it. But browser Solidity can execute contracts without connecting
    to any node and everything happens in memory. It achieves this using ethereumjs-vm,
    which is a JavaScript implementation of EVM. Using ethereumjs-vm, you can create
    our own EVM and run byte code. If we want, we can configure browser Solidity to
    use the Ethereum node by providing the URL to connect to. The UI is very informative;
    therefore, you can try all these by yourself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器 Solidity 不仅让我们编写、编译和为我们的合约生成 web3.js 代码，还可以在那里测试这些合约。直到现在，为了测试我们的合约，我们都是设置了以太坊节点并向其发送交易。但是浏览器
    Solidity 可以在不连接到任何节点的情况下执行合约，所有操作都在内存中进行。它使用 ethereumjs-vm 实现了这一点，这是 EVM 的 JavaScript
    实现。使用 ethereumjs-vm，你可以创建自己的 EVM 并运行字节码。如果需要，我们可以通过提供连接的 URL 来配置浏览器 Solidity 使用以太坊节点。用户界面非常信息丰富；因此，你可以自己尝试所有这些。
- en: What's special about the Oraclize web IDE is that it deploys the Oraclize contract
    in the in-memory execution environment so that you don't have to connect to the
    testnet or mainnet node, but if you use browser Solidity, then you have to connect
    to the testnet or mainnet node to test Oraclize APIs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Oraclize Web IDE 的特殊之处在于它在内存执行环境中部署了 Oraclize 合约，因此您不必连接到测试网或主网节点，但如果您使用浏览器
    Solidity，则必须连接到测试网或主网节点以测试 Oraclize API。
- en: You can find more resources related to integrating Oraclize at [https://dev.Oraclize.it/](https://dev.oraclize.it/).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://dev.Oraclize.it/](https://dev.oraclize.it/) 找到更多与集成 Oraclize 相关的资源。
- en: Working with strings
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Working with strings in Solidity is not as easy as working with strings in other
    high-level programming languages, such as JavaScript, Python, and so on. Therefore,
    many Solidity programmers have come up with various libraries and contracts to
    make it easy to work with strings.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中处理字符串不像在其他高级编程语言（如 JavaScript、Python 等）中那样容易。因此，许多 Solidity 程序员提出了各种库和合约，以便轻松处理字符串。
- en: The `strings` library is the most popular strings utility library. It lets us
    join, concatenate, split, compare, and so on by converting a string to something
    called a slice. A slice is a struct that holds the length of the string and the
    address of the string. Since a slice only has to specify an offset and a length,
    copying and manipulating slices is a lot less expensive than copying and manipulating
    the strings they reference.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings` 库是最流行的字符串实用程序库。它允许我们通过将字符串转换为称为切片的东西来连接、连接、拆分、比较等等。切片是一个结构，它保存了字符串的长度和字符串的地址。由于切片只需指定一个偏移量和一个长度，复制和操作切片要比复制和操作它们引用的字符串便宜得多。'
- en: To further reduce gas costs, most functions on slice that need to return a slice
    modify the original one instead of allocating a new one; for instance, `s.split(".")`
    will return the text up to the first `"."`, modifying s to only contain the remainder
    of the string after the `"."`. In situations where you do not want to modify the
    original slice, you can make a copy with `.copy()`, for example, `s.copy().split(".")`.
    Try and avoid using this idiom in loops; since Solidity has no memory management,
    it will result in allocating many short-lived slices that are later discarded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步减少 gas 成本，大多数需要返回切片的切片函数会修改原始切片，而不是分配一个新的切片；例如，`s.split(".")` 将返回直到第一个
    `"."` 的文本，并修改 s 以仅包含该 `"."` 后的字符串。在你不想修改原始切片的情况下，可以使用 `.copy()` 进行复制，例如，`s.copy().split(".")`。尽量避免在循环中使用这种习惯用法；由于
    Solidity 没有内存管理，这将导致分配许多短暂的切片，稍后会被丢弃。
- en: Functions that have to copy string data will return strings rather than slices;
    these can be cast back to slices for further processing if required.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 必须复制字符串数据的函数将返回字符串而不是切片；如果需要，可以将其强制转换回切片以进行进一步处理。
- en: 'Let''s look at a few examples of working with strings using the `strings` library:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `strings` 库处理字符串的几个示例：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is self-explanatory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码是不言自明的。
- en: 'Functions that return two slices come in two versions: a nonallocating version
    that takes the second slice as an argument, modifying it in place, and an allocating
    version that allocates and returns the second slice; for example, let''s take
    a look at the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个切片的函数有两个版本：一个是不分配的版本，它将第二个切片作为参数，直接在原地修改它；另一个是分配并返回第二个切片的版本。例如，让我们来看看以下内容：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can learn more about the strings library at [https://github.com/Arachnid/Solidity-stringutils](https://github.com/Arachnid/solidity-stringutils).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/Arachnid/Solidity-stringutils](https://github.com/Arachnid/solidity-stringutils)了解更多关于
    strings 库的信息。
- en: Building the betting contract
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建投注合同
- en: In our betting application, two people can choose to bet on a football match
    with one person supporting the home team and the other person supporting the away
    team. They both should bet the same amount of money, and the winner takes all
    the money. If the match is a draw, then they both will take back their money.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的投注应用程序中，两个人可以选择在一场足球比赛上进行投注，一个人支持主队，另一个人支持客队。他们都应该以相同的金额进行投注，赢家将拿走所有的钱。如果比赛是平局，那么他们两人都将拿回他们的钱。
- en: We will use the FastestLiveScores API to find out the result of matches. It
    provides a free API, which lets us make 100 requests per hour for free. First,
    go ahead and create an account and then generate an API key. To create an account,
    visit [https://customer.fastestlivescores.com/register](https://customer.fastestlivescores.com/register),
    and once the account is created, you will have the API key visible at [https://customer.fastestlivescores.com/](https://customer.fastestlivescores.com/).
    You can find the API documentation at [https://docs.crowdscores.com/](https://docs.crowdscores.com/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 FastestLiveScores API 来了解比赛的结果。它提供了一个免费的 API，让我们每小时可以免费进行 100 次请求。首先，去创建一个账户，然后生成一个
    API 密钥。要创建一个账户，请访问 [https://customer.fastestlivescores.com/register](https://customer.fastestlivescores.com/register)，一旦账户创建完成，您将在
    [https://customer.fastestlivescores.com/](https://customer.fastestlivescores.com/)
    看到 API 密钥。您可以在 [https://docs.crowdscores.com/](https://docs.crowdscores.com/)
    找到 API 文档。
- en: For every bet between two people in our application, a betting contract will
    be deployed. The contract will contain the match ID retrieved from the `FastestLiveScores`
    API, the amount of wei each of the parties need to invest, and the addresses of
    the parties. Once both parties have invested in the contract, they will find out
    the result of the match. If the match is not yet finished, then they will try
    to check the result after every 24 hours.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们应用程序中两个人之间的每次投注，都会部署一个投注合同。合同将包含从 `FastestLiveScores` API 检索到的比赛 ID，双方需要投资的
    wei 金额以及双方的地址。一旦双方都在合同中投资了，他们将得知比赛的结果。如果比赛尚未结束，则他们将在每隔 24 小时后尝试检查结果。
- en: 'Here is the code for the contract:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合同的代码：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The contract code is self-explanatory. Now compile the preceding code using
    `solc.js` or browser Solidity depending on whatever you are comfortable with.
    You will not need to link the `strings` library because all the functions in it
    are set to the `internal` visibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 合同代码是自说明的。现在使用 `solc.js` 或浏览器 Solidity 编译上述代码，具体取决于您自己的喜好。您不需要链接 `strings` 库，因为其中的所有函数都设置为`internal`可见性。
- en: In browser Solidity, when specifying to import a library or contract from the
    HTTP URL, make sure that it's hosted on GitHub; otherwise, it won't fetch it.
    In that GitHub file URL, make sure that you remove the protocol as well as `blob/{branch-name}`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器 Solidity 中，当指定从 HTTP URL 导入库或合同时，请确保它是托管在 GitHub 上；否则，它将无法获取。在 GitHub 文件
    URL 中，请确保删除协议以及 `blob/{branch-name}`。
- en: Building a client for the betting contract
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为投注合同构建客户端
- en: To make it easy to find match's IDs, deploy, and invest in contracts, we need
    to build a UI client. So let's get started with building a client, which will
    have two paths, that is, the home path to deploy contracts and bet on matches
    and the other path to find the list of matches. We will let users deploy and bet
    using their own offline accounts so that the entire process of betting happens
    in a decentralized manner and nobody can cheat.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便查找匹配的 ID、部署和投资于合同，我们需要构建一个 UI 客户端。所以让我们开始构建一个客户端，它将有两条路径，即主页路径用于部署合同和投注比赛，另一条路径用于查找比赛列表。我们将允许用户使用他们自己的离线账户进行部署和投注，以便整个投注过程以分散的方式进行，没有人能作弊。
- en: 'Before we start building our client, make sure that you have testnet synced
    because Oraclize works only on Ethereum''s testnet/mainnet and not on private
    networks. You can switch to testnet and start downloading the testnet blockchain
    by replacing the `--dev` option with the `--testnet` option. For example, take
    a look at the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建客户端之前，请确保您已经同步了测试网络，因为 Oraclize 仅在以太坊的测试网络/主网络上运行，而不在私有网络上运行。您可以切换到测试网络，并通过将`--dev`选项替换为`--testnet`选项来开始下载测试网络区块链。例如，看一下以下内容：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Projecting the structure
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划结构
- en: In the exercise files of this chapter, you will find two directories, that is,
    Final and Initial. Final contains the final source code of the project, whereas
    Initial contains the empty source code files and libraries to get started with
    building the application quickly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，您将找到两个目录，即Final和Initial。Final包含项目的最终源代码，而Initial包含空的源代码文件和库，以快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and then run the app using the `node app.js` command inside the Final directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Final`目录，您需要在其中运行`npm install`，然后使用`Final`目录内的`node app.js`命令运行应用程序。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. The `package.json` file contains the backend
    dependencies of our app, and `app.js` is where you will place the backend source
    code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Initial`目录中，您将找到一个`public`目录和两个名为`app.js`和`package.json`的文件。`package.json`文件包含我们应用程序的后端依赖关系，`app.js`是您将放置后端源代码的地方。
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the bootstrap library. Inside `public/html`,
    you will find the `index.html` and `matches.ejs` files, where you will place the
    HTML code of our app, and in the `public/js` directory, you will find js files
    for web3.js, and ethereumjs-tx. Inside `public/js`, you will also find a `main.js`
    file, where you will place the frontend JS code of our app. You will also find
    the Oraclize Python tool to encrypt queries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`目录包含与前端相关的文件。在`public/css`内，您将找到`bootstrap.min.css`，这是bootstrap库。在`public/html`内，您将找到`index.html`和`matches.ejs`文件，您将在其中放置我们应用程序的HTML代码，并且在`public/js`目录内，您将找到web3.js和ethereumjs-tx的js文件。在`public/js`内，您还会找到一个`main.js`文件，您将在其中放置我们应用程序的前端JS代码。您还将在Oraclize
    Python工具中找到加密查询的内容。'
- en: Building the backend
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: Let's first build the backend of the app. First of all, run `npm install` inside
    the Initial directory to install the required dependencies for our backend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构建应用程序的后端。首先，在Initial目录内运行`npm install`以安装后端所需的依赖。
- en: 'Here is the backend code to run an express service and serve the `index.html`
    file and static files and set the view engine:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行express服务并提供`index.html`文件和静态文件并设置视图引擎的后端代码：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is self-explanatory. Now let''s proceed further. Our app
    will have another page, which will display a list of recent matches with matches''
    IDs and result if a match has finished. Here is the code for the endpoint:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们继续进行。我们的应用程序将有另一个页面，其中将显示最近的比赛列表，包括比赛的ID和结果（如果比赛已结束）。以下是端点的代码：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are making the API request to fetch the list of recent matches and
    then we are passing the result to the `matches.ejs` file so that it can render
    the result in a user-friendly UI. The API results give us the match start time
    as a timestamp; therefore, we are using moment to convert it to a human readable
    format. We make this request from the backend and not from the frontend so that
    we don't expose the API key to the users.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在进行API请求以获取最近比赛的列表，然后将结果传递给`matches.ejs`文件，以便它可以在用户友好的UI中渲染结果。API结果以时间戳形式给出比赛开始时间；因此，我们正在使用moment将其转换为可读的人类格式。我们从后端而不是从前端发出此请求，以便我们不会向用户公开API密钥。
- en: Our backend will provide an API to the frontend, using which the frontend can
    encrypt the query before deploying the contract. Our application will not prompt
    users to create an API key, as it would be a bad UX practice. The application's
    developer controlling the API key will cause no harm as the developer cannot modify
    the result from the API servers; therefore, users will still trust the app even
    after the application's developer knows the API key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端将向前端提供API，通过该API前端可以在部署合约之前加密查询。我们的应用程序不会提示用户创建API密钥，因为这将是不良的UX实践。应用程序的开发人员控制API密钥不会造成任何伤害，因为开发人员无法修改API服务器的结果；因此，即使应用程序的开发人员知道API密钥，用户仍将信任该应用程序。
- en: 'Here is code for the encryption endpoint:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是加密端点的代码：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have already seen how to use this tool. To run this endpoint successfully,
    make sure that Python is installed on your system. Even if Python is installed,
    this endpoint may show errors, indicating that Python's cryptography and base58
    modules aren't installed. So make sure you install these modules if the tool prompts
    you to.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用此工具。为了成功运行此端点，请确保在您的系统上安装了 Python。即使安装了 Python，此端点也可能显示错误，指示未安装 Python
    的密码学和 base58 模块。因此，如果工具提示您安装这些模块，请确保您安装了这些模块。
- en: Building the frontend
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: Now let's build the frontend of our application. Our frontend will let users
    see the list of recent matches, deploy the betting contract, bet on a game, and
    let them see information about a betting contract.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建应用程序的前端。我们的前端将让用户看到最近比赛的列表，部署投注合约，对游戏进行投注，并让他们看到有关投注合约的信息。
- en: 'Let''s first implement the `matches.ejs` file, which will display the list
    of recent matches. Here is the code for this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现`matches.ejs`文件，该文件将显示最近比赛的列表。这是这个文件的代码：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is self-explanatory. Now let's write the HTML code for our
    home page. Our home page will display three forms. The first form is to deploy
    a betting contract, the second form is to invest in a betting contract, and the
    third form is to display information on a deployed betting contract.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们为我们的首页编写 HTML 代码。我们的首页将显示三个表单。第一个表单用于部署一个投注合约，第二个表单用于投资一个投注合约，第三个表单用于显示已部署投注合约的信息。
- en: 'Here is the HTML code for the home page. Place this code in the `index.html`
    page:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是首页的 HTML 代码。将此代码放在`index.html`页面中：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is self-explanatory. Now let''s write JavaScript code to
    actually deploy the contract, invest in contracts, and display information on
    contracts. Here is the code for all this. Place this code in the `main.js` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们编写 JavaScript 代码来实际部署合约，在合约上投资，并显示有关合约的信息。以下是所有这些的代码。将此代码放在`main.js`文件中：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is how the preceding code works:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前代码的工作原理：
- en: At first, we store the contract byte code and ABI in the `bettingContractByteCode`
    and `bettingContractABI` variables, respectively.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将合约的字节码和 ABI 存储在`bettingContractByteCode`和`bettingContractABI`变量中。
- en: Then, we are create a `Web3` instance, which is connected to our testnet node.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个连接到我们的测试网节点的`Web3`实例。
- en: Then, we have the `getAJAXObject` function (a cross-browser compatible function),
    which returns an AJAX object.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`getAJAXObject`函数（一个跨浏览器兼容的函数），它返回一个 AJAX 对象。
- en: Then, we attach a `submit` event listener to the first form, which is used to
    deploy the contract. In the event listener's callback, we make a request to the
    `getURL` endpoint by passing `matchId` to get the encrypted query string. And
    then, we generate the data to deploy the contract. Then, we find out the `gasRequired`.
    We use the function object's estimateGas method to calculate the gas required,
    but you can use the web3.eth.estimateGas method too. They both differ in terms
    of arguments; that is, in the preceding case, you don't need to pass the transaction
    data. Remember that `estimateGas` will return the block gas limit if the function
    call throws an exception. Then, we calculate the nonce. Here, we just use the
    `getTransactionCount` method instead of the actual procedure we learned earlier.
    We do this just for simplification of the code. Then, we create the raw transaction,
    signing it and broadcasting it. Once the transaction is mined, we display the
    contract address.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`submit`事件侦听器附加到第一个表单上，该表单用于部署合约。在事件侦听器的回调中，我们通过传递`matchId`来向`getURL`端点发出请求，以获取加密的查询字符串。然后，我们生成用于部署合约的数据。然后，我们找出`gasRequired`。我们使用函数对象的`estimateGas`方法来计算所需的
    gas，但您也可以使用`web3.eth.estimateGas`方法。它们在参数方面有所不同；即，在前面的情况下，您不需要传递交易数据。请记住，如果函数调用引发异常，`estimateGas`将返回块
    gas 限制。然后，我们计算 nonce。在这里，我们只是使用`getTransactionCount`方法而不是我们之前学到的实际过程。我们之所以这样做，只是为了简化代码。然后，我们创建原始交易，对其进行签名并广播。一旦交易被挖掘，我们将显示合约地址。
- en: Then, we attach a `submit` event listener for the second form, which is used
    to invest in a contract. Here, we generate the `data` part of the transaction,
    calculating the gas required, creating the raw transaction, signing it, and broadcasting
    it. While calculating the gas required for the transaction, we pass the contract
    address from the account address and value object properties as it's a function
    call, and the gas differs depending on the value, the from address, and contract
    address. Remember that while finding the gas required to call a contract's function,
    you can pass the `to`, `from`,and `value` properties because gas depends on these
    values.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为第二个表单附加了一个`submit`事件监听器，用于投资合约。在这里，我们生成交易的`data`部分，计算所需的 gas，创建原始交易，签名并广播。在计算交易所需的
    gas 时，我们传递了从账户地址和值对象属性到合约地址，因为它是一个函数调用，而 gas 取决于值、来自地址和合约地址。请记住，在找到调用合约函数所需的 gas
    时，您可以传递`to`、`from`和`value`属性，因为 gas 取决于这些值。
- en: Finally, we have a `submit` event listener for the third form, that is, to display
    information on a deployed betting contract.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为第三个表单添加了一个`submit`事件监听器，即显示部署的押注合约的信息。
- en: Testing the client
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端
- en: Now that we have finished building our betting platform, it's time to test it.
    Before testing, make sure the testnet blockchain is completely downloaded and
    is looking for new incoming blocks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了建立我们的押注平台，是时候测试它了。在测试之前，请确保测试网络区块链已完全下载并正在寻找新的入块。
- en: Now using our wallet service we built earlier, generate three account. Add one
    ether to each of the accounts using [http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用我们之前构建的钱包服务，生成三个账户。使用 [http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/)
    为每个账户添加一以太币。
- en: 'Then, run `node app.js` inside the `Initial` directory and then visit `http://localhost:8080/matches`,
    and you will see what is shown in this screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Initial`目录中运行`node app.js`，然后访问`http://localhost:8080/matches`，您将看到以下截图中显示的内容：
- en: '![](img/image_07_001.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_001.png)'
- en: 'Here, you can copy any match ID. Let''s assume you want to test with the first
    match, that is, 123945\. Now visit [`http://localhost:8080`](http://localhost:8080)
    and you will see what is shown in this screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以复制任何比赛 ID。假设您想使用第一场比赛进行测试，即 123945。现在访问 [`http://localhost:8080`](http://localhost:8080)
    您将看到以下截图中显示的内容：
- en: '![](img/image_07_002.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_002.png)'
- en: Now deploy the contract by filling the input fields in the first form and clicking
    on the Deploy button, as shown here. Use your first account to deploy the contract.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过填写第一个表单中的输入字段并单击“部署”按钮来部署合约，如下所示。使用您的第一个账户来部署合约。
- en: '![](img/image_07_003.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_003.png)'
- en: 'Now bet on the contract''s home team from the second account and the `away
    team` from the third account , as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从第二个账户对合约的主队和从第三个账户对`客队`进行押注，如下所示：
- en: '![](img/image_07_004.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_004.png)'
- en: 'Now put the contract address on the third form and click on the Find button
    to see the details about the contract. You will see something similar to what
    is shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在第三个表单中输入合约地址并单击“查找”按钮以查看合约的详细信息。您将看到类似于以下截图的内容：
- en: '![](img/image_07_005.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_005.png)'
- en: 'Once both the transactions are mined, check the details of the contract again,
    and you will see something similar to what is shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两笔交易都被挖掘，再次检查合约的详细信息，您将看到类似于以下截图的内容：
- en: '![](img/image_07_006.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_006.png)'
- en: Here, you can see that the contract doesn't have any ether and all the ether
    was transferred to the account that put the bet on the home team.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到合约没有任何以太币，所有以太币都被转移到押注主队的账户。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about Oraclize and the `strings` library in depth.
    We used them together to build a decentralized betting platform. Now you can go
    ahead and customize the contract and the client based on your requirements. To
    enhance the app, you can add events to the contract and display notifications
    on the client. The objective was to understand the basic architecture of a decentralized
    betting app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入学习了 Oraclize 和 `strings` 库。我们将它们一起使用，构建了一个去中心化的押注平台。现在您可以根据您的需求进一步定制合约和客户端。为了增强应用程序，您可以向合约添加事件并在客户端显示通知。我们的目标是了解去中心化押注应用程序的基本架构。
- en: In the next chapter, we will learn how to build enterprise-level Ethereum smart
    contracts using truffle by building our own crypto currency.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 truffle 构建企业级以太坊智能合约，通过构建我们自己的加密货币。
