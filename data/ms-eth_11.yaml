- en: Decentralized Exchanges Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化交易所工作流程
- en: Decentralized exchanges, also known as **DAXs**, are a hot topic for the simple
    reason that all cryptocurrencies need to be exchanged by others to give them some
    kind of utility. Could you imagine a world where you couldn't trade Bitcoin for
    dollars? Or Ethereum for Bitcoin? It would destroy the real-world utility of most
    cryptocurrencies. That's why we have exchanges, to allow the trading of all kinds
    of currencies in a free market. We'll start by working on an explanation about
    DAXs so that you understand the idea behind them. Then you'll understand how the
    orders are made and how to manage user funds in a secure manner. After that, you'll
    create a real-world DAX with a complex smart contract and a detailed interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化交易所，也被称为**DAXs**，是一个热门话题，简单的原因是所有加密货币都需要通过其他货币进行交换，以赋予它们某种实用性。你能想象一个世界，在这个世界里你不能用比特币换取美元吗？或者以太坊换比特币？这将摧毁大多数加密货币的实际实用性。这就是为什么我们有交易所，为了允许各种货币在自由市场中交易。我们将首先介绍关于
    DAXs 的解释，以便你理解它们背后的思想。然后你会理解订单是如何进行的以及如何以安全的方式管理用户资金。之后，你将创建一个具有复杂智能合约和详细界面的真实世界
    DAX。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Introducing decentralized exchanges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍去中心化交易所
- en: Understanding the trading and matching engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交易和匹配引擎
- en: Managing cryptocurrency wallets and cold storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理加密货币钱包和冷存储
- en: Building the user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Building the Ethereum backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建以太坊后端
- en: Finishing the dApp
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成 dApp
- en: Introducing decentralized exchanges
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍去中心化交易所
- en: What are DAXs, really? Well, normal exchanges, such as the stock market, are
    built upon a centralized system where a server processes all orders and displays
    the results to the users. They run very efficient systems that are quite expensive
    to set up, although it's understandable given the utility they provide. DAXs,
    on the other hand, don't rely on a centralized system where all orders have to
    go through a server that makes the necessary computations. Instead, DAXs work
    on top of Ethereum's infrastructure to provide users with a system that can be
    executed by anyone and processed by the gigantic net of computers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到底什么是 DAXs？嗯，普通的交易所，比如股票市场，建立在一个集中式系统之上，其中一个服务器处理所有订单并向用户显示结果。他们运行非常高效的系统，但是要建立这样的系统成本相当高，尽管考虑到它们提供的效用是可以理解的。另一方面，DAXs
    不依赖于一个集中式系统，所有订单都必须通过一个进行必要计算的服务器进行处理。相反，DAXs 基于以太坊的基础架构工作，为用户提供一个可以由任何人执行并由庞大的计算机网络处理的系统。
- en: The first difference with DAX compared to centralized exchanges is that they
    are limited by the technology behind them. You can't create a DAX that trades
    fiat currencies, such as the American dollar or the European euro, because those
    currencies are based on a different technology; they run on a different market,
    known as FOREX, where banks all over the world trade global currencies. Equally,
    you can't trade ERC20 tokens on the stock market exchange because they run on
    top of Ethereum, and the developers working on those centralized exchanges don't
    have the tools required to create a fluid connection between those systems – the
    main reason being the differences in speed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与中心化交易所相比，DAX 的第一个区别是它们受到背后技术的限制。你不能创建一个交易法币的 DAX，比如美元或欧元，因为这些货币是基于不同的技术的；它们在一个称为
    FOREX 的不同市场上运行，那里的全球银行交易全球货币。同样，你也不能在股票市场交易 ERC20 代币，因为它们是基于以太坊运行的，而且在那些中心化交易所工作的开发者没有创建这些系统之间流畅连接所需的工具——主要原因是速度上的差异。
- en: Ethereum naturally makes slower transactions because they have to be confirmed
    by every node of the network. That's why it's expected to have a slow trading
    system in DAXs. However, there are scaling technologies, such as *plasma* and
    *state channels*, that allow you to trade way more efficiently after an initial
    setup. We'll explore how they work and we'll build a DAX so that you understand
    how they work. You could even create your own rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊自然会产生较慢的交易，因为它们必须被网络的每个节点确认。这就是为什么在 DAXs 中预期会有一个慢速交易系统。然而，还有一些扩展技术，比如 *plasma*
    和 *state channels*，允许你在初始设置后更有效地进行交易。我们将探讨它们的工作原理，并构建一个 DAX，以便你理解它们是如何工作的。你甚至可以创建自己的规则。
- en: Cons of DAXs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DAXs 的缺点
- en: DAXs are generally slower since you can't make instant transactions unless you
    rely on off-chain systems between a pair of currencies, slowing you down when
    you desire to trade between other cryptocurrencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs通常较慢，因为除非你依赖于货币对之间的链下系统，否则无法进行即时交易，在你希望在其他加密货币之间进行交易时将会放慢你的速度。
- en: They are also limited in the sense that you can't trade fiat currencies or cryptocurrencies
    based on different blockchains. For instance, the only way to exchange **Bitcoin**
    (**BTC**) for **Ethereum** (**ETH**) is to have a centralized system that holds
    both of those currencies and provides the user with a fair exchange at any given
    moment. There are a few projects that have integrated both types of currencies,
    but they are still young and need to mature to become popular.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在某种程度上也受限，因为你不能交易不同区块链上基于法定货币或加密货币的货币。例如，交换**比特币**（**BTC**）兑换**以太坊**（**ETH**）的唯一方法是拥有中心化系统，该系统持有这两种货币，并在任何时刻提供用户公平的交换。有一些项目已经整合了这两种类型的货币，但它们仍然年轻，并需要成熟才能变得受欢迎。
- en: DAXs are not yet used by the mainstream public, so they are not as good as they
    could be, since we lack the tools and protocols needed to create the type of exchanges
    that work without issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs目前尚未被主流公众使用，所以它们没有达到它们可能达到的水平，因为我们缺乏创建无故障工作的交易所所需的工具和协议。
- en: Pros of DAXs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DAXs的优势
- en: On the other hand, these types of exchanges have the potential to overcome the
    outdated technology from most markets that rely on centralized transactions. Because
    they are being created from scratch, they can take all that's great from other
    projects and implement them with better features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这些类型的交易所有可能克服多数依赖中心化交易的大多数市场过时技术。因为它们是从零开始创建的，所以它们可以在其他项目中获取所有优点，并将其更好地实施。
- en: DAXs can work with thousands of tokens by default, since most of them implement
    the ERC20 standard, giving them a huge array of possibilities. There are great
    projects that are building protocols, such as the **0xprotocol** where developers
    can implement a set of known functions to their own systems so that they can communicate
    freely as one global system of interconnected DAXs. In fact, the 0xprotocol shares
    the liquidity of tokens among many exchanges, giving them the power to perform
    as a trader without requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs默认可以使用数千种代币，因为它们大多数实施了ERC20标准，为它们提供了巨大的可能性。有许多优秀的项目正在构建协议，比如**0xprotocol**，其中开发人员可以将一组已知功能添加到自己的系统中，以便它们可以自由通信，作为一个全球互连DAXs系统。事实上，0xprotocol分享了代币的流动性，使它们可以在没有任何要求的情况下作为交易者运行。
- en: With the new scaling solutions being developed by the core Ethereum team, DAXs
    are about to vastly improve, with faster transactions that resemble real-work
    centralized markets, making Ethereum a core player in the global economy of virtual
    currency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着以太坊核心团队开发的新的扩容解决方案，DAXs即将大幅改善，交易速度更快，类似于真实的中心化市场，使以太坊成为全球虚拟货币经济中的核心参与者。
- en: Many successful exchanges are improving to expand the paradigm of what's possible
    with decentralized technology, and they are using stablecoins, such as Tether
    and USD Coin, to keep a constant value backed on fiat currencies, thus bridging
    the gap between both worlds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多成功的交易所正不断提高以扩展去中心化技术的可能性范式，并且它们正在使用稳定币，如泰达币和USD Coin，以维持以法定货币支持的不变价值，从而弥合了两个世界之间的鸿沟。
- en: We could talk about DAXs for hours in several different books, but the point
    that I'm trying to bring across is that DAXs have the potential to surpass existing
    technology to become the main place where the global market of centralized and
    decentralized currencies takes place. That's why I want you to understand how
    all of this is possible by building a simple DAX based on solidity smart contracts
    to have the practical experience required to work for the many companies that
    create DAXs, or even start your own since they are one of the core elements of
    decentralized technology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几本不同的书中讨论数小时有关DAXs，但我想要传达的观点是，DAXs有潜力超越现有技术，成为全球中心化和去中心化货币市场的主要场所。这就是为什么我希望你通过构建基于solidity智能合约的简单DAX来明白所有这些是如何可能的，以获取为创建DAXs的许多公司工作所需的实践经验，甚至自己开始DAX，因为它们是去中心化技术的核心要素之一。
- en: Essential trading terms
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本交易术语
- en: The world of exchanges is vast and complicated; that's why the people using
    them created lots of terms to help each other understand what they mean precisely.
    For instance, instead of saying *I want to buy 10 BTC hoping that it goes up in
    the future*, you say *I want to go long on 10 BTC*. They mean the same thing,
    but it's a more precise way of communicating with each other.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 交易世界广阔而复杂；这就是为什么使用它们的人们创造了许多术语来帮助彼此准确理解它们的含义。例如，与其说 *我想购买 10 个 BTC，希望未来价格上涨*，你可以说
    *我想多买入 10 个 BTC*。它们的意思是一样的，但这是一种更精确的相互沟通方式。
- en: 'Let''s go through some important terminology to comprehend some aspects of
    exchange markets:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一些重要的术语，以理解交易市场的一些方面：
- en: '**Market order**: An action that consists of selling or buying a currency for
    the lowest or highest price available. You see, in exchanges there are sellers
    and buyers, those that want to get rid of some currency and those that want to
    grab some of it. Each one of them sets a price for what they want to get in return
    and the prices are always in pairs. For instance, *I want to buy 10 BTC at the
    price of 50 ETH*. In this case the pair would be BTC-ETH because you''re stating
    that you want to get ETH in exchange for your Bitcoin; there, you''re being a
    buyer of Bitcoin and a seller of Ether at the same time. People set different
    prices, so when you make a market order you just buy or sell at the largest profit.
    The same thing happens when you buy something online with dollars. If you are
    European, like me, you''d notice that many things online are priced in dollars,
    making it impossible to buy those items as you have euros, and they are not the
    same thing. So what happens when you buy say, a book? In the backend, some program
    is exchanging euros for dollars at the price set by the market and it''s buying
    the book with dollars.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市价单**：一种以最低或最高价格买入或卖出货币的行为。你看，交易所有卖家和买家，那些想要摆脱某种货币的人和那些想要获取一些货币的人。每个人都为自己想要得到的东西设定一个价格，价格总是成对出现的。例如，*我想以
    50 个 ETH 的价格购买 10 个 BTC*。在这种情况下，这对将是 BTC-ETH，因为你声明你想用你的比特币交换以太币；在那里，你同时是比特币的买家和以太币的卖家。人们设定不同的价格，所以当你进行市价交易时，你只是以最大的利润买入或卖出。当你用美元在线购买东西时也是一样的。如果你是欧洲人，像我一样，你会注意到许多在线物品的价格是以美元计价的，这使得用欧元购买这些物品成为不可能，因为它们不是同一种货币。那么当你购买书籍时会发生什么？在后台，一些程序以市场设定的价格将欧元兑换为美元，并用美元购买书籍。'
- en: '**Limit order**: An action where you sell or buy at a fixed price that you
    set by yourself. These types of orders are used for those that predict price movements
    or are comfortable waiting until their order gets filled over a longer time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限价单**：一种你自己设定的固定价格买入或卖出的行为。这些类型的订单用于那些预测价格变动或愿意等待订单在较长时间内得到执行的人。'
- en: '**Broker**: A person that lends you money with interest for your trading activities.
    Brokers usually help you with actions, such as executing your trades, because
    they have more money so they enjoy special privileges in the exchange you''re
    in.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经纪人**：一位向你提供贷款以进行交易活动的人。经纪人通常会帮助你执行交易等行动，因为他们有更多的资金，所以在你所在的交易所享有特权。'
- en: '**Margin account**: A special type of user account where you can borrow money
    from brokers as you trade.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保证金账户**：一种特殊类型的用户账户，你可以在其中在交易时从经纪人那里借钱。'
- en: '**Long buying**: An action where you buy a specific currency because you believe
    it will go up in value to make a profit, or to support the technology behind the
    currency.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多买入**：一种购买特定货币的行为，因为你相信它将升值以获利，或者支持货币背后的技术。'
- en: '**Short selling**: An action where you win when the currency that you''re shorting
    goes down in value. For instance, you could say, *I''m going to go short on euros
    because I believe the price will go down in the next five days*. It''s a system
    where you can sell currencies that you don''t own. The reasoning behind consists
    of the following:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空头交易**：一种当你看空的货币价值下跌时赢得的行为。例如，你可以说，*我要做空欧元，因为我相信价格会在接下来的五天内下跌*。这是一个你可以卖出你不拥有的货币的系统。其背后的推理包括以下内容：'
- en: First, you borrow money from another person, called the broker, who gives you
    the desired amount of currencies that you want to short, such as 100 ETH that
    you short.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你从另一个人，称为经纪人，那里借钱，他会给你想要做空的货币的所需数量，比如你做空的 100 个 ETH。
- en: You automatically sell those 100 ETH at the market price.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会自动以市场价格出售那 100 个 ETH。
- en: At a later date, you buy those 100 ETH. This is called closing your position.
    For instance, after 20 days, you close your short position by buying 100 ETH at
    the market price.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在稍后的日期，你会购买这 100 个 ETH。这被称为平仓。例如，20 天后，你以市价购买 100 个 ETH 来平掉你的空头仓位。
- en: You win or lose money based on the price when selling and buying. If you start
    shorting at a high price and close your position at a low price, you win the difference.
    For instance, if you go 100 ETH short at $20 each and you close your position
    5 days later where ETH is worth $10, you would have won $10 dollars per Ether
    or a total of 100 ETH × $10 = $1,000 dollars.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据买入和卖出时的价格，你会赚取或亏损资金。如果你在高价位做空，然后在低价位平仓，你会赚取价格差。例如，如果你以每个以太币 20 美元的价格做空 100
    个 ETH，5 天后以太币价格为 10 美元时平仓，你将赚取每个以太币 10 美元，总计 100 个 ETH × 10 美元 = 1000 美元。
- en: Usually shorting is only available on margin accounts. Those are accounts where
    you can borrow money from brokers with some restrictions.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常做空只在保证金账户上可用。这些账户是你可以从经纪人借钱的账户，但有一些限制。
- en: There's also the bid and ask, which are equivalent to buy and sell. Now that
    you better understand a few complicated concepts, you can move on to learn more
    about the DAX that we are going to build in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有买价和卖价，分别等同于买入和出售。现在你更好地理解了一些复杂的概念，你可以继续学习我们将在本章构建的 DAX 更多相关内容。
- en: Understanding the trading and matching engine
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解交易和匹配引擎
- en: A trading and matching engine is a set of functions that use different types
    of algorithms to create and close orders. An algorithm could focus on completing
    the orders with the higher price or those that were executed earlier. It depends
    on the preferences of the developers. Because we'll work with smart contracts
    and ERC20 tokens, our engine will focus on completing the orders as quickly as
    they come, since it will be the users that close the orders, given that the frontend
    is where most of the logic will be.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 交易和匹配引擎是一组使用不同类型算法创建和关闭订单的函数。算法可能专注于完成具有更高价格或之前执行的订单。这取决于开发人员的偏好。因为我们将使用智能合约和
    ERC20 代币，我们的引擎将专注于按照订单依次快速完成，因为将会是用户关闭订单，前端将包含大部分逻辑。
- en: We can't process large amounts of information on smart contracts since gas is
    expensive, so we let the React application take control of the trading to save
    people's funds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在智能合约中处理大量信息，因为 gas 费用昂贵，所以我们让 React 应用程序控制交易以保护人们的资金。
- en: 'Let''s start by planning the functions that we''ll need so that we have a solid
    foundation when we create the contracts and the frontend functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计划我们将需要的函数开始，这样当我们创建合约和前端函数时就有了坚实的基础：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That function signature (the function name with parameters but no body) will
    take care of generating limit orders. Let''s see some examples and check whether
    the signature of the function checks out:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数签名（带参数但不含主体的函数名称）将负责生成限价订单。让我们看一些示例，并检查函数签名是否正确：
- en: 'For example, *I want to sell 7 BTC in exchange for 90 ETH*, execute the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*我想用 90 个 ETH 换取 7 个 BTC*，执行以下代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we reversed the order of the symbol to convert that sell order
    into a buy order where the user is willing to buy `ETH` in exchange for `BTC`.
    It has the same effect with just one function, instead of creating an exclusive
    function for selling.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将符号的顺序颠倒，将卖出订单转换为买入订单，用户愿意用 `ETH` 换取 `BTC`。它具有相同的效果，只需一个函数，而不需要为出售创建专门函数。
- en: For example, *I want to buy 10 BTC for 20 ETH*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*我想用 20 个 ETH 买入 10 个 BTC*。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we put the symbols in the same order as expected since we are
    creating a limit order to buy `BTC` while selling `ETH`. Now we can create the
    signature of the market order function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将符号按照期望的顺序放置，因为我们正在创建一个买入 `BTC` 并卖出 `ETH` 的限价订单。现在我们可以创建市价订单函数的签名。
- en: Market orders are interesting, since we want to immediately fill the order at
    the cheapest or highest price possible. What happens under the hood is that we're
    closing a limit order with our market order. Nevertheless, it's often impossible
    to fill the entire order at the latest market price for the simple reason that
    the most profitable limit order is buying or selling minimal quantities of a token.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 市价订单很有趣，因为我们希望以最便宜或最贵的价格立即填充订单。背后发生的是我们用市价订单来关闭限价订单。然而，通常不可能以最新市价填满整个订单，简单的原因是最赚钱的限价订单是购买或出售最少数量的代币。
- en: For instance, we want to sell 10 TokenA at the market price for TokenB. The
    most profitable limit order available says *buy 5 TokenA in exchange for 40 TokenB*.
    In that case, the price of 1 TokenA would be 8 TokenB and vice versa. So we create
    the market order and we immediately sell 5 TokenA to buy 40 TokenB from that limit
    order, but what happens with the remaining 5 TokenA that we want to sell? We go
    to the next most profitable buy order, which says *buy 100 TokenA for 700 TokenB*.
    In that case, the price of 1 TokenA would be 7 TokenB, which is less profitable
    than the last one but still not bad. So we sell 5 TokenA in exchange for 35 TokenB,
    leaving that limit buy order at *buy 95 tokenA for 665 TokenB* until the next
    user fills it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想以市场价格出售10个TokenA换取TokenB。最有利可图的限价订单是*以40个TokenB换取5个TokenA*。在这种情况下，1个TokenA的价格将为8个TokenB，反之亦然。因此，我们创建了市价订单，立即从该限价订单中出售5个TokenA以换取40个TokenB，但是我们想要出售的剩余的5个TokenA怎么办？我们转向下一个最有利可图的买单，即*以700个TokenB换取100个TokenA*。在这种情况下，1个TokenA的价格将为7个TokenB，虽然不如上一个订单的利润高，但仍然不错。因此，我们交换了5个TokenA以换取35个TokenB，将该限价买单保留在*以665个TokenB购买95个TokenA*，直到下一个用户填满为止。
- en: 'At the end, we got 75 TokenB for 10 TokenA using a combination of market prices
    at that specific moment that depended on the most profitable limit orders at that
    time. With that understanding, we can create the signature of our market order
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用那一特定时刻的最有利可图限价订单的组合，以10个TokenA获得了75个TokenB。通过这种理解，我们可以创建我们的市场订单功能的签名：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_maxPrice` parameter is simply a number that states the lowest price that
    you're willing to sell, or the highest price that you're willing to buy. By default,
    it's zero, which is unlimited so you'll get the most profitable price as long
    as there are sellers or buyers available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`_maxPrice`参数只是一个数字，表示您愿意出售的最低价格，或者您愿意购买的最高价格。默认情况下为零，即无限制，因此只要有卖家或买家可用，您就会得到最有利可图的价格。'
- en: Managing cryptocurrency wallets and cold storage
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理加密货币钱包和冷存储
- en: When it comes to storing people's funds, we must pay extra attention to how
    we do it since we could risk losing millions of dollars using our DAX. That's
    why the largest exchanges use cold storage with lots of security systems in place.
    Essentially, they keep funds offline in a remote location stored in secure hardware
    devices that are customized to their needs such as Trezor, Ledger, or their own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管理人们的资金时，我们必须格外注意我们的操作方式，因为使用我们的DAX可能会面临数百万美元的风险。这就是为什么最大的交易所采用冷存储并配备了许多安全系统的原因。基本上，他们会将资金离线存储在远程位置的安全硬件设备中，这些设备根据其需求进行定制，如Trezor、Ledger或他们自己的设备。
- en: In our case, we'll store funds in a series of smart contracts, known as **escrows**,
    whose only goal is to store people's money. There will be an escrow contract associated
    with each user account to independently secure all of their funds. That escrow
    contract will have a function to receive funds, only ERC20 tokens, and a function
    to extract funds executable by the owner of that escrow. Go ahead and create a
    folder named `decentralized-exchange`, then run the `truffle init` and `npm init
    -y` commands, and create a contract inside the `contracts/` folder named `Escrow.sol`.
    The following is how our escrow will look.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将资金存储在一系列智能合约中，称为**托管合约**，其唯一目标是存储人们的资金。每个用户帐户将关联一个托管合约，独立安全地保管所有他们的资金。该托管合约将具有一个函数来接收资金，仅限ERC20代币，并具有一个可以由该托管合约所有者执行的提取资金的函数。现在，请创建一个名为`decentralized-exchange`的文件夹，然后运行`truffle
    init`和`npm init -y`命令，在`contracts/`文件夹中创建一个名为`Escrow.sol`的合约。以下是我们的托管合约的外观。
- en: 'First, it contains the interface for ERC20 tokens since we don''t need the
    entire implementation to be able to trade with tokens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它包含了ERC20代币的接口，因为我们不需要整个实现来进行代币交易：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we add the `Escrow` contract, which will be used to manage the funds of
    each user:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们添加了`Escrow`合约，用于管理每个用户的资金：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Escrow` contract receives token transfers to keep the funds safely inside.
    Each user will have a unique escrow contract to decentralize the location of funds
    so that attackers can't focus on a single place. You can manage the token funds
    inside with the `transferTokens()` function and you can check the balance of tokens
    inside the contract with the `checkTokenBalance()` function, which is a simplified
    `.balanceOf()` ERC20 helper function. Finally, I've added an empty non-payable
    fallback function to avoid receiving Ether since we only want tokens inside.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Escrow`合约接收代币转账以将资金安全地保存在内部。每个用户将拥有一个独特的托管合约来分散资金的位置，以便攻击者无法集中于单一地点。您可以通过`transferTokens()`函数管理合约内的代币资金，并且可以使用`checkTokenBalance()`函数检查合约内的代币余额，这是一个简化的`.balanceOf()`ERC20辅助函数。最后，我添加了一个空的非付款回退函数，以避免接收Ether，因为我们只想要代币内部。
- en: We'll use this `Escrow` contract to manage people's funds later on, since we
    want a secure place to keep their precious tokens. Ideally, we would create a
    system that uses cold storage in hardware devices, but such an action would require
    a complex system that takes care of securely managing every step of the way to
    prevent middlemen attacks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后使用这个`Escrow`合约来管理人们的资金，因为我们希望有一个安全的地方来保存他们珍贵的代币。理想情况下，我们会创建一个使用硬件设备中的冷存储的系统，但这样的操作将需要一个复杂的系统，负责安全管理每一个步骤，以防止中间人攻击。
- en: Building the user interface
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: The user interface for DAXs is the same as the ones used for traditional exchanges,
    such as the stock exchange, or centralized crypto-exchanges, such as **Binance**.
    The idea is to provide a data-driven design where they can quickly understand
    the situation of the selected token pairs. A central section will be used for
    the data, a sidebar will be used for the actions that users may take, and an additional
    sidebar to the right will be used for secondary data; in our case, it will be
    used for past trades.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs的用户界面与传统交易所（如股票交易所）或中心化加密交易所（如**币安**）使用的界面相同。其理念是提供一个数据驱动的设计，使他们能够快速了解所选代币对的情况。中心区域将用于数据显示，侧边栏将用于用户可能采取的操作，右侧将用于辅助数据；在我们的情况下，它将用于过去的交易。
- en: As usual, create a `src` and `dist` folder that will include our project. You
    can just copy the setup from previous projects by taking a look at my own version
    on [github.com/merlox/dapp](http://github.com/merlox/dapp). Our design will be
    based on most exchanges since they have a studied formula that feels great. Create
    the sidebar with a new component inside your `index.js` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，创建一个包含我们项目的`src`和`dist`文件夹。您可以通过查看我的GitHub上的自己版本 [github.com/merlox/dapp](http://github.com/merlox/dapp)
    来直接复制之前项目的设置。我们的设计将基于大多数交易所，因为它们有一个经过研究的公式，感觉很棒。在您的`index.js`文件中创建一个新组件作为侧边栏的一部分。
- en: 'First, add the `Main` component along with the required imports for a normal
    React application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加`Main`组件以及普通React应用程序所需的导入：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then add the `Sidebar` component with some basic actions that the user can
    take, such as a money-management section to add or withdraw money, and a section
    to create buy or sell orders:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`Sidebar`组件，其中包含用户可以执行的一些基本操作，例如资金管理部分以添加或提取资金，以及创建买入或卖出订单的部分：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The classes and elements that you add are completely up to you. Personally,
    I like to show users the currency pair they are trading, their balance for each
    one, and a set of actions such as buy, sell, deposit, and withdraw. Then we can
    add some `css`. In this project, we''ll be using a `css` preprocessor known as
    `stylus` ([stylus-lang.com](http://stylus-lang.com)), which allows you to write
    `css` without brackets and nested classes, among many other nice features. You
    can install it as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您添加的类和元素完全由您决定。我个人喜欢向用户显示他们正在交易的货币对，每个货币对的余额以及一组操作，如购买、出售、存款和提款。然后，我们可以添加一些`css`。在这个项目中，我们将使用一种称为`stylus`的`css`预处理器（[stylus-lang.com](http://stylus-lang.com)），它允许您在没有括号和嵌套类的情况下编写`css`，以及许多其他很好的功能。您可以按照以下步骤安装它：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add it to your `webpack` configuration file as a new rules block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到你的`webpack`配置文件中作为新的规则块：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new `index.styl` file inside your source folder and add your Stylus
    code. If you want to create the same design as me, check the stylus code on the
    official GitHub here: [https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的源文件夹内创建一个新的`index.styl`文件，并添加你的Stylus代码。如果你想创建和我一样的设计，请在官方GitHub上查看stylus代码：[https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl)。
- en: 'This generates a nice-looking sidebar for our DAX. Remember to bundle your
    files with `webpack -w -d`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的DAX生成了一个漂亮的侧边栏。记得用`webpack -w -d`打包你的文件：
- en: '![](img/0c8388d6-1c5b-42cf-94c9-93968fa57683.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8388d6-1c5b-42cf-94c9-93968fa57683.png)'
- en: As you can see, Stylus allows you to write clean, nestable `css` to organize
    big chunks of styling easily so that your projects are easier to maintain. At
    the end, the code gets converted into valid `css` that runs on all browsers since
    Stylus compiles each file properly. Then we can add a trades section where we'll
    show the trades taking place in our exchange for all pairs, so that people understand
    the overall price of their coins.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Stylus允许你编写清晰、可嵌套的`css`，以便轻松组织大块的样式，从而使你的项目更易于维护。最后，该代码会被转换成有效的在所有浏览器上运行的`css`，因为Stylus会正确地编译每个文件。然后我们可以添加一个交易部分，展示在我们的交易所中所有货币对的交易，以便人们了解他们的硬币的总体价格。
- en: 'First, add new state trades to the state object with fake data to the `Main`
    component so that we can see how the dApp will look once completed in its final
    design:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Main`组件的状态对象中添加假数据的新交易以实现最终设计时dApp的展示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, update the `render()` function with the new state objects by passing
    the props to the `Trades` and `History` components:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过将props传递给`Trades`和`History`组件，用新的状态对象更新`render()`函数：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the new `Trades` component so that it displays the trades that we just
    added:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的`Trades`组件，以便显示我们刚刚添加的交易：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we''ve added lots of sample trades and history trades since
    we''ll need them to understand how our exchange looks in a real environment; note
    how we updated the `Main` component to pass the state data to each component.
    Then we can add some Stylus to make it look good. Check the final Stylus code
    on the official GitHub here: [https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl.).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由于我们需要它们来了解我们的交易所在实际环境中的样子，我们增加了许多样例交易和历史交易；请注意我们如何更新了`Main`组件，以将状态数据传递给每个组件。然后我们可以添加一些Stylus让它看起来更好。在官方GitHub上查看最终的Stylus代码：[https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl)。
- en: 'To get a great-looking design. Notice that I''ve included 15 trade objects
    and 15 history trade objects in the state of the `Main` component so that we can
    see how the dApp looks when fully loaded:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个外观漂亮的设计。请注意，我在`Main`组件的状态对象中包含了15个交易对象和15个历史交易对象，以便我们在完全加载后看到dApp的样子：
- en: '![](img/31ff1751-fdc3-48c3-8fc1-aa1f88b065c1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31ff1751-fdc3-48c3-8fc1-aa1f88b065c1.png)'
- en: 'The trade at the top of each BUY and SELL section is the market price for that
    cryptocurrency pair, since market orders are always the most profitable trade
    at that particular moment. Those trades will update in real-time as people trade
    different currencies over time. It''s a fantastic way to understand price movements.
    Finally, we can add the `History` section, which will show the most recent trades:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个BUY和SELL部分顶部最上面的交易是该加密货币对的市价，因为市价订单在那个特定时刻一直是最有利可图的交易。随着人们随着时间交易不同的货币，这些交易将实时更新。这是了解价格走势的一种奇妙方式。最后，我们可以添加`History`部分，它将显示最近的交易：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remember to add the `render()` function from the `react-dom` package to render
    your components. Then we can add some more `css`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得添加来自`react-dom`包的`render()`函数以渲染你的组件。然后我们可以添加更多`css`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if you run `webpack` and an `http-server`, you''ll see our finished product.
    It''s not responsive for mobile devices since our goal is to create an exchange
    to be used in desktop computers and it''s quite a time-consuming task to verify
    every breakpoint to accommodate it to the different dimensions for phones and
    tablets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`webpack`和`http-server`，你会看到我们的成品。由于我们的目标是创建一个用于桌面电脑的交易所，而要验证每个断点以适应手机和平板电脑的不同尺寸是一项耗时的任务，因此它对移动设备不具有响应性：
- en: '![](img/ba5184f6-415d-49c9-bd5c-4fa2fc4fdf98.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5184f6-415d-49c9-bd5c-4fa2fc4fdf98.png)'
- en: This will be our basic design. You can freely add more currency pairs with ERC20
    tokens, graphs with D3.js, and even state channels! The great thing about the
    project shown in this book is that you can build upon the existing structure to
    create a truly high-quality product that you can use for an ICO or to grow the
    ecosystem of dApps with your own solution. Let's move on to build the smart contracts
    needed to create trades and use the DAX with MetaMask.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的基本设计。您可以自由添加更多的货币对，使用 ERC20 代币，使用 D3.js 创建图表，甚至使用状态通道！本书中展示的项目的优点在于，您可以在现有结构的基础上构建一个真正高质量的产品，该产品可用于
    ICO 或使用您自己的解决方案来扩展 dApps 生态系统。让我们继续构建所需的智能合约来创建交易并使用 MetaMask 进行交易。
- en: Building the Ethereum backend
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建以太坊后端
- en: The backend for our project will take care of generating trades that can be
    filled by anyone as long as they have enough funds to pay the established price.
    When the user gets registered, they'll deploy an Escrow contract which will be
    used by our main DAX contract. So let's start by setting up the requirements and
    the contract structure before starting to fill all the functions to practice the
    system to improve, developer's efficiency that we studied in [Chapter 4](2b43135a-08f4-46d3-8c2a-5dd70bb02843.xhtml),
    *Mastering Smart Contracts*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的后端将负责生成可以由任何人填写的交易，只要他们有足够的资金支付已确定的价格即可。当用户注册时，他们将部署一个 Escrow 合约，该合约将由我们的主要
    DAX 合约使用。因此，让我们首先设置要求和合约结构，然后开始填写所有功能以练习在 [第四章](2b43135a-08f4-46d3-8c2a-5dd70bb02843.xhtml)
    中学习的系统以提高开发者的效率，*精通智能合约*。
- en: 'Start by defining the functions that we''ll need in a big comment at the beginning
    of the file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件开头的大型注释中定义我们将需要的函数：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set up the Solidity version used, import the `Escrow` contract, and define
    the token interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所使用的 Solidity 版本，导入 `Escrow` 合约，并定义令牌接口：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `DAX` contract by first defining the `Order` struct that we''ll
    use for creating new orders:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过定义我们将用于创建新订单的 `Order` 结构来创建 `DAX` 合约：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then define the many variables needed to manage sell and buy orders, while
    also whitelisting tokens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义管理卖单和买单所需的许多变量，同时也将令牌列入白名单：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the mappings required for add and manage the token symbols and to find
    the orders by the given IDs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需的映射以添加和管理令牌符号，并根据给定的 ID 查找订单：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, add the `onlyOwner` modifier, the fallback function which reverts, and
    the constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加 `onlyOwner` 修饰符，回退函数将还原，以及构造函数：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the whitelisting token function with the complete NatSpec documentation
    and the function signature. I''ve highlighted the function so that you can clearly
    differentiate the function from the comments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的 NatSpec 文档和函数签名定义白名单令牌函数。我已经突出显示了该函数，以便您可以清楚地区分函数和注释：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To manage tokens, create the following two functions with the documentation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理令牌，请创建以下两个带有文档的函数：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the market and limit the order functions with the parameters required for
    them to work properly, since these will be the main functions used to create orders
    and to interact with the DAX:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们正常工作所需的参数添加市场和限价订单功能，因为这些将是创建订单和与 DAX 交互的主要功能：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, add the `view` functions that you''ll use as helpers and getters for
    important variables that your interface may need. Try to add them yourself. Then
    check the solution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `view` 函数，您可以将其用作界面可能需要的帮助程序和获取器。尝试自己添加它们。然后检查解决方案：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we set up an `event` to log token transfers so that people can see when
    a token is sold or purchased. We could add more events but I'll leave it up to
    you to discover which events you need. Then we added a ton of necessary variables,
    starting with an `enum` that defines whether an order is open or closed. We added
    a `struct` for each property of each order to clearly define which token is being
    dealt.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一个 `event` 来记录令牌转移，以便人们可以看到什么时候卖出或购买了令牌。我们可以添加更多事件，但我将让您自行发现您需要哪些事件。然后，我们添加了大量必要的变量，从一个定义订单是开放还是关闭的
    `enum` 开始。我们为每个订单的每个属性添加了一个 `struct`，以清晰地定义正在处理哪个令牌。
- en: Then we added three arrays to store existing orders, while also having a few
    variables to whitelist new tokens so that we can trade with a wider set of cryptocurrencies.
    After that, we added multiple mappings to find each specific order easily while
    optimizing gas costs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了三个数组来存储现有订单，同时还有一些变量来将新代币列入白名单，以便我们可以与更广泛的加密货币集进行交易。之后，我们添加了多个映射以轻松找到每个特定订单，同时优化了
    gas 成本。
- en: We added an `onlyOwner` modifier to restrict access to the whitelisting function
    so that it doesn't get too crazy when it comes to adding cryptocurrencies. We
    added a fallback function that doesn't allow ETH transfers so that people don't
    send funds to this exchange, as well as a constructor that defines DAX's owner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`onlyOwner`修饰符来限制对whitelisting函数的访问，以防止在添加加密货币时变得太疯狂。我们添加了一个不允许以太币转账的fallback函数，以防止人们向这个交易所发送资金，并添加了一个定义DAX所有者的构造函数。
- en: Then we added the `whitelistToken()` function, which takes a token address,
    and an array of symbols to create pairs with that main token; that way, you're
    able to trade with a large quantity of pairs at once. The `depositTokens()` function
    is used by users that want to increase their token balance. They can directly
    transfer the tokens they want to trade to their associated Escrow contract, but
    users first have to create a new Escrow, which can only be done through this function.
    Then the `Escrow` address will be associated with that account in the `escrowByUserAddress`
    mapping. This deposit function also requires that the user previously uses the
    `approve()` function to allow the DAX contract to transfer tokens to the Escrow
    contract; otherwise, it will fail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`whitelistToken()`函数，该函数接受一个令牌地址和一个符号数组，用于创建与该主令牌的交易对；这样，你就能够一次交易大量的交易对。`depositTokens()`函数是由想增加其令牌余额的用户使用的。他们可以直接将他们想要交易的令牌转移到与他们相关联的Escrow合约中，但用户必须首先通过这个函数创建一个新的Escrow，这只能通过这个函数完成。然后，Escrow地址将与`escrowByUserAddress`映射中的该帐户关联起来。此存款函数还要求用户之前使用`approve()`函数来允许DAX合约将令牌转移到Escrow合约；否则，它将失败。
- en: Next, the `extractTokens()` function is used to move tokens from the Escrow
    to the user's address. It's a shortcut to the `transferTokens()` function inside
    the `Escrow` contract to facilitate token management. After that, we have the
    complex market and limit order functions. Both are big functions because they
    have to sort, update, and find orders to match existing ones while working within
    the limitations of the blockchain regarding gas usage. We'll soon see how they
    are implemented in depth. Finally, we have some helper functions to sort orders,
    check whether a given pair of token exists, and to retrieve an array of token
    pairs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`extractTokens()`函数用于将令牌从托管账户移动到用户的地址。这是一个快捷方式，用于在`Escrow`合约内部调用`transferTokens()`函数以便于令牌管理。之后，我们有复杂的市场和限价订单函数。它们都是大函数，因为它们需要对订单进行排序、更新和查找以匹配现有订单，并在区块链的燃气使用限制内工作。我们很快会深入了解它们是如何实现的。最后，我们有一些辅助函数用于对订单进行排序，检查给定的令牌对是否存在，以及检索令牌对的数组。
- en: 'Let''s go ahead and implement some of those functions. Remember to start with
    the simplest ones, and progress to the more complex ones, so that you have a solid
    structure behind them. Here is how the `whitelisting` function should look:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现一些这些函数。记得从最简单的函数开始，逐步进展到更复杂的函数，这样你就会有一个坚实的结构支撑它们。这是`whitelisting`函数应该的样子：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The whitelisting function makes some require checks, then whitelists each of
    the given token pairs so that you can trade with them independently. For instance,
    if your main token symbol is BAT and your array of `_tokenPairSymbols` contains
    `['TOK', 'TIK']`, you'll be able to trade with BAT - TOK and BAT - TIK. Simple
    stuff. The function should not run out of gas as long as you keep a low number
    of token pairs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: whitelisting函数进行一些要求检查，然后为每个给定的令牌对进行白名单设置，以便您可以独立交易。例如，如果你的主要令牌符号是BAT，并且你的`_tokenPairSymbols`数组包含`['TOK',
    'TIK']`，你就可以与BAT - TOK和BAT - TIK交易。简单的事情。只要你保持低数量的令牌对，该函数就不会耗尽燃气。
- en: 'The following are the next functions for managing token funds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于管理令牌资金的下一个函数：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The deposit function checks whether the user has an `Escrow` contract associated
    with their address. If not, the function creates a new `Escrow`, then transfers
    the deposit of tokens that the user requested as long as they previously approved
    some in the appropriate ERC20 contract.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 存款函数检查用户是否有与他们地址相关联的`Escrow`合约。如果没有，函数会创建一个新的`Escrow`，然后转移用户请求的令牌存款，只要他们之前在适当的ERC20合约中批准了一些令牌。
- en: The extract function is simply running the `transferTokens()` function to the
    owner's address, as long as they have some previous balance inside. Otherwise
    it will revert.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: extract函数只是简单地运行`transferTokens()`函数到所有者的地址，只要他们之前有一些余额。否则它会回滚。
- en: Let's move on to the limit order function. Because this is a larger function,
    we'll break it down into smaller parts so that you understand how each section
    operates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行限价订单功能。因为这是一个较大的功能，我们将其拆分为更小的部分，以便您了解每个部分的操作方式。
- en: 'First, we have an updated document based on changes that come across as you
    create the function. It''s never too late to improve the documentation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据创建函数时出现的更改更新的文档。改进文档永远不会太迟：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we run the many `require()` checks to be sure that the user is executing
    the limit order function properly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行许多`require()`检查，以确保用户正确执行限价订单功能：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, execute the `buy` functionality if the user is creating a buy limit
    order:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果用户创建买入限价订单，则执行`buy`功能：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Otherwise, change the array where the order will get added while also sorting
    the orders once added:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，更改订单添加的数组，同时在添加后对订单进行排序：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s the entire limit order function broken down into comprehensible pieces
    to explain the logic behind every statement. You saw that we used the `sortIdsByPrices`
    function because we need to sort the orders arrays. The following is how the sort
    function looks once completed. Notice that the function is a `view` type, which
    means that it won''t cost any gas to run all of the calculations, because they
    will be done locally so the sorted array can be limitless:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个限价订单功能拆分成易于理解的片段，以解释每个语句背后的逻辑。你看到我们使用了`sortIdsByPrices`函数，因为我们需要对订单数组进行排序。下面是完成后的排序函数的样子。请注意，该函数是`view`类型，这意味着运行所有计算不会产生任何Gas费用，因为它们将在本地执行，因此排序后的数组可以是无限的：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pay attention to the `sortIdsByPrice()` function. It reads the respective state
    variables that contain the order structs, and then organizes the orders in ascending
    order if those are buy limit orders, or descending, if they are sell limit orders.
    We need it for the limit order function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`sortIdsByPrice()`函数。它读取包含订单结构的相应状态变量，然后按升序排列订单（如果是买入限价单），或按降序排列订单（如果是卖出限价单）。我们需要它用于限价订单功能。
- en: The `limitOrder()` function starts by checking that the parameters are valid
    and that the tokens can be traded. Depending on the type of order requested, it
    will push a new `Order` struct instance to the `sellOrders()` or `buyOrders()`
    arrays while sorting those arrays to push this new limit order to the right location.
    Remember, the idea is to have a sorted array of orders so that we can find the
    most profitable ones quickly; that's why we have the sort function. Finally, it
    updates the arrays of orders and the mapping of order indexes, so that we can
    later find where each `Order` instance is located in those arrays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`limitOrder()`函数首先检查参数是否有效，以及代币是否可以交易。根据请求的订单类型，它将一个新的`Order`结构实例推送到`sellOrders()`或`buyOrders()`数组中，同时对这些数组进行排序，以将这个新的限价订单推送到正确的位置。请记住，我们的想法是有一个排序后的订单数组，以便我们可以快速找到最有利可图的订单；这就是为什么我们有排序功能。最后，它更新订单数组和订单索引映射，以便我们以后可以找到每个`Order`实例在这些数组中的位置。'
- en: 'Now, we can take a look at the massive `marketOrder` function implementation;
    this is my own way of doing it, I recommend you try to recreate a market order
    function from scratch, considering all the gas restrictions and limitations. It''s
    not perfect but it clearly displays how a DAX exchange works. Here''s the function
    breakdown for your understanding. First, update the documentation of the function
    to be sure that it explains what''s executed inside:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看一下庞大的`marketOrder`函数实现；这是我自己的方式来实现，我建议你尝试从头开始重新创建一个市场订单功能，考虑到所有的Gas限制和限制。虽然不完美，但它清楚地显示了DAX交易所的工作原理。以下是您理解的功能分解。首先，更新函数的文档以确保它解释了内部执行的内容：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then add the `require()` function checks to verify that the given tokens are
    valid and that the quantities are correct:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`require()`函数检查以验证给定的代币是否有效，以及数量是否正确：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just like with the limit order function, we execute the buying or selling functionality
    depending on the state of the existing orders:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像限价订单功能一样，根据现有订单的状态执行买入或卖出功能：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It never hurts to add some additional comments when developing such complex
    logic. Here, I''ve added some clarifications to remind myself of how this function
    should work on a more technical level:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发如此复杂的逻辑时，添加一些额外的注释永远不会有害。在这里，我添加了一些说明，以提醒自己这个功能应该在更技术层面上如何工作：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we''ve generated an array of orders to fill and the quantities required
    per order, we can start filling each of those orders with another loop:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们生成了要填充的订单数组和每个订单所需的数量，我们可以开始使用另一个循环填充每个订单：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have to break it down by type to see whether the order is actually a buy
    or sell order, to guarantee that we are fulfilling the right order with the right
    quantities:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按类型分解，以查看订单实际上是买单还是卖单，以确保我们以正确的数量实现正确的订单：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If it''s a sell order, we change the arrays used, but the logic is the same:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个卖单，我们改变使用的数组，但逻辑是一样的：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At first glance, you can see that we have no less than three `for` loops, which
    is extremely unoptimized since it won't be able to handle more than a few orders
    at a time, but it's one of the few solutions for a DAX that doesn't require a
    centralized server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你会发现我们不止有三个`for`循环，这是非常不经优化的，因为它无法处理超过几个订单，但对于不需要中心服务器的 DAX，这是为数不多的解决方案之一。
- en: First, we do the required checks to verify that the user is creating a valid
    market order with the appropriate `approve()` to what they want to buy or sell
    so that the contract can purchase the tokens freely. Then, we start looping through
    all of our sorted order arrays to fill the most profitable ones first, while keeping
    track of how many tokens will be filled for each order. Once we have a list of
    orders to fill with the quantities, we can move on to filling each one of those.
    How do we do it?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进行所需的检查，以验证用户是否创建了一个具有适当`approve()`的有效市场订单，以便合同可以自由购买代币。然后，我们开始循环遍历我们排好序的所有订单数组，首先填充利润最高的订单，同时跟踪每个订单将填充多少代币。一旦我们有了要填充的订单列表和数量，我们就可以开始填充其中的每一个。我们应该如何做？
- en: We update the state of each order so that we mark the quantities as zero or
    a reduced amount while also using `enum OrderState.CLOSED` for those that are
    filled completely. We then transfer the right quantity of tokens to each user.
    That's where the mapping of `buyOrderIndexById[]` is especially useful since we
    want to update a specific order without altering the order of the entire array,
    thus saving gas and processing costs. Finally, we emit some events to indicate
    that we made some token transfers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新每个订单的状态，以便在数量为零或减少数量的同时，对完全填充的订单使用`enum OrderState.CLOSED`。然后我们将正确数量的代币转移到每个用户。这就是`buyOrderIndexById[]`映射特别有用的地方，因为我们想要更新特定订单而不改变整个数组的顺序，从而节省燃气和处理成本。最后，我们发出一些事件，以指示我们进行了一些代币转移。
- en: That should be it! The following is the entire contract so that you can see
    how it all ties together. It is available on the official GitHub at [https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol](https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容了！以下是完整的合同，以便您了解所有内容是如何联系在一起的。它可以在官方 GitHub 上找到： [https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol](https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol)。
- en: 'It''s quite a big contract, so I recommend you write some tests for it to verify
    that it''s working. You can check and run the tests I''ve written by cloning my
    GitHub with all the code here: [https://github.com/merlox/decentralized-exchange](https://github.com/merlox/decentralized-exchange).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大的合同，所以我建议您为它编写一些测试，以验证它是否正常运行。您可以通过克隆我的 GitHub 并使用这里的所有代码来检查并运行我编写的测试：[https://github.com/merlox/decentralized-exchange](https://github.com/merlox/decentralized-exchange)。
- en: Finishing the dApp
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 dApp
- en: 'Now that we have a working smart contract with our desired logic, we can implement
    the dApp using Truffle and web3.js in a simple React application. Start by importing
    the required components inside your `index.js` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个具有所需逻辑的工作智能合同，我们可以在简单的 React 应用程序中使用 Truffle 和 web3.js 实现 dApp。首先在您的`index.js`文件中导入所需的组件：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll use only two tokens in this prototype for you to learn how to create the
    application since a fully-featured DAX is outside the scope of this book. The
    goal is to show you the path so you can create a more advanced DAX if you desire.
    We start by importing our required ABIs for creating the token instances and the
    token addresses. Those are the tokens we'll use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型中，我们将只使用两种代币，以便您学习如何创建应用程序，因为一个具有完整功能的 DAX 超出了本书的范围。我们首先导入所需的 ABIs 来创建代币实例和代币地址。这些就是我们将使用的代币。
- en: 'Start by updating the state object in the `Main` component with the new required
    variables that we''ll use to interact with the smart contract. Notice how we removed
    the trades and history arrays because we''ll get that data from the contract instead:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过更新`Main`组件中的状态对象，添加新的所需变量，我们将使用这些变量与智能合约进行交互。注意，我们移除了交易和历史数组，因为我们将从合约中获取这些数据：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the `bytes32()` helper function, which generates a valid hexadecimal string
    required for web3.js:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`bytes32()`辅助函数，用于生成 web3.js 所需的有效十六进制字符串：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then create the `setup()` to initialize the web3.js instance while also getting
    the user''s consent to use their MetaMask account credentials:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建`setup()`函数，初始化 web3.js 实例，并获取用户同意使用他们的 MetaMask 账户凭据：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because the contract setup in the react application is more complicated, we
    have to create a separate function for maintainability:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 react 应用中设置合约更加复杂，我们必须为可维护性创建一个单独的函数：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After setting up the web3 and contract instances, we can start getting orders
    from the smart contract to populate our user interface with orders. First, we
    get the length of the arrays used to be able to loop through all the orders. That''s
    the only way to securely take into account all the elements contained in the arrays:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完 web3 和合约实例后，我们可以开始从智能合约获取订单，以便用订单填充我们的用户界面。首先，我们获取用于循环遍历所有订单的数组长度。这是唯一一种安全地考虑到数组中包含的所有元素的方法：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we start looping over the buy orders array by calling the smart contract
    with each component independently:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始循环遍历买单数组，通过独立调用智能合约来处理每个组件：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We do the same thing with the sell orders array:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对卖单数组也做同样的事情：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Again, we do the same thing with the closed orders array. We need this one
    to display past historical trades that can help people understand what happened
    before they joined the fun:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们对关闭订单数组执行相同的操作。我们需要这个数组来显示过去的历史交易，这可以帮助人们了解在加入乐趣之前发生了什么：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, create a function named `setPairs()`, which will be used in the future
    to add new token pairs to the platform. Because we don''t want to overcomplicate
    this initial DAX that we''re creating, we''ll limit ourselves to just one token
    pair composed of two imaginary tokens, named `WAT` and `BAT`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`setPairs()`的函数，将来用于向平台添加新的令牌对。因为我们不想过度复杂化我们正在创建的初始 DAX，所以我们将自己限制在只有一个令牌对的范围内，由两个虚拟令牌组成，分别命名为`WAT`和`BAT`：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We start by setting up the constructor with the essential variables required
    for the entire application. Then a `setup()` function takes care of getting all
    the initial information. The `bytes32()` function is used to convert normal strings
    to hexadecimal since the new version of web3 forces us to send hexadecimal strings
    instead of plain texts to identify the `bytes32` variables. Personally, I prefer
    to write the `bytes32` variables as strings, but `web3` is their framework so
    we have to follow its programming style. We continue by setting up the contract
    instances with the `setContractInstances()` function that starts our contract
    from the given addresses and ABIs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从设置构造函数开始，其中包含整个应用程序所需的基本变量。然后，`setup()`函数负责获取所有初始信息。`bytes32()`函数用于将普通字符串转换为十六进制，因为新版本的
    web3 强制我们发送十六进制字符串而不是纯文本以识别`bytes32`变量。个人而言，我更喜欢将`bytes32`变量写成字符串，但`web3`是他们的框架，所以我们必须遵循它的编程风格。然后，我们使用`setContractInstances()`函数设置合约实例，该函数使用给定的地址和
    ABI 启动我们的合约。
- en: Then we set up the orders with the `setOrders()` function. This one looks scarier
    since it contains a lot more code, but the idea is to simply get each order from
    the smart contract and store them in organized arrays inside the react state variables.
    Finally, we set up the token pairs with `setPairs()`, which updates the state
    with our tokens.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`setOrders()`函数设置订单。这个看起来更吓人，因为它包含了更多的代码，但其实想法很简单，就是从智能合约中获取每个订单，并将它们存储在
    react 状态变量的组织良好的数组中。最后，我们使用`setPairs()`设置令牌对，它会用我们的令牌更新状态。
- en: 'Now we need to implement the remaining functions in the smart contract. Here
    is how the whitelist function looks in the React dApp:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在智能合约中实现剩余的函数。以下是 React dApp 中白名单函数的样子：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we implement the deposit tokens function which will increase the available
    balance that the user adds to the platform for trading the tokens. I''ve added
    plenty of comments for you to understand what''s going on:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现存款令牌函数，它将增加用户为交易令牌而向平台添加的可用余额。我已经添加了大量注释，让您了解正在发生的事情：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The withdraw tokens function is quite simple and will be used for both tokens:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提取代币函数相当简单，将用于两种代币：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we have to implement the limit and market orders functions which,
    ironically, are the smallest ones, since we only have to pass the required information
    to the smart contract for it to execute the entire functionality by itself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须实现限价和市价订单功能，讽刺的是，这是最小的功能，因为我们只需要将所需信息传递给智能合约，它就会自行执行整个功能：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The whitelist function is pretty straightforward since we only run the whitelisting
    function from the smart contract using the main Ethereum address. Remember that
    this function can only be executed by the owner of the contract.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 白名单功能相当简单，因为我们只使用主以太坊地址从智能合约运行白名单功能。请记住，此功能只能由合约的所有者执行。
- en: 'The deposit tokens function checks whether you have enough tokens in your Ethereum
    address, and then it creates two approvals: the first one is to reduce the approval
    to zero since we can''t increase the approval quantity safely since there are
    some security risks in that function; the second one is to `approve()` the desired
    quantity of tokens to deposit for the selected token. Then we run the `depositTokens()`
    method from our `DAX` contract to move the tokens to the escrow address and create
    one if the user doesn''t have an escrow yet.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 存款代币函数检查您的以太坊地址中是否有足够的代币，然后创建两个批准：第一个批准是将批准数量减少到零，因为我们无法安全地增加批准数量，由于该功能存在一些安全风险；第二个批准是批准要存入所选代币的所需数量。然后，我们运行我们的`DAX`合约中的`depositTokens()`方法，将代币移动到托管地址，并在用户尚未拥有托管时创建一个托管。
- en: The withdraw function simply runs the `extractTokens()` method from our `DAX`
    contract to move the tokens from escrow to the user's address because we don't
    need to check anything there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提取函数简单地运行我们的`DAX`合约中的`extractTokens()`方法，将代币从托管转移到用户的地址，因为我们在那里不需要检查任何东西。
- en: Then we move to the `createLimitOrder()` function. Remember how complicated
    and large it was in the `DAX` contract? Well, in this case, it's just a matter
    of putting the right parameters in the right places. We'll see later in the `render()`
    function how we get those parameters. The same thing applies with the `createMarketOrder()`
    which runs the `marketOrder` method from our `DAX` contract.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向`createLimitOrder()`函数。还记得在`DAX`合约中它是多么复杂和庞大吗？嗯，在这种情况下，只是将正确的参数放在正确的位置。我们将在后面的`render()`函数中看到如何获取这些参数。与运行我们的`DAX`合约中的`marketOrder`方法相同，`createMarketOrder()`也是如此。
- en: 'Here''s the `render()` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`render()`函数：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The render function generates three components: `Sidebar`, `Orders`, and `History`.
    Those are the three sections that we created earlier. In this case, we''ve added
    lots of props to each component to communicate data easily. You can see that the
    limit order and market order props are simply taking parameters and sending them
    to the functions of the `Main` component.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数生成三个组件：`Sidebar`、`Orders`和`History`。这些是我们之前创建的三个部分。在这种情况下，我们向每个组件添加了许多属性，以便轻松地传递数据。您可以看到，限价订单和市价订单属性只是接收参数并将它们发送到`Main`组件的函数中。
- en: 'Let''s explore my implementation of each of those components; this is my own
    way of doing it so you can see how a DAX should look. I recommend you create your
    own version based on what you''ve learned. The following is the `Sidebar` component;
    we start by creating the updated `constructor()`, `bytes32()`, and `resetInputs()`
    functions that will be used in the render:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索每个组件的实现方式；这是我自己的做法，所以您可以看到 DAX 应该是什么样子。我建议您根据您所学到的知识创建您自己的版本。以下是`Sidebar`组件；我们首先创建更新的`constructor()`、`bytes32()`和`resetInputs()`函数，这些函数将在渲染中使用：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `render()` function in this case is a bit too large for you to understand
    it, so we''ll break it down into smaller, digestible pieces. Because we want to
    give the user more options, we''ve added a deposit and withdraw button for each
    token to keep it simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`render()`函数有点过大，您可能无法理解它，因此我们将其分解为更小、更易消化的部分。因为我们想要给用户更多的选择，所以为每种代币添加了一个存款和提取按钮，以保持简单：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, those buttons ask the user how many tokens to move with the
    `prompt()` global JavaScript function, which provides a clear, albeit basic, dynamic
    input. Then the respective functions get called on the `Main` component by passing
    them via `props`. Then, we can add the `buy` button functionality to format the
    required input for the limit or market orders:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些按钮通过`prompt()`全局 JavaScript 函数询问用户要移动多少代币，该函数提供了清晰但基本的动态输入。然后通过`props`将相应的函数调用传递到`Main`组件中。然后，我们可以添加`buy`按钮功能来格式化限价或市价订单所需的输入：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The sell button does the same thing, but with the sell type in the topmost
    functions to tell the smart contract that we want to sell:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 卖出按钮做的事情是一样的，但是在顶层函数中使用卖出类型告诉智能合约我们想要卖出：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we give the user a simple select input to indicate that they want
    to create a limit order or a market order. If they select a limit order, an additional
    input will be displayed to indicate the sell or buy price:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们给用户一个简单的选择输入，表示他们想要创建限价订单还是市价订单。如果他们选择了限价订单，将显示一个额外的输入来指示卖出或买入价格：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As before, we have a constructor, a `bytes32` function, and a `render()` function.
    The `resetInputs()` function takes care of cleaning the input fields so that you
    reset their values after buying or selling. The most complex part is the render,
    which creates our design. The main logic can be found in the buttons. We have
    four buttons in the money management section to deposit BAT or WAT and withdraw
    BAT or WAT. There is a simple system for managing how many tokens you have in
    your escrow. Then, there are a couple of main buttons to buy or sell. Each of
    those buttons runs the `createLimitOrder` or `createMarketOrder` methods, depending
    on whether you have selected the limit order drop-down or the other. When you
    click the buttons, the component reads the values stored in the input to transmit
    them to the right functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们有一个构造函数，一个`bytes32`函数和一个`render()`函数。`resetInputs()`函数负责清理输入字段，以便在购买或出售后重置它们的值。渲染最复杂的部分是创建我们的设计。主要逻辑可以在按钮中找到。我们在资金管理部分有四个按钮，用于存入
    BAT 或 WAT 和取出 BAT 或 WAT。有一个简单的系统来管理你在托管账户中有多少代币。然后，有几个主要按钮用于买入或卖出。这些按钮中的每一个都运行`createLimitOrder`或`createMarketOrder`方法，取决于您是否选择了限价订单下拉框还是其他选项。当您点击这些按钮时，组件读取存储在输入中的值，然后将它们传递给正确的函数。
- en: 'Take a closer look at the logic behind the buttons to understand how they decide
    which function to call and how they move that information to the `Main` component.
    Let''s move on to the `Orders` component, previously named `Trades`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察按钮背后的逻辑，了解它们如何决定调用哪个函数以及如何将信息传递到`Main`组件。现在让我们转向`Orders`组件，之前称为`Trades`：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We only have a render and constructor to generate our desired design from the
    buy or sell orders objects given from the `Main` component. There isn't much to
    say about it, apart from the fact that it creates a clean interface for endless
    orders.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个渲染和构造函数，从`Main`组件给出的买入或卖出订单对象生成我们所需的设计。除此之外，我们没有太多可说的，它为无尽的订单创建了一个清晰的界面。
- en: 'Now, here''s the last `History` component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是最后一个`History`组件：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It's almost identical to the `Orders` component, but with a different styling.
    Remember to run the `ReactDOM.render()` function to display your dApp.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它几乎与`Orders`组件相同，但样式不同。记得运行`ReactDOM.render()`函数来显示你的 dApp。
- en: 'That''s about it! Now you should have a working DAX that you can use and build
    upon to create a stronger exchange for hundreds or even thousands of tokens, since
    you understand how it works from the inside out. This is probably the most direct
    way to start your own exchange. Here''s how it looks after some trades:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样了！现在你应该有一个可用的 DAX，可以使用并构建它，以创建一个更强大的交易所，因为你从内到外了解了它的工作方式。这可能是启动自己的交易所的最直接方式。这是一些交易后的样子：
- en: '![](img/8cc7387d-dcc8-41d5-99fe-5f3919182a81.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cc7387d-dcc8-41d5-99fe-5f3919182a81.png)'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to build a DAX from scratch, going from the
    idea of how exchanges work, to the user interface using react and truffle, to
    creating the required smart contracts so that you saw for yourself how a fully-decentralized
    system works, to finally combining it all together in a beautiful dApp that communicates
    with your deployed contracts and tokens. You learned about the differences between
    traditional, centralized cryptocurrency exchanges and fully-featured DAXs, so
    that you can choose the best type for your requirements.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何从零开始构建一个 DAX，从交易所的工作原理的想法，到使用 react 和 truffle 构建用户界面，再到创建所需的智能合约，以便你亲眼看到一个完全去中心化的系统如何工作，最后将所有这些组合在一起，创建一个与你部署的合约和代币进行通信的漂亮
    dApp。你了解了传统的、中心化的加密货币交易所与功能齐全的 DAX 之间的区别，以便你可以选择最适合你需求的类型。
- en: After that short introduction, you got into the technical aspects of the DAX
    by understanding how we implement the trading and matching engine via a set of
    smart contracts. Finally, you developed a clean interface without graphs to keep
    it simple, and you integrated all the complex smart contract logic via manageable
    components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个简短的介绍之后，你通过理解我们如何通过一系列智能合约实现交易和撮合引擎的技术方面，深入了解了 DAX 的技术方面。最后，你开发了一个简洁的界面，没有图表，以保持简单，并且通过可管理的组件集成了所有复杂的智能合约逻辑。
- en: In the next chapter, we'll explore Machine Learning on the blockchain, a topic
    that you may have heard about, since it combines the two most popular technologies
    regarding the future of money and computing by building a dApp that allows us
    to make predictions with a trained model using Linear Regression algorithms in
    a smart contract.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨区块链上的机器学习，这可能是你听说过的话题，因为它结合了关于货币和计算未来的两种最流行的技术，通过构建一个允许我们使用智能合约中的线性回归算法训练模型来进行预测的
    dApp。
