- en: Developing Your First Decentralized Application with Ethereum
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用以太坊开发您的第一个去中心化应用程序
- en: '**DApps** or a **Decentralized applications** is an application that is run
    on a blockchain. Ethereum provides its users with some flexibility that allows
    them to create such applications. In this chapter, we will focus on creating a
    DApp and learn how to implement it in various aspects of our lives.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**DApps** 或 **去中心化应用程序** 是在区块链上运行的应用程序。以太坊为其用户提供了一些灵活性，使他们能够创建此类应用程序。在本章中，我们将专注于创建一个
    DApp 并学习如何在我们生活的各个方面实施它。'
- en: 'In this chapter, we will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何进行以下操作：
- en: Create a project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个项目
- en: Deploying and testing a project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和测试项目
- en: Explore the Solidity syntax and JavaScript codes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Solidity 语法和 JavaScript 代码
- en: Bug fixing and debugging smart contracts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复智能合约中的错误并进行调试
- en: Changing our application with a better payment method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用更好的支付方式改变我们的应用程序
- en: In order to build an application, we need to understand the codes and syntax
    that are used to develop it. Hence, we will take a look at the Solidity syntax
    and also understand the working of the JavaScript codes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个应用程序，我们需要理解用于开发它的代码和语法。因此，我们将查看 Solidity 语法，并了解 JavaScript 代码的工作方式。
- en: Creating a project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个项目
- en: This section will teach us how to create a new project. It will require us to
    explore the code and the Solidity syntax. Deploying the project will help us understand
    how easy it is to transform this project into a better payment application. To
    get a better understanding of the concept, we are going to take a look at some
    specifics on bug fixing and also learn to debug smart contracts and some function
    applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教我们如何创建一个新项目。我们需要探索代码和 Solidity 语法。部署项目将帮助我们了解将该项目转变为更好的支付应用程序有多容易。为了更好地理解这个概念，我们将详细了解一些关于
    bug 修复的具体内容，还将学习调试智能合约和一些功能应用程序。
- en: To begin, we need to create a new folder. For convention's sake, let's name
    this `my_first_project`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个新文件夹。为了符合约定，让我们将其命名为 `my_first_project`。
- en: '![](img/66999888-2bde-4cf7-992e-3aed7b7ea6da.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66999888-2bde-4cf7-992e-3aed7b7ea6da.png)'
- en: 'The immediate next step would be to run Truffle. The following command is used
    for this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的即时步骤是运行 Truffle。使用以下命令进行此操作：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the command should be as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出应该如下所示：
- en: '![](img/c68e875d-1fba-43fc-b8a5-a6d5c108b3a2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c68e875d-1fba-43fc-b8a5-a6d5c108b3a2.png)'
- en: This displays the list of commands that can be used for various processes for
    Truffle. The Truffle `init` command allows us to initialize a new Truffle project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了可以用于 Truffle 的各种过程的命令列表。Truffle `init` 命令允许我们初始化一个新的 Truffle 项目。
- en: 'Throughout the book, we will use a handy Truffle unbox command which will download
    and set up a boilerplate project. For this, we will use the `webpack` box, which
    is done by running the `truffle unbox webpack` command as shown in the following
    screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用一个方便的 Truffle unbox 命令来下载和设置一个样板项目。为此，我们将使用 `webpack` 盒子，通过运行 `truffle
    unbox webpack` 命令来完成，如下面的截图所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All the boxes are listed on their website and it is a growing list, among which
    there are some React boxes and many others. The unboxing takes a while, after
    which you will see the following message on your screen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的盒子都在他们的网站上列出来，这是一个不断增长的列表，其中包括一些 React 盒子和许多其他盒子。解包需要一段时间，之后您将在屏幕上看到以下消息：
- en: '![](img/eeaa6c41-8142-4a7a-8001-4552a630a0db.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eeaa6c41-8142-4a7a-8001-4552a630a0db.png)'
- en: 'Once this is done, we can start creating our project in an editor of our choice.
    We can begin by examining the project structure. The unboxing will have created
    several files and folders for us. Your screen should look similar to the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以在所选编辑器中开始创建我们的项目。我们可以通过查看项目结构开始。解包将为我们创建几个文件和文件夹。您的屏幕应该看起来类似于以下内容：
- en: '![](img/7a4d73c4-08dc-4041-a98e-2c8de9df1a9f.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a4d73c4-08dc-4041-a98e-2c8de9df1a9f.png)'
- en: 'It will also install a webpack, which can be configured through the `webpack.config.js`
    file. This file allows you to configure how you will minimize your JSON, CSS,
    and JavaScript, and everything in-between. You will also have a `truffle.js` file,
    which is used to define your networks. Upon clicking this, your screen will look
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将安装一个 webpack，可以通过 `webpack.config.js` 文件进行配置。此文件允许您配置如何将 JSON、CSS 和 JavaScript
    进行最小化，以及介于其中的所有内容。您还将拥有一个 `truffle.js` 文件，用于定义您的网络。点击此按钮后，您的屏幕将如下所示：
- en: '![](img/2964361c-a825-49f2-9c83-812fc2db5748.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2964361c-a825-49f2-9c83-812fc2db5748.png)'
- en: The `truffle.js` file comes predefined with a development network that defaults
    to a localhost on port `7545`. It will also create an app folder that contains
    our main project. This folder contains an index of HTML and some CSS and JavaScript
    that imports our smart contracts. The `contracts` folder contains `ConvertLib`
    which is a simple library for demonstration purposes that is imported inside of
    the `main` file, `MetaCoin.sol`. The file extension clearly depicts that the language
    used here is Solidity, which one might call a dialect of JavaScript that was developed
    for Ethereum. You can also see a migrations and `test` folder. Each serves its
    own purpose, which we shall learn during the course of the book. The next section
    will show us how to deploy and test a project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`truffle.js`文件预先定义了一个默认为`localhost:7545`的开发网络。它还将创建一个包含我们主要项目的app文件夹。此文件夹包含一个HTML索引以及一些CSS和JavaScript，用于导入我们的智能合约。`contracts`文件夹包含一个`ConvertLib`，这是一个简单的库，用于演示目的，在`main`文件`MetaCoin.sol`中导入。文件扩展名清楚地表明此处使用的语言是Solidity，有人可能称其为为Ethereum开发的JavaScript方言。您还可以看到迁移和`test`文件夹。每个都有自己的目的，我们将在本书的课程中学习。下一节将向我们展示如何部署和测试项目。'
- en: Deploying and testing a projects
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试项目
- en: We will now be deploying the application that we created in the previous section.
    We will do so by starting a development blockchain, configuring our deployment,
    deploying our smart contracts, and building the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将部署在前一节中创建的应用程序。我们将通过启动开发区块链，配置我们的部署，部署我们的智能合约以及构建应用程序来完成此操作。
- en: Starting a development blockchain
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动开发区块链
- en: 'Firstly, we are going to want to run our development blockchain. This can be
    done by typing `ganache-cli` in the terminal window. Your screen will look as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要运行我们的开发区块链。这可以通过在终端窗口中输入`ganache-cli`来完成。您的屏幕将如下所示：
- en: '![](img/9a094982-7658-4806-85a6-d2e169d31ef1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a094982-7658-4806-85a6-d2e169d31ef1.png)'
- en: Make sure you jot down or remember the localhost port number. It is of importance,
    as you will be connecting to it in the later stages of this project. Ganache-cli
    generates 10 available accounts and then the corresponding private keys. These
    private keys are used to encrypt the transactions that are being sent from each
    individual account. At the bottom, you will see a Mnemonic. These twelve words
    are very important. Always remember to save these words because you will require
    them to import your private keys and the same accounts into MetaMask.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确保记下或记住本地主机端口号。这很重要，因为您将在项目的后期阶段连接到它。Ganache-cli生成10个可用账户，然后生成相应的私钥。这些私钥用于加密从每个个人账户发送的交易。在底部，您将看到一个助记词。这十二个单词非常重要。请务必记住这些单词，因为您将需要它们来导入您的私钥以及相同的账户到MetaMask中。
- en: Configuring your deployment
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的部署
- en: 'Moving ahead, we need to make sure that the project settings are corresponding
    to the hostname and the port on which our blockchain was created. To do this,
    you need to go back to your editor, find the `truffle.js` file that is situated
    in the `root` folder, and change the port number here from `7545` to `8545` to
    match the port number that is hosting our development blockchain. There will be
    no need to make any changes to the host as that is just the localhost. Then, proceed
    to deploying your project on the terminal window, in the `my_first_project` folder.
    Use the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们需要确保项目设置与我们的区块链创建时的主机名和端口对应。为此，您需要回到编辑器，找到位于`root`文件夹中的`truffle.js`文件，并在此处将端口号从`7545`更改为`8545`，以匹配托管我们的开发区块链的端口号。不需要对主机进行任何更改，因为它只是本地主机。然后，在终端窗口中继续在`my_first_project`文件夹中部署您的项目。使用以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are using the Windows system we need to make some changes in the npm
    Package folder which will be located at `C:/users/[YOUR USERNAME]/appdata/roaming/npm`.
    The path may be vary depending upon where each user has installed the `npm` package
    different machine. We need to rename the `truffle.cmd` file to `truffle-cli.cmd`
    in the `npm` package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows系统，我们需要在位于`C:/users/[YOUR USERNAME]/appdata/roaming/npm`的npm包文件夹中进行一些更改。路径可能因每个用户在不同机器上安装`npm`包的位置而异。我们需要将`npm`包中的`truffle.cmd`文件重命名为`truffle-cli.cmd`。
- en: 'This ensures that the smart contracts get compiled without any errors. Once
    this happens, your screen should look something as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保智能合约在没有任何错误的情况下被编译。一旦发生这种情况，您的屏幕应如下所示：
- en: '![](img/ece463c7-39a6-4506-b825-a1af40254e0d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ece463c7-39a6-4506-b825-a1af40254e0d.png)'
- en: The build output files have now been written in the contracts folder (also known
    as the `build` folder).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建输出文件现在已写入合同文件夹（也称为 `build` 文件夹）。
- en: Deploying the smart contracts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署智能合约
- en: 'The immediate next step would be to migrate and deploy these smart contracts
    to your development blockchain. To do this, we use the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 立即执行的下一步是将这些智能合约迁移并部署到您的开发区块链。为此，我们使用以下命令：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/560cfa8c-50dd-4d71-99d2-7cfa873c2452.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560cfa8c-50dd-4d71-99d2-7cfa873c2452.png)'
- en: 'The preceding command helps create your contracts and conducts transactions
    for each of them. The following screenshot should help you clearly determine the
    factors that you need to look out for on your screen:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令有助于创建您的合同并为每个合同进行交易。以下截图应该帮助您清楚地确定您需要在屏幕上注意的因素：
- en: '![](img/b82efac0-b101-4326-b4c9-7045a7bf49be.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b82efac0-b101-4326-b4c9-7045a7bf49be.png)'
- en: Here, you can observe the creation of the first contract post—some variables
    were updated and some transactions took place. The same process iterates to create
    multiple contracts each having their own variables and transactions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以观察到第一个合同后的创建 - 某些变量已更新，某些交易已发生。同样的过程重复创建多个合同，每个合同都有自己的变量和交易。
- en: Going back to your editor of choice, you will find these contracts in your `migration`
    folder. The process of deploying begins with the `migration` smart contract and
    then moves on to the `ConverLib` smart contract. `MetaCoin` is the last smart
    contract to be deployed. A more clear understanding can be achieved if we take
    a look at the `deploy_contracts.js` file that lies in the `migration` folder on
    your editor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您选择的编辑器，您将在您的 `migration` 文件夹中找到这些合约。部署的过程从 `migration` 智能合约开始，然后转移到 `ConverLib`
    智能合约。`MetaCoin` 是最后一个要部署的智能合约。如果我们查看位于编辑器的 `migration` 文件夹中的 `deploy_contracts.js`
    文件，就可以更清楚地理解。
- en: 'The following screenshot also helps you understand the order the smart contracts
    have been deployed in:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图还可帮助您了解已部署的智能合约的顺序：
- en: '![](img/6a915eee-e54f-4f19-834f-09d1d505542e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a915eee-e54f-4f19-834f-09d1d505542e.png)'
- en: Exploring the Solidity syntax and JavaScript codes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Solidity 语法和 JavaScript 代码
- en: This section will help us understand the Solidity syntax. We will explore the
    Solidity and JavaScript codes to understand our project in depth. This will also
    give us the power to alter the code to customize it to our needs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助我们理解 Solidity 语法。我们将探索 Solidity 和 JavaScript 代码，以深入了解我们的项目。这也将赋予我们修改代码以根据需要自定义它的能力。
- en: Understanding the Solidity syntax
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Solidity 语法
- en: 'For understanding the syntax, let''s take a look at the Solidity file `MetaCoin.sol`.
    The following screenshot will act as a guide so that we understand every line
    of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解语法，让我们看一下 Solidity 文件 `MetaCoin.sol`。以下截图将作为指南，以便我们理解每一行代码：
- en: '![](img/b997671f-6a65-4a53-8c74-c57bfef0188e.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b997671f-6a65-4a53-8c74-c57bfef0188e.png)'
- en: 'As you can see, every Solidity file begins with the definition of the Solidity
    version that you are currently using. In this case, that would be 0.4.17\. This
    is immediately followed by the importing of the conversion library (commonly known
    as `ConvertLib.sol`). This is shown the the code block as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个 Solidity 文件都以您当前使用的 Solidity 版本的定义开始。在本例中，那将是 0.4.17。接下来立即导入转换库（通常称为
    `ConvertLib.sol`）。如下所示的代码块显示了这一点：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will now move on to creating a contract. We will use the contract keyword
    followed by the name of your contract. For example, contract xyz. A contract runs
    is similar to the concept of a class in any other programming language:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续创建一个合约。我们将使用 contract 关键字，后跟您的合约名称。例如，contract xyz。合约运行类似于其他任何编程语言中的类的概念：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `MetaCoin` smart contract begins by adding the first variable that is mapping,
    a mapping called **balances**. Mapping is essentially a key value storage that
    allows you to map an address to an unsigned integer. This address can be a unique
    person or a unique account. This `mapping` function is the core variable of your
    application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaCoin` 智能合约首先添加的是第一个变量，即映射，一个名为 **balances** 的映射。映射本质上是一种键值存储，允许您将地址映射到无符号整数。这个地址可以是一个独特的人或一个独特的账户。这个
    `mapping` 函数是您应用程序的核心变量：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next variable that is defined is an event and it has three parameters assigned
    to it. These parameters are `FROM`, `TO`, and `VALUE`. An event can be used to
    trigger a JavaScript event or even to log some data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量被定义为一个事件，并且它被分配了三个参数。这些参数是`FROM`，`TO`和`VALUE`。事件可以用于触发JavaScript事件，甚至记录一些数据：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `MetaCoin` constructor is used to give the person who deployed the smart
    contracts 10,000 `MetaCoin`. This person is usually the administrator. It can
    also be another smart contract that has deployed this smart contract:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaCoin` 构造函数用于向部署智能合约的人提供10,000个`MetaCoin`。这个人通常是管理员。也可以是另一个部署了这个智能合约的智能合约：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next function is `sendCoin`. It accepts two parameters: receiver and amount.
    It can also return a value. There are two methods to define a return value in
    a function. The first method would be a direct implementation of the return function,
    which is written as `returns(uint)`, and the second would be where we give it
    any name such as `returns(bool sufficient)`. This function uses the `if` loop
    to check if the sender of the message or the transaction has sufficient balance.
    The code then proceeds to check if the sender''s balance is less than the amount
    he/she wants to send and, if it is, the value returned is false or an insufficient
    balance. If not, we just continue to move ahead and check that it deducts the
    amount from the sender and adds the same amount to the receiver.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`sendCoin`。它接受两个参数：接收者和金额。它也可以返回一个值。在函数中定义返回值有两种方法。第一种方法是直接实现返回函数，写作`returns(uint)`，第二种是给它任何名字，比如`returns(bool
    sufficient)`。这个函数使用`if`循环来检查消息或交易的发送者是否有足够的余额。然后代码继续检查如果发送者的余额小于他/她想要发送的金额，如果是，返回的值是`false`或者是不足额的余额。如果不是，我们继续前进并检查它是否从发送者扣除了金额，并将相同金额添加到接收者。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After this, the transfer event is triggered, which is followed by the log or
    the JavaScript event which will also return true to indicate that the sender did
    in fact have a sufficient balance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结束后，将触发转账事件，随后是日志或JavaScript事件，也会返回`true`来指示发送者实际上有足够的余额：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getBalanceInEth` and the `getBalance` functions are defined as views that
    return an integer. A view is a function that returns data for presenting. The
    `getBalanceInEth` function makes use of the Convert library and the first parameter
    that it passes is derived from the `getBalance` function. The `getBalance` function
    returns the balance of the parameter that is being passed. You can observe that
    `address.addr` is being externally called, hence it will be passed on the JavaScript
    side. The number two is passed as a second parameter. This is the conversion rate,
    whereas the first parameter is the amount. This is a simple multiplication to
    simulate a conversion between a token and ether.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBalanceInEth` 和 `getBalance` 函数被定义为视图，返回一个整数。视图是一种返回展示数据的功能。`getBalanceInEth`
    函数利用了 Convert 库，它传递的第一个参数来源于 `getBalance` 函数。`getBalance` 函数返回被传递的参数的余额。你可以观察到
    `address.addr` 被外部调用，因此它将被传递到 JavaScript 端。数字2被传递作为第二个参数。这是一个转换率，而第一个参数是金额。这是一个简单的乘法，模拟代币和以太币之间的转换。'
- en: 'We will now use `ConvertLib`, which is not only defined as a library but is
    also deployed separately. The following code helps us understand the workings
    a little better:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`ConvertLib`，它不仅被定义为一个库，而且还被单独部署。以下代码帮助我们更好地理解其运作方式：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The primary benefit of this is that you can maintain a smart contract which
    contains your business logic and you can maintain a smart contract which contains
    a bunch of helper functions and maybe even variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要好处是你可以维护一个包含你的业务逻辑的智能合约，也可以维护一个包含一堆辅助函数甚至变量的智能合约。
- en: Working with JavaScript
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript
- en: 'Truffle provides us with the tools to easily import and interface with our
    smart contracts. The following is a screenshot of a JavaScript code file named
    `app.js` which you can find in the `javascript` folder under the `app` directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle为我们提供了易于导入并与智能合约交互的工具。以下是一个名为`app.js`的JavaScript代码文件的截图，你可以在`app`目录下的`javascript`文件夹中找到它：
- en: '![](img/ef2bdb24-db70-4f3c-b242-7b4e85a94465.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef2bdb24-db70-4f3c-b242-7b4e85a94465.png)'
- en: The first import here is the `Web3` library which is by Ethereum. It interfaces
    with the Ethereum blockchain. It can request information or send a transaction
    based on the requirements of the moment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先导入的是`Web3`库，它是由以太坊提供的。它与以太坊区块链进行接口。它可以根据当前需求请求信息或发送交易。
- en: The next import is the `truffle-contract`. It acts as a wrapper around the contract
    interface that Truffle provides.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个导入是`truffle-contract`。它作为Truffle提供的合约接口的包装器。
- en: We then proceed to import `metacoin_artifacts` from the `MetaCoin.JSON` file
    that lies in the `build` directory. A `MetaCoin` variable is initialized with
    this contract and we pass the `metacoin_artifacts` as a parameter to this contract
    constructor. This allows us to have a usable abstraction of the `MetaCoin` smart
    contract. The `MetaCoin` contract is used to set a provider and this provider
    is how we will interface with the blockchain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`build`目录中的`MetaCoin.JSON`文件导入`metacoin_artifacts`。使用此合约初始化一个`MetaCoin`变量，并将`metacoin_artifacts`作为参数传递给此合约构造函数。这使我们可以使用`MetaCoin`智能合约的可用抽象。`MetaCoin`合约用于设置提供者，这个提供者是我们将与区块链进行接口的方式。
- en: The `currentProvider` is usually filled by whatever provides the `Web3` library,
    which in this case is `MetaMask`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentProvider`通常由提供`Web3`库的任何东西填充，这在这种情况下是`MetaMask`。'
- en: We then use the `Web3` library to get all of the accounts that are active within
    our setup of this test blockchain. The `getAccounts` function will get all of
    the accounts that are available on your installation which are actually owned
    by you. For understanding purposes, let's assume that each account represents
    multiple people or multiple accounts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Web3`库获取我们测试区块链设置中处于活动状态的所有账户。`getAccounts`函数将获取您拥有的实际上属于您的安装中所有可用的账户。为了理解，让我们假设每个账户代表多个人或多个账户。
- en: If you are running an actual, live blockchain node, the `getAccounts` function
    will not actually get all of the accounts in the concerned blockchain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行一个真实的、在线的区块链节点，`getAccounts`函数实际上不会获取到所关注的区块链中的所有账户。
- en: Once the accounts have been obtained, the `refreshBalance` function uses the
    `MetaCoin` abstraction that we defined earlier to get the deployed instances of
    the concerned contract. This instance is then used to get the balance. Keep in
    mind that this is not a transaction; this is a call that is used to get some data.
    Hence, the keyword call is used. A call won't actually cost us anything.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦账户被获取，`refreshBalance`函数就会使用我们之前定义的`MetaCoin`抽象来获取所关注合约的已部署实例。然后，该实例用于获取余额。请记住，这不是一个交易；这是一个用于获取一些数据的调用。因此，使用关键字调用。调用实际上不会花费我们任何东西。
- en: What would you change if this was actually a transaction? Not much. You would
    only eliminate the keyword `call`. Easy, right?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这真的是一笔交易，你会改变什么？不多。你只会消除关键字`call`。简单，对吧？
- en: Let us proceed to define the first parameter of the `getBalance` function; the
    account parameter here coincides with the first parameter that we defined for
    the `getBalance` or the `getBalanceinEth` functions that belong to our Solidity
    file, `MetaCoin.sol`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义`getBalance`函数的第一个参数；这里的账户参数与我们为我们的Solidity文件`MetaCoin.sol`定义的`getBalance`或`getBalanceinEth`函数的第一个参数相一致。
- en: The second parameter here is some extra data that you can add to a call or a
    transaction. In this case, we can determine that it is from the same account that
    the call is for. After this is complete, we can either return a value or use this
    to update the `balance_element`. If an error occurs, it will get logged on the
    console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个参数是一些额外的数据，你可以添加到一个调用或一个交易中。在这种情况下，我们可以确定它来自于与调用相同的账户。完成后，我们可以返回一个值，或者使用它来更新`balance_element`。如果发生错误，它将被记录在控制台上。
- en: A similar process is used for sending a coin—we again obtain the deployed instance
    and then use the `sendCoin` function. Looking closely will make us realize that
    there is no call keyword here as this is an actual transaction. A coin being sent
    from one person to another is a change in the blockchain, thus making this a transaction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 发送一枚硬币也是使用类似的过程——我们再次获取已部署的实例，然后使用`sendCoin`函数。仔细观察会让我们意识到这里没有`call`关键字，因为这是一笔实际的交易。从一个人发送一枚硬币到另一个人是区块链的变化，因此这是一笔交易。
- en: The further steps would remain the same; these include the syntax, the order
    of the parameters, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的步骤将保持不变；这些包括语法、参数顺序等。
- en: Bug fixing and debugging smart contracts
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复和调试智能合约
- en: This section tells you how to go about bug fixing and debugging your code. Usually,
    the code will be debugged in the developer console which is similar to developing
    regular JavaScript code. If there is an error present in the JavaScript code,
    you could easily rectify it on the developer console. However, if the bug is in
    your smart contract, you are going to want to go a bit deeper. How are you going
    to debug your smart contract once it is live? Well, you cannot—not locally at
    least. What if somebody finds a bug? You need to find out where it came from.
    For these very reasons, we can use [remix.ethereum.org](http://remix.ethereum.org/#optimize=false&version=soljson-v0.4.24+commit.e67f0147.js)
    and `etherscan.io`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节告诉您如何进行故障修复和调试代码。通常，代码将在开发者控制台中调试，这类似于开发常规JavaScript代码。如果JavaScript代码中存在错误，则可以在开发者控制台上轻松更正。但是，如果错误出现在您的智能合约中，您需要深入了解。一旦智能合约上线，您将如何调试它？好吧，您不能在本地调试。如果有人发现了错误，您需要找出它来自哪里。因为这些原因，我们可以使用[remix.ethereum.org](http://remix.ethereum.org/#optimize=false&version=soljson-v0.4.24+commit.e67f0147.js)和`etherscan.io`。
- en: 'The modified version of the `MetaCoin Solidity` file found at [remix.ethereum.org](http://remix.ethereum.org/#optimize=false&version=soljson-v0.4.24+commit.e67f0147.js)
    is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[remix.ethereum.org](http://remix.ethereum.org/#optimize=false&version=soljson-v0.4.24+commit.e67f0147.js)找到的`MetaCoin
    Solidity`文件的修改版本如下所示：
- en: '![](img/2882f9fa-b652-4e7f-af9c-ac1bdcd1d40d.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2882f9fa-b652-4e7f-af9c-ac1bdcd1d40d.png)'
- en: You can create this file yourself by clicking the little plus icon in the top-left
    corner and giving it a name of your choice. Once you compile this code, you will
    notice a green bar which indicates that the code has been compiled successfully.
    Let us try introducing an error by eliminating a semicolon; the bar will now turn
    red, indicating that there is some error that you need to rectify.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击左上角的加号图标并给它一个您选择的名称来创建此文件。编译此代码后，您将注意到一个绿色的条形图，表示代码已成功编译。让我们尝试通过省略一个分号引入错误；条形图现在将变为红色，表示存在需要纠正的错误。
- en: 'The following screenshot will help you understand the various tabs present
    on your screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将帮助您了解屏幕上的各个选项卡：
- en: '![](img/6b000619-3189-47b1-84bc-9540620ab431.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b000619-3189-47b1-84bc-9540620ab431.png)'
- en: The Run tab encapsulates the Environment section, where we should make sure
    to select JavaScript VM as the environment that we wish to work on. This allows
    us to simulate the Ethereum blockchain within our browser, which is something
    similar to what TestRPC did.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行选项卡包含环境部分，我们应确保选择JavaScript VM作为我们希望使用的环境。这样可以在我们的浏览器中模拟以太坊区块链，类似于TestRPC的功能。
- en: You may notice that the constructor of the `MetaCoin Solidity` file now contains
    a `firstHolder` parameter. The `firstHolder` will be the first person to get 10,000
    MetaCoins. You can vary the person who gets to be the `firstHolder`. You can select
    any account at random. You then need to make sure you copy it and give it as a
    parameter for the constructor. For addresses, it's usually a good idea to put
    them between quotes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`MetaCoin Solidity`文件的构造函数现在包含一个`firstHolder`参数。`firstHolder`将是首个获得10,000个MetaCoins的人。您可以选择任意账户。然后需要确保您复制并将其作为构造函数的参数给出。对于地址，通常最好将它们放在引号之间。
- en: 'Upon creating a `MetaCoin`, the lower half of your screen will display a window
    that contains your transaction. It looks something as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`MetaCoin`后，屏幕下半部分将显示一个包含您的交易的窗口。它看起来像下面的截图所示：
- en: '![](img/c7cac424-1c60-43f4-88f2-364e036c7646.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7cac424-1c60-43f4-88f2-364e036c7646.png)'
- en: Transaction of coins
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 货币交易
- en: This window contains the details of the transaction. We can also debug the file.
    However, let us first get the balance of this person by copying the address to
    the GetBalance tab.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口包含交易的详细信息。我们还可以调试文件。但首先让我们通过将地址复制到GetBalance选项卡来获取此人的余额。
- en: Once this is done, we can proceed to debug this. We can do it step by step to
    understand the process better. There will be only three steps as this is a small
    function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以继续调试。我们可以逐步进行以更好地理解过程。这将仅有三个步骤，因为这是一个小函数。
- en: 'Let us now try to send some coins between any two accounts. This will require
    us to copy the address of the second account and use it as a first parameter in
    the SendCoin tab. The second parameter of course will be the number of coins that
    you would like to transfer. Refer to the following screenshot for clarity:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着在任意两个帐户之间发送一些硬币。这将要求我们复制第二个帐户的地址并将其用作“SendCoin”选项卡中的第一个参数。当然，第二个参数将是您希望转移的硬币数量。请参考以下屏幕截图以获得清晰的理解：
- en: '![](img/25bb7c16-812b-4e85-bd0b-75c3bae24495.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25bb7c16-812b-4e85-bd0b-75c3bae24495.png)'
- en: 'You can check the details of the transaction in the grey area under Details or
    Debug as shown in the following screenshot. You can also check the status of the
    transaction. To get a clear understanding, click debug to see the step-by-step
    process. Since remix is an open source project by the Ethereum developers, just
    about everyone and anyone can use it. You can use it locally by pulling it from
    Git or you can use it online. The choice is yours:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在“详细信息”下的灰色区域或调试中检查交易的详细信息，如下面的屏幕截图所示。您还可以检查交易的状态。要了解清楚，请单击调试以查看逐步过程。由于remix是以太坊开发者的开源项目，几乎任何人都可以使用它。您可以通过从Git上拉取它，也可以在线使用它。由您决定：
- en: '![](img/48a57bd6-73ed-4aa4-b2fc-e97186397dbf.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48a57bd6-73ed-4aa4-b2fc-e97186397dbf.png)'
- en: Getting the balance and send coins to different accounts
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 获取余额并将硬币发送到不同的账户
- en: Once your smart contract is live, you can monitor transactions on `etherscan.io`.
    Just select any random transaction. You can see the source code or find out if
    it is a smart contract or not. The transaction information shows any transaction
    that has taken place. You can see the event logs, which display the text that
    is written by the events that you create in the Solidity codes. If any of these
    transactions have been done by you, you can trace them using `Geth DebugTrace`.
    If you try to trace any transaction that does not belong to you, you will encounter
    an error since there is not trace available. This can be seen in the tools and
    utilities section of the transaction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的智能合同启动，您可以在`etherscan.io`上监视交易。只需选择任意交易。您可以查看源代码或找出它是否是智能合同。交易信息显示所有已发生的交易。您可以查看事件日志，其中显示了你在Solidity代码中创建的事件写入的文本。如果您已执行其中任何交易，您可以使用`Geth
    DebugTrace`来追踪它们。如果您试图追踪不属于您的任何交易，您会遇到错误，因为没有可用的追踪。这可以在交易的工具和实用程序部分中看到。
- en: The parity trace is just another Ethereum client that one can use. You will
    see the trace here, though it probably won't make a lot of sense. When your smart
    contract is live, you will not be fixing it—instead you will be updating it. You
    can always just debug it locally.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Parity跟踪只是另一个可以使用的以太坊客户端。您将在这里看到跟踪，尽管这可能没有太多意义。当您的智能合同上线时，您将不会对其进行修复，而是进行更新。您总是可以在本地进行调试。
- en: Changing our application with a better payment application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改我们的应用程序，使用更好的支付应用程序
- en: This section will focus on us improving our code. This will include adding functionalities
    such as depositing ether, gaining tokens, and withdrawing ether in exchange of
    tokens and also a creator fee.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将集中于我们改进我们的代码。这将包括添加诸如存入以太币、获得代币和以以太币换取代币以及一个创建者费用等功能。
- en: We will work on the same code that was used for the previous section and continue
    to build on it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节中使用的相同代码并继续构建它。
- en: 'As we do not want to give away free tokens in exchange for deposited ether,
    we will eliminate the following line of code completely:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望以太币的存款交换免费代币，我们将彻底删除以下代码行：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We begin by setting a creator. To do this, we will need to define an address
    creator and a `creatorFee` as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个创建者。为此，我们需要定义一个地址创建者和一个`creatorFee`如下：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `collectedFees` is what one might call a pot. This is used to collect the
    `creatorFees`. The conversion rate is the rate that is used to multiply the number
    of tokens. For example, if you have one ether, you will get five tokens in exchange.
    Let us consider that one has 0.1 ether; the conversion still works with integers
    at the backend. The `currency_multiplier` is used to equate the values of your
    tokens and ether. The smallest denomination is a wei.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectedFees`可以说是一个资金池。这用于收集`creatorFees`。转换率是用来乘以代币数量的率。例如，如果您有一单位以太币，您将获得五个代币作为交换。假设有0.1单位以太币的情况下，转换仍然在后端使用整数。`currency_multiplier`用于等价您的代币和以太币的价值。最小面额是wei。'
- en: 'We also need to initialize the creator as the `message.sender` when the smart
    contract is being created:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '当智能合约被创建时，我们还需要将`message.sender`初始化为创建者:'
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The creator needs some special functions of its own, such as one for the withdrawal
    of fees. This requires us to create a modifier called `onlyCreator`. It would
    look something as follows in the code here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '创建者需要一些自己的特殊功能，比如用于提取费用的功能。这要求我们创建一个名为`onlyCreator`的修饰符。在这里，代码应该如下所示:'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This adds the condition that if the `message.sender` is the creator or if the
    `transaction.origin` comes from the creator, only then will the code be executed.
    This is done by adding an underscore.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了一个条件，即如果`message.sender`是创建者，或者如果`transaction.origin`来自创建者，那么才会执行代码。这是通过添加下划线来实现的。
- en: 'The next step would be to create a function called `collectFees`. For the code''s
    sake, we''ll make it public, but such that only the creator can call this function.
    Your code should look something as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来的步骤将是创建一个名为`collectFees`的函数。出于代码的考虑，我们将它设为public，但仅有创建者才能调用这个函数。您的代码应该如下所示:'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we will transfer the funds to the creator and set the collectedFees to 0\.
    Now, what we do want to add is some functions so that whenever somebody sends
    a coin, we want a part of that coin to be able to go to the creator, and for this
    we will create the deposit and the withdraw functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将资金转移到创建者，并将收取的费用设置为0。现在，我们要添加的是一些功能，以便每当有人发送硬币时，我们希望这些硬币的一部分能够流向创建者，为此我们将创建存款和提款功能。
- en: 'The deposit function will be a payable function. A payable function is used
    whenever you want to receive ether. If you do forget to use it, it will just display
    an error:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '存款功能将是一个可支付的功能。可支付功能在您想要接收以太币时使用。如果您忘记使用它，它只会显示一个错误:'
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The conversion rate used has already been set in the contract function. Remember,
    our tokens will work the same as one ether; that means one token will be multiplied
    by 10 to the power 18\. So when you deposit any tokens, it will be multiplied
    by the `CURRENCY_MULTIPLIER`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在合同函数中设置了使用的转化率。记住，我们的代币将与以太币的工作方式相同;这意味着一个代币将被乘以10的18次方。因此，当您存款任何代币时，它将被乘以`CURRENCY_MULTIPLIER`。
- en: 'We will then move on to the withdraw function. There has to be some amount
    of caution while implementing this, because we first need to multiply with a currency
    multiplier that has been set in the contract function. Then we will proceed to
    deduct the balance of the executor of the transaction with the amount that needs
    to be withdrawn. The amount will be divided by the conversion rate. The code for
    this is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们将进入提款功能。在实现此功能时需要格外小心，因为我们首先需要使用合同函数中设置的货币乘数进行乘法。然后我们将通过执行交易者的余额来扣除需要提取的金额。该金额将被除以转换率。此功能的代码如下:'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at how to create an Ethereum based application.
    We also deployed and tested the same projects. We then delved into the Solidity
    syntax which isn't only vast but is also extensive. JavaScript codes were also
    looked into. We learned how to fix bugs using our own systems as well as externally.
    In the end, we finally converted our project into a payment application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下如何创建基于以太坊的应用程序。我们还部署并测试了相同的项目。然后，我们深入了解了Solidity语法，这不仅是庞大的，而且还非常广泛。我们还学习了如何使用我们自己的系统以及外部系统来修复错误。最后，我们将我们的项目转换为一个支付应用程序。
- en: The next chapter focuses on the concepts of creating our own tokens. We will
    take closer look at ICO's and also at handling our own token transactions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章重点介绍了创建我们自己的代币的概念。我们将更仔细地研究ICO和处理我们自己的代币交易。
