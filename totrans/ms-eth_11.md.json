["```\n/// @notice To create a limit order for buying the _symbolBuy while selling the _symbolSell.\n/// @param _symbolBuy The 3 character or more name of the token to buy.\n/// @param _symbolSell The 3 character or more name of the token to sell.\n/// @param _priceBid The price for how many _symbolBuy tokens you desire to buy. For instance: buy 10 ETH for 1 BTC.\n/// @param _priceAsk The price for how many tokens you desire to sell of the _symbolSell in exchange for the _symbolBuy. For instance: sell 10 BTC for 2 ETH.\nfunction createLimitOrder(bytes32 _symbolBuy, bytes32 _symbolSell, uint256 _priceBid, uint256 _priceAsk) public {}\n\n```", "```\nfunction createLimitOrder(\"ETH\",\"BTC\", 90, 7);\n```", "```\nfunction createLimitOrder(\"BTC\", \"ETH\", 10, 20);\n```", "```\n/// @notice The function to create market orders by filling existing limit orders\n/// @param _type The type of the market order which can be \"Buy\" or \"Sell\"\n/// @param _symbol The token that we want to buy or sell\n/// @param _maxPrice The maximum price we are willing to sell or buy the token for, set it to 0 to not limit the order\nfunction createMarketOrder(bytes32 _type, bytes32 _symbol, uint256 _maxPrice);\n```", "```\npragma solidity 0.5.4;\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n```", "```\ncontract Escrow {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, 'You must be the owner to execute that function');\n        _;\n    }\n\n    /// @notice This contract does not accept ETH transfers\n    function () external { revert(); }\n\n    /// @notice To setup the initial tokens that the user will store when creating the escrow\n    /// @param _owner The address that will be the owner of this escrow, must be the owner of the tokens\n    constructor (address _owner) public {\n        require(_owner != address(0), 'The owner address must be set');\n        owner = _owner;\n    }\n\n    /// @notice To transfer tokens to another address, usually the buyer or seller of an existing order\n    /// @param _token The address of the token to transfer\n    /// @param _to The address of the receiver\n    /// @param _amount The amount of tokens to transfer\n    function transferTokens(address _token, address _to, uint256 _amount) public onlyOwner {\n        require(_token != address(0), 'The token address must be set');\n        require(_to != address(0), 'The receiver address must be set');\n        require(_amount > 0, 'You must specify the amount of tokens to transfer');\n\n        require(IERC20(_token).transfer(_to, _amount), 'The transfer must be successful');\n    }\n\n    /// @notice To see how many of a particular token this contract contains\n    /// @param _token The address of the token to check\n    /// @return uint256 The number of tokens this contract contains\n    function checkTokenBalance(address _token) public view returns(uint256) {\n        require(_token != address(0), 'The token address must be set');\n        return IERC20(_token).balanceOf(address(this));\n    }\n}\n```", "```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.styl'\n\nclass Main extends React.Component {\n    constructor() {\n        super()\n    }\n\n    render() {\n        return (\n            <div>\n                <Sidebar />\n            </div>\n        )\n    }\n}\n```", "```\n/// Create the basic sidebar html, then we'll add the style css\n// The sidebar where you take all your actions\nclass Sidebar extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            showLimitOrderInput: false\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"sidebar\">\n                <div className=\"selected-assets-title\">Selected assets:</div>\n                <div className=\"selected-asset-one\">ETH</div>\n                <div className=\"selected-asset-two\">BAT</div>\n                <div className=\"your-portfolio\">Your portfolio:</div>\n                <div className=\"grid-center\">ETH:</div><div className=\"grid-center\">10</div>\n                <div className=\"grid-center\">BAT:</div><div className=\"grid-center\">200</div>\n                <div className=\"money-management\">Money management:</div>\n                <button className=\"button-outline\">Deposit</button>\n                <button className=\"button-outline\">Withdraw</button>\n                <div className=\"actions\">Actions:</div>\n                <button>Buy</button>\n                <button className=\"sell\">Sell</button>\n                <select defaultValue=\"market-order\" onChange={selected => {\n                    if(selected.target.value == 'limit-order') this.setState({showLimitOrderInput: true})\n                    else this.setState({showLimitOrderInput: false})\n                }}>\n                    <option value=\"market-order\">Market Order</option>\n                    <option value=\"limit-order\">Limit Order</option>\n                </select>\n                <input ref=\"limit-order-amount\" className={this.state.showLimitOrderInput ? '' : 'hidden'} type=\"number\" placeholder=\"Price to buy or sell at...\"/>\n            </div>\n        )\n    }\n}\n```", "```\nnpm i -S style-loader css-loader stylus-loader stylus\n```", "```\n{\n    test: /\\.styl$/,\n    exclude: /node_modules/,\n    use: ['style-loader', 'css-loader', 'stylus-loader']\n}\n```", "```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.styl'\n\nclass Main extends React.Component {\n    constructor() {\n        super()\n\n        this.state = {\n            trades: [{\n                id: 123,\n                type: 'buy',\n                firstSymbol: 'ETH',\n                secondSymbol: 'BAT',\n                quantity: 120, // You want to buy 120 firstSymbol\n                price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol\n            }, {\n                id: 927,\n                type: 'sell',\n                firstSymbol: 'ETH',\n                secondSymbol: 'BAT',\n                quantity: 80, // You want to buy 80 secondSymbol\n                price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol\n            }],\n            history: [{\n                id: 927,\n                type: 'buy',\n                firstSymbol: 'ETH',\n                secondSymbol: 'BAT',\n                quantity: 2,\n                price: 20\n            }, {\n                id: 927,\n                type: 'sell',\n                firstSymbol: 'ETH',\n                secondSymbol: 'BAT',\n                quantity: 2, // You want to buy 80 secondSymbol\n                price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol\n            }]\n        }\n    }\n```", "```\n\n    render() {\n        return (\n            <div className=\"main-container\">\n                <Sidebar />\n                <Trades\n                    trades={this.state.trades}\n                />\n                <History\n                    history={this.state.history}\n                />\n            </div>\n        )\n    }\n}\n\n```", "```\n// The main section to see live trades taking place\nclass Trades extends React.Component {\n    constructor() {\n        super()\n    }\n\n    render() {\n        let buyTrades = this.props.trades.filter(trade => trade.type == 'buy')\n        buyTrades = buyTrades.map((trade, index) => (\n            <div key={trade.id + index} className=\"trade-container buy-trade\">\n                <div className=\"trade-symbol\">{trade.firstSymbol}</div>\n                <div className=\"trade-symbol\">{trade.secondSymbol}</div>\n                <div className=\"trade-pricing\">{trade.type} {trade.quantity} {trade.firstSymbol} at {trade.price} {trade.secondSymbol} each</div>\n            </div>\n        ))\n        let sellTrades = this.props.trades.filter(trade => trade.type == 'sell')\n        sellTrades = sellTrades.map((trade, index) => (\n            <div key={trade.id + index} className=\"trade-container sell-trade\">\n                <div className=\"trade-symbol\">{trade.firstSymbol}</div>\n                <div className=\"trade-symbol\">{trade.secondSymbol}</div>\n                <div className=\"trade-pricing\">{trade.type} {trade.quantity} {trade.firstSymbol} at {trade.price} {trade.secondSymbol} each</div>\n            </div>\n        ))\n        return (\n            <div className=\"trades\">\n                <div className=\"buy-trades-title heading\">Buy</div>\n                <div className=\"buy-trades-container\">{buyTrades}</div>\n                <div className=\"sell-trades-title heading\">Sell</div>\n                <div className=\"sell-trades-container\">{sellTrades}</div>\n            </div>\n        )\n    }\n}\n```", "```\n// Past historical trades\nclass History extends React.Component {\n    constructor() {\n        super()\n    }\n\n    render() {\n        const historicalTrades = this.props.history.map((trade, index) => (\n            <div key={trade.id + index} className=\"historical-trade\">\n                <div className={trade.type == 'sell' ? 'sell-trade' : 'buy-trade'}>{trade.type} {trade.quantity} {trade.firstSymbol} for {trade.quantity * trade.price} {trade.secondSymbol} at {trade.price} each</div>\n            </div>\n        ))\n        return (\n            <div className=\"history\">\n                <div className=\"heading\">Recent history</div>\n                <div className=\"historical-trades-container\">{historicalTrades}</div>\n            </div>\n        )\n    }\n}\n\nReactDOM.render(<Main />, document.querySelector('#root'))\n\n```", "```\n.history\n    padding: 15px\n    background-color: whitesmoke\n    height: 100vh\n    overflow: auto\n\n    .historical-trades-container\n        text-align: center\n\n        .historical-trade\n            font-size: 0.95em\n            margin-bottom: 10px\n\n            &:first-letter\n                text-transform: uppercase\n\n            .sell-trade\n                color: rgb(223, 98, 98)\n\n            .buy-trade\n                color: rgb(98, 133, 223)\n```", "```\n// Functions that we need:\n/*\n    1\\. Constructor to setup the owner\n    2\\. Fallback non-payable function to reject ETH from direct transfers since we only want people to use the functions designed to trade a specific pair\n    3\\. Function to extract tokens from this contract in case someone mistakenly sends ERC20 to the wrong function\n    4\\. Function to create whitelist a token by the owner\n    5\\. Function to create market orders\n    6\\. Function to create limit orders\n */\n```", "```\npragma solidity ^0.5.4;\n\nimport './Escrow.sol';\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n```", "```\ncontract DAX {\n    event TransferOrder(bytes32 _type, address indexed from, address indexed to, bytes32 tokenSymbol, uint256 quantity);\n    enum OrderState {OPEN, CLOSED}\n\n    struct Order {\n        uint256 id;\n        address owner;\n        bytes32 orderType;\n        bytes32 firstSymbol;\n        bytes32 secondSymbol;\n        uint256 quantity;\n        uint256 price;\n        uint256 timestamp;\n        OrderState state;\n    }\n```", "```\n    Order[] public buyOrders;\n    Order[] public sellOrders;\n    Order[] public closedOrders;\n    uint256 public orderIdCounter;\n    address public owner;\n    address[] public whitelistedTokens;\n    bytes32[] public whitelistedTokenSymbols;\n    address[] public users;\n```", "```\n    // Token address => isWhitelisted or not\n    mapping(address => bool) public isTokenWhitelisted;\n    mapping(bytes32 => bool) public isTokenSymbolWhitelisted;\n    mapping(bytes32 => bytes32[]) public tokenPairs; // A token symbol pair made of 'FIRST' => 'SECOND'\n    mapping(bytes32 => address) public tokenAddressBySymbol; // Symbol => address of the token\n    mapping(uint256 => Order) public orderById; // Id => trade object\n    mapping(uint256 => uint256) public buyOrderIndexById; // Id => index inside the buyOrders array\n    mapping(uint256 => uint256) public sellOrderIndexById; // Id => index inside the sellOrders array\n    mapping(address => address) public escrowByUserAddress; // User address => escrow contract address\n```", "```\n    modifier onlyOwner {\n        require(msg.sender == owner, 'The sender must be the owner for this function');\n        _;\n    }\n\n    /// @notice Users should not send ether to this contract\n    function () external {\n        revert();\n    }\n\n    constructor () public {\n        owner = msg.sender;\n    }\n```", "```\n     /// @notice To whitelist a token so that is tradable in the exchange\n     /// @dev If the transaction reverts, it could be because of the quantity of token pairs, try reducing the number and breaking the transaction into several pieces\n     /// @param _symbol The symbol of the token\n     /// @param _token The token to whitelist, for instance 'TOK'\n    /// @param _tokenPairSymbols The token pairs to whitelist for this new token, for instance: ['BAT', 'HYDRO'] which will be converted to ['TOK', 'BAT'] and ['TOK', 'HYDRO']\n    /// @param _tokenPairAddresses The token pair addresses to whitelist for this new token, for instance: ['0x213...', '0x927...', '0x128...']\n    function whitelistToken(bytes32 _symbol, address _token, bytes32[] memory _tokenPairSymbols, address[] memory _tokenPairAddresses) public onlyOwner {}\n```", "```\n    /// @notice To store tokens inside the escrow contract associated with the user accounts as long as the users made an approval beforehand\n    /// @dev It will revert is the user doesn't approve tokens beforehand to this contract\n    /// @param _token The token address\n    /// @param _amount The quantity to deposit to the escrow contract\n    function depositTokens(address _token, uint256 _amount) public {}\n\n    /// @notice To extract tokens\n    /// @param _token The token address to extract\n    /// @param _amount The amount of tokens to transfer\n    function extractTokens(address _token, uint256 _amount) public {}\n```", "```\n    /// @notice To create a market order by filling one or more existing limit orders at the most profitable price given a token pair, type of order (buy or sell) and the amount of tokens to trade, the _quantity is how many _firstSymbol tokens you want to buy if it's a buy order or how many _firstSymbol tokens you want to sell at market price\n    /// @param _type The type of order either 'buy' or 'sell'\n    /// @param _firstSymbol The first token to buy or sell\n    /// @param _secondSymbol The second token to create a pair\n    /// @param _quantity The amount of tokens to sell or buy\n    function marketOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity) public {}\n\n    /// @notice To create a market order given a token pair, type of order, amount of tokens to trade and the price per token. If the type is buy, the price will determine how many _secondSymbol tokens you are willing to pay for each _firstSymbol up until your _quantity or better if there are more profitable prices. If the type if sell, the price will determine how many _secondSymbol tokens you get for each _firstSymbol\n    /// @param _type The type of order either 'buy' or 'sell'\n    /// @param _firstSymbol The first symbol to deal with\n    /// @param _secondSymbol The second symbol that you want to deal\n    /// @param _quantity How many tokens you want to deal, these are _firstSymbol tokens\n    /// @param _pricePerToken How many tokens you get or pay for your other symbol, the total quantity is _pricePerToken * _quantity\n    function limitOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity, uint256 _pricePerToken) public {}\n```", "```\n    /// @notice Sorts the selected array of Orders by price from lower to higher if it's a buy order or from highest to lowest if it's a sell order\n    /// @param _type The type of order either 'sell' or 'buy'\n    /// @return uint256[] Returns the sorted ids\n function sortIdsByPrices(bytes32 _type) public view returns (uint256[] memory) {}\n\n    /// @notice Checks if a pair is valid\n    /// @param _firstSymbol The first symbol of the pair\n    /// @param _secondSymbol The second symbol of the pair\n    /// @returns bool If the pair is valid or not\n function checkValidPair(bytes32 _firstSymbol, bytes32 _secondSymbol) public view returns(bool) {}\n\n    /// @notice Returns the token pairs\n    /// @param _token To get the array of token pair for that selected token\n    /// @returns bytes32[] An array containing the pairs\n function getTokenPairs(bytes32 _token) public view returns(bytes32[] memory) {}\n}\n```", "```\n/// @notice To whitelist a token so that is tradable in the exchange\n/// @dev If the transaction reverts, it could be because of the quantity of token pairs, try reducing the number and breaking the transaction into several pieces\n/// @param _symbol The symbol of the token\n/// @param _token The token to whitelist, for instance 'TOK'\n/// @param _tokenPairSymbols The token pairs to whitelist for this new token, for instance: ['BAT', 'HYDRO'] which will be converted to ['TOK', 'BAT'] and ['TOK', 'HYDRO']\n/// @param _tokenPairAddresses The token pair addresses to whitelist for this new token, for instance: ['0x213...', '0x927...', '0x128...']\nfunction whitelistToken(bytes32 _symbol, address _token, bytes32[] memory _tokenPairSymbols, address[] memory _tokenPairAddresses) public onlyOwner {\n    require(_token != address(0), 'You must specify the token address to whitelist');\n    require(IERC20(_token).totalSupply() > 0, 'The token address specified is not a valid ERC20 token');\n    require(_tokenPairAddresses.length == _tokenPairSymbols.length, 'You must send the same number of addresses and symbols');\n\n    isTokenWhitelisted[_token] = true;\n    isTokenSymbolWhitelisted[_symbol] = true;\n    whitelistedTokens.push(_token);\n    whitelistedTokenSymbols.push(_symbol);\n    tokenAddressBySymbol[_symbol] = _token;\n    tokenPairs[_symbol] = _tokenPairSymbols;\n\n    for(uint256 i = 0; i < _tokenPairAddresses.length; i++) {\n        address currentAddress = _tokenPairAddresses[i];\n        bytes32 currentSymbol = _tokenPairSymbols[i];\n        tokenPairs[currentSymbol].push(_symbol);\n        if(!isTokenWhitelisted[currentAddress]) {\n            isTokenWhitelisted[currentAddress] = true;\n            isTokenSymbolWhitelisted[currentSymbol] = true;\n            whitelistedTokens.push(currentAddress);\n            whitelistedTokenSymbols.push(currentSymbol);\n            tokenAddressBySymbol[currentSymbol] = currentAddress;\n        }\n    }\n}\n```", "```\n/// @notice To store tokens inside the escrow contract associated with the user accounts as long as the users made an approval beforehand\n/// @dev It will revert is the user doesn't approve tokens beforehand to this contract\n/// @param _token The token address\n/// @param _amount The quantity to deposit to the escrow contract\nfunction depositTokens(address _token, uint256 _amount) public {\n    require(isTokenWhitelisted[_token], 'The token to deposit must be whitelisted');\n    require(_token != address(0), 'You must specify the token address');\n    require(_amount > 0, 'You must send some tokens with this deposit function');\n    require(IERC20(_token).allowance(msg.sender, address(this)) >= _amount, 'You must approve() the quantity of tokens that you want to deposit first');\n    if(escrowByUserAddress[msg.sender] == address(0)) {\n        Escrow newEscrow = new Escrow(address(this));\n        escrowByUserAddress[msg.sender] = address(newEscrow);\n        users.push(msg.sender);\n    }\n    IERC20(_token).transferFrom(msg.sender, escrowByUserAddress[msg.sender], _amount);\n}\n\n/// @notice To extract tokens\n/// @param _token The token address to extract\n/// @param _amount The amount of tokens to transfer\nfunction extractTokens(address _token, uint256 _amount) public {\n    require(_token != address(0), 'You must specify the token address');\n    require(_amount > 0, 'You must send some tokens with this deposit function');\n    Escrow(escrowByUserAddress[msg.sender]).transferTokens(_token, msg.sender, _amount);\n}\n```", "```\n/// @notice To create a market order given a token pair, type of order, amount of tokens to trade and the price per token. If the type is buy, the price will determine how many _secondSymbol tokens you are willing to pay for each _firstSymbol up until your _quantity or better if there are more profitable prices. If the type if sell, the price will determine how many _secondSymbol tokens you get for each _firstSymbol\n/// @param _type The type of order either 'buy' or 'sell'\n/// @param _firstSymbol The first symbol to deal with\n/// @param _secondSymbol The second symbol that you want to deal\n/// @param _quantity How many tokens you want to deal, these are _firstSymbol tokens\n/// @param _pricePerToken How many tokens you get or pay for your other symbol, the total quantity is _pricePerToken * _quantity\n```", "```\nfunction limitOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity, uint256 _pricePerToken) public {\n    address userEscrow = escrowByUserAddress[msg.sender];\n    address firstSymbolAddress = tokenAddressBySymbol[_firstSymbol];\n    address secondSymbolAddress = tokenAddressBySymbol[_secondSymbol];\n\n    require(firstSymbolAddress != address(0), 'The first symbol has not been whitelisted');\n    require(secondSymbolAddress != address(0), 'The second symbol has not been whitelisted');\n    require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted to trade with it');\n    require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted to trade with it');\n    require(userEscrow != address(0), 'You must deposit some tokens before creating orders, use depositToken()');\n    require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');\n```", "```\n    Order memory myOrder = Order(orderIdCounter, msg.sender, _type, _firstSymbol, _secondSymbol, _quantity, _pricePerToken, now, OrderState.OPEN);\n    orderById[orderIdCounter] = myOrder;\n    if(_type == 'buy') {\n        // Check that the user has enough of the second symbol if he wants to buy the first symbol at that price\n        require(IERC20(secondSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough second token funds in your escrow contract to create this buy order');\n\n        buyOrders.push(myOrder);\n\n        // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a buy array for each token\n        uint256[] memory sortedIds = sortIdsByPrices('buy');\n        delete buyOrders;\n        buyOrders.length = sortedIds.length;\n        for(uint256 i = 0; i < sortedIds.length; i++) {\n            buyOrders[i] = orderById[sortedIds[i]];\n            buyOrderIndexById[sortedIds[i]] = i;\n        }\n```", "```\n    } else {\n        // Check that the user has enough of the first symbol if he wants to sell it for the second symbol\n        require(IERC20(firstSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough first token funds in your escrow contract to create this sell order');\n\n        // Add the new order\n        sellOrders.push(myOrder);\n\n        // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a sell array for each token\n        uint256[] memory sortedIds = sortIdsByPrices('sell');\n        delete sellOrders; // Reset orders\n        sellOrders.length = sortedIds.length;\n        for(uint256 i = 0; i < sortedIds.length; i++) {\n            sellOrders[i] = orderById[sortedIds[i]];\n            sellOrderIndexById[sortedIds[i]] = i;\n        }\n    }\n\n    orderIdCounter++;\n}\n```", "```\n/// @notice Sorts the selected array of Orders by price from lower to higher if it's a buy order or from highest to lowest if it's a sell order\n/// @param _type The type of order either 'sell' or 'buy'\n/// @return uint256[] Returns the sorted ids\nfunction sortIdsByPrices(bytes32 _type) public view returns (uint256[] memory) {\n    Order[] memory orders;\n    if(_type == 'sell') orders = sellOrders;\n    else orders = buyOrders;\n\n    uint256 length = orders.length;\n    uint256[] memory orderedIds = new uint256[](length);\n    uint256 lastId = 0;\n    for(uint i = 0; i < length; i++) {\n        if(orders[i].quantity > 0) {\n            for(uint j = i+1; j < length; j++) {\n                // If it's a buy order, sort from lowest to highest since we want the lowest prices first\n                if(_type == 'buy' && orders[i].price > orders[j].price) {\n                    Order memory temporaryOrder = orders[i];\n                    orders[i] = orders[j];\n                    orders[j] = temporaryOrder;\n                }\n                // If it's a sell order, sort from highest to lowest since we want the highest sell prices first\n                if(_type == 'sell' && orders[i].price < orders[j].price) {\n                    Order memory temporaryOrder = orders[i];\n                    orders[i] = orders[j];\n                    orders[j] = temporaryOrder;\n                }\n            }\n            orderedIds[lastId] = orders[i].id;\n            lastId++;\n        }\n    }\n    return orderedIds;\n}\n```", "```\n/// @notice To create a market order by filling one or more existing limit orders at the most profitable price given a token pair, type of order (buy or sell) and the amount of tokens to trade, the _quantity is how many _firstSymbol tokens you want to buy if it's a buy order or how many _firstSymbol tokens you want to sell at market price\n/// @param _type The type of order either 'buy' or 'sell'\n/// @param _firstSymbol The first token to buy or sell\n/// @param _secondSymbol The second token to create a pair\n/// @param _quantity The amount of tokens to sell or buy\n```", "```\nfunction marketOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity) public {\n    require(_type.length > 0, 'You must specify the type');\n    require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted');\n    require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted');\n    require(_quantity > 0, 'You must specify the quantity to buy or sell');\n    require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');\n```", "```\n    // Fills the latest market orders up until the _quantity is reached\n    uint256[] memory ordersToFillIds;\n    uint256[] memory quantitiesToFillPerOrder;\n    uint256 currentQuantity = 0;\n    if(_type == 'buy') {\n        ordersToFillIds = new uint256[](sellOrders.length);\n        quantitiesToFillPerOrder = new uint256[](sellOrders.length);\n        // Loop through all the sell orders until we fill the quantity\n        for(uint256 i = 0; i < sellOrders.length; i++) {\n            ordersToFillIds[i] = sellOrders[i].id;\n            if((currentQuantity + sellOrders[i].quantity) > _quantity) {\n                quantitiesToFillPerOrder[i] = _quantity - currentQuantity;\n                break;\n            }\n            currentQuantity += sellOrders[i].quantity;\n            quantitiesToFillPerOrder[i] = sellOrders[i].quantity;\n        }\n    } else {\n        ordersToFillIds = new uint256[](buyOrders.length);\n        quantitiesToFillPerOrder = new uint256[](buyOrders.length);\n        for(uint256 i = 0; i < buyOrders.length; i++) {\n            ordersToFillIds[i] = buyOrders[i].id;\n            if((currentQuantity + buyOrders[i].quantity) > _quantity) {\n                quantitiesToFillPerOrder[i] = _quantity - currentQuantity;\n                break;\n            }\n            currentQuantity += buyOrders[i].quantity;\n            quantitiesToFillPerOrder[i] = buyOrders[i].quantity;\n        }\n    }\n```", "```\n    // When the myOrder.type == sell or _type == buy\n    // myOrder.owner send quantityToFill[] of _firstSymbol to msg.sender\n    // msg.sender send quantityToFill[] * myOwner.price of _secondSymbol to myOrder.owner\n\n    // When the myOrder.type == buy or _type == sell\n    // myOrder.owner send quantityToFill[] * myOwner.price of _secondSymbol to msg.sender\n    // msg.sender send quantityToFill[] of _firstSymbol to myOrder.owner\n```", "```\n    // Close and fill orders\n    for(uint256 i = 0; i < ordersToFillIds.length; i++) {\n        Order memory myOrder = orderById[ordersToFillIds[i]];\n\n        // If we fill the entire order, mark it as closed\n        if(quantitiesToFillPerOrder[i] == myOrder.quantity) {\n            myOrder.state = OrderState.CLOSED;\n            closedOrders.push(myOrder);\n        }\n        myOrder.quantity -= quantitiesToFillPerOrder[i];\n        orderById[myOrder.id] = myOrder;\n```", "```\n        if(_type == 'buy') {\n            // If the limit order is a buy order, send the firstSymbol to the creator of the limit order which is the buyer\n            Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_firstSymbol], msg.sender, quantitiesToFillPerOrder[i]);\n            Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_secondSymbol], myOrder.owner, quantitiesToFillPerOrder[i] * myOrder.price);\n\n            sellOrders[sellOrderIndexById[myOrder.id]] = myOrder;\n\n            emit TransferOrder('sell', escrowByUserAddress[myOrder.owner], msg.sender, _firstSymbol, quantitiesToFillPerOrder[i]);\n            emit TransferOrder('buy', escrowByUserAddress[msg.sender], myOrder.owner, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);\n```", "```\n        } else {\n            // If this is a buy market order or a sell limit order for the opposite, send firstSymbol to the second user\n                Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_secondSymbol], msg.sender, quantitiesToFillPerOrder[i] * myOrder.price);\n            Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_firstSymbol], myOrder.owner, quantitiesToFillPerOrder[i]);\n\n            buyOrders[buyOrderIndexById[myOrder.id]] = myOrder;\n\n            emit TransferOrder('buy', escrowByUserAddress[myOrder.owner], msg.sender, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);\n            emit TransferOrder('sell', escrowByUserAddress[msg.sender], myOrder.owner, _firstSymbol, quantitiesToFillPerOrder[i]);\n        }\n\n    }\n}\n```", "```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport MyWeb3 from 'web3'\nimport './index.styl'\nimport ABI from '../build/contracts/DAX.json'\nimport TokenABI from '../build/contracts/ERC20.json'\n\nconst batToken = '0x850Cbb38828adF8a89d7d799CCf1010Dc238F665'\nconst watToken = '0x029cc401Ef45B2a2B2D6D2D6677b9F94E26cfF9d'\nconst dax = ABI.networks['3'].address\n```", "```\nclass Main extends React.Component {\n    constructor() {\n        super()\n\n        this.state = {\n            contractInstance: {},\n            tokenInstance: {},\n            secondTokenInstance: {},\n            userAddress: '',\n            firstSymbol: 'BAT', // Sample tokens\n            secondSymbol: 'WAT', // Sample tokens\n            balanceFirstSymbol: 0,\n            balanceSecondSymbol: 0,\n            escrow: '',\n            buyOrders: [],\n            sellOrders: [],\n            closedOrders: []\n        }\n\n        this.setup()\n    }\n```", "```\n    // To use bytes32 functions\n    bytes32(name) {\n        return myWeb3.utils.fromAscii(name)\n    }\n```", "```\n async setup() {\n        // Create the contract instance\n        window.myWeb3 = new MyWeb3(ethereum)\n        try {\n            await ethereum.enable();\n        } catch (error) {\n            console.error('You must approve this dApp to interact with it')\n        }\n        console.log('Setting up contract instances')\n        await this.setContractInstances()\n        console.log('Setting up orders')\n        await this.setOrders()\n        console.log('Setting up pairs')\n        await this.setPairs()\n    }\n```", "```\n    async setContractInstances() {\n        const userAddress = (await myWeb3.eth.getAccounts())[0]\n        if(!userAddress) return console.error('You must unlock metamask to use this dApp on ropsten!')\n        await this.setState({userAddress})\n        const contractInstance = new myWeb3.eth.Contract(ABI.abi, dax, {\n            from: this.state.userAddress,\n            gasPrice: 2e9\n        })\n        const tokenInstance = new myWeb3.eth.Contract(TokenABI.abi, batToken, {\n            from: this.state.userAddress,\n            gasPrice: 2e9\n        })\n        const secondTokenInstance = new myWeb3.eth.Contract(TokenABI.abi, watToken, {\n            from: this.state.userAddress,\n            gasPrice: 2e9\n        })\n        await this.setState({contractInstance, tokenInstance, secondTokenInstance})\n    }\n```", "```\n    async setOrders() {\n        // First get the length of all the orders so that you can loop through them\n        const buyOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32(\"buy\")).call({ from: this.state.userAddress })\n        const sellOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32('sell')).call({ from: this.state.userAddress })\n        const closedOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32('closed')).call({ from: this.state.userAddress })\n        let buyOrders = []\n        let sellOrders = []\n        let closedOrders = []\n```", "```\n        for(let i = 0; i < buyOrdersLength; i++) {\n            const order = await this.state.contractInstance.methods.getOrder(this.bytes32('buy'), i).call({ from: this.state.userAddress })\n            const orderObject = {\n                id: order[0],\n                owner: order[1],\n                type: myWeb3.utils.toUtf8(order[2]),\n                firstSymbol: myWeb3.utils.toUtf8(order[3]),\n                secondSymbol: myWeb3.utils.toUtf8(order[4]),\n                quantity: order[5],\n                price: order[6],\n                timestamp: order[7],\n                state: order[8],\n            }\n            buyOrders.push(orderObject)\n        }\n```", "```\n        for(let i = 0; i < sellOrdersLength; i++) {\n            const order = await this.state.contractInstance.methods.getOrder(this.bytes32('sell'), 0).call({ from: this.state.userAddress })\n            const orderObject = {\n                id: order[0],\n                owner: order[1],\n                type: myWeb3.utils.toUtf8(order[2]),\n                firstSymbol: myWeb3.utils.toUtf8(order[3]),\n                secondSymbol: myWeb3.utils.toUtf8(order[4]),\n                quantity: order[5],\n                price: order[6],\n                timestamp: order[7],\n                state: order[8],\n            }\n            sellOrders.push(orderObject)\n        }\n```", "```\n        for(let i = 0; i < closedOrdersLength; i++) {\n            const order = await this.state.contractInstance.methods.closedOrders(this.bytes32('close'), 0).call({ from: this.state.userAddress })\n            const orderObject = {\n                id: order[0],\n                owner: order[1],\n                type: myWeb3.utils.toUtf8(order[2]),\n                firstSymbol: myWeb3.utils.toUtf8(order[3]),\n                secondSymbol: myWeb3.utils.toUtf8(order[4]),\n                quantity: order[5],\n                price: order[6],\n                timestamp: order[7],\n                state: order[8],\n            }\n            closedOrders.push(orderObject)\n        }\n        this.setState({buyOrders, sellOrders, closedOrders})\n    }\n```", "```\n    async setPairs() {\n        // Here you'd add all the logic to get all the token symbols, in this case we're keeping it simple with one fixed pair\n        // If there are no pairs, whitelist a new one automatically if this is the owner of the DAX contract\n        const owner = await this.state.contractInstance.methods.owner().call({ from: this.state.userAddress })\n        const isWhitelisted = await this.state.contractInstance.methods.isTokenWhitelisted(batToken).call({ from: this.state.userAddress })\n        if(owner == this.state.userAddress && !isWhitelisted) {\n            await this.state.contractInstance.methods.whitelistToken(this.bytes32('BAT'), batToken, [this.bytes32('WAT')], [watToken]).send({ from: this.state.userAddress, gas: 8e6 })\n        }\n\n        // Set the balance of each symbol considering how many tokens you have in escrow\n        const escrow = await this.state.contractInstance.methods.escrowByUserAddress(this.state.userAddress).call({ from: this.state.userAddress })\n        const balanceOne = await this.state.tokenInstance.methods.balanceOf(escrow).call({ from: this.state.userAddress })\n        const balanceTwo = await this.state.secondTokenInstance.methods.balanceOf(escrow).call({ from: this.state.userAddress })\n        this.setState({escrow, balanceOne, balanceTwo})\n }\n}\n```", "```\nasync whitelistTokens(symbol, token, pairSymbols, pairAddresses) {\n    await this.state.contractInstance.methods.whitelistToken(this.bytes32(symbol), token, pairSymbols, pairAddresses).send({ from: this.state.userAddress })\n}\n```", "```\nasync depositTokens(symbol, amount) {\n    if(symbol == 'BAT') {\n        // Check the token balance before approving\n        const balance = await this.state.tokenInstance.methods.balanceOf(this.state.userAddress).call({ from: this.state.userAddress })\n        if(balance < amount) return alert(`You can't deposit ${amount} BAT since you have ${balance} BAT in your account, get more tokens before depositing`)\n        // First approve to 0 to avoid errors and then increase it\n        await this.state.tokenInstance.methods.approve(dax, 0).send({ from: this.state.userAddress })\n        await this.state.tokenInstance.methods.approve(dax, amount).send({ from: this.state.userAddress })\n        // Create the transaction\n        await this.state.contractInstance.methods.depositTokens(batToken, amount).send({ from: this.state.userAddress })\n    } else if(symbol == 'WAT') {\n        // Check the token balace before approving\n        const balance = await this.state.secondTokenInstance.methods.balanceOf(this.state.userAddress).call({ from: this.state.userAddress })\n        if(balance < amount) return alert(`You can't deposit ${amount} WAT since you have ${balance} WAT in your account, get more tokens before depositing`)\n        // First approve to 0 to avoid errors and then increase it\n        await this.state.secondTokenInstance.methods.approve(dax, 0).send({ from: this.state.userAddress })\n        await this.state.secondTokenInstance.methods.approve(dax, amount).send({ from: this.state.userAddress })\n        // Create the transaction\n        await this.state.contractInstance.methods.depositTokens(watToken, amount).send({ from: this.state.userAddress })\n    }\n}\n```", "```\nasync withdrawTokens(symbol, amount) {\n    if(symbol == 'BAT') {\n        await this.state.contractInstance.methods.extractTokens(batToken, amount).send({ from: this.state.userAddress })\n    } else if(symbol == 'WAT') {\n        await this.state.contractInstance.methods.extractTokens(watToken, amount).send({ from: this.state.userAddress })\n    }\n}\n```", "```\nasync createLimitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken) {\n    // Create the limit order\n    await this.state.contractInstance.methods.limitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken).send({ from: this.state.userAddress })\n}\n\nasync createMarketOrder(type, firstSymbol, secondSymbol, quantity) {\n    // Create the market order\n    await this.state.contractInstance.methods.marketOrder(type, firstSymbol, secondSymbol, quantity).send({ from: this.state.userAddress })\n}\n```", "```\nrender() {\n    return (\n        <div className=\"main-container\">\n            <Sidebar\n                firstSymbol={this.state.firstSymbol}\n                secondSymbol={this.state.secondSymbol}\n                balanceOne={this.state.balanceOne}\n                balanceTwo={this.state.balanceTwo}\n                deposit={(symbol, amount) => this.depositTokens(symbol, amount)}\n                withdraw={(symbol, amount) => this.withdrawTokens(symbol, amount)}\n                limitOrder={(type, firstSymbol, secondSymbol, quantity, pricePerToken) => this.createLimitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken)}\n                marketOrder={(type, firstSymbol, secondSymbol, quantity) => this.createMarketOrder(type, firstSymbol, secondSymbol, quantity)}\n            />\n            <Orders\n                buyOrders={this.state.buyOrders}\n                sellOrders={this.state.sellOrders}\n            />\n            <History\n                closedOrders={this.state.closedOrders}\n            />\n        </div>\n    )\n}\n```", "```\nclass Sidebar extends React.Component {\n constructor() {\n        super()\n        this.state = {\n            selectedLimitOrder: false,\n            limitOrderPrice: 0,\n            orderQuantity: 0,\n        }\n }\n\n    // To use bytes32 functions\n bytes32(name) {\n        return myWeb3.utils.fromAscii(name)\n }\n\n resetInputs() {\n        this.refs.limitOrderPrice.value = ''\n        this.refs.orderQuantity.value = ''\n        this.setState({\n            limitOrderPrice: 0,\n            orderQuantity: 0,\n        })\n }\n```", "```\n render() {\n        return (\n            <div className=\"sidebar\">\n                <div className=\"selected-assets-title heading\">Selected assets</div>\n                <div className=\"selected-asset-one\">{this.props.firstSymbol}</div>\n                <div className=\"selected-asset-two\">{this.props.secondSymbol}</div>\n                <div className=\"your-portfolio heading\">Your portfolio</div>\n                <div className=\"grid-center\">{this.props.firstSymbol}:</div><div className=\"grid-center\">{this.props.balanceOne ? this.props.balanceOne : 'Loading...'}</div>\n                <div className=\"grid-center\">{this.props.secondSymbol}:</div><div className=\"grid-center\">{this.props.balanceTwo ? this.props.balanceTwo : 'Loading...'}</div>\n                <div className=\"money-management heading\">Money management</div>\n                <button className=\"button-outline\" onClick={() => {\n                    const amount = prompt(`How many ${this.props.firstSymbol} tokens do you want to deposit?`)\n                    this.props.deposit(this.props.firstSymbol, amount)\n                }}>Deposit {this.props.firstSymbol} </button>\n                <button className=\"button-outline\" onClick={() => {\n                    const amount = prompt(`How many ${this.props.firstSymbol} tokens do you want to withdraw?`)\n                    this.props.withdraw(this.props.firstSymbol, amount)\n                }}>Withdraw {this.props.firstSymbol}</button>\n                <button className=\"button-outline\" onClick={() => {\n                    const amount = prompt(`How many ${this.props.secondSymbol} tokens do you want to deposit?`)\n                    this.props.deposit(this.props.secondSymbol, amount)\n                }}>Deposit {this.props.secondSymbol} </button>\n                <button className=\"button-outline\" onClick={() => {\n                    const amount = prompt(`How many ${this.props.secondSymbol} tokens do you want to withdraw?`)\n                    this.props.withdraw(this.props.secondSymbol, amount)\n                }}>Withdraw {this.props.secondSymbol}</button>\n```", "```\n                <div className=\"actions heading\">Actions</div>\n                <button onClick={() => {\n                    if(this.state.orderQuantity == 0) return alert('You must specify how many tokens you want to buy')\n                    if(this.state.selectedLimitOrder) {\n                        if(this.state.limitOrderPrice == 0) return alert('You must specify the token price at which you want to buy')\n                        if(this.props.balanceTwo < (this.state.orderQuantity * this.state.limitOrderPrice)) {\n                            return alert(`You must approve ${this.state.orderQuantity * this.state.limitOrderPrice} of ${this.props.secondSymbol} tokens to create this buy limit order, your ${this.props.secondSymbol} token balance must be larger than ${this.state.orderQuantity * this.state.limitOrderPrice}`)\n                        }\n                        // Buy the this.state.orderQuantity of this.props.firstSymbol\n                        this.props.limitOrder(this.bytes32('buy'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity, this.state.limitOrderPrice)\n                    } else {\n                        this.props.marketOrder(this.bytes32('buy'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity)\n                    }\n                    this.resetInputs()\n                }}>Buy {this.props.firstSymbol}</button>\n```", "```\n                <button onClick={() => {\n                    if(this.state.orderQuantity == 0) return alert('You must specify how many tokens you want to sell')\n                    if(this.state.selectedLimitOrder) {\n                        if(this.state.limitOrderPrice == 0) return alert('You must specify the token price at which you want to sell')\n                        if(this.props.balanceOne < this.state.orderQuantity) {\n                            return alert(`You must approve ${this.state.orderQuantity} of ${this.props.firstSymbol} tokens to create this sell limit order, your ${this.props.firstSymbol} token balance must be larger than ${this.state.orderQuantity}`)\n                        }\n                        // Buy the this.state.orderQuantity of this.props.firstSymbol\n                        this.props.limitOrder(this.bytes32('sell'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity, this.state.limitOrderPrice)\n                    } else {\n                        this.props.marketOrder(this.bytes32('sell'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity)\n                    }\n                    this.resetInputs()\n                }} className=\"sell\">Sell {this.props.firstSymbol}</button>\n```", "```\n                <select defaultValue=\"market-order\" onChange={selected => {\n                    if(selected.target.value == 'limit-order') {\n                        this.setState({selectedLimitOrder: true})\n                    } else {\n                        this.setState({selectedLimitOrder: false})\n                    }\n                }}>\n                    <option value=\"market-order\">Market Order</option>\n                    <option value=\"limit-order\">Limit Order</option>\n                </select>\n                <input ref=\"limitOrderPrice\" onChange={event => {\n                    this.setState({limitOrderPrice: event.target.value})\n                }} className={this.state.selectedLimitOrder ? '' : 'hidden'} type=\"number\" placeholder=\"Price to buy or sell at...\" />\n                <input ref=\"orderQuantity\" onChange={event => {\n                    this.setState({orderQuantity: event.target.value})\n                }} type=\"number\" placeholder={`Quantity of ${this.props.firstSymbol} to buy or sell...`} />\n            </div>\n        )\n }\n}\n```", "```\n// The main section to see live trades taking place\nclass Orders extends React.Component {\n constructor() {\n        super()\n }\n\n render() {\n        let buyOrders = this.props.buyOrders\n        let sellOrders = this.props.sellOrders\n        if(buyOrders.length > 0) {\n            buyOrders = buyOrders.map((trade, index) => (\n                <div key={trade.id + index} className=\"trade-container buy-trade\">\n                    <div className=\"trade-symbol\">{trade.firstSymbol}</div>\n                    <div className=\"trade-symbol\">{trade.secondSymbol}</div>\n                    <div className=\"trade-pricing\">{trade.type} {trade.quantity} {trade.secondSymbol} at {trade.price} {trade.secondSymbol} each</div>\n                </div>\n            ))\n        }\n\n        if(sellOrders.length > 0) {\n            sellOrders = sellOrders.map((trade, index) => (\n                <div key={trade.id + index} className=\"trade-container sell-trade\">\n                    <div className=\"trade-symbol\">{trade.firstSymbol}</div>\n                    <div className=\"trade-symbol\">{trade.secondSymbol}</div>\n                    <div className=\"trade-pricing\">{trade.type} {trade.quantity} {trade.secondSymbol} at {trade.price} {trade.secondSymbol} each</div>\n                </div>\n            ))\n        }\n        return (\n            <div className=\"trades\">\n                <div className=\"buy-trades-title heading\">Buy</div>\n                <div className=\"buy-trades-container\">{buyOrders}</div>\n                <div className=\"sell-trades-title heading\">Sell</div>\n                <div className=\"sell-trades-container\">{sellOrders}</div>\n            </div>\n        )\n    }\n}\n```", "```\n// Past historical trades\nclass History extends React.Component {\n constructor() {\n        super()\n }\n\n render() {\n        let closedOrders = this.props.closedOrders\n        if(closedOrders.length > 0) {\n            closedOrders = closedOrders.map((trade, index) => (\n                <div key={trade.id + index} className=\"historical-trade\">\n                    <div className={trade.type == 'sell' ? 'sell-trade' : 'buy-trade'}>{trade.type} {trade.quantity} {trade.firstSymbol} for {trade.quantity * trade.price} {trade.secondSymbol} at {trade.price} each</div>\n                </div>\n            ))\n        }\n        return (\n            <div className=\"history\">\n                <div className=\"heading\">Recent history</div>\n                <div className=\"historical-trades-container\">{closedOrders}</div>\n            </div>\n        )\n    }\n}\n\nReactDOM.render(<Main />, document.querySelector('#root'))\n```"]