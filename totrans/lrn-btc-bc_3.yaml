- en: Advanced Blockchain Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链的高级概念
- en: In this chapter, we will discuss the advanced concepts of blockchain and the
    various protocols, challenges, and solutions to it. In the earlier chapters, we
    looked at the consensus protocol or algorithm as one of the most critical components,
    or building blocks, of the blockchain. When we speak about blockchain, the first
    thing that comes to mind is security and the blockchain consensus algorithm. We
    will look into these challenges and the solutions. From there, we will progress
    into smart contracts and how they work with the protocols in the blockchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论区块链的高级概念，以及相关的协议、挑战和解决方案。在前几章中，我们看到共识协议或算法作为区块链最关键组件或构建模块之一。当谈到区块链时，首先想到的是安全性和区块链共识算法。我们将研究这些挑战和解决方案。而后，我们将深入探讨智能合约以及它们在区块链中的运作方式。
- en: 'In this chapter, we will cover the following advanced concepts of the blockchain:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖区块链的以下高级概念：
- en: Consensus protocols, which are the running engine of the blockchain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识协议，即区块链的运行引擎
- en: Types of consensus algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识算法类型
- en: Key challenges in the blockchain to maintain privacy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链中保持隐私的关键挑战
- en: Smart contracts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约
- en: Distributed applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式应用
- en: Introduction to consensus protocols
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识协议介绍
- en: A consensus algorithm is a process implemented in distributed processes or systems
    to achieve agreement on some particular data. The blockchain consensus algorithm
    keeps the ledger transactions synchronized across the network to ensure that ledgers
    are only updated when the appropriate participating board approves transactions
    and, when ledgers are updated, they are updated with the same transactions in
    the same order. This process is called a **consensus**, and the protocol program
    that keeps this running is the consensus algorithm. That is why a consensus is
    considered to be the running engine or heart of blockchain.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法是在分布式进程或系统中实施的过程，用于就某些特定数据达成一致。区块链共识算法使账本交易在网络中保持同步，以确保只有适当参与者批准交易时才更新账本，而且当账本被更新时，它们所包含的交易以相同的顺序一致更新。这个过程被称为**共识**，而保持其运行的协议程序即为共识算法。这就是为什么共识被认为是区块链的运行引擎或核心。
- en: So, consensus primarily establishes a strong technology infrastructure layer
    for the blockchain, which makes it the most critical part. It ensures that every
    next block that gets added to the blockchain is the one and only true version
    and that there are no other blocks that represent another version. It also safeguards
    the entire blockchain against powerful adversaries that may potentially derail
    it and cause it to fail to maintain its integrity. In short, for a blockchain
    network, achieving consensus ensures that all nodes in the network agree upon
    the consistent global state of the blockchain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，共识主要为区块链建立了强大的技术基础层，使其成为最关键的部分。它确保每个添加到区块链的下一个区块是唯一真实的版本，并且没有其他代表另一个版本的区块。它还保护整个区块链免受可能破坏它并导致它失去完整性的强大对手。简而言之，对于区块链网络来说，达成共识确保网络中的所有节点对区块链的一致全局状态达成一致意见。
- en: Properties of consensus mechanism
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识机制的特性
- en: 'A consensus protocol has the following few key properties, which determine
    its applicability and efficacy:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议具有以下几个关键特性，决定了它的适用性和有效性：
- en: '**Safety**: According to the rules of the protocol, if all nodes produce the
    same output and the outputs produced are valid, the consensus protocol is determined
    to be safe. This is also referred to as the consistency of the shared legislature.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：根据协议规则，如果所有节点产生相同的输出，并且产生的输出是有效的，共识协议就确定为安全。这也被称为共享立法的一致性。'
- en: '**Liveness**: The liveness of a consensus protocol is guaranteed if all the
    faulty nodes participating in the consensus eventually produce a value.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活性**：如果所有参与共识的故障节点最终产生一个数值，则共识协议的活性是有保障的。'
- en: '**Tolerance**: A consensus protocol provides fault tolerance if it can recover
    from failure often or participate in a consensus.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容忍性**：如果共识协议能经常从故障中恢复或参与共识，它提供容错性。'
- en: '**Non-repudiation**: This provides the means to verify that the supposed sender
    really sent the message.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：这提供了验证消息发送者真实发送消息的手段。'
- en: '**Decentralized consensus**: A single central authority cannot provide transaction
    finality. Hence, the consensus must be of a decentralized nature.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分散式共识**：单一中央权威无法提供交易最终性。因此，共识必须具有分散的性质。'
- en: '**Quorum structure**: Nodes exchange messages in predefined ways, which may
    include several stages or tiers at the same time.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法定结构**：节点以预定义的方式交换消息，可能同时包括多个阶段或层次。'
- en: '**Authentication**: The consensus process provides the means to verify the
    participants'' identity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：共识过程提供了验证参与者身份的手段。'
- en: '**Integrity**: The process enforces the validation of the transaction integrity.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：该流程强制执行交易完整性的验证。'
- en: While all the preceding properties are crucial, a famous result by Fisher, Lynch,
    and Peterson, known as the **FLP Impossibility Result**, states that no deterministic
    consensus protocol can guarantee safety, liveness, and fault tolerance all together
    in an asynchronous system. Although fault tolerance is crucial for globally distributed
    networks to operate, depending on their system requirements and assumptions, distributed
    systems tend to choose between safety and liveness.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述所有特性都至关重要，但Fisher、Lynch和Peterson提出的著名成果，即**FLP不可能性结果**，表明在异步系统中，没有确定性共识协议可以保证安全性、活性和容错性全部同时满足。尽管容错性对于全球分布式网络的运行至关重要，但根据其系统要求和假设，分布式系统往往在安全性和活性之间进行选择。
- en: The Byzantine Generals' Problem
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拜占庭将军问题
- en: 'In a distributed system, faults are categorized into the following two types:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，故障分为以下两种类型：
- en: '**Fail-stop faults**: These are benign faults that cause nodes to stop participating
    in the consensus protocol due to hardware or software crashes. The nodes will
    stop responding when the fail-stop fault occurs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止故障**：这些是导致节点由于硬件或软件崩溃而停止参与共识协议的良性故障。发生停止故障时，节点将停止响应。'
- en: '**Byzantine faults**: These are faults that cause nodes to behave erratically.
    Leslie Lampert also identified and characterized this category of fault as the
    **Byzantine Generals'' Problem**.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拜占庭故障**：这些故障会导致节点表现异常。莱斯利·兰伯特还将这一类故障鉴定并描述为**拜占庭将军问题**。'
- en: The Byzantine Generals' Problem is conceptualized on the basis of a situation
    where a group of generals, each commanding a part of the Byzantine army, have
    surrounded an enemy fort. To successfully attack and take over the fort, all the
    generals have to agree on a common battle plan and generals can communicate through
    messengers (horse riders or runners) only. But, there is a possibility that these
    messengers might get captured by the enemy and the message might never reach the
    other generals. Moreover, the difficulty in reaching an agreement is that one
    or more generals might be traitors and might possibly be interested in sabotaging
    the whole battle plan. Being traitors, they might send false messages, distort
    messages, or not send any message at all. But all loyal generals will act accordingly
    to the plan. In short, a small number of traitors should not cause the loyal generals
    to adopt a bad or a wrong plan. With this example, we can see that the Byzantine Generals'
    Problem is a typical challenge for a distributed and decentralized system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭将军问题的概念基于这样一种情况：一群将军，每个将军都指挥着拜占庭军队的一部分，围困了一座敌方堡垒。要成功进攻并夺取堡垒，所有将军都必须就一项共同的作战计划达成一致。将军们只能通过信使（骑手或跑步者）进行通信。但是，有可能这些信使会被敌人抓住，消息可能永远无法传达给其他将军。此外，达成一致的困难在于，一名或多名将军可能是叛徒，并可能有意破坏整个作战计划。作为叛徒，他们可能发送虚假消息，扭曲消息，或根本不发送任何消息。但所有忠诚的将军将按照计划行事。简言之，少数叛徒不应导致忠诚的将军采纳一个糟糕或错误的计划。通过这个例子，我们可以看到，拜占庭将军问题对于分布式和去中心化系统来说是一个典型的挑战。
- en: Solution to the Byzantine Generals' Problem
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拜占庭将军问题的解决方案
- en: Distributed systems now have a traditional consensus approach that focuses on
    building fault tolerance in the face of unreliable systems, provisioning mainly
    for fail-stop faults. Some examples of the Byzantine General's Problem are **Paxos**,
    **Raft**, and **Viewstamped** replication. The traditional consensus approach is
    used for putting an order of transactions in the distributed databases, to order
    client-generated requests and other respective stage changes which take place
    in distributed applications by using replicated state machines. The number of
    nodes needed in such networks is `2 f + 1` to be able to tolerate `f` fail-stop
    failures. Tolerating Byzantine faults increases the complexity of the consensus
    protocol by adding several extra layers of messaging to the system. All these
    solutions carry overhead and add more complexity, making them practically impossible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在分布式系统采用传统的共识方法，重点是在面对不可靠系统时建立容错机制，主要用于应对故障停止错误。拜占庭将军问题的一些示例是 **Paxos**、**Raft**
    和 **Viewstamped** 复制。传统的共识方法用于将交易顺序放入分布式数据库中，以排序客户生成的请求和其他分布式应用程序中发生的各个阶段变化，通过使用复制状态机。在这种网络中，需要
    `2 f + 1` 个节点才能容忍 `f` 个故障停止失败。容忍拜占庭错误会通过向系统添加多个额外的消息层增加共识协议的复杂性。所有这些解决方案都带来了开销，并增加了更多复杂性，使它们在实践中几乎不可能。
- en: Practical Byzantine Fault Tolerance
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拜占庭容错实用性
- en: The approach that allowed for Byzantine fault-tolerant applications with low
    overhead was **Practical Byzantine Fault Tolerance** (**PBFT**). PBFT was first
    proposed by Miguel Castro and Barbara Liskov in 1999\. PBFT can process an enormous
    number of direct P2P messages with minimal latency. To be able to tolerate `f` faults
    in the system, PBFT needs `3f + 1` replicas. So, PBFT uses the concept of primary
    and secondary replicas, where the secondary replicas automatically check the sanity
    and liveness of decisions taken by the primary, and can collectively switch to
    a new primary if the primary is found to be compromised. Each node maintains an
    internal state. Upon receiving a message, the respective node uses the message,
    in conjunction with the internal state, to run a computation or operation. This
    directs the node as to what to do or think about the message it received. Once
    the node reaches an individual decision about the respective message, it propagates
    this decision with all other nodes participating in the system. A consensus decision
    is arrived at, based on decisions propagated by all the participating nodes. This
    mechanism of arriving at a consensus requires less effort and adds less overhead
    than the other methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 允许具有低开销的拜占庭容错应用程序的方法是 **实用拜占庭容错** (**PBFT**)。PBFT 于 1999 年由米格尔·卡斯特罗和芭芭拉·利斯科夫首次提出。PBFT
    可以以最小的延迟处理大量直接的 P2P 消息。为了能够容忍系统中的 `f` 个故障，PBFT 需要 `3f + 1` 个副本。因此，PBFT 使用主副本的概念，其中副本自动检查主要副本所做决策的健全性和活性，并且如果发现主要副本受到损害，则可以集体切换到新的主要副本。每个节点都维护着一个内部状态。收到消息后，各节点将消息与内部状态结合起来，运行计算或操作。这指导了节点对接收到的消息该做什么或思考什么。一旦节点就各自的消息做出了决定，它就会将这个决定与系统中的所有其他节点传播。通过传播所有参与节点传播的决定，达成共识决策。与其他方法相比，这种达成共识的机制需要的工作量较少，增加的开销也较少。
- en: Types of consensus algorithms
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法类型
- en: 'The following three consensus algorithms or protocols are used in the majority
    of blockchain platforms:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三种共识算法或协议被用于大多数区块链平台：
- en: PoW
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PoW
- en: PoS
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PoS
- en: PoET
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PoET
- en: 'We will also do a quick comparison of these three, in the later sections. Before
    we look at these different consensus algorithms, let''s take a look at the reasons
    behind the variety of algorithms. The following are some of the reasons for that
    variety:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在后面的章节中对这三种进行快速比较。在我们看这些不同的共识算法之前，让我们先看一下背后的算法种类的原因。以下是其中一些原因：
- en: '**Business need**: Business demands drive which algorithm to use.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务需求**：业务需求决定使用哪种算法。'
- en: '**Use case**: The use case for using a public or private blockchain influences
    which algorithm will be used.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：使用公共或私有区块链的用例会影响使用哪种算法。'
- en: '**Token need**: Not every business case needs to use tokens or cryptocurrencies,
    and may just want to use the underlying blockchain with a consensus.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌需求**：并非每个业务案例都需要使用令牌或加密货币，可能只想使用底层区块链与共识。'
- en: '**Security and privacy**: Security requirements may vary, and the same goes
    for privacy. Some may want a public blockchain, while others may prefer private
    ones.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和隐私**：安全要求可能有所不同，隐私也是如此。有些人可能希望有一个公共区块链，而其他人可能更喜欢私人区块链。'
- en: '**Performance**: Public blockchains may need more time to arrive at a consensus,
    while private ones may do it faster.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：公共区块链可能需要更多时间来达成共识，而私人区块链可能更快。'
- en: '**Robustness**: Banking use cases may demand extremely high cryptography and
    consensus algorithms, as compared to others.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳健性**：银行业务用例可能要求非常高的加密和共识算法，与其他用例相比。'
- en: Proof of Work
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作量证明
- en: The PoW algorithm, also used by Bitcoin, is the best known method of achieving
    a consensus on a blockchain. To achieve a consensus in PoW, unlike PBFT, the submission
    of individual conclusions is not required from all the nodes in the network. Instead,
    PoW uses a hash function to create conditions that allow a single/individual participant
    to announce their conclusions about the submitted information, which are then
    verified by all the other system participants. The hash function has a parameter
    that ensures false information will fail to compute in an acceptable way to prevent
    any false conclusions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PoW算法，也被比特币使用，是在区块链上实现共识的最知名的方法。为了在PoW中达成共识，与PBFT不同，网络中并不需要所有节点提交个别的结论。相反，PoW使用哈希函数创建条件，允许单个参与者宣布他们关于提交信息的结论，然后由所有其他系统参与者进行验证。哈希函数具有参数，确保虚假信息无法以可接受的方式计算，以防止任何错误的结论。
- en: Participants in the Bitcoin system, who publicly verify information on behalf
    of the network, are rewarded with a newly created Bitcoin. This process of searching
    for valid hashes for the verification of information is called **mining**. This
    system of rewarding participation in the network allows broad participation, which
    results in building a more robust network and a safer blockchain. This broad participation
    ensures greater network stability with minimal requirements for each participant
    and allows participants to remain anonymous.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币系统中，代表网络公开验证信息的参与者会收到新创建的比特币作为奖励。搜索用于验证信息的有效哈希的过程称为**挖矿**。这种参与网络奖励的系统有利于广泛参与，从而建立更健壮的网络和更安全的区块链。这种广泛的参与确保更大的网络稳定性，减少了每个参与者的需求，并允许参与者保持匿名。
- en: Challenges with PoW
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PoW的挑战
- en: Although PoW has its benefits, besides being the best known method, it also
    has its own inherent challenges. Nodes need to use real-world resources, such
    as computers and electricity. It takes a lot of power to run the computers, or
    clusters of computers, that calculate different potential solutions, which from
    an ecological standpoint isn't ideal and it is bad for the environment as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PoW有其优点，除了是最知名的方法之外，它也有其固有的挑战。节点需要使用现实世界的资源，比如计算机和电力。运行计算不同潜在解决方案的计算机或计算机集群需要大量电力，从生态角度来看并不理想，对环境也不利。
- en: The nodes need a lot of computing hardware to reach a consensus and such hardware
    is really expensive. There is a possibility of miners moving their hardware to
    mine a different coin or an old coin if the reward is better there. In this case,
    miners and nodes are less loyal. PoW incentivizes the consensus process, which
    is a motivation for miners to mine blocks and earns rewards. However, with the
    maximum capacity of 21 million Bitcoins, with more and more points being released
    over a period of time, miners' rewards will come down as coins become harder to
    mine. This may lead to demotivation for miners to continue mining, which might
    challenge the overall consensus.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 节点需要大量的计算硬件才能达成共识，而这样的硬件成本昂贵。存在矿工将他们的硬件转移到挖掘不同币种或旧币种的可能性，如果那里的奖励更好的话。在这种情况下，矿工和节点就没有那么忠诚了。
    PoW激励共识过程，这是矿工挖掘区块并获得奖励的动机。然而，在21,000,000比特币的最大容量下，随着随着时间的推移释放更多的点，随着硬币变得更难挖掘，矿工的奖励会减少。这可能导致矿工停止继续挖矿的消极情绪，这可能挑战整体共识。
- en: The fact that you need a serious amount of computing power, more than the average
    person could afford or would even be able to work with, means the mining community
    is getting smaller and more exclusive. This goes against the idea of decentralization
    and could potentially lead to a 51% attack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要大量计算能力，超过普通人能负担或甚至能够使用的平均水平，这意味着挖矿社区正在变得越来越小和更加排他。 这与去中心化的想法相违背，可能潜在地导致51%的攻击。
- en: Proof of Stake
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股权证明
- en: PoS is the most common alternative to PoW for verifying and validating the transactions
    on the block. In this type of consensus algorithm, instead of investing in expensive
    computer equipment in a race to mine blocks, a validator invests in the coins
    in the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: PoS 是用于验证和确认区块上的交易的最常见的 PoW 的替代方案。在这种类型的共识算法中，验证者不再投资于昂贵的计算机设备来竞争挖掘区块，而是投资于系统中的代币。
- en: Note the term validator, because no coin creation or mining takes place in PoS.
    Instead, all the coins exist from day one and validators, also called stakeholders,
    are paired strictly in transaction fees only.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意术语“验证者”，因为 PoS 中不进行币的创建或挖矿。相反，所有的代币从第一天起就存在，并且验证者，也称为利益相关者，仅通过交易费用进行配对。
- en: In PoS, the selection of individuals for the approval of new messages to confirm
    the validity of new information submitted to the database is done in a more deterministic
    way. This selection is done by the network on the proportional stake of each individual
    in the network. In PoS, your chance of being picked to create the next new block
    depends on the fraction of coins in the system you own or have to set aside as
    a stake. For example, a validator with 500 coins will be five times as likely
    to be chosen as someone with 100 coins.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PoS 中，用于审批新信息以确认提交到数据库的有效性的个体选择是以更确定性的方式进行的。网络根据每个个体在网络中所拥有的代币比例来进行选择。在 PoS
    中，你被选中创建下一个新区块的机会取决于你在系统中拥有的或需要作为抵押物设定的硬币的比例。例如，拥有 500 枚代币的验证者被选择的可能性是拥有 100 枚代币的人的五倍。
- en: Switching to PoS could help to encourage more community participation as well
    as aid decentralization. Taking mining out of the hands of the few pools of GPU
    farms doing the bulk of the mining, which somewhat resembles an oligopoly, and
    then distributing it evenly across the network, should lead to a more real decentralized
    system. Naive PoS algorithms suffer from a problem of keeping nothing at stake.
    It doesn't punish actors for validating more than one history, meaning the network
    could easily disagree on the real history. A participant with nothing to lose
    or with no stake involved has no reason not to behave badly. These implementations
    do not provide incentives for nodes to vote on the correct block. Therefore, nodes
    can vote on multiple blocks, supporting multiple forks, to maximize their chances
    of winning a reward, as they do not expend anything in doing so. This nothing-at-stake
    problem needs to be tackled for the correct and efficient implementation of PoS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 转向 PoS 可以帮助鼓励更多的社区参与并促进去中心化。将挖矿从少数掌握大部分挖矿活动的 GPU 矿场的手中拿走，然后均匀地分配到整个网络中，应该会导致一个更加真正的去中心化系统。朴素的
    PoS 算法存在一个无所谓风险的问题。它不惩罚验证者验证多个历史记录，这意味着网络很容易对真实历史产生分歧。没有什么可以失去或没有利益关系的参与者没有理由不表现得糟糕。这些实现不为节点投票正确的区块提供激励。因此，节点可以投票支持多个区块，支持多个分叉，以最大化他们获得奖励的机会，因为他们不需要任何支出来这样做。必须解决这个无所谓风险问题，以便正确和有效地实现
    PoS。
- en: Proof of Elapsed Time
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**时间证明**'
- en: PoET is a consensus algorithm similar to PoW which it consumes far less electricity,
    that Intel has developed for their own use. The algorithm uses a **t****rusted
    execution environment** (**TEE**), such as **Software Guard Extensions** (**SGX**),
    to ensure blocks get produced in a random lottery fashion without any work done,
    instead of having participants solve a cryptographic puzzle. This approach is
    based on a guaranteed rate time provided through the TEE. According to Intel,
    the PoET algorithm scales to thousands of nodes and will run efficiently on any
    Intel processor that supports SGX. A major drawback for PoET is the requirement
    to always put your trust in Intel, when moving away from putting trust in third-parties
    is the fundamental reason for the public blockchain. This algorithm can be looked
    at as another alternative approach.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: PoET 是一种类似于 PoW 的共识算法，但它消耗的电力要少得多，这是英特尔为自己开发的。该算法使用**受信任的执行环境**（**TEE**），例如**软件保护扩展**（**SGX**），以确保区块以随机抽签的方式产生，而无需进行任何工作，而不是让参与者解决密码难题。这种方法基于
    TEE 提供的保证的时间速率。据英特尔称，PoET 算法可扩展到数千个节点，并且将在任何支持 SGX 的英特尔处理器上有效运行。PoET 的一个主要缺点是始终需要信任英特尔，而从对第三方的信任转向对公共区块链的基本原因。该算法可以被看作是另一种替代方法。
- en: Comparison between PoW, PoS, and PoET
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PoW、PoS 和 PoET 的比较
- en: 'We will now compare the three consensus algorithms that we have seen for a
    better understanding, and weigh them against certain parameters. The following
    table shows the state of respective consensus algorithms for each parameter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将比较我们已经看到的三种共识算法，以便更好地理解，并根据某些参数权衡它们。以下表格显示了各个参数下各个共识算法的状态：
- en: '| **Parameters** | **PoW** | **PoS** | **PoET** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **PoW** | **PoS** | **PoET** |'
- en: '| Blockchain type | Permissionless | Both | Both |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 区块链类型 | 无许可 | 两者 | 两者 |'
- en: '| Transaction finality | Probabilistic | Probabilistic | Probabilistic |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 交易终态 | 概率性 | 概率性 | 概率性 |'
- en: '| Transaction rate | Low | High | Medium |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 交易速率 | 低 | 高 | 中等 |'
- en: '| Token needed | Yes | Yes | No |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 需要代币 | 是 | 是 | 否 |'
- en: '| Cost of participation | Yes | Yes | No |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 参与成本 | 是 | 是 | 否 |'
- en: '| Scalability of peer network | High | High | High |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 对等网络的可扩展性 | 高 | 高 | 高 |'
- en: '| Trust model | Untrusted | Untrusted | Untrusted |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 信任模型 | 不受信任 | 不受信任 | 不受信任 |'
- en: 'Now, let''s discuss the preceding table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论上述表格：
- en: '**Blockchain type**: This indicates the type of blockchain platform, permission
    or permissionless, in which the consensus model can be used. This is mainly governed
    by the type of membership allowed by the consensus model. While PoW models are
    built exclusively for the permissionless platform with open-ended participation,
    they can technically be used with permission platforms but won''t be ideal in
    that setting. PoS and PoET, by design, can work in both function types.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块链类型**：这表明共识模型可以在其中使用的区块链平台的类型，是许可还是无许可，这主要受共识模型允许的成员类型的限制。虽然PoW模型专门为无许可平台设计，参与是开放的，但它们在技术上可以用于许可平台，但在那种情况下不是理想的。而PoS和PoET则可以根据设计，在两种功能类型中工作。'
- en: '**Transaction finality**: This indicates whether the transaction, once added
    to a block in the blockchain, is considered final. PoW- and PoET-based consensus
    models carry the risk of multiple blocks being mined at the same time due to their
    model of leader relationship in combination with network latency.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易终态**：这指示了一旦交易添加到区块链中的区块中，是否被视为最终。基于PoW和PoET的共识模型由于其领导关系模型与网络延迟的结合而存在多个区块同时被挖掘的风险。'
- en: '**Transaction rate**: Platforms that can confirm transactions immediately and
    reach a consensus quickly have a higher transaction rate. PoW approaches are probabilistic
    and have to spend a significant amount of time-solving a cryptographic puzzle.
    Therefore, these models have high transactional latencies, hence a low transaction
    rate.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易速率**：能够立即确认交易并迅速达成共识的平台具有更高的交易速率。PoW方法是概率性的，并且需要花费大量时间来解决加密难题。因此，这些模型具有高交易延迟，因此交易速率低。'
- en: '**Token needed**: As the designs are based on the existence of a token, a cryptographic
    token is inherently required for PoW and PoS models, whereas PoET models do not
    require a token for a consensus to be achieved.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要代币**：由于设计基于代币的存在，对于PoW和PoS模型，本质上需要一个加密代币才能达成共识，而PoET模型不需要代币来实现共识。'
- en: '**Cost of participation:** There are inherent costs associated for PoW and
    PoS to participate in a consensus. To develop the security deposit to declare
    interest and bond with the platform, PoW requires expending energy, which is a
    resource that is external to the consensus protocol, while PoS requires nodes
    to buy some initial cryptocurrency.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参与成本**：PoW和PoS参与共识都有固有成本。为了开发安全存款以声明利息并与平台结合，PoW需要消耗能量，这是共识协议外部的资源，而PoS需要节点购买一些初始加密货币。'
- en: '**Scalability of peer network**: The scalability of the consensus model is
    its ability to reach consensus when the number of peer nodes is constantly increasing.
    All models summarized previously have high scalability.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对等网络的可扩展性**：共识模型的可扩展性是指在对等节点数量不断增加时达成共识的能力。之前总结的所有模型都具有很高的可扩展性。'
- en: '**Trust model**: This determines whether the nodes participating in the consensus
    have to be known or trusted. In PoW, PoS, and PoET, nodes can be untrusted as
    the mechanism to reach consensus is based on other means, such as computational
    work or security deposits. As long as more than 25 to 50% of the network is not
    adversarial, consensus decisions will not be effective.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信任模型**：这决定了参与共识的节点是否必须被认识或信任。在PoW、PoS和PoET中，节点可以是不受信任的，因为达成共识的机制基于其他手段，例如计算工作或安全存款。只要网络中超过25%到50%的节点不是敌对的，共识决策就不会有效。'
- en: 'There is one more parameter that is not listed here, which is **adversary tolerance**:
    that is the fraction of the network that can be compromised without the consensus
    being affected. Each consensus model has a certain threshold or true adversary
    tolerance.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个未在此处列出的参数，即**对手容忍度**：这是可以被破坏而不影响共识的网络的一部分。每个共识模型都有一定的阈值或真正的对手容忍度。
- en: Key privacy challenges of the blockchain
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链的主要隐私挑战
- en: Let's take a look at some general challenges regarding privacy in blockchain
    and the solutions to overcome those challenges. Eric Hughes, cofounder of the
    Cyberpunk Movement, UC Berkeley, and a well-known mathematician, said in 1993
    that privacy in an open society requires anonymous transaction systems. Until
    now, cash has been the primary system. An anonymous system empowers individuals
    to reveal their identity when desired, and only when desired. But, is this the
    case with Bitcoin and public blockchain? There is a popular delusion that Bitcoin
    is anonymous and untraceable. It's an understandable mistake, given Bitcoin's
    popular use case, which was the infamous Silk Road we covered in earlier chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看关于区块链隐私的一些一般性挑战以及克服这些挑战的解决方案。加州大学伯克利分校的网络朋克运动联合创始人、著名数学家埃里克·休斯于 1993 年表示，开放社会的隐私需要匿名交易系统。到目前为止，现金一直是主要的系统。一个匿名系统赋予个人在需要时，仅在需要时，揭示其身份的能力。但是，比特币和公开的区块链是这样的情况吗？有一个流行的错觉认为比特币是匿名且不可追踪的。这是一个可以理解的错误，考虑到比特币的流行用例，即我们在前面章节中介绍的臭名昭著的丝绸之路。
- en: 'The FBI was able to trace and expose people involved in this case with the
    help of immutability in the Bitcoin blockchain. However, we must not ignore that
    they were able to trace the flow of currency and single out the exact person they
    sought. The truth is that Bitcoin is indeed pseudonymous and traceable. Every
    transaction in Bitcoin maps the inputs to the outputs, allowing anyone to follow
    the money in a very trivial manner. Satoshi Nakamoto in his white paper defined
    Bitcoin as a history of its custody. In 2009, he stated the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: FBI 能够利用比特币区块链中的不可变性追踪和揭露与此案件有关的人员。然而，我们不能忽视的是，他们能够追踪货币流动并单独找出他们所寻找的确切人物。事实是，比特币确实是伪匿名和可追踪的。比特币中的每笔交易都将输入映射到输出，允许任何人以非常琐碎的方式跟踪货币。在他的白皮书中，中本聪将比特币定义为其监护历史。在
    2009 年，他说：
- en: '*"We define an electronic coin as a chain of digital signatures."*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*"我们将电子硬币定义为数字签名的链。"*'
- en: Pseudonymous behavior of Bitcoin
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币的伪匿名行为
- en: Pseudonymity is when we arrive at a relationship with some entity without disclosing
    the individual identity of that entity. A pseudonym refers to a unique alternative
    identifier, such as the nickname of a person, credit card number, student number
    from college, and bank account number. Using a pseudonym, you can tag various
    messages and transactions from the same entity by making a group of these transactions.
    Pseudonyms are widely used in social networks and other virtual communication
    channels. For example, any customer care representative introduces himself or
    herself with a pseudonym, instead of revealing their original name; this is pseudonymity.
    Twitter handles and Facebook accounts, for example, are classic examples of pseudonyms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与某个实体建立关系时而不透露该实体的个人身份时，我们就处于化名状态。化名指的是一种唯一的替代标识符，例如一个人的昵称、信用卡号、大学的学生号码和银行账户号码。使用化名，你可以通过组成这些交易的一个群组来标记来自同一实体的各种消息和交易。化名在社交网络和其他虚拟通信渠道中被广泛使用。例如，任何客户服务代表都会用一个化名来介绍自己，而不是透露他们的原始姓名；这就是化名。Twitter
    的用户名和 Facebook 账户，例如，就是化名的经典例子。
- en: 'We must remember that while using pseudonymity, one cannot be identified but
    can still be singled out, and that''s what poses a challenge in privacy for blockchain. Let''s
    take a look at the following challenges:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用化名时，我们必须记住一个人虽然不能被识别，但仍然可以被单独指出，这就是区块链隐私面临的挑战。让我们来看看以下挑战：
- en: '**Public blockchain ledger**: Since the public blockchain ledger is available
    for anyone, some addresses can be grouped by their ownership, using behavioral
    patterns and publicly available information from outside blockchain sources.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开的区块链账本**：由于公开的区块链账本对任何人都是可用的，一些地址可以通过它们的所有权进行分组，利用行为模式和来自区块链外部的公开可用信息。'
- en: '**Wallet address**: The wallet address reuse links your transactions together
    into a single profile.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**钱包地址**：钱包地址的重复使用会将您的交易链接成一个单一的档案。'
- en: '**IP address reuse**: IP address reuse also hints to the world that a single
    party, such as you or me, controls various addresses.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP地址重用**：IP地址重用也暗示着一个单一方，比如你或我，控制着各种地址。'
- en: '**Combining inputs from multiple transactions**: This reveals the set of addresses
    you control.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将来自多个交易的输入合并**：这会显示你控制的地址集。'
- en: '**Using lite clients**:If you''re using lite clients, not really strictly written
    clients, these are effectively revealing to a third-party your full set of addresses
    and whatnot.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用轻量级客户端**：如果你使用的是轻量级客户端，而不是严格编写的客户端，这实际上向第三方揭示了你的所有地址集以及其他信息。'
- en: Bitcoin addresses clustering as another famous technology stack, which poses
    a challenge for deanonymizing  Bitcoin address users. It does so while addressing
    all addresses generated by a single user, via analysis of information derived
    from the blockchain. It can then be observed that the P2P network represents other
    information sources that aid in the deanonymization of Bitcoin users. Combining
    these two together can easily assist Bitcoin address clustering and help in identifying
    individuals. In some cases, it can also help in correlating all transactions of
    the file user. At the same time, there are many companies in the world today that
    are building businesses around blockchain. As the network increases, these companies
    gain a lot of importance because incentives to track the flow of such capital
    becomes stronger.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币地址聚类作为另一个著名的技术堆栈，这给比特币地址用户去匿名化提出了挑战。它通过分析来自区块链的信息来解决由单个用户生成的所有地址问题。可以看到P2P网络代表了其他信息源，有助于去匿名化比特币用户。将这两者结合起来可以轻松辅助比特币地址聚类，并有助于识别个人。在某些情况下，它还可以帮助相关联文件用户的所有交易。与此同时，今天世界上有许多公司都正在围绕区块链建立业务。随着网络的增长，这些公司变得非常重要，因为追踪这种资本流动的动机变得更强烈。
- en: Solutions to privacy challenges
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐私挑战的解决方案
- en: Let's look at some of the solutions that can help deal with the privacy challenges
    posed by public blockchain.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可以帮助应对公共区块链所提出的隐私挑战的解决方案。
- en: CoinJoin
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoinJoin
- en: CoinJoin is an anonymization method for Bitcoin transactions proposed by Gregory
    Maxwell. It is a method of Bitcoin transaction compression, which aims to improve
    privacy by discarding unnecessary information. A CoinJoin transaction is one where
    multiple people agree to form a single transaction where some of the outputs have
    the same value. All parties come together over some anonymous channel and each
    of them provides a destination address, which belongs to them. One of the party
    creates a transaction, which sends one coin to each destination address. All parties
    log out and then separately log in to the channel, and each contributes one coin
    to the account from which the funds will be paid out. If `X` number of coins is
    paid into the account, they are distributed to the destination addresses; otherwise,
    they are refunded. Some popular examples of CoinJoin implementations are SharedCoins,
    Dark Wallets, CoinShuffle, and Dash.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CoinJoin是由Gregory Maxwell提出的比特币交易匿名化方法。这是一种比特币交易压缩方法，旨在通过丢弃不必要的信息来提高隐私性。CoinJoin交易是多人同意形成一笔交易的一种交易，其中一些输出具有相同的价值。所有参与者通过某个匿名通道相聚在一起，每个人提供一个属于自己的目的地址。其中一方创建一笔交易，将一枚硬币发送到每个目的地址。所有参与者退出，然后分别登录到通道，并每人从将支付资金的帐户中贡献一枚硬币。如果支付了`X`个硬币到该账户，它们将分配给目的地址；否则将退款。一些流行的CoinJoin实现示例包括SharedCoins、Dark
    Wallets、CoinShuffle和Dash。
- en: Ring signatures
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环签名
- en: Ring signatures are a technically complicated technology but are extremely promising
    and help to achieve token anonymization and to identify applications. Essentially,
    a ring signature is something that proves that the signer has a private key corresponding
    to one of a specific set of public keys, but does not reveal which one it is.
    It is composed of the actual signer, who is then combined with the nonsigner to
    form a ring. The actual signer and nonsigner in this ring are both considered
    to be equal and valid. The actual signer is a one-time use key thing that corresponds
    with an output being sent from the sender's wallet. The nonsigners are outputs
    from past transactions that are drawn from the blockchain. These past transaction
    outputs function as a decoy in the ring signature transaction by forming part
    of the input of a transaction. All the inputs appear equally as likely to be the
    output being spent in a transaction from outside the ring.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 环签名是一种技术上复杂的技术，但非常有前景，并有助于实现代币匿名化和识别应用程序。基本上，环签名是证明签署者拥有与一组特定的公钥之一对应的私钥的东西，但不会透露具体是哪一个。它由实际签署者组成，然后与非签署者结合形成一个环。在这个环中，实际签署者和非签署者都被视为相等和有效。实际签署者是与从发送者钱包发送的输出相对应的一次性使用密钥事物。这些非签署者是从区块链中提取的过去交易的输出。这些过去的交易输出在环签名交易中充当诱饵，成为交易的输入的一部分。所有的输入看起来都同样可能是从环外花费的输出。
- en: For example, if Dan wishes to send one Monero to Melissa with a ring size value
    of five, one of the five inputs will be pulled from Dan's wallet, which will then
    be added to the ring signature transaction. The other four inputs are past transaction
    outputs that are pulled from the blockchain. These four inputs are decoys and,
    when fused with the input from Dan's wallet, form a group of five possible signers,
    making a ring of those five. A third party would not be able to determine which
    input was actually signed by Dan's one-time use key. However, with the use of
    a key image, the network is able to verify that the asset or coin being transferred
    to Melissa has not been spent before. Monero is the best example that uses the
    ring signature mechanism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果丹希望向梅丽莎发送一个环签名值为五的门罗币，那么五个输入中的一个将从丹的钱包中提取，然后添加到环签名交易中。另外四个输入是从区块链中提取的过去交易的输出。这四个输入是诱饵，与来自丹钱包的输入合并后，形成一个包含五个可能签署者的组，构成这五个人的一个环。第三方将无法确定哪个输入实际上由丹的一次性使用密钥签署。然而，通过使用一个密钥图像，网络能够验证向梅丽莎转移的资产或货币以前没有花费过。门罗币是使用环签名机制的最佳例子。
- en: Zero-knowledge proof
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零知识证明
- en: Another technology that has very powerful properties to solve privacy challenges
    is **zero-knowledge proof** (**ZKP**). ZKP allows a user to construct a mathematical
    proof so that, when a program is executed on some hidden input known only to that
    user, it has a particular publicly known output, but without revealing any other
    information beyond this. **Zero-Knowledge Succinct Non-Interactive Argument of
    Knowledge** (**Zk-SNARKS**) is an even stronger technology in the ZKP protocol.
    It is proof that something is true without revealing anything about what specifically
    makes it true. Zcash is the first ever cryptocurrency that maintains total anonymity.
    It uses a Zk-SNARKS cryptography implementation. It provides complete anonymity
    by hiding all knowledge about the transactions. It provides users with a private
    access control of their specific financial information. It also uses a concept
    called a **view key**. Users can provide this view key to individuals to get details
    of the transaction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项具有非常强大属性以解决隐私挑战的技术是**零知识证明**（**ZKP**）。ZKP允许用户构建一个数学证明，以便当程序在仅用户知道的某个隐藏输入上执行时，它具有特定的公开已知输出，但不会透露任何其他信息。**零知识简明非交互性知识论证**（**Zk-SNARKS**）是ZKP协议中更强大的技术。这证明了某些事情是真实的，而不透露使其成为真实的特定内容。Zcash是第一个保持完全匿名的加密货币。它使用了Zk-SNARKS密码学实现。它通过隐藏所有有关交易的知识提供完全匿名性。它为用户提供了对其特定财务信息的私人访问控制。它还使用了一个称为**视图密钥**的概念。用户可以向个人提供此视图密钥以获取交易的详细信息。
- en: Smart contracts and decentralized applications
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约和去中心化应用
- en: We discussed Bitcoin and blockchain in earlier chapters, and how this entire
    technology is the next big innovation after the internet. Besides all the unique
    features of the blockchain, such as immutability, cryptography, and security,
    smart contracts make blockchain an even more innovative technology. Besides the
    P2P network and private key cryptography, blockchain program is something that
    governs the execution of money flow in a programmatic manner. These programs are
    a kind of smart contract that remains at the core of blockchain. If you look at
    a typical standard contract agreement between two parties, it basically dictates
    the terms of a relationship, where these terms or relationships are then usually
    enforced by legal entities. On the other hand, smart contracts enforce their relationships
    with smart code written using cryptographic techniques. In simple words, smart
    contracts are programs that execute themselves exactly in the way written by their
    creators or programmers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期章节讨论了比特币和区块链，以及这整个技术是继互联网之后的下一个大创新。除了区块链的所有独特特性，如不可变性、密码学和安全性，智能合约使区块链成为更具创新性的技术。除了P2P网络和私钥密码学，区块链程序是能够以程序化方式控制货币流动的东西。这些程序是区块链核心的一种智能合约。如果你看看两个当事方之间的典型标准合同协议，它基本上规定了关系的条款，这些条款或关系通常是由法律实体强制执行的。另一方面，智能合约通过使用密码技术编写的智能代码来强制执行它们的关系。简单地说，智能合约是由它们的创建者或程序员编写的能够自我执行的程序。
- en: This concept was first conceptualized in 1993 by Nick Szabo, a famous computer
    scientist and cryptographer. He made the analogy of a digital vending machine
    and explained how users could input anything, such as data or a value, and receive
    a specific item, similar to a real-world snack or soft drink that we could get
    from a vending machine. In the case of blockchain, the user would create a smart
    contract by writing a program and pushing the data to that contract so that it
    could execute the desired command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念最初是由尼克·萨保（Nick Szabo），一位著名的计算机科学家和密码学家于1993年首次概念化的。他用数字自动售货机做类比，解释了用户如何输入任何东西，如数据或价值，然后得到一个特定的物品，类似于我们从自动售货机中获得的真实零食或软饮料。在区块链的情况下，用户将通过编写程序创建智能合约，并将数据推送到该合约中，以便它执行所需的命令。
- en: Understanding smart contracts
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解智能合约
- en: Smart contracts are at the core of blockchain technology. These are programs
    written in Turing-complete programming languages and are capable of self-verifying
    and self-executing agreements that can function autonomously or without any external
    intervention. In layman's terms, if we consider Bitcoin as digital money, a smart
    contract is highly programmable digital money. A smart contract is a piece of
    code that is stored in the blockchain, is triggered by the blockchain transactions,
    and which then reads or writes data from/to that blockchain's database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是区块链技术的核心。这些程序是用图灵完备的编程语言编写的，并且能够自我验证和自我执行协议，可以独立或无需任何外部干预而运行。通俗地说，如果我们将比特币视为数字货币，智能合约就是高度可编程的数字货币。智能合约是存储在区块链中的一段代码，它由区块链交易触发，并从该区块链的数据库中读取或写入数据。
- en: The network of nodes will only validate transactions if certain conditions are
    met, but Bitcoin is limited to dealing only with the currency use case. But, what
    about many nonfinancial use cases or even financial use cases where money is not
    a center point but is involved at the triggering point? Ethereum, one more variant
    of blockchain that was forked from Bitcoin and modified further, replaced Bitcoin's
    restricted language with a Turing-complete, more robust language that allows for
    the writing of extensive smart contracts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 节点网络只有在满足一定条件时才会验证交易，但比特币仅限于处理货币使用情况。但是，对于许多非金融用途案例甚至金融用例中，货币并不是中心点而是涉及到触发点的情况怎么样呢？以太坊，区块链的另一个变体，是从比特币分叉并进一步修改而来，用图灵完备的更强大的语言取代了比特币限制的语言，可以编写更广泛的智能合约。
- en: Workings of smart contracts
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约的工作原理
- en: 'Now, let''s look briefly at the following factors and conditions that trigger
    the working of a smart contract:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看看以下触发智能合约工作的因素和条件：
- en: '**Agreement**: An option contract between two or more parties is written, coded,
    and deployed on the blockchain platform. The individual parties involved can remain
    anonymous, but the contract is written in the public ledger and remains unchanged.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：两个或多个方之间的期权合同被编写、编码并部署在区块链平台上。参与的各方可以保持匿名，但合同被写入公共账本并保持不变。'
- en: '**The triggering or execution point**: Any triggering event, be it within the
    blockchain or outside of the blockchain, gets the contract into execution according
    to the coded terms. A triggering event, for example, could be an expiration date
    or a renewal date of a contract, a particular price being hit on an exchange,
    or some cut-off rate being reached on our system.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发或执行点**：任何触发事件，无论是在区块链内还是在区块链外，都会根据编码的条款使合同执行。例如，触发事件可以是合同的到期日或续约日期，在交易所达到特定价格，或者在我们的系统中达到某个截止率。'
- en: '**Outcome**: The execution of a smart contract can produce an outcome that
    will change the state of a transaction, or the state of the blockchain for that
    matter, for example, a cash ledger. It may also impact on other systems as well.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：智能合同的执行可能产生会改变交易状态或区块链状态的结果，例如现金分类账。它也可能影响其他系统。'
- en: '**Transparency**: This is another important aspect of contracts. These contracts
    are immutably available on the blockchain. Regulators can use these on blockchain
    to understand the activity of the market while maintaining the privacy of the
    individual parties involved.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明度**：这是合同的另一个重要方面。这些合同在区块链上是不可变的。监管机构可以利用区块链上的这些合同来了解市场活动，同时保持涉及的个人方的隐私。'
- en: 'Now, let''s look at an example of writing a contract. The following are the
    steps to follow to start:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个编写合同的例子。以下是开始的步骤：
- en: Create a new file and name it `sample.sol`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并命名为`sample.sol`。
- en: 'Next, open the file to begin writing the code, as shown in the following screenshot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开文件开始编写代码，如下截图所示：
- en: '![](img/8e3c48b3-5fe7-4be3-ab89-75fdd6668d09.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e3c48b3-5fe7-4be3-ab89-75fdd6668d09.png)'
- en: B11516_3_03
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: B11516_3_03
- en: 'Let''s see the steps covered in the preceding code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前述代码中涉及的步骤：
- en: First, let's declare the version of Solidity we'll use, which is `pragma solidity^0.4.17`.
    This allows the Ethereum platform to compile the contract in a specific version.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们声明我们将使用的Solidity版本，即`pragma solidity^0.4.17`。这允许以太坊平台在特定版本中编译合同。
- en: Then, let's declare a contract and name it `Welcome`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们声明一个合同并命名为`Welcome`。
- en: Next, let's declare two instance table variables in this contract. One is the `contractOwner` address.
    This will capture the address or the account of the owner of this contract, who
    is going to deploy the contract on the Solidity platform.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在这个合同中声明两个实例表变量。一个是`contractOwner`地址。这将捕获部署合同在Solidity平台上的合同所有者的地址或帐户。
- en: Next, we declare a `greetMsg` string, which we capture from the contract's owner.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个`greetMsg`字符串，它是从合同的所有者那里获取的。
- en: Now, we declare a `Welcome` function. Whenever the contract gets deployed on
    the Ethereum platform, this instance or function gets called publicly.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们声明一个`Welcome`函数。每当合同在以太坊平台上部署时，此实例或函数将被公开调用。
- en: Next, we pass the `_greetMsg` string in this function. We will also make this
    a public contract.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在此函数中传递`_greetMsg`字符串。我们还将此函数设置为公共合同。
- en: Next, we assign the `contractOwner` variable its value: `contractOwner = msg.sender`.
    So, whoever has called this function will actually be the message owner, who has
    a right to create this contract.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为`contractOwner`变量分配其值：`contractOwner = msg.sender`。因此，无论谁调用了此函数实际上都是消息所有者，有权创建此合同。
- en: Likewise, we also assign the value of `greetMsg` as `greetMsg = _greetMsg`.
    So, what we have done here is we have created a  constructor function called `Welcome`,
    which gets called when the contract gets deployed on the Ethereum platform.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也将`greetMsg`的值设置为`greetMsg = _greetMsg`。所以，我们在这里做的是创建了一个名为`Welcome`的构造函数，在合同在以太坊平台上部署时调用。
- en: Then, we declare one more function called `sendGreeting()`, which will return
    a string-type variable, `greetMsg`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明了另一个名为`sendGreeting()`的函数，它将返回一个字符串类型的变量`greetMsg`。
- en: To see one more function, let's convert `public returns(string)` to a void view
    function by adding the `public view returns(string)` view.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看另一个函数，让我们通过添加`public view returns(string)`将`public returns(string)`转换为无效视图函数。
- en: We can slightly tweak this function to become a condition: `if message.sender
    == contractOwner`. This will return `Hello Mr. Owner why you need to be greeted!` to
    the owner, or else it will return `greetMsg`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以稍微调整这个函数成为一个条件：`if message.sender == contractOwner`。这将返回`Hello Mr. Owner
    why you need to be greeted!`给所有者，否则将返回`greetMsg`。
- en: Again, we will declare one more public function called `killContract()`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将声明一个名为`killContract()`的公共函数。
- en: Then, we give a condition, `if message.sender == contract Owner`, and assign
    a task, `selfdestruct(this)`. So, unless the owner of the contract calls this
    kill contract function, it will disturb the contract from the Ethereum platform.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们给出一个条件，`if message.sender == contract Owner`，并分配一个任务，`selfdestruct(this)`。因此，除非合同所有者调用此终止合同函数，否则它将扰乱以太坊平台上的合同。
- en: This is very important so you can decide the conditions in which you want to
    resolve the contract from the platform. So, there you can have a time-bound contract
    being created there.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常重要，因此您可以决定您希望在哪些条件下解决合同从平台中删除。因此，您可以在那里创建一个有时限的合同。
- en: So, that was an example of how you write detailed smart contracts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个详细编写智能合约的例子。
- en: Decentralized applications
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化应用程序
- en: Since its inception, the application of the blockchain has already increased
    a lot of expectations from every industry and it also promises to be more prevalent
    in most innovative technologies. It has a lot to offer in terms of immutability,
    security, cryptography, distributed ledgers, and so on. We should not ignore the
    fact that blockchain can solve specific issues with immutability, transparency,
    anonymity, and security. However, it has its own challenges as well, for example,
    the speed of a consensus required, the time required to arrive at a consensus,
    and the replication time across the public ledger.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自诞生以来，区块链的应用已经引起了各行业的很多期待，并且承诺在大多数创新技术中更加普遍。它在不可变性，安全性，密码学，分布式分类账等方面都有很多提供。我们不应忽视区块链可以解决不可变性、透明性、匿名性和安全性方面的特定问题。然而，它也有自身的挑战，例如所需共识的速度，到达共识所需的时间以及在公共账本上的复制时间。
- en: Challenges and solutions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战和解决方案
- en: We have already covered decentralized applications in the previous chapter.
    Dapps are not owned by anyone, cannot be shut down, and cannot have downtime.
    So, whenever we want to build a Dapp, we need to keep some considerations in mind,
    such as that a Dapp has to be a completely open source and operate autonomously,
    with no entity in charge of the majority of its currency. It has to have protocol
    changes that are designed to make some overall improvements, approved by all users.
    It cryptographically stores all of its operations data in a public blockchain,
    and most importantly, it has to incentivize. You truly need to have a consensus among
    miners to arrive at a consensus. There has to be some motivation for miners at
    the same time. If the objective is just to use bring about decentralization, then
    there are many other ways to achieve it, such as BitTorrent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章已经涵盖了去中心化应用程序。Dapps 不归任何人所有，不能被关闭，也不能有宕机时间。所以，每当我们想要构建一个 Dapp 时，我们需要牢记一些考虑因素，比如
    Dapp 必须完全开源并且能够自主运行，没有一个实体负责大部分货币。它必须有协议更改，旨在进行一些整体改进，经所有用户批准。它以加密形式存储所有操作数据在公共区块链上，而且最重要的是它必须有激励机制。你真的需要矿工之间达成共识。同时矿工必须有动机。如果目标只是实现去中心化，那么也有许多其他方法可以实现，比如比特流。
- en: So, while blockchain is still evolving and there are many new things being derived,
    making it more and more mature, we as an entire community need to avoid abusing
    this technology by not using it everywhere. Rather, there has to be a thorough
    analysis of a technological, architectural, and design basis as to when and why
    to use blockchain as a solution to solve a problem. We must not think that it
    is a one-stop solution that fits all problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然区块链仍在不断发展，并且有许多新事物得出，使其变得越来越成熟，但作为整个社区，我们需要避免滥用这项技术，不要到处使用它。相反，需要对技术、架构和设计基础进行彻底分析，评估何时以及为什么使用区块链作为解决问题的解决方案。我们不能认为它是满足所有问题的一站式解决方案。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about some of the advanced concepts used in blockchain
    and covered various consensus protocols used in various blockchain implementations.
    We also looked at some of the key challenges to privacy on blockchain and how
    solutions such as ZKP can help safeguard privacy. Then, we progressed to discussing smart
    contracts, one of the core building blocks of blockchain; how they are written;
    what they are; and how they are executed. We also looked at Dapps, when to use
    them, and when not to use them. In the next chapter, we will look at some of the
    general practices used to safeguard Bitcoin and cryptocurrencies in general.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了区块链中使用的一些高级概念，并涵盖了各种区块链实现中使用的各种共识协议。我们还讨论了区块链隐私面临的一些关键挑战，以及诸如ZKP之类的解决方案如何帮助保护隐私。然后，我们进一步讨论了智能合约，这是区块链的核心构建模块之一；它们是如何编写的，是什么，以及它们如何执行。我们还讨论了Dapps，何时使用它们，以及何时不使用它们。在下一章中，我们将探讨一些通用的做法，用于保护比特币和加密货币。
