- en: Building a DApp for Digitizing Medical Records
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为数字化医疗记录构建 DApp
- en: The whole health industry is filled with a great many paper-based medical records,
    which is causing huge losses in terms of money, time, and lives. **Electronic
    Medical Records** (**EMRs**) are the solutions to many of the problems caused
    by paper records. There are many companies and researchers working on building
    EMR data management and sharing systems using blockchain technology. We will design
    a very different solution than the ones you will find on the internet, in the
    sense that those are focused only on anonymity, access control, security, and
    privacy, whereas our solution will also provide user experience and mass adoptability
    by enabling cross-application communication. While building the system, we will
    learn how to achieve privacy using **Proxy Re-Encryption** (**PRE**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 整个医疗行业都充斥着大量的纸质医疗记录，这导致了巨大的经济、时间和生命损失。电子医疗记录（EMRs）是纸质记录引起的许多问题的解决方案。有许多公司和研究人员正在利用区块链技术构建
    EMR 数据管理和共享系统。我们将设计一种与互联网上的解决方案非常不同的解决方案，因为那些解决方案仅专注于匿名性、访问控制、安全性和隐私，而我们的解决方案还将通过实现跨应用程序通信来提供用户体验和大规模采用。在构建系统时，我们将学习如何使用
    Proxy Re-Encryption（PRE）实现隐私。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: What a healthcare data management system is and what its functionalities are?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是医疗数据管理系统，以及它的功能是什么？
- en: The problems caused by paper medical records and the benefits of digitalized
    medical records
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纸质医疗记录引起的问题以及数字化医疗记录的好处
- en: The limitations of healthcare data management systems?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗数据管理系统的限制？
- en: The problems with building a centralized healthcare data management application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建集中式医疗数据管理应用程序的问题
- en: What PRE is and how it helps to achieve data privacy in a blockchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 PRE 以及它如何帮助实现区块链中的数据隐私
- en: How to architect a decentralized healthcare data management system that enables
    cross-application data sharing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计一个去中心化的医疗数据管理系统，实现跨应用程序的数据共享
- en: How to build smart contracts and tests for a healthcare data management, DApp,
    using Python and JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python和JavaScript为医疗数据管理的 DApp 构建智能合约和测试
- en: Introduction to EMRs data management and sharing systems
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 EMRs 数据管理和共享系统
- en: EMRs consist of critical, highly sensitive private information in healthcare,
    and need to be frequently shared among peers. EMR data management and sharing
    systems facilitate secure and trustable ways for different actors to read and
    write EMRs to the system. These systems should ensure privacy, security, availability,
    and fine-grained access control over EMR data. EMRs include prescriptions, lab
    reports, bills, and any other paper-based record that you can find in hospitals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 电子医疗记录（EMRs）包含了医疗保健领域中的关键、高度敏感的私人信息，并且需要在同行之间频繁共享。EMR 数据管理和共享系统促进了不同参与者以安全可信的方式读取和写入
    EMR 到系统中。这些系统应确保 EMR 数据的隐私、安全、可用性和细粒度的访问控制。EMRs 包括处方、实验室报告、账单以及在医院中找到的任何其他纸质记录。
- en: In general, an EMR data management and sharing system allow doctors to issue
    digital prescriptions, pharmacies to pull prescriptions based on a patient's identity,
    labs to issue digital reports, patients to see all their records and share them
    with others, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，EMR 数据管理和共享系统允许医生开具数字处方，药店根据患者身份提取处方，实验室发出数字报告，患者查看所有记录并与他人共享等。
- en: Problems with paper-based medical records
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纸质医疗记录存在的问题
- en: Medical records need to be distributed and shared among peers, such as healthcare
    providers, insurance companies, pharmacies, researchers, and patients' families,
    which is a challenge in itself. Even after sharing, these records need to be constantly
    updated during the treatment process. It's also easier to lose or misplace paper
    records. When someone is suffering from a serious medical condition, such as cancer
    or HIV, they have to maintain a long history of records as this is crucial for
    the treatment. With paper records, it's cumbersome to maintain a long history
    of records.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 医疗记录需要在医疗过程中分发和共享给同行，如医疗服务提供者、保险公司、药店、研究人员和患者家属，这本身就是一个挑战。即使在共享后，这些记录在治疗过程中也需要不断更新。纸质记录也更容易丢失或放错位置。当有人患有严重的医疗状况，如癌症或艾滋病时，他们必须维护长时间的记录，因为这对治疗至关重要。使用纸质记录时，维护长时间的记录很麻烦。
- en: In addition, forged health records are submitted to insurance companies, resulting
    in huge financial losses to the insurance companies. Many times, doctors and labs
    also issue fake prescriptions and records to patients with patients' consent.
    For example, universities require students to pass several tests before being
    admitted, and sometimes students try to get fake reports without going through
    the tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，伪造的健康记录被提交给保险公司，导致保险公司巨大的财务损失。很多时候，医生和实验室也会在患者的同意下发布虚假处方和记录。例如，大学要求学生通过几项测试才能被录取，有时学生会试图获取假报告而不参加测试。
- en: Many patients don't buy their medication, and there is no way to track whether
    a patient has consumed the necessary medicines. This results in harm being done
    to the patient's quality of life and an increased cost to the healthcare system.
    If a patient is visiting different doctors, then there is a huge chance of harmful
    side effects due to different types of medicines recommended by different doctors. If
    an individual has multiple doctors treating them, then there is no way for these
    doctors to work together on the patient's medicine management plan, therefore
    making it impossible to streamline the entire process for all involved parties.
    Because of a patient's failure to present their past records, tests related to
    allergies due to particular chemicals or substances need to be done again and
    again when visiting different clinics, which is not needed if the patient's medical
    history is maintained.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多患者不购买自己的药物，也没有办法追踪患者是否服用了必要的药物。这导致患者生活质量受损，医疗系统成本增加。如果患者去不同的医生那里就诊，那么由于不同医生推荐不同类型的药物，患者出现有害副作用的可能性很大。如果一个人有多个医生为其治疗，那么这些医生就无法共同制定患者的药物管理计划，因此无法为所有相关方简化整个流程。由于患者未能提供他们的过去记录，当他们在不同的诊所就诊时，需要再次进行与特定化学品或物质相关的过敏测试，如果患者的医疗史得以保持，则无需进行此类测试。
- en: Bad handwriting in prescriptionscan also create a risk of medication errors.
    Also, due to oral communication between doctors when there is remote communication,
    there is a huge chance of medication errors. Also, due to a prescriber's insufficient knowledge
    of the desired dosage of a drug, or undesired interactions between multiple drugs.
    There is also no way to implement warning and alert systems in paper prescriptions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处方中的潦草字迹也可能导致用药错误的风险。此外，由于远程通信时医生之间的口头交流，用药错误的可能性很大。此外，由于开具处方者对药物的期望剂量或多种药物之间的不良相互作用了解不足，也没有办法在纸质处方中实施警告和警报系统。
- en: It's difficult for research companies to collect and structure medical records
    for research purposes. There is no way to renew a prescription after finishing
    medicines, so the patient will need a doctor again, which is a cumbersome process.
    Paper subscriptions have failed to enable purchase medicines online, but digital
    subscriptions can open the door for online medicine delivery as prescriptions
    can be verified online.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于研究公司来说，收集和整理医疗记录用于研究目的是困难的。用药结束后无法续开处方，因此患者需要再次看医生，这是一个繁琐的过程。纸质处方无法实现在线购买药物，但数字化处方可以为在线药物配送打开大门，因为处方可以在线验证。
- en: An EMR data management and sharing system should aim to solve a few or all of
    the previous problems. For example, in the case of prescription renewal, the first
    step is to digitize the prescription. Then, on the patient's request, pharmacy
    staff can generate a renewal request that is delivered to the prescriber. The
    prescriber can then review the request and act accordingly by approving or denying
    the request. With limited resource utilization and just a few clicks from the
    prescriber, they can complete a medication renewal task while enhancing continuous
    patient documentation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 电子医疗记录（EMR）数据管理和共享系统应旨在解决之前的一些或所有问题。例如，在处方续开的情况下，第一步是数字化处方。然后，在患者的请求下，药房工作人员可以生成一个续开请求，该请求将被送达给开具处方的人员。开具处方的人员随后可以审查请求，并根据情况批准或拒绝请求。通过有限的资源利用和从开具处方者那里点击几下，他们就可以完成药物续开任务，同时增强持续的患者文档。
- en: The previous issues are just a few of the problems caused by paper-based records.
    But the whole healthcare industry is filled with a huge number of problems due
    to paper-based records. A solution should be designed in such a way that it solves
    these problems, and could be enhanced regularly to solve additional problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前述问题只是纸质记录带来的一些问题之一。但整个医疗保健行业充斥着大量由纸质记录引起的问题。解决方案应设计成能够解决这些问题，并且可以定期增强以解决额外的问题。
- en: Limitations of EMR data management and sharing systems
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子病历数据管理和共享系统的局限性
- en: 'Though an EMR data management and sharing system solves a lot of problems,
    it has some limitations that effect its adaptability and the trust that people
    place in it. The following are some of the limitations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管电子病历数据管理和共享系统解决了很多问题，但它也有一些限制，影响了它的适应性和人们对其的信任。以下是一些限制：
- en: '**Financial cost and return on investment**: The costs of purchasing, implementing,
    supporting, and maintaining such a system are unaffordable, especially for small
    hospitals and clinics. Even if they are given the system for free, there are other
    financial costs related to the management of the interface, customization for
    flexibility, training, maintenance, and upgrades.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**财务成本和投资回报**：购买、实施、支持和维护此类系统的成本是无法承受的，特别是对于小型医院和诊所来说。即使他们免费获得系统，也会有其他与界面管理、灵活性定制、培训、维护和升级相关的财务成本。'
- en: '**Upgrading the workforce**: Currently, the workforce is addicted to paper-based
    records. Training patients, doctors, pharmacies, hospitals, and so on to adopt
    the solution is a difficult and time-consuming task. Sometimes it may require
    changing the workforce. For example, when banks started implementing computers,
    transitioning from record-keeping books to digital records, a lot of people couldn''t
    understand and adopt it and therefore lost jobs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级员工队伍**：目前，员工沉迷于纸质记录。培训患者、医生、药店、医院等接受解决方案是一项困难且耗时的任务。有时可能需要改变员工队伍。例如，当银行开始实施计算机，从记账簿转向数字记录时，许多人无法理解和接受，因此失去了工作。'
- en: '**Integrity of data input**: Accidental data entry errors, such as selecting
    the wrong patient or clicking on the wrong choice in a menu of dosages, may occur.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据输入的完整性**：意外的数据输入错误，比如选择了错误的患者或在剂量菜单中点击了错误的选择，可能会发生。'
- en: '**Security and privacy**: This is one of the most important concerns. Health
    records need to be stored securely as eHealth databases are always a target of
    hackers. Health records contain very sensitive information, and leakage could
    result in catastrophe. Strong access control should be implemented and regular
    feedback should be taken. Without the patient''s consent, their records should
    not be shared with anyone.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全与隐私**：这是最重要的关注之一。健康记录需要安全存储，因为电子健康数据库始终是黑客攻击的目标。健康记录包含非常敏感的信息，泄露可能会导致灾难。应实施严格的访问控制，并定期征求反馈意见。在没有患者同意的情况下，他们的记录不应与任何人共享。'
- en: '**System downtime**: There are chances of regular system downtime due to network
    or hardware related issues. The inability to use the system is of great concern.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统停机时间**：由于网络或硬件相关问题，定期发生系统停机的可能性很高。无法使用系统是一个大问题。'
- en: '**Lost patient access**: In the event of a development beyond the control of
    the patient, such as a software malfunction in the healthcare provider''s office,
    the patient can no longer ask the care provider for a paper script to take to
    a pharmacy in order to obtain needed medicines. This leaves the patient at the
    mercy of technicians or other undiscoverable workers.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**患者丢失访问权**：在患者无法控制的情况下，比如医疗提供者办公室的软件故障，患者无法再向医疗提供者要求纸质处方以去药房购买所需的药物。这使患者完全依赖技术人员或其他不可发现的工作者。'
- en: Centralized versus decentralized EMR management systems
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中化与去中心化的电子病历管理系统
- en: Regardless of whether an EMR management system is centralized or decentralized,
    it has to be compliant with a health authority's laws. Because of the fact that
    it's sensitive public data, there should be a regulatory body to define the standards
    and dictate the rules of how the data is shared and stored. For example, the **Health
    Insurance Portability and Accountability Act** (**HIPAA**) of 1996 is United States
    legislation that provides data privacy and security provisions for safeguarding
    medical information. Similarly, different countries have different legislation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论EMR管理系统是集中式还是分散式，它都必须符合卫生当局的法律法规。由于这是敏感的公共数据，应该有一个监管机构来定义标准并规定数据的分享和存储规则。例如，1996年的《健康保险移植和责任法案》（HIPAA）是美国的一项立法，为保障医疗信息的数据隐私和安全提供了规定。同样，不同国家有不同的立法。
- en: To understand what the problem is with centralized EMR data management apps,
    let's take an example of the Google Health centralized service. The Google Health
    service allowed users to add their health records to the app either manually or
    by logging in to Google's partnered health service providers. Records stored in
    the app could include health conditions, medications, allergies, and lab results.
    Google Health used the information to provide the users with information on medical
    conditions and possible interactions between drugs, conditions, and allergies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解集中式EMR数据管理应用程序的问题，让我们以谷歌健康集中服务为例。谷歌健康服务允许用户手动添加他们的健康记录到应用中，或者通过登录到谷歌合作的健康服务提供者来添加。应用中存储的记录可能包括健康状况、药物、过敏以及实验室结果。谷歌健康利用这些信息为用户提供关于医疗状况、药物、状况和过敏之间可能的互动的信息。
- en: In 2011, Google announced it was retiring Google Health in January 1, 2012\.
    Data was available for download through to January 1, 2013\. The reason Google
    gave for abandoning the project was the lack of widespread adoption.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，谷歌宣布将于2012年1月1日停止谷歌健康服务。数据可通过下载方式获取直至2013年1月1日。谷歌放弃该项目的原因是缺乏普遍的接受程度。
- en: This shows that it's difficult for us to trust centralized apps as they can
    discontinue the service at any time. As a patient, this is a big concern as suddenly
    you have to look for a different option to manage your records. Even hospitals
    and other health service providers will have to change their system. Even if you
    wish to switch to a different app, migrating the data is not easy. Many Google
    Health customers moved to using Microsoft HealthVault, which was a competing service.
    Microsoft released a tool that let Google Health customers transfer their personal
    health information to a Microsoft HealthVault account. But what if Microsoft also
    stops their service? Therefore, centralized health applications built by private
    companies cannot be trusted and adopted.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们很难相信集中式应用程序，因为它们可以随时终止服务。作为患者，这是一个大问题，因为突然间你不得不寻找其他选项来管理你的记录。即使是医院和其他卫生服务提供者也将不得不改变他们的系统。即使你想转换到另一个应用，迁移数据也不容易。许多谷歌健康（Google
    Health）的客户转向使用微软健康宝库（Microsoft HealthVault），这是一个竞争性的服务。微软发布了一个工具，让谷歌健康的客户将他们的个人健康信息转移到微软健康宝库账户。但是如果微软也停止他们的服务呢？因此，私人公司开发的集中式卫生应用程序是不值得信赖和采用的。
- en: Because of  this, many governments have come up with their own centralized services.
    An example of this is the e-prescriptions service of Estonia. Government services
    can be trusted, and adoption is not a problem because of the fact that governments
    can make it compulsory for health service providers to use the service. They are
    the authority to mandate this. But the problem is that one app cannot solve all
    problems, provide the best set of features, have the best user experience, and
    so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多政府都推出了他们自己的集中服务。爱沙尼亚的电子处方服务就是一个例子。政府服务是可以信赖的，采用并不是问题，因为政府可以强制卫生服务提供者使用该服务。这是他们强制的权威。但问题是一个应用无法解决所有问题，提供最佳功能集，拥有最佳用户体验等等。
- en: Both government and private centralized apps have issues for example, in the
    event of a security breach, hackers could compromise all public records in centralized
    services. Also, what's the guarantee that the health records will not be modified
    or that certain records are not removed by the central server?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 政府和私人的集中式应用都存在问题，例如，在出现安全漏洞时，黑客可能危及集中服务中的所有公共记录。此外，有什么保证健康记录不会被修改，或者中央服务器不会删除某些记录呢？
- en: The preceding concerns mean that we need to design a decentralized system using
    a blockchain, where blockchain is used for EMR access control and identity management
    only, and where the EMRs reside in a centralized and distributed storage. All
    of the apps connected to this network can talk to each other and share data. Users
    can switch between the apps easily and the health authority will be able to regulate
    and monitor the network. For example, two different service provides can build
    different apps with different sets of features and user experiences, but users
    of the different apps can read/write to each app's EMRs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前述问题意味着我们需要设计一个使用区块链的分散系统，其中区块链仅用于EMR访问控制和身份管理，而EMR位于中央化和分布式存储中。连接到该网络的所有应用程序都可以相互通信并共享数据。用户可以轻松切换应用程序，卫生管理机构将能够监管和监控网络。例如，两个不同的服务提供商可以构建具有不同功能和用户体验集合的不同应用程序，但是不同应用程序的用户可以读取/写入每个应用程序的EMR。
- en: The health authority decides who joins the network and can provide healthcare
    apps. To join the network, the health authority can set a precheck list of standards
    and measures that the apps should meet in order to be able to join the network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 卫生管理机构决定谁可以加入网络并提供医疗应用程序。为了加入网络，卫生管理机构可以设定一个预先检查的标准和措施清单，应用程序必须符合这些标准和措施才能加入网络。
- en: Ensuring data privacy in a blockchain using PRE
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在区块链中使用PRE确保数据隐私
- en: Before getting any further and building our decentralized EMR data management
    and sharing system, let's learn about what PRE is. In our solution, we will be
    using PRE to ensure security and privacy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步进行并构建我们的分布式EMR数据管理和共享系统之前，让我们先了解一下PRE是什么。在我们的解决方案中，我们将使用PRE来确保安全和隐私。
- en: PRE is a set of algorithms that allows you to encrypt some text with your key
    and then alter the ciphertext so that it can be decrypted by another party without
    revealing your key. To alter the ciphertext, you need the other party's private
    or public key, based on whether you are using interactive or noninteractive PRE
    algorithms, respectively. Regardless of the algorithm, PRE involves generating
    a re-encrypt key, which is used to re-encrypt the data. The re-encrypt key is
    generated based on the owner's private key and the recipient's private or public
    key, based on the type of algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PRE是一组算法，允许您使用您的密钥对一些文本进行加密，然后更改密文，以便另一方可以解密，而不会透露您的密钥。要更改密文，您需要另一方的私钥或公钥，具体取决于您是使用交互式还是非交互式PRE算法。无论使用哪种算法，PRE都涉及生成重新加密密钥，该密钥用于重新加密数据。重新加密密钥是基于所有者的私钥和接收者的私钥或公钥生成的，具体取决于算法类型。
- en: In practice, PRE is used to store sensitive data on a third-party server and
    lets you decide who gets access to the data without revealing the actual data
    to the third-party server. PRE allows third parties (proxies) to alter a ciphertext
    that has been encrypted for one party so that it can be decrypted by another party.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，PRE用于在第三方服务器上存储敏感数据，并允许您决定谁可以访问数据，而不会向第三方服务器透露实际数据。PRE允许第三方（代理）更改已为一方加密的密文，以便另一方可以解密。
- en: Rather than naively sharing your private key with recipients (insecure) or encrypting
    the entire message *n *times for each recipient, PRE allows you to encrypt the
    data once and then delegate access to it based on the recipients' public keys.
    This removes the requirement for the data owner to be online (data can stored
    in a different server, which you don't have to manage) and also facilitates the 
    revocation of access (to block access, you can run PRE again to change your keys
    and then delete the old ciphertext).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与其简单地与接收方共享您的私钥（不安全）或者为每个接收方分别加密整个消息*n*次，PRE允许您仅加密数据一次，然后基于接收方的公钥委派对其进行访问。这消除了数据所有者必须在线的要求（数据可以存储在您不必管理的不同服务器上），并且还便于撤销访问权限（要阻止访问，您可以再次运行PRE来更改您的密钥，然后删除旧的密文）。
- en: The PRE algorithm that NuCypher PRE currently supports is BBS98\. BBS98 is based
    on elliptic curve cryptography. This library, by default, uses the secp256k1 curve.
    Note that the Ethereum accounts also use the same curve (secp256k1), so we can
    use the Ethereum account keys with NuCypher.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: NuCypher PRE当前支持的PRE算法是BBS98。BBS98基于椭圆曲线密码学。该库默认使用secp256k1曲线。请注意，以太坊帐户也使用相同的曲线（secp256k1），因此我们可以使用以太坊帐户密钥与NuCypher。
- en: Currently, the field of PRE is still under heavily researched and developed.
    There aren't many libraries available for PRE. You will find Java or Python-based
    libraries for interactive PRE, but for non-interactive—or symmetric key-based,
    you won't find any. Because of this limitation, we will adhere to a microservices
    architecture and move all proxy re-encrypted code to a Python-based microservice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，PRE 领域仍在积极研究和开发中。目前还没有多少用于 PRE 的库可用。你会发现基于 Java 或 Python 的交互式 PRE 库，但对于非交互式或基于对称密钥的，你找不到任何库。由于这个限制，我们将坚持使用微服务架构，并将所有代理重加密代码移至基于
    Python 的微服务。
- en: The NuCypher PRE library
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NuCypher PRE 库
- en: NuCypher is a company that has built a decentralized PRE as a service product
    called NuCypher **Key Management Service** (**KMS**). NuCypher KMS is a decentralized
    KMS, encryption, and access control service. It enables private data sharing between
    arbitrary numbers of participants in public networks, using PRE to delegate decryption
    rights in a way that cannot be achieved by traditional symmetric or public key
    encryption schemes. Native tokens are used to **incentivize network** participants
    to perform key management and access delegation/revocation operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NuCypher 是一家构建去中心化的 PRE 服务产品的公司，称为 NuCypher **密钥管理服务**（**KMS**）。NuCypher KMS
    是一种去中心化的 KMS、加密和访问控制服务。它使得在公共网络中任意数量的参与者之间进行私密数据共享成为可能，使用 PRE 来委托解密权限，这是传统的对称或公钥加密方案无法实现的。原生代币用于**激励网络**参与者执行密钥管理和访问委托/撤销操作。
- en: We won't be going through NuCypher KMS in depth or using it in this book. Instead,
    we will explore how to use the PRE library built by NuCypher. NuCypher provides
    PRE libraries for Python and Java, but we will only learn how to use the Python
    PRE library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究 NuCypher KMS，也不会在本书中使用它。相反，我们将探索如何使用 NuCypher 构建的 PRE 库。NuCypher 提供了
    Python 和 Java 的 PRE 库，但我们只会学习如何使用 Python PRE 库。
- en: NuCypher is not the only Python library available for PRE. There are a few others
    out there. For example, ZeroDB also provides a PRE library that supports the AFGH
    algorithm, which is a non-interactive PRE algorithm. You can find out more about
    it at:[ ](https://github.com/zerodb/zerodb-afgh-pre)[https://github.com/zerodb/zerodb-afgh-pre.](https://github.com/zerodb/zerodb-afgh-pre)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NuCypher 不是 PRE 的唯一 Python 库。还有其他一些库可用。例如，ZeroDB 也提供了一个支持 AFGH 算法的 PRE 库，这是一个非交互式
    PRE 算法。你可以在[这里](https://github.com/zerodb/zerodb-afgh-pre)了解更多信息。
- en: Installing the library
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装库
- en: 'This library requires `python3`, `libssl-dev`, and `libgmp-dev` as prerequisites.
    To install these on Ubuntu, run the following commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此库需要 `python3`、`libssl-dev` 和 `libgmp-dev` 作为先决条件。要在 Ubuntu 上安装这些，请运行以下命令：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the following commands on macOS:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上使用以下命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s install the PRE library. To install it, run the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装 PRE 库。要安装它，请运行以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the library
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库
- en: Let's see an example of how to use this library. This library supports only
    interactive algorithms; it requires the sender to know about the recipient's private
    key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何使用这个库的例子。该库仅支持交互式算法；它需要发送方了解接收方的私钥。
- en: 'We will create a sample Python script where **Alice** will encrypt some text,
    **Bob** will share his private key with **Alice**, **Alice** will create a derivation
    key with **Bob** private key, then the **Proxy** will re-encrypt using the derivation
    key, and finally the re-encrypted data will be decrypted by **Bob** using his
    private key:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例 Python 脚本，其中 **Alice** 将加密一些文本，**Bob** 将与 **Alice** 分享他的私钥，**Alice**
    将使用 **Bob** 的私钥创建一个派生密钥，然后 **代理** 将使用派生密钥进行再加密，最后 **Bob** 将使用他的私钥解密再加密的数据：
- en: '![](img/1bfe3548-1299-4aa1-98a6-af95499059ab.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bfe3548-1299-4aa1-98a6-af95499059ab.png)'
- en: 'Here is the code for these interactions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些交互的代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is self-explanatory. But the problem in the preceding scenario
    is that, for Alice to give access to the data to Bob, Alice needs to know Bob's
    private key. This is not an ideal situation and Bob may not be comfortable with
    sharing his key. For example, if Bob is using the same key for making blockchain
    transactions, then he would surely not want to share the key with Alice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不言自明。但上述场景中的问题是，为了让 Alice 将数据访问权限授予 Bob，Alice 需要知道 Bob 的私钥。这不是理想的情况，Bob
    可能不愿意分享他的密钥。例如，如果 Bob 在使用相同的密钥进行区块链交易，那么他肯定不希望与 Alice 共享密钥。
- en: 'Luckily, there is a workaround: The trick involves Alice generating a new key
    pair, giving access to that key pair, and then sharing that key pair by encrypting
    it with Bob''s public key. We will see this in practice later in this chapter.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个变通方法：这个技巧涉及到 Alice 生成一个新的密钥对，给予访问该密钥对的权限，然后用 Bob 的公钥加密该密钥对并分享。我们将在本章后面实际看到这一点。
- en: Architecting DApp for EMRs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 EMR 的 DApp 架构
- en: Let's design the architect of the DApp for enabling healthcare applications
    to share data with each other. Basically, users with different healthcare apps
    can share EMRs with each other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为使医疗应用程序能够共享数据而设计 DApp 的架构。基本上，使用不同医疗应用程序的用户可以相互分享 EMR。
- en: The ecosystem of this app will consist of healthcare service providers (such
    as hospitals, labs, and insurance companies), patients, app providers (the companies
    that will build healthcare apps integrated with this blockchain network), and
    a network authority or administrator (the health authority and/or solution provider).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的生态系统将由医疗服务提供商（如医院、实验室和保险公司）、患者、应用程序提供商（将构建与此区块链网络集成的医疗应用程序的公司）以及网络管理机构或管理员（卫生部门和/或解决方案提供商）组成。
- en: 'The following diagram shows the high-level architecture:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了高级别的架构：
- en: '![](img/61cd3ecd-be80-4477-88f0-8f3d9a5b4681.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61cd3ecd-be80-4477-88f0-8f3d9a5b4681.png)'
- en: 'This is how the preceding architecture works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前述架构的工作原理：
- en: The administrator of the network decides who can join the network and connect
    to the Cloud server.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络管理员决定谁可以加入网络并连接到云服务器。
- en: 'The blockchain will hold the service providers and patients'' identities and
    permissions, whereas the centralized and distributed server will store the encrypted
    EMRs. Every user and service provider will have their own Ethereum keys to identify
    themselves. There are two reasons why we are not storing the encrypted EMRs in
    the blockchain itself:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链将保存服务提供商和患者的身份和权限，而集中式和分布式服务器将存储加密的 EMR。每个用户和服务提供商都将拥有自己的以太坊密钥来识别自己。我们之所以不把加密的
    EMR 存储在区块链中，有两个原因：
- en: Every piece of data will be replicated to every node in the blockchain. This
    will harm scalability as the node size will increase drastically.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一份数据都将被复制到区块链中的每个节点。这将损害可扩展性，因为节点的大小将大幅增加。
- en: According to compliance, you are not supposed to even share encrypted data,
    as encryption algorithms may break in the future and all of the data will get
    leaked. So, if it's kept in a central location, then the server can be unplugged
    immediately.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据合规性规定，你甚至不应该分享加密数据，因为加密算法可能在未来被破解，所有数据都将泄漏。所以，如果它被保存在一个中心位置，那么服务器可以立即被拔掉。
- en: Whenever someone requests data from the storage, the server will check the blockchain
    to see whether the patient has granted access, and if so, then it will re-encrypt
    it using the re-encryption key and give the re-encrypted data to the recipient.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当有人从存储中请求数据时，服务器将检查区块链以查看患者是否已授予访问权限，如果是，则将使用重新加密密钥重新加密数据，并将重新加密的数据提供给接收者。
- en: While asking to read or write data to the Cloud server, the client should sign
    a token provided by the server to prove their identity. Based on this, the Cloud
    server will look for permissions in the blockchain and decide whether to re-encrypt
    or not. The client will sign using their private Ethereum key. This is the process
    of authentication to the Cloud server.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向云服务器请求读取或写入数据时，客户端应该使用服务器提供的令牌进行签名以证明其身份。基于此，云服务器将在区块链中寻找权限并决定是否重新加密。客户端将使用他们的私有以太坊密钥进行签名。这是向云服务器进行身份验证的过程。
- en: The user will register their identity on the blockchain. If a patient wants
    to give access to their data, then they will generate a new private key and a
    random token. Using this private key, the patient will generate a re-encrypt key
    and put it on the blockchain for the Cloud server to refer to while re-encrypting
    data. The user cannot generate the re-encrypt key directly using the service provider's
    key because, in that case, the service provider has to expose their private key,
    as we are using the interactive PRE algorithm. The random token's hash will be
    added to the blockchain by the patient and the service provider has to send a
    transaction proving that they know the random token acts as a proof that the user
    has shared access. This is a method of authorization to give data access. For
    example, if a user wants to give access to their EMRs on a mobile phone, then
    the user will generate a QR code, which has a private key and token. Then they
    will send the transaction to the blockchain, stating that whoever proves they
    have the token will be given access to their data. At the hospital, the receptionist
    can simply scan the QR code and push a transaction proofing to acquire the random
    string, thereby gaining access to the user's data. The QR code will also hold
    the private key. Every time the patient wants to give someone access, they have
    to generate a new key pair and token.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将在区块链上注册其身份。如果患者想要授权其数据访问权限，那么他们将生成一个新的私钥和一个随机令牌。患者将使用这个私钥生成一个重加密密钥，并将其放到区块链上，供云服务器在重新加密数据时参考。用户无法直接使用服务提供商的密钥生成重加密密钥，因为在这种情况下，服务提供商必须暴露他们的私钥，因为我们正在使用交互式PRE算法。患者将会把随机令牌的哈希值添加到区块链上，而服务提供商必须发送一笔交易，证明他们知道随机令牌，作为用户分享访问权限的证明。这是一种授权数据访问的方法。例如，如果用户想要在手机上授权他们的EMR，那么用户将生成一个包含私钥和令牌的二维码。然后他们将把交易发送到区块链，声明任何能证明他们拥有令牌的人都将被授予访问他们数据的权限。在医院，前台可以简单扫描二维码，推动一笔交易证明获取随机字符串，从而获得用户的数据访问权限。二维码也将保存私钥。每次患者想要授权某人访问时，他们都必须生成新的密钥对和令牌。
- en: Once write access is granted, the service provider can create EMRs of a defined
    format, put their hash on the blockchain, and send the EMR—which is encrypted
    using the patient's public key to the Cloud server for storage.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦获得写入访问权限，服务提供商可以创建指定格式的EMR，将其哈希值放在区块链上，然后将使用患者的公钥加密的EMR发送至云服务器存储。
- en: The Cloud server is controlled by the health authority or by the solution provider.
    It should be health-authority-compliant and should adhere to the standards. Even
    if the Cloud server gets hacked, the hackers won't be able to read anything because
    everything that is stored in it is encrypted and the keys are distributed across
    various app providers.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务器由卫生主管部门或解决方案提供商控制。它应该符合卫生主管部门的标准并遵守规范。即使云服务器被黑客攻击，黑客也无法读取任何内容，因为存储在其中的所有内容都是加密的，并且密钥分布在各个应用提供商之间。
- en: The solution can be extended in such a way that the end users control their
    private keys so that they don't have to trust the app provider. But this will
    harm the user experience, as users are not used to storing private keys. If they
    lose the key, then access to their EMRs is lost forever.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过扩展这个解决方案，让最终用户控制他们的私钥，从而不必信任应用提供商。但这将损害用户体验，因为用户不习惯存储私钥。如果他们失去了密钥，那么他们对EMR的访问权限将永远丢失。
- en: Although the Cloud server creates centralization for accessing the EMRs, you
    can still trust it. The keys aren't stored in the Cloud server—it just acts as
    storage. Even if the Cloud server gives access to your data to someone without
    your permission, the recipient cannot read the data, so the Cloud server can be
    trusted. This server can be distributed to achieve high availability.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管云服务器为访问EMR创建了集中化，但您仍然可以信任它。密钥并没有存储在云服务器中，它只是起到存储作用。即使云服务器未经您的允许将您的数据授权给他人，接收者也无法读取数据，因此可以信任云服务器。该服务器可以分布式部署以实现高可用性。
- en: This solution allows you to use different healthcare apps from different app
    providers and still have visibility of all the EMRs on each of the apps. To import
    all EMRs on a new app, a user has to export the key from the previous app and
    import it on the new app.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个解决方案允许您从不同的应用提供商那里使用不同的医疗保健应用，并且仍然在每个应用上看到所有的EMR。要在新应用上导入所有EMR，用户必须从上一个应用中导出密钥，并将其导入新的应用中。
- en: 'One issue that still exists is: how would you revoke access after granting
    access to someone? Of course, you can revoke the access on the blockchain, but
    what if the Cloud server still gives access to your new EMRs to the service provider?
    There is very little chance this would happen as it is unlikely any incentive
    for the Cloud server to do this. But this can be avoided by patients if they change
    their keys and run PRE on their data. This will invalidate all the re-encrypt
    keys you have shared so far, therefore new EMRs cannot be read by the existing
    service providers that you had given access to in the past.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一个问题：在授予某人访问权限后，如何撤销访问权限？当然，您可以在区块链上撤销访问权限，但如果云服务器仍然向服务提供商提供您的新 EMR 访问权限怎么办？云服务器这样做的可能性很小，因为云服务器没有任何激励这样做。但患者可以通过更改其密钥并在其数据上运行
    PRE 来避免这种情况。这将使您分享的所有重新加密密钥无效，因此以前授予访问权限的现有服务提供商无法读取新的 EMR。
- en: Smart contracts for identity and access control
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份和访问控制的智能合约
- en: Let's write the smart contracts that will be responsible for registering the
    identity of patients and service providers, and for providing access control.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写智能合约，负责注册患者和服务提供者的身份，并提供访问控制。
- en: 'Here is the smart contract code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是智能合约代码：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of the code in the preceding smart contract is self-explanatory. While
    registering patients and service providers, we are passing the public key and
    also verifying whether the public key is correct. `address(keccak256(fromHex(publicKey))`
    phrase calculates `address` from `publicKey.changePatientAccount` is used to change
    the account keys of the user, in case the keys are compromised. For example, this
    can be used if your app provider's servers get hacked and your private keys get
    leaked; the app provider can use this functionality to deactivate previous accounts
    and generate new ones for the users. The Cloud server will look for the `patientAccountChanged`
    event and run re-encryption on your encrypted EMRs so that you can access them
    with the new key. It will then delete the old encrypted EMRs. This can also be
    used by users to revoke access to the EMRs from all service providers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前述智能合约中的大部分代码都是不言自明的。在注册患者和服务提供者时，我们正在传递公钥，并验证公钥是否正确。`address(keccak256(fromHex(publicKey))`短语计算`publicKey`的`address`，`changePatientAccount`用于更改用户的帐户密钥，以防密钥被泄露。例如，如果您的应用提供商的服务器遭到黑客攻击并且您的私钥泄露了，应用提供商可以使用此功能来停用以前的帐户并为用户生成新帐户。云服务器将查找`patientAccountChanged`事件，并对加密的
    EMR 运行重新加密，以便您可以使用新密钥访问它们。然后它将删除旧的加密 EMR。用户还可以使用此功能向所有服务提供商撤销对 EMR 的访问权限。
- en: Writing Python and JS scripts for testing
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写用于测试的 Python 和 JS 脚本
- en: Let's now write some test scripts to test the smart contract and the data and
    user flow. We will write Python scripts to encrypt data, decrypt data, generate
    a re-encryption key, and re-encrypt data. And we will use Node.js to invoke the
    Python scripts and smart contract functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一些测试脚本来测试智能合约和数据和用户流。我们将编写 Python 脚本来加密数据、解密数据、生成重新加密密钥和重新加密数据。我们将使用
    Node.js 调用 Python 脚本和智能合约函数。
- en: 'Create a directory named `test`. In this, create a file named `encrypt.py` and
    place the following code into it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`test`的目录。在其中，创建一个名为`encrypt.py`的文件，并将以下代码放入其中：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This script takes two arguments, `publicKey` and a raw message. `publicKey`
    is passed as a `base64` encoded public key. This script converts the public key
    to bytes so that the `npre` library can utilize it. Finally, it encrypts the message
    and prints it as a `base64` encoded ciphertext.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本接受两个参数，`publicKey` 和原始消息。 `publicKey` 作为`base64`编码的公钥传递。此脚本将公钥转换为字节，以便`npre`库可以利用它。最后，它加密消息并将其打印为`base64`编码的密文。
- en: 'Create another file called `decrypt.py` and place the following code into it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个名为`decrypt.py`的文件，并将以下代码放入其中：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code is responsible for decryption. Now, create another file called `generate_reEncKey.py`
    and place the following code in it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责解密。现在，创建另一个名为`generate_reEncKey.py`的文件，并将以下代码放入其中：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code is responsible for generating the re-encryption key. Now, create
    another file called `re_encrypt.py` and place the following code into it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责生成重新加密密钥。现在，创建另一个名为`re_encrypt.py`的文件，并将以下代码放入其中：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code is responsible for re-encrypting the ciphertext. Now create a `package.json`
    file, which will hold the dependencies of our Node.js app. Place the following
    content in the file and run the `npm install` command to install the modules:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责重新加密密文。现在创建一个 `package.json` 文件，用于保存我们 Node.js 应用程序的依赖项。将以下内容放入文件中，并运行
    `npm install` 命令来安装模块：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, finally, create a file named `app.js` and place within it the following
    test code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，创建一个名为 `app.js` 的文件，并在其中放置以下测试代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile the smart contract and populate the `healthContract` and `health` variables
    with the ABI and bytecode respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译智能合约，并将 ABI 和字节码分别填充到 `healthContract` 和 `health` 变量中。
- en: 'Here is how the preceding code works:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码的工作原理：
- en: We use the `ethereumjs` libraries for creating offline accounts and signing
    transactions using those accounts.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `ethereumjs` 库来创建离线账户，并使用这些账户进行交易签名。
- en: We use `child_process` to execute Python scripts from Node.js. Though you can
    use RESTful APIs and adopt a microservices architecture, for testing purposes,
    this is fine.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `child_process` 来从 Node.js 执行 Python 脚本。尽管您可以使用 RESTful API 并采用微服务架构，但出于测试目的，这样做是可以的。
- en: We use `EthCrypto` to compress and uncompress the public key. The public key
    generated by `ethereumjs-wallet` is uncompressed, whereas the public key that
    is generated and used by `npre` is compressed. Private keys are always 32 bytes,
    and public keys are always 65 bytes (or 33 bytes for a compressed public key).
    Public key hashes are always 20 bytes. `npre` also adds `0x00` in the beginning
    of a private key and `0x01` in the beginning of a public key.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `EthCrypto` 来压缩和解压缩公钥。由 `ethereumjs-wallet` 生成的公钥是未压缩的，而由 `npre` 生成和使用的公钥是压缩的。私钥始终为
    32 字节，公钥始终为 65 字节（或者压缩公钥为 33 字节）。公钥哈希始终为 20 字节。 `npre` 还在私钥的开头添加了 `0x00`，在公钥的开头添加了
    `0x01`。
- en: At first, we generate a patient's wallet and register it on the blockchain.
    In a real application, you can also register the user profile and service provider
    on the Cloud server. The user profile can contain details such as the name, age,
    and other details on patients; similarly, the service provider profile can contain
    license numbers, names, and so on. These profiles can be encrypted using the owner's
    public key and stored on the Cloud server.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们生成一个患者的钱包，并将其注册到区块链上。在真实应用程序中，您还可以在云服务器上注册用户配置文件和服务提供商。用户配置文件可以包含患者的姓名、年龄和其他详细信息；同样，服务提供商配置文件可以包含许可证号码、名称等。这些配置文件可以使用所有者的公钥加密并存储在云服务器上。
- en: 'Now, insert the following code where we have a continuation comment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们有一个续行注释的地方插入以下代码：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we generated a temporary key pair and assumed that it's shared with the
    service provider. Then, we generated a re-encrypt key using the patient's private
    key and a temporary private key. Then, we made a `addToken` transaction from the
    patient's wallet and a `requestAccess` transaction from the service provider's
    wallet. These two transactions provide the service provider with access to the
    patient's EMRs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成了一个临时密钥对，并假设它与服务提供商共享。然后，我们使用患者的私钥和临时私钥生成了一个重新加密密钥。然后，我们从患者的钱包执行了一个
    `addToken` 交易和一个从服务提供商的钱包执行了一个 `requestAccess` 交易。这两个交易为服务提供商提供了访问患者 EMR 的权限。
- en: 'Now insert the following code where we have a continuation comment:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们有一个续行注释的地方插入以下代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we created a sample EMR representing blood group. And then we put the hash
    on the blockchain and assumed putting the encrypted EMR on the Cloud server. And
    then we simulate a scenario where the Cloud server re-encrypts the ciphertext
    and the service provider decrypts the ciphertext. Finally, we generated another
    key pair and moved all EMRs of the patient to this account and closed the old
    account.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个表示血型的样本 EMR。然后我们将哈希放在区块链上，并假设将加密的 EMR 放在了云服务器上。然后，我们模拟了一个场景，云服务器重新加密了密文，服务提供商解密了密文。最后，我们生成了另一对密钥，并将患者的所有
    EMR 移动到该账户，并关闭了旧账户。
- en: So, you saw how we simulated the whole user flow and how you can use PRE for
    security and privacy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你看到了我们是如何模拟整个用户流程的，以及你如何使用 PRE 来确保安全性和隐私性。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned how to use PRE for enabling encrypted data sharing
    in a blockchain. PRE can be a good alternative to private transactions and ZSL,
    in many cases. The architecture we looked at  can be applied to many other use
    cases where sensitive assets need to be stored and shared among peers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用PRE在区块链中实现加密数据共享。在许多情况下，PRE可以成为私有交易和ZSL的良好替代方案。我们所看到的架构可以应用于许多其他情况，其中敏感资产需要在对等方之间存储和共享。
- en: Apart from PRE, we learned about a lot of JS and Python libraries, such as `etherumjs-wallet`,
    `ethereumjs-tx`, `ethereumjs-util`, and `npre`. We also learned how to send raw
    transactions, such as the process of signing transactions using keys stored outside
    of the geth node. In the next chapter how to implement network permissioning in
    Quorum and  how to build a solution to transfer money using a mobile number.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了PRE外，我们还了解了许多JS和Python库，比如`etherumjs-wallet`，`ethereumjs-tx`，`ethereumjs-util`和`npre`。我们还学习了如何发送原始交易，比如使用存储在geth节点外部的密钥签署交易的过程。在下一章中，我们将学习如何在Quorum中实现网络权限管理，以及如何使用手机号码构建转账解决方案。
