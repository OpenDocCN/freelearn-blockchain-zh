["```\npragma solidity ^0.4.23;\ninterface ERC20 {\n function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n```", "```\npragma solidity ^0.4.23;\nimport \"./ERC20.sol\";\n\ncontract Crowdsale {\n\n // The token being sold, conforms to ERC20 standard.\n ERC20 public token;\n\n // 1 tokens per Eth, both have 18 decimals.\n uint256 public rate = 1; \n\n constructor(ERC20 _token) public {\n    token = _token;\n }\n\n function () external payable {\n    uint256 _tokenAmount = msg.value * rate;\n    token.transfer(msg.sender, _tokenAmount);\n }\n}\n```", "```\nconstructor(ERC20 _token) public {\n    token = _token;\n}\n```", "```\nfunction () external payable {\n    uint 256 _tokenAmount = msg.value * rate; //Calculate tokens purchased\n    token.transfer(msg.sender, _tokenAmount); //Execute send on token contract.\n}\n```", "```\nfunction approve(address _spender, uint256 _value) public returns (bool) {\n   allowed[msg.sender][_spender] = _value;\n   emit Approval(msg.sender, _spender, _value);\n   return true;\n }\n```", "```\nfunction transferFrom(address _from,address _to,uint256 _value) public returns (bool) {\n   require(_to != address(0)); // check to make sure we aren't transfering to nowhere.\n\n   // checks to ensure that the number of tokens being moved is valid.\n   require(_value <= balances[_from]); \n   require(_value <= allowed[_from][msg.sender]);\n\n   // execute the transfer.\n   balances[_from] = balances[_from].sub(_value);\n   balances[_to] = balances[_to].add(_value);\n   allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n   //Record the transfer to the blockchain.\n   emit Transfer(_from, _to, _value); \n   // let the calling code or app know that the transfer was a success.\n   return true;\n }\n```"]