- en: Smart Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides an introduction to smart contracts. This concept is not
    new, but, with the advent of the blockchain, interest in this idea was revived,
    and this is now an active area of research in the blockchain space. Due to the
    cost-saving benefits that smart contracts can bring to the financial services
    industry by reducing the cost of transactions and simplifying complex contracts,
    rigorous research is being carried out by various commercial and academic institutions
    to formalize and make the implementation of smart contracts easy and practical,
    as soon as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: History
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smart contracts were first theorized by Nick Szabo in the late 1990s in an
    article named *Formalizing and Securing Relationships on Public Networks*, but
    it was almost 20 years before the real potential and benefits of them were indeed
    appreciated with the invention of Bitcoin and subsequent development in blockchain
    technology. Smart contracts are described by Szabo as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '"A smart contract is an electronic transaction protocol that executes the terms
    of a contract. The general objectives are to satisfy common contractual conditions
    (such as payment terms, liens, confidentiality, and even enforcement), minimize
    exceptions both malicious and accidental, and minimize the need for trusted intermediaries.
    Related economic goals include lowering fraud loss, arbitrations and enforcement
    costs, and other transaction costs."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The original article written by Szabo is available at [http://firstmonday.org/ojs/index.php/fm/article/view/548](http://firstmonday.org/ojs/index.php/fm/article/view/548).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This idea of smart contracts was implemented in a limited fashion in Bitcoin
    in 2009, where Bitcoin transactions using a limited scripting language can be
    used to transfer value between users, over a peer-to-peer network where users
    do not necessarily trust each other, and there is no need for a trusted intermediary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no consensus on a standard definition of smart contracts. It is essential
    to define what a smart contract is, and the following is my attempt to provide
    a generalized definition of a smart contract:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '*A smart contract is a secure and unstoppable computer program representing
    an agreement that is automatically executable and enforceable.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting this definition further reveals that a smart contract is, in fact,
    a computer program that is written in a language that a computer or target machine
    can understand. Also, it encompasses agreements between parties in the form of
    business logic. Another fundamental idea is that smart contracts are automatically
    executed when certain conditions are met. They are enforceable, which means that
    all contractual terms are executed as defined and expected, even in the presence
    of adversaries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement is a broader term that encompasses traditional enforcement in the
    form of law, along with the implementation of specific measures and controls that
    make it possible to execute contract terms without requiring any mediation. It
    should be noted that true smart contracts should not rely on traditional methods
    of enforcement. Instead, they should work on the principle that code is law, meaning
    that there is no need for an arbitrator or a third party to control or influence
    the execution of the smart contract. Smart contracts are self-enforcing as opposed
    to legally enforceable. This idea might be regarded as a libertarian's dream,
    but it is entirely possible and is in line with the true spirit of smart contracts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, they are secure and unstoppable, which means that these computer programs
    are required to be designed in such a fashion that they are fault-tolerant and
    executable in a reasonable amount of time. These programs should be able to execute
    and maintain a healthy internal state, even if external factors are unfavorable.
    For example, imagine a typical computer program that is encoded with some logic
    and executes according to the instruction coded within it. However, if the environment
    it is running in or external factors it relies on deviate from the normal or expected
    state, the program may react arbitrarily or simply abort. It is essential that
    smart contracts be immune to this type of issue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Secure and unstoppable may well be considered requirements or desirable features
    but it will provide more significant benefits in the long run if security and
    unstoppable properties are included in the smart contract definition from the
    beginning. This will allow researchers to focus on these aspects from the start
    and will help to build strong foundations on which further research can then be
    based. There is also a suggestion by some researchers that smart contracts need
    not be automatically executable; instead, they can be what's called automatable,
    due to manual human input required in some scenarios. For example, a manual verification
    of a medical record might be required by a qualified medical professional. In
    such cases fully automated approaches may not work best. While it is true that
    in some cases human input and control is desirable, it is not necessary; and,
    for a contract to be truly smart, in the author's opinion, it has to be fully
    automated. Some inputs that need to be provided by people can and should also
    be automated via the use of Oracles. Oracles will be discussed later in this chapter
    in greater detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts usually operate by managing their internal state using a state
    machine model. This allows development of an effective framework for programming
    smart contracts, where the state of a contract is advanced further based on some
    predefined criteria and conditions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also on-going debate on the question of whether the code is acceptable
    as a contract in a court of law. A smart contract is different in presentation
    from traditional legal prose, albeit they do represent and enforce all contractual
    clauses but a court of law does not understand the code. This dilemma raises several
    questions about how a smart contract can be legally binding: can it be developed
    in such a way that it is readily acceptable and understandable in a court of law?
    How can dispute resolution be implemented within the code, and is it possible?
    Moreover, regulatory and compliance requirements is another topic that needs to
    be addressed before smart contracts can be used as efficiently as traditional
    legal documents.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就代码是否可以作为法院合同的基础而进行的讨论也在持续进行。智能合同在形式上与传统的法律文书有所不同，尽管它们代表并执行所有合同条款，但法院并不理解代码。这一困境提出了有关智能合同如何具有法律约束力的几个问题：它能否以一种容易被法院接受和理解的方式开发？如何在代码内实施争端解决，这是可能的吗？此外，在智能合同能够像传统法律文件一样有效使用之前需要解决的另一个主题是监管和合规要求。
- en: Even though smart contracts are named smart, they in fact only do what they
    have been programmed to do, and that is fine because this very property of smart
    contracts ensures that smart contracts produce same output every time they are
    executed. This deterministic nature of smart contracts is highly desirable in
    blockchain platforms due to consistent consensus requirements. This means that
    smart contracts are not really smart, they are simply doing what they are programmed
    to do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使智能合同被称为智能，它们实际上只做它们被编程做的事情，这是可以接受的，因为智能合同的这一属性确保智能合同每次执行时都产生相同的输出。由于一致的共识要求，这种确定性的性质在区块链平台上非常理想。这意味着智能合同并不是真正的智能，它们只是做它们被编程做的事情。
- en: Now this gives rise to a problem whereby a large gap between real world and
    blockchain world emerges. In this situation, natural language is not understandable
    by the smart contract, and similarly, the code is not comprehensible to the natural
    world. So, a few questions arise, how real-life contracts can be deployed on a
    blockchain? How can this bridge between the real world and smart contract world
    be built?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这引发了一个问题，即现实世界和区块链世界之间出现了很大的差距。在这种情况下，自然语言对智能合同来说是不可理解的，类似地，代码对自然世界来说也是无法理解的。因此，一些问题出现了，现实生活中的合同如何部署在区块链上？如何构建真实世界和智能合同世界之间的桥梁？
- en: The preceding questions open up various possibilities, such as making a smart
    contract code readable not only by machines but also by people. If humans and
    machines can both understand the code written in a smart contract it might be
    more acceptable in legal situations, as opposed to just a piece of code that no-one
    understands except for programmers. This desirable property is an area ripe for
    research, and a large research effort has been expended in this area to answer
    questions around semantics, meaning, and interpretation of a contract.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题打开了各种可能性，例如使智能合同代码不仅可以被机器理解，还可以被人理解。如果人类和机器都能理解智能合同中编写的代码，它在法律情况下可能更容易被接受，而不只是一个除程序员外没有人能够理解的代码片段。这种可取的属性是一个值得研究的领域，大量的研究工作在这一领域已经进行，以回答关于合同的语义、含义和解释的问题。
- en: Some work has already been done to describe natural language contracts formally
    by combining both smart contract code and natural language contract through linking
    contract terms with machine understandable elements. This is achieved using a
    markup language. An example of this type of markup language is called **Legal
    Knowledge Interchange Format** (**LKIF**), which is an XML schema for representing
    theories and proofs. It was developed under the ESTRELLA Project in 2008.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一些工作通过将智能合同代码和自然语言合同组合在一起，通过链接合同术语与机器可理解的元素，形式上描述自然语言合同。这是通过使用一种标记语言来实现的。这种标记语言的示例称为**法律知识交换格式**（**LKIF**），它是用于表示理论和证明的XML模式。它是在2008年的ESTRELLA项目下开发的。
- en: More information is available in a research paper available at [https://doi.org/10.1007/978-3-642-15402-7_30](https://doi.org/10.1007/978-3-642-15402-7_30).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更多信息，请参阅研究论文：[https://doi.org/10.1007/978-3-642-15402-7_30](https://doi.org/10.1007/978-3-642-15402-7_30)。
- en: Smart contracts are inherently required to be deterministic. This property will
    allow a smart contract to be run by any node on a network and achieve the same
    result. If the result differs even slightly between nodes, then consensus cannot
    be achieved, and a whole paradigm of distributed consensus on blockchain can fail.
    Moreover, it is also desirable that the contract language itself is deterministic,
    thus ensuring integrity and stability of the smart contracts. Deterministic in
    the sense that there are no non-deterministic functions used in the language,
    which can produce different results on various nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let's take, for example, various floating-point operations calculated by various
    functions in a variety of programming languages can produce different results
    in different runtime environments. Another example is some math functions in JavaScript,
    which can produce different results for the same input on different browsers,
    and which can, in turn, lead to various bugs. This is highly undesirable in smart
    contracts because if results are inconsistent between nodes, then consensus will
    never be achieved.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A deterministic feature ensures that smart contracts always produce the same
    output for a specific input. In other words, programs, when executed, produce
    a reliable and accurate business logic that is entirely in line with the requirements
    programmed in the high-level code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, a smart contract has the following four properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Automatically executable
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforceable
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantically sound
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure and unstoppable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two properties are required as a minimum, whereas the latter two may
    not be required or implementable in some scenarios and can be relaxed. For example,
    a financial derivatives contract does not perhaps need to be semantically sound
    and unstoppable but should at least be automatically executable and enforceable
    at a fundamental level. On the other hand, a title deed needs to be semantically
    sound and complete, therefore, for it to be implemented as a smart contract, the
    language must be understood by both computers and people. Ian Grigg addressed
    this issue of interpretation with his invention of Ricardian contracts, which
    we will look at in more detail in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Ricardian contracts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ricardian contracts were initially proposed in the paper, *Financial Cryptography
    in 7 Layers*, by *Ian Grigg* in late 1990s. These contracts were used initially
    in a bond trading and payment system called **Ricardo**. The fundamental idea
    is to write a document that is understandable and acceptable by both a court of
    law and computer software. Ricardian contracts address the challenge of issuance
    of value over the internet. It identifies the issuer and captures all the terms
    and clauses of the contract in a document to make it acceptable as a legally binding
    contract.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'A Ricardian contract is a document that has several of the following properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A contract offered by an issuer to holders
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A valuable right held by holders and managed by the issuer
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily readable by people (like a contract on paper)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable by programs (parsable, like a database)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digitally signed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carries the keys and server information
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allied with a unique and secure identifier
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding information is based on the original definition by Ian Grigg at
    [http://iang.org/papers/ricardian_contract.html](http://iang.org/papers/ricardian_contract.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the contracts are implemented by producing a single document that
    contains the terms of the contract in legal prose and the required machine-readable
    tags. This document is digitally signed by the issuer using their private key.
    This document is then hashed using a message digest function to produce a hash
    by which the document can be identified. This hash is then further used and signed
    by parties during the performance of the contract to link each transaction, with
    the identifier hash thus serving as an evidence of intent. This is depicted in
    the next diagram, usually called a bowtie model.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows number of elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The **World of Law** on the left-hand side from where the document originates.
    This document is a written contract in legal prose with some machine-readable
    tags.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This document is then hashed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resultant message digest is used as an identifier throughout the **World
    of Accountancy**, shown on the right-hand side of the diagram.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **World of Accountancy** element represents any accounting, trading, and
    information systems that are being used in the business to perform various business
    operations. The idea behind this flow is that the message digest generated by
    hashing the document is first used in a so-called **genesis transaction**, or
    first transaction, and then used in every transaction as an identifier throughout
    the operational execution of the contract.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, a secure link is created between the original written contract and
    every transaction in the **World of Accounting**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62dd13c0-6989-4883-beb3-86776dc07cce.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Ricardian contracts, bowtie diagram
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'A Ricardian contract is different from a smart contract in the sense that a
    smart contract does not include any contractual document and is focused purely
    on the execution of the contract. A Ricardian contract, on the other hand, is
    more concerned with the semantic richness and production of a document that contains
    contractual legal prose. The semantics of a contract can be divided into two types:
    operational semantics and denotational semantics.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The first type defines the actual execution, correctness, and safety of the
    contract, and the latter is concerned with the real-world meaning of the full
    contract. Some researchers have differentiated between smart contract code and
    smart legal contracts where a smart contract is only concerned with the execution
    of the contract. The second type encompasses both the denotational and operational
    semantics of a legal agreement. It perhaps makes sense to categorize smart contracts
    based on the difference between semantics, but it is better to consider smart
    contracts as a standalone entity that is capable of encoding legal prose and code
    (business logic) in it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型定义了合同的实际执行、正确性和安全性，后者则涉及完整合同的真实含义。 一些研究人员已经区分了智能合同代码和智能法律合同，其中智能合同仅涉及合同的执行。
    第二种类型包括法律协议的指示和操作语义。 基于语义的差异将智能合同划分为类型也许有意义，但最好将智能合同视为能够在其中编码法律散文和代码（业务逻辑）的独立实体。
- en: In Bitcoin, a straightforward implementation of basic smart contracts (conditional
    logic) can be observed, which is entirely oriented towards the execution and performance
    of the contract, whereas a Ricardian contract is more geared towards producing
    a document that is understandable by humans with some parts that a computer program
    can understand. This can be viewed as legal semantics versus operational performance
    (semantics versus performance) as shown in the following diagram. The diagram
    shows that Ricardian contracts are more semantically-rich, whereas smart contracts
    are more performance-rich. This concept was initially proposed by *Ian Grigg*
    in his paper, *On the intersection of Ricardian and smart contracts*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，可以观察到基本智能合同（条件逻辑）的直接实现，它完全面向合同的执行和性能，而里卡迪安合同更倾向于生成一个对人类易懂的文件，其中有些部分是计算机程序可以理解的。
    这可以看作是法律语义与操作性能（语义与性能）的对比，如下图所示。 本图显示里卡迪安合同更加语义丰富，而智能合同更加性能丰富。 这个概念最初是由*Ian Grigg*在他的论文《On
    the intersection of Ricardian and smart contracts》中提出的。
- en: '![](img/7592380b-e496-41c9-a1d7-c3e6bc01d2b3.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7592380b-e496-41c9-a1d7-c3e6bc01d2b3.jpg)'
- en: Diagram explaining performance versus semantics are orthogonal issues as described
    by Ian Grigg; slightly modiﬁed to show examples of diﬀerent types of contracts
    on both axis
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图解释了性能与语义是Ian Grigg描述的正交问题；稍微修改以展示两个轴上不同类型合同的示例
- en: A smart contract is made up to have both of these elements (performance and
    semantics) embedded together, which completes an ideal model of a smart contract.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个智能合同包括了这两个元素（性能和语义）的嵌入，从而完成了一个完美的智能合同模型。
- en: A Ricardian contract can be represented as a tuple of three objects, namely
    *Prose*, *parameters,* and *code*. Prose represents the legal contract in natural
    language; code represents the program that is a computer-understandable representation
    of legal prose; and parameters join the appropriate parts of the legal contract
    to the equivalent code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 里卡迪安合同可以表示为三个对象的元组，即*散文*、*参数*和*代码*。 散文代表自然语言中的法律合同；代码代表了计算机可理解的法律散文的表示；参数将法律合同的适当部分与等效代码连接起来。
- en: Ricardian contracts have been implemented in many systems, such as CommonAccord,
    OpenBazaar, OpenAssets, and Askemos.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 里卡迪安合同已经在许多系统中实施，例如CommonAccord、OpenBazaar、OpenAssets和Askemos。
- en: Smart contract templates
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合同模板
- en: Smart contracts can be implemented for any industry where required, but most
    current use cases are related to the financial industry. This is due to the fact
    that blockchain found many use cases in the Finance industry first and sparked
    great research interest in the financial industry long before other industries.
    Recent work in smart contract space specific to the financial industry has proposed
    the idea of smart contract templates. The idea is to build standard templates
    that provide a framework to support legal agreements for financial instruments.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合同可以在需要的任何行业实现，但大多数当前的用例与金融行业相关。 这是因为区块链最初在金融业发现了许多用例，并在其他行业很久之前就引起了金融业的巨大研究兴趣。
    特定于金融行业的智能合同领域的最新工作提出了智能合同模板的理念。 这个理念是建立提供支持金融工具法律协议的标准模板框架。
- en: 'This idea was proposed by *Clack et al.* in their paper published in 2016,
    named *Smart Contract Templates: Foundations, design landscape and research directions*.
    The paper also proposed that domain-specific languages should be built to support
    design and implementation of smart contract templates. A language named CLACK,
    a common language for augmented contract knowledge has been proposed, and research
    has begun to develop the language. This language is intended to be very rich and
    provide a large variety of functions ranging from supporting legal prose to the
    ability to be executed on multiple platforms and cryptographic functions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent work to develop smart contract templates that support legally enforceable
    smart contracts have been carried out by Clack et al. This proposal has been discussed
    in their research paper *Smart Contract Templates: essential requirements and
    design options*. The main aim of this paper is to investigate how legal prose
    can be linked with code using a markup language. It also covers that how smart
    legal agreements can be created, formatted, executed, and serialized for storage
    and transmission. This is an ongoing work and an open area for further research
    and development.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Contracts in the finance industry is not a new concept, and various domain-specific
    language DSLs are already in use in the financial industry to provide specific
    language for a specific domain. For example, there are DSLs available that support
    development of insurance products, represent energy derivatives, or are being
    used to build trading strategies.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive list of financial domain-specific languages can be found at
    [http://www.dslfin.org/resources.html](http://www.dslfin.org/resources.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand the concept of domain-specific languages
    as this type of languages can be developed to program smart contracts. These languages
    are developed with limited expressiveness for a particular application or area
    of interest. **Domain-specific languages** (**DSLs**) are different from **general-purpose
    programming languages** (**GPLs**). DSLs have a small set of features that are
    sufficient and optimized for the domain they are intended to be used in and, unlike
    GPLs, are usually not used to build general purpose large application programs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Based on the design philosophy of DSLs it can be envisaged that such languages
    will be developed specifically to write smart contracts. Some work has already
    been done, and Solidity is one such language that has been introduced with Ethereum
    blockchain to write smart contracts. Vyper is another language that has been recently
    introduced for Ethereum smart contact development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: This idea of domain-specific languages for smart contract programming can be
    further extended to a *graphical domain-specific language*, a smart contract modeling
    platform where a domain expert (not a programmer, for example, a front desk dealer)
    can use a graphical user interface and a canvas to define and draw the semantics
    and performance of a financial contract. Once the flow has been drawn and completed,
    it can be emulated first to test and then be deployed from the same system to
    the target platform, which can be a blockchain. This is also not a new concept,
    and a similar approach is used in the Tibco StreamBase product, which is a Java-based
    system used for building event-driven, high-frequency trading systems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用于智能合约编程的领域特定语言的概念可以进一步扩展到*图形领域特定语言*，这是一个智能合约建模平台，领域专家（比如前台交易员而非程序员）可以使用图形用户界面和画布定义和绘制金融合同的语义和性能。一旦流程被绘制并完成，可以首先进行仿真测试，然后从同一系统部署到目标平台，可以是区块链。这也不是一个新概念，在Tibco
    StreamBase产品中也使用了类似的方法，该产品是一个基于Java的系统，用于构建事件驱动的高频交易系统。
- en: It is proposed that research should also be conducted in the area of developing
    high-level DSLs that can be used to program a smart contract in a user-friendly
    graphical user interface, thus allowing a non-programmer domain expert (for example,
    a lawyer) to design smart contracts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在开发可用于使用用户友好的图形用户界面编程智能合约的高级DSL领域也应进行研究，从而使非程序员领域专家（例如律师）能够设计智能合约。
- en: Oracles
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神谕
- en: Oracles are an important component of the smart contract ecosystem. The limitation
    with smart contracts is that they cannot access external data, which might be
    required to control the execution of the business logic; for example, the stock
    price of a security product that is required by the contract to release the dividend
    payments. Oracles can be used to provide external data to smart contracts. An
    Oracle is an interface that delivers data from an external source to smart contracts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 神谕是智能合约生态系统的重要组成部分。智能合约的限制在于它们无法访问外部数据，而这些数据可能是控制业务逻辑执行所需的；例如，合约需要发布股息支付所需的证券产品的股价。神谕可以用来为智能合约提供外部数据。神谕是一个从外部来源向智能合约传递数据的接口。
- en: Depending on the industry and requirements, Oracles can deliver different types
    of data ranging from weather reports, real-world news, and corporate actions to
    data coming from **Internet of Things** (**IoT**) devices. Oracles are trusted
    entities that use a secure channel to transfer data to a smart contract.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据行业和要求，神谕可以提供不同类型的数据，包括天气报告、现实世界新闻和公司行动以及来自**物联网（IoT）**设备的数据。神谕是受信任的实体，使用安全通道将数据传输到智能合约。
- en: Oracles are also capable of digitally signing the data proving that the source
    of the data is authentic. Smart contracts can then subscribe to the Oracles, and
    the smart contracts can either pull the data or Oracles can push the data to the
    smart contracts. It is also necessary that Oracles should not be able to manipulate
    the data they provide and must be able to provide authentic data. Even though
    Oracles are trusted, it may still be possible in some cases that the data is incorrect
    due to manipulation. Therefore, it is necessary that Oracles are unable to change
    the data. This validation can be provided by using various notary schemes, discussed
    later in the chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 神谕还能够数字签名数据，证明数据来源真实可靠。智能合约可以订阅神谕，然后智能合约可以拉取数据，或者神谕可以将数据推送给智能合约。还需要确保神谕无法操纵他们提供的数据，并且必须能够提供真实可靠的数据。虽然神谕是可信的，但在某些情况下，由于操纵原因，数据可能仍然是不正确的。因此，需要确保神谕无法更改数据。后面章节将讨论使用各种公证方案提供此验证。
- en: In this approach, an issue can already be seen which perhaps is not desirable
    in some cases, and that is the issue of trust. How do you trust a third party
    about the quality and authenticity of data they provide? This is especially true
    in the financial world, where market data must be accurate and reliable. It might
    be acceptable for a smart contract designer to accept data for an Oracle that
    is provided by a large, reputable, trusted third party, but the issue of centralization
    remains. These types of Oracles can be called standard or simple Oracles. For
    example, the source of the data can be from a reputable weather reporting agency
    or airport information system relaying the flight delays.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Another concept that can be used to ensure the credibility of data provided
    by third-party sources for Oracles is that data is sourced from multiple sources;
    even users or members of the public that have access and knowledge about some
    data can provide the required data. This data can then be aggregated and if a
    high number of same information is fed from multiple sources, then there is a
    high chance that the data is correct and can be trusted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Another type of Oracle, which essentially emerged due to the decentralization
    requirements, is called **decentralized** Oracles. These types of Oracles can
    be built based on some distributed mechanism. It can also be envisaged that the
    Oracles can find themselves source data from another blockchain, which is driven
    by distributed consensus, thus ensuring the authenticity of data. For example,
    one institution running their private blockchain can publish their data feed via
    an Oracle that can then be consumed by other blockchains.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Another concept of hardware Oracles is also introduced by researchers where
    real-world data from physical devices is required. For example, this can be used
    in telemetry and IoT. However, this approach requires a mechanism in which hardware
    devices are tamperproof. This can be achieved by providing cryptographic evidence
    (non-repudiation and integrity) of IoT device's data and anti-tampering mechanism
    on the IoT device, which renders the device useless in case of tampering attempts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a generic model of an Oracle and smart contract
    ecosystem:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3dcbb82-d077-4677-b8d9-fd6cb3a0dedf.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: A generic model of an Oracle and smart contract ecosystem
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: There are platforms available now to enable a smart contract to get external
    data using an Oracle. There are different methods used by an Oracle to write data
    into the blockchain depending on the type of blockchain used. For example, in
    Bitcoin blockchain, an Oracle can write data to a specific transaction and a smart
    contract can monitor that transaction in the blockchain and read the data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Various online services such as [http://www.oraclize.it/](http://www.oraclize.it/)
    and [https://www.realitykeys.com/](https://www.realitykeys.com/) are available
    that provide Oracle services. Another service at [https://smartcontract.com/](https://smartcontract.com/)
    is also available, which provides external data and the ability to make payments
    using smart contracts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: All these services aim to enable the smart contract to get the data it needs
    to execute and make decisions. To prove the authenticity of the data retrieved
    by the Oracles from external sources, mechanisms like TLSnotary can be used which
    produce proof of communication between the data source and the Oracle. This ensures
    that the data fed back to the smart contract is retrieved from the source.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: More details about TLSnotary can be found here: [https://tlsnotary.org/](https://tlsnotary.org/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Smart Oracles
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An idea of Smart Oracle has also been proposed by *Ripple labs (codius)*. Its
    original whitepaper is available at [https://github.com/codius/codius/wiki/Smart-Oracles:-A-Simple,-Powerful-Approach-to-Smart-Contracts](https://github.com/codius/codius/wiki/Smart-Oracles:-A-Simple,-Powerful-Approach-to-Smart-Contracts).
    Smart Oracles are entities just like Oracles, but with the added capability of
    contract code execution. Smart Oracles proposed by Codius run using Google Native
    Client, which is a sandboxed environment for running untrusted x86 native code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Deploying smart contracts on a blockchain
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts may or may not be deployed on a blockchain, but it makes sense
    to deploy them on a blockchain due to the distributed and decentralized consensus
    mechanism provided by blockchain. Ethereum is an example of a blockchain platform
    that natively supports the development and deployment of smart contracts. Smart
    contracts on Ethereum blockchain are usually part of a broader application such
    as **Decentralized Autonomous organization** (**DAOs**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: As a comparison, in Bitcoin blockchain, the transaction timelocks such as the `nLocktime`
    field and CHECKLOCKTIMEVERIFY (CLTV), CHECKSEQUENCEVERIFY script operator in the
    Bitcoin transaction can be seen as an enabler of a simple version of a smart contract.
    These timelocks enable a transaction to be locked until a specified time or until
    a number of blocks, thus enforcing a basic contract that a certain transaction
    can only be unlocked if certain conditions (elapsed time or number of blocks)
    are met. For example, you can implement conditions such as "Pay party X, N amount
    of bitcoins after 3 months". However, this is very limited and should be only
    viewed as an example of a basic smart contract. In addition to the example mentioned
    above, Bitcoin scripting language, though limited, can be used to construct basic
    smart contracts. One example, of a basic smart contract, is to fund a Bitcoin
    address that can be spent by anyone who demonstrates a "hash collision attack".
    This was a contest that was announced on the Bitcointalk forum where bitcoins
    were set as a reward for whoever manages to find hash collisions (we discussed
    this concept in [Chapter 6](c49f1747-2096-4ab6-a1e1-334e092ef2be.xhtml), *Public
    Key Cryptography*) for hash functions. This conditional unlocking of Bitcoin only
    on the demonstration of a successful attack is a basic type of smart contract.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: This idea was presented on the Bitcointalk forum, and more information can be
    found at [https://bitcointalk.org/index.php?topic=293382.0](https://bitcointalk.org/index.php?topic=293382.0).
    This can also be considered a basic form of smart contract.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Various other blockchain platforms support smart contracts such as Monax, Lisk,
    Counterparty, Stellar, Hyperledger fabric, corda, and Axoni core. Smart contracts
    can be developed in various languages. The critical requirement, however, is determinism,
    which is very important because it is vital that regardless of where the smart
    contract code executes, it produces the same result every time and everywhere.
    This requirement of deterministic nature of smart contracts also implies that
    smart contract code is absolutely bug-free. Validation and verification of smart
    contracts is an active area of research and detailed discussion of this topic
    will be presented in [Chapter 16](d0ef443d-d4b0-4afb-91f4-c5863ea1cf43.xhtml),
    *Scalability and Other Challenges*. Various languages have been developed to build
    smart contracts such as Solidity, which runs on **Ethereum Virtual Machine** (**EVM**).
    It's worth noting that there are platforms which already support mainstream languages
    for smart contract development, such as Lisk which supports JavaScript. However,
    another prominent example is Hyperledger fabric which supports Golang, Java, and
    JavaScript for smart contract development.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The DAO
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DAO is one of the highest crowdfunded projects, and it started in April
    2016\. This was a set of smart contracts written to provide a platform for investment.
    Due to a bug in the code, this was hacked in June 2016, and an equivalent of 50
    million dollars was siphoned out of the DAO into another account.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Even though the term hacked is used above, it was not really hacked, the smart
    contract simply did what it was asked to do. It was just an unintentional behavior
    that programmers of the DAO did not foresee. This incident resulted in a hard
    fork on Ethereum to recover from the attack. It should be noted that the notion
    of *code is the law* or unstoppable smart contracts should be viewed with some
    skepticism as the implementation of these concepts is not mature enough to merit
    full and unquestionable trust. This is evident from the recent events where the
    Ethereum foundation was able to stop and change the execution of *The DAO* by
    introducing a hard fork. Though this hard fork was introduced for genuine reasons,
    it goes against the true spirit of decentralization, and the notion of *code is
    law*. On the other hand, resistance against this hard fork and some miners who
    decided to keep mining on the original chain resulted in the creation of Ethereum
    Classic. This chain is the original, non-forked Ethereum blockchain where *the
    code is still the law*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: This attack highlights the dangers of not formally and thoroughly testing smart
    contracts. It also highlights the absolute need to develop a formal language for
    development and verification of smart contracts. The attack also highlighted the
    importance of thorough testing to avoid the issues that the DAO experienced. There
    have been various vulnerabilities discovered in Ethereum recently around the smart
    contract development language. Therefore, it is of utmost importance that a standard
    framework is developed to address all these issues. Some work has already begun,
    for example, an online service at [https://securify.ch](https://securify.ch),
    which provides tools to formally verify smart contract. However, this area is
    ripe for more research to address limitations in smart contract languages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by introducing a history of smart contracts and was followed
    by a detailed discussion on the definition of a smart contract. As there is no
    agreement on the standard definition of a smart contract, we attempted to introduce
    a definition that encompasses the crux of smart contracts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Ricardian contracts was also provided, and the difference
    between Ricardian contracts and smart contracts was explained, highlighting the
    fact that Ricardian contracts are concerned with the definition of the contract
    whereas smart contracts are geared towards the actual execution of the contract.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The concept of smart contract templates was discussed, on the subject of which
    high-quality active research is currently being conducted in academia and industry.
    Some ideas about the possibility of creating high-level domain-specific languages
    were also discussed to create smart contracts or smart contract templates. In
    the later sections of the chapter, the concepts of Oracles were introduced followed
    by a brief discussion on the DAO, and security issues in DAO and smart contracts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了智能合约模板的概念，针对该主题，学术界和行业正在进行高质量的积极研究。 还讨论了创建高级领域特定语言来创建智能合约或智能合约模板的可能性。 在本章的后续部分中，介绍了Oracle的概念，随后简要讨论了DAO以及DAO和智能合约中的安全问题。
- en: Discussion regarding formal verification and security of smart contracts will
    be presented later in this book in [Chapter 16](d0ef443d-d4b0-4afb-91f4-c5863ea1cf43.xhtml),
    *Scalability and Other Challenges.*
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论智能合约的形式验证和安全性将在本书的[第16章](d0ef443d-d4b0-4afb-91f4-c5863ea1cf43.xhtml) *可扩展性及其他挑战*
    中介绍。
- en: In the next chapter, you will be introduced to the concepts, theory, and practical
    aspects of *symmetric cryptography*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将介绍*对称加密*的概念、理论和实际方面。
