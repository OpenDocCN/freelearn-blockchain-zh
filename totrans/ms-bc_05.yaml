- en: Chapter 5. Alternative Coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the initial success of bitcoin, many alternative currency projects have
    been launched. Bitcoin was released in 2009 and the first alternative coin project
    (named Namecoin) was introduced in 2011\. In 2013 and 2014, the altcoin market
    grew exponentially and many different types of alternative coin project were started.
    A few of those became a success, whereas many were unpopular and did not succeed.
    A few were *pump and dump* scams that surfaced for some time but soon disappeared.
    Alternative approaches to bitcoin can be divided broadly into two categories,
    based on the primary purpose of their development. If the primary purpose is to
    build a decentralized blockchain platform, they are called alternative chains;
    if the sole purpose of the alternative project is to introduce a new virtual currency,
    it's called an altcoin. Alternative blockchains will be discussed in detail in
    later chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is mainly dedicated to alternative coins (altcoins) whose main
    purpose is to introduce a new virtual currency (coin) although some material will
    also be presented on the topic of alternate protocols built on top of bitcoin
    in order to provide various services. These include concepts such as Namecoin,
    where the primary purpose is to provide decentralized naming and identity services
    instead of currency.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, as of late 2016, there are hundreds of altcoins on the market and
    they hold a certain monetary value. Many of these alternative projects are direct
    forks of bitcoin source code although some of those have been written from scratch.
    Some altcoins set out to address bitcoin limitations such as privacy. Some others
    offer different types of mining, changes in block times, and distribution schemes.
  prefs: []
  type: TYPE_NORMAL
- en: By definition an altcoin is generated in the case of a hard fork. If bitcoin
    has a hard fork then the other, older chain is effectively considered another
    coin. However there is no established rule as to which chain becomes the altcoin.
    This has happened recently with Ethereum, where a hard fork caused a new currency
    **ETC** (**Ethereum classic**) to come into existence in addition to the **Ethereum**
    (**ETH**) currency. Ethereum classic is the old chain and Ether is the new chain
    after the fork. Such a contentious hard fork is not desirable for a number of
    reasons. First it is against the true spirit of decentralization as the Ethereum
    foundation, a central entity, decided to go ahead with the hardfork even though not
    everyone agreed to the proposition; second it also splits the user community due
    to disagreement over the hard fork. Although a hard fork in theory generates an
    altcoin, it is limited in what it can offer due to the fact that, even if the
    change results in a hard fork, usually there are no drastic changes around the
    fundamental parameters of the coin. They usually remain the same. For this reason,
    it is desirable to either write a new coin from scratch or fork the bitcoin (or
    another coin's source code) to create a new currency with the desired parameters
    and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Altcoins must be able to attract new users, trades, and miners otherwise the
    currency will have no value. Currency gains its value, especially in the virtual
    currency space, due to the network effect and its acceptability by the community.
    If a coin fails to attract enough users then soon it will be forgotten. Users
    can be attracted by providing an initial amount of coins and can be achieved by
    using various methods. Methods of providing an initial number of altcoins are
    discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new blockchain**: Altcoins can create a new blockchain and allocate
    coins to initial miners but this approach is now unpopular due to many scam schemes
    or *pump and dump* schemes where initial miners made a profit with the launch
    of a new currency and then disappeared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proof of burn**: Another approach to allocating initial funds to a new altcoin
    is *Proof of burn*, also called a one-way peg or price ceiling. In this method
    users permanently destroy a certain quantity of bitcoins in proportion to the
    quantity of altcoins to be claimed. For example if 10 bitcoins were destroyed
    then altcoins can have a value no greater than the amount of bitcoins destroyed.
    This basically means that bitcoins are being *converted* into altcoins by burning
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proof of Ownership**: Instead of permanently destroying bitcoins, an alternative
    method is to prove that users own a certain number of bitcoins. This proof of
    ownership can be used to claim altcoins by tethering altcoin blocks to bitcoin
    blocks. For example, this can be achieved by merged mining in which effectively
    bitcoin miners can mine altcoin blocks while mining for bitcoin without any extra
    work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pegged sidechains**: Sidechains, as the name suggests, are blockchains separate
    from the bitcoin network but bitcoins can be transferred to them. Altcoins can
    also be transferred back to the bitcoin network. This concept is called a two-way
    peg.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Investing and trading these alternative coins is also a big business, albeit
    not as big as bitcoin but enough to attract new investors and traders and provide
    liquidity to the market. Combined altcoin market capitalization is shown as follows
    in the graph generated from [http://coinmarketcap.com](http://coinmarketcap.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alternative Coins](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows that at the time of writing the Combined Altcoin Market Capitalization
    is more than 2 billion US Dollars
  prefs: []
  type: TYPE_NORMAL
- en: 'Current market cap (as of Oct 2016) of the top 10 coins is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alternative Coins](img/5975_table.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data is taken from https://coinmarketcap.com/
  prefs: []
  type: TYPE_NORMAL
- en: There are various factors and new concepts introduced with alternative coins.
    Many concepts were invented even before bitcoin but with bitcoin not only were
    new concepts, such as a solution to the Byzantine Generals' problem, introduced
    for the first time but also previous concepts such as hashcash and Proof of Work
    were used in an ingenious way and came into the limelight. Since then, with the
    introduction of alternative coin projects, various new techniques and concepts
    have been developed and introduced. In order to appreciate the current landscape
    of alternative cryptocurrencies, it is essential to understand some theoretical
    concepts first. In the following section, some new concepts that have been introduced
    with altcoin projects are introduced to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretical foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, various theoretical concepts are introduced to the reader that
    have been developed with the introduction of different altcoins in the past few
    years.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Proof of Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Proof of Work** (**PoW**) scheme in the context of cryptocurrency was
    first used in bitcoin and served as a mechanism to provide assurance that a miner
    had completed the required number of work in order to find a block. This in return
    provided decentralization, security, and stability for the blockchain. Also, this
    is the main vehicle in bitcoin for providing decentralized distributed consensus.
    PoW schemes are required to have a much desired property called *progress freeness*,
    which basically means that the reward for consuming computational resources should
    be random and proportional to the contribution made by the miners. In this case,
    some chance of winning the block reward is given to even those miners who have
    comparatively less computational power. The term *progress freeness* was introduced
    by *Arvind Narayanan .et.al* in the book *Bitcoin and Cryptocurrency Technologies*.
    Other requirements for mining computational puzzles include adjustable difficulty
    and quick verification. Adjustable difficulty ensures that the difficulty target
    for mining on the blockchain is regulated in response to increased hashing power
    and the number of users. Quick verification is a property which means that mining
    computational puzzles should be easy and quick to verify. Another aspect of the
    PoW scheme, especially the one used in Bitcoin (Double SHA-256), is that since
    the introduction of ASICs the power is shifting towards miners or mining pools
    who can afford to operate large-scale ASIC farms and this challenges the core
    philosophy of the decentralization of bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few alternatives that have been proposed such as ASIC-resistant
    puzzles and are designed in such a way that building ASICs for solving this puzzle
    is infeasible and does not result in a major performance gain over commodity hardware.
    A common technique used for this purpose is to apply a class of computational
    hard problems called *memory hard* computational puzzles. The core idea behind
    this method is that as puzzle solving requires a large amount of memory, it is
    not feasible to be implemented on ASIC-based systems. This technique was initially
    used in litecoin and Tenebrix where the Scrypt hash function was used as an ASIC-resistant
    PoW scheme. Even though this scheme was initially advertised as ASIC resistant,
    recently Scrypt ASICs have now become available disproving the original claim
    by litecoin.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to ASIC resistance is where multiple hash functions are required
    to be calculated in order to provide PoW. This is also called a chained hashing
    scheme. The rationale behind this idea is that designing multiple hash functions
    on an ASIC is not very feasible. The most common example is the X11 memory hard
    function implemented in Dash. X11 comprises 11 SHA3 contestants where one algorithm
    outputs the calculated hash to the next algorithm until all 11 algorithms are
    used in a sequence. These algorithms include blake, bmw, groestl, jh, keccak,
    skein, luffa, cubehash, shavite, simd, and echo.
  prefs: []
  type: TYPE_NORMAL
- en: This approach did provide some resistance to ASIC development initially but
    now ASIC miners are available commercially and support mining of X11 and similar
    schemes. A recent example is ASIC Baikal Miner, which supports X11, X13, X14,
    and X15 mining. Other examples include miners such as iBeLink DM384M X11 miner
    and Pinidea X11 ASIC miner.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps another approach could be to design *self-mutating puzzles* that intelligently
    or randomly change the PoW scheme or its requirements as a function of time. This
    will make it almost impossible to be implemented in ASICs as it will require multiple
    ASICs to be designed for each function and also randomly changing schemes would
    be almost impossible to handle in ASICs. At the moment, it is unclear how this
    can be achieved practically.
  prefs: []
  type: TYPE_NORMAL
- en: PoW has various drawbacks and the biggest of all is energy consumption. It is
    estimated that the total electricity consumed by bitcoin miners will be equivalent
    to that of Denmark by 2020\. This is huge and all that power is in a way wasted;
    in fact no useful purpose is served except for of mining. Environmentalists have
    raised real concerns about this situation.
  prefs: []
  type: TYPE_NORMAL
- en: It has been proposed that PoW puzzles can be designed in such a way that they
    serve two purposes. First their primary purpose is in consensus mechanisms and
    second to perform some useful scientific computation. This way not only can the
    schemes be used in mining but they can also help to potentially solve other scientific
    problems too. This proof of useful work has been recently put into practice by
    Primecoin where the requirement is to find special prime number chains known as
    Cunningham chains and bi-twin chains. As the study of prime number distribution
    has special significance in scientific disciplines such as physics, by mining
    Primecoin miners not only achieve the block reward but also help in finding the
    special prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also known as proof of irretrievability, this is another type of proof of useful
    work that requires storage of large number of data. Introduced by Microsoft Research,
    this scheme provides a useful benefit of distributed storage of archival data.
    Miners are required to store a pseudo, randomly-selected subset of large data
    in order to perform mining.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This proof is also called virtual mining. This is another type of mining puzzle
    that has been proposed as an alternative to traditional PoW schemes. It was first
    proposed in PeerCoin in August, 2012\. In this scheme, the idea is that users
    are required to demonstrate possession of a certain amount of currency (coins)
    thus proving that they have a stake in the coin. The simplest form of stake is
    where mining is made comparatively easier for those users who demonstrably own
    larger amounts of digital currency. The benefits of this scheme are twofold; first
    acquiring large amounts of digital currency is relatively difficult as compared
    to buying high-end ASIC devices and second it results in saving computational
    resources. Various forms of stake have been proposed and are briefly discussed
    below.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of coinage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The age of a coin is the time since the coins were last used or held. This is
    a different approach from the usual form of Proof of Stake where mining is made
    easier for users who have the highest stake in the altcoin. In the coin-age-based
    approach the age of the coin (coinage) is reset every time a block is mined. The
    miner is rewarded for holding and not spending coins for a time period. This mechanism
    has been implemented in Peercoin combined with PoW in a creative way. The difficulty
    of mining puzzles (PoW) is inversely proportional to the coin-age, meaning that
    if miners consume some coin-age using *coin-stake* transactions then the PoW requirements
    are relieved.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of deposit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The core idea behind this scheme is that newly minted blocks by miners are made
    un-spendable for a certain period of time. More precisely the coins get locked
    for a set number of blocks during the mining operation. The scheme works by allowing
    miners to perform mining at the cost of freezing a certain number of coins for
    some time. This is a type of Proof of Stake.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of burn
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an alternate expenditure to computing power, proof of burn in fact destroys
    a certain amount of bitcoins in order to get equivalent altcoins. This is commonly
    used when starting up new coin projects as a means to provide a fair initial distribution.
    This can be considered an alternative mining scheme where the value of the new
    coins comes from the fact that previously a certain number of coins have been
    destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of activity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This scheme is a hybrid of PoW and Proof of Stake. In this scheme, blocks are
    initially produced by using PoW but then each block randomly assigns three stakeholders
    that are required to digitally sign it. The validity of subsequent blocks is dependent
    on the successful signing of previously randomly chosen blocks.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however a possible issue known as the *nothing at stake* problem where
    it would be trivial to create a fork of the blockchain. This is possible because
    in PoW appropriate computational resources are required to mine whereas in Proof
    of Stake there is no such requirement; as a result, an attacker can try to mine
    on multiple chains using the same coin.
  prefs: []
  type: TYPE_NORMAL
- en: Non-outsourceable puzzles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key motivation behind this puzzle is to develop resistance again the development
    of mining pools. Mining pools as previously discussed offer rewards to all participants
    in proportion to the computing power they consume. However, in this model the
    mining pool operator is a central authority to whom all the rewards go and who
    can enforce certain rules. Also, in this model all miners only trust each other
    because they are working towards a common goal together in the hope of the pool
    manager getting the reward. Non-outsourceable puzzles are a scheme that allows
    miners to claim rewards for themselves; consequently pool formation becomes unlikely
    due to inherent mistrust between anonymous miners.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty adjustment and retargeting algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another concept that has been introduced with the advent of bitcoin and altcoins
    is difficulty in retargeting algorithms. In bitcoin a difficulty target is calculated
    simply by the following equation; however other coins have either developed their
    own algorithms or implemented modified versions of the bitcoin difficulty algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T = Time previous * time actual / 2016 * 10 min*'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind difficulty regulation in bitcoin is that a generation of 2016
    blocks should take roughly around 2 weeks (inter-block time should be around 10
    minutes). If it takes longer than 2 weeks to mine 2016 blocks then the difficulty
    is decreased and if it takes less than two weeks to mine 2016 blocks then the
    difficulty is increased. When ASICs were introduced due to a high block generation
    rate the difficulty increased exponentially and that is one drawback of PoW algorithms
    that are not ASIC resistant. This leads to mining power centralization. This also
    poses another problem; if a new coin starts now with the same Proof of Work based
    on SHA256 as bitcoin uses, then it would be easy for a malicious user to just
    simply use an ASIC miner and control the entire network. This attack would be
    more practical if there is less interest in the new altcoin and someone decides
    to take over the network by consuming adequately high computing resources. This
    may not be a feasible attack if other miners with similar computing power also
    join the the altcoin network because then miners will be competing with each other.
    Also, multipools pose a greater threat where a group of miners can automatically
    switch to the currency that is becoming profitable. This phenomenon is known as
    **pool hopping** and can adversely affect a blockchain, and consequently the growth
    of the altcoin. Pool hopping impacts the network adversely because pool hoppers
    join the network only when the difficulty is low and they can gain quick rewards;
    the moment difficulty goes up (or is readjusted) they *hop off* and then come
    back again when the difficulty is adjusted back. For example if a multipool consumes
    its resources in quickly mining a new coin, the difficulty will increase very
    quickly; when the multipool leaves the currency network; it becomes almost unusable
    because of the fact that now the difficulty has increased to such a level that
    it is no longer profitable for solo miners and can no longer be maintained. The
    only fix for this problem is to initiate a hard fork which is usually undesirable
    for the community.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few algorithms that have come into existence to address this issue
    and are discussed later. All these algorithms are based on the idea of readjusting
    various parameters in response to hash rate changes; these parameters include the
    number of previous blocks, difficulty of previous blocks, ratio of adjustment,
    and the number by which the difficulty can be readjusted back or up. In the following
    section, readers will be introduced to the few difficulty algorithms being used
    in and proposed for various altcoins.
  prefs: []
  type: TYPE_NORMAL
- en: Kimoto Gravity Well
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This algorithm is used in various altcoins to regulate difficulty. This was
    first introduced in Megacoin and used to adaptively adjust difficulty of the network
    every block. The logic of the algorithm is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*KGW = 1 + (0.7084 * pow((double(PastBlocksMass)/double(144)), -1.228))*'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the algorithm runs in a loop that goes through a set of predetermined
    blocks (`PastBlockMass`) and calculates a new readjustment value. The core idea
    behind this algorithm is to develop an adaptive difficulty regulation mechanism
    that can readjust the difficulty in response to rapid spikes in hash rates. **Kimoto
    Gravity Well** (**KGW**) ensures that the time between blocks remains approximately
    the same. In bitcoin the difficulty is adjusted every 2016 blocks but in KGW the
    difficulty is adjusted at every block.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is vulnerable to time warp attacks, which allow an attacker to
    temporarily enjoy less difficulty in creating new blocks. This attack allows a
    time window where the difficulty becomes low and the attacker can easily generate
    many coins at a fast rate.
  prefs: []
  type: TYPE_NORMAL
- en: Dark Gravity Wave
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dark Gravity Wave** (**DGW**) is a new algorithm designed to address certain
    flaws such as the time warp attack in the KGW algorithm. This was first introduced
    in Dash, previously known as Darkcoin. It makes use of multiple exponential moving
    averages and simple move averages to achieve a smoother readjustment mechanism.
    The formula is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2222222/ (((Difficulty+2600)/9)^2)*'
  prefs: []
  type: TYPE_NORMAL
- en: This formula is implemented in Dash coin and various other altcoins as a mechanism
    to readjust difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: DGW version 3.0 is the latest implementation of this algorithm and allows improved
    difficulty retargeting compared to KGW.
  prefs: []
  type: TYPE_NORMAL
- en: DigiShield
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another difficulty retargeting algorithm that has recently been used
    in Zcash with slight variations and after adequate experimentation. This algorithm
    works by going through a fixed number of previous blocks to calculate the time
    they took to be generated and then readjusts the difficulty to the difficulty
    of the previous block by dividing the actual time span by averaging the target
    time. In this scheme, the retargeting is calculated much much rapidly and also
    the recovery from a sudden increase or decrease in hashrate is quick. This algorithm
    protects against multipools, which can result in rapid hashrate increases. The
    network difficulty is readjusted every block or every minute depending on the
    implementation. The key innovation is faster readjust times as compared to KGW.
  prefs: []
  type: TYPE_NORMAL
- en: MIDAS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Multi Interval Difficulty Adjustment System** (**MIDAS**) is an algorithm that
    is comparatively more complex than the algorithms discussed previously. This method
    responds much more rapidly to abrupt changes in hash rates. This algorithm also
    provides protection against time warp attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Many currencies have emerged as an attempt to address various limitations in
    bitcoin. A brief discussion of bitcoin limitations is provided as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various limitations in bitcoin have also sparked some interest in altcoins,
    which were developed specifically to address limitations in bitcoin. The most
    prominent and widely discussed limitation is the lack of anonymity in bitcoin.
    This limitation is discussed in detail as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy and anonymity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the blockchain is a public ledger of all transactions and is openly available
    it becomes trivial to analyse it. Combined with traffic analyses, transactions
    can be linked back to their source IP addresses, thus possibly revealing a transaction's
    originator. This is a big concern from a privacy point of view. Even though in
    bitcoin it is a recommended and common practice to generate a new address for
    every transaction, thus allowing some level of unlinkability, this is not enough
    and various techniques have been developed and successfully used to trace the
    flow of transactions throughout the network and link them back to their originator.
    Various methods to analyse blockchains such as transaction graphs, address graphs,
    and entity graphs have been used by researchers to link users to the transactions,
    thus raising privacy concerns. The afore mentioned analysis techniques can be
    further enriched by using publicly available information about transactions and
    linking them to the actual users. There are open source block parsers available
    that can be used to extract transaction information, balances, and scripts from
    the blockchain database. A parser available at [https://github.com/mikispag/rusty-blockparser](https://github.com/mikispag/rusty-blockparser) is
    written in Rust and provides advanced blockchain analysis capabilities. An earlier
    version of this work is called BitIodine but is no longer being actively developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various proposals have been made to address the privacy issue in bitcoin. These
    proposals fall into three categories: mixing protocols, third-party mixing networks,
    and inherent anonymity. A brief discussion of each category is presented as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: Mixing protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These schemes are used to provide anonymity to bitcoin transactions. In this
    model, a mixing service provider (an intermediary or a shared wallet) is used.
    Users send coins to this shared wallet as a deposit and the shared wallet then
    can send some other coins (of the same value deposited by some other users) to
    the destination. Users can also receive coins that were sent by others via this
    intermediary. This way the link between outputs and inputs is no longer there
    and transaction graph analysis will not be able to reveal the true relationship
    between senders and receivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'CoinJoin is one example of mixing protocols, where two transactions are joined
    together to form a single transaction while keeping the inputs and outputs unchanged.
    The core idea behind CoinJoin is to build a shared transaction that is signed
    by all participants. This technique improves privacy for all participants involved
    in the transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixing protocols](img/B05975_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CoinJoin transaction with three users joining their transaction into a single
    larger CoinJoin transaction
  prefs: []
  type: TYPE_NORMAL
- en: Third-party mixing protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various third-party mixing services are available but if the service is centralized
    then it poses the threat of tracing the mapping between senders and receivers,
    because the mixing service knows about all inputs and outputs. In addition to
    this, fully centralized miners even pose the risk of the administrators of the
    service stealing the coins.
  prefs: []
  type: TYPE_NORMAL
- en: Various services, with varying degrees of complexity, such as CoinShuffle, Coinmux,
    and dark send in Dash (coin) are available that are based on the idea of CoinJoin
    (mixing) transactions. CoinShuffle is a decentralized alternative to traditional
    mixing services as it does not require a trusted third party.
  prefs: []
  type: TYPE_NORMAL
- en: CoinJoin-based schemes, however, have some weaknesses, most prominently the
    possibility of launching a Denial of Service attack by users who committed to
    signing the transactions initially but now are not providing their signature,
    thus delaying or stopping joint transaction a altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Inherent anonymity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This category includes coins that support privacy inherently and is built into
    the design of the currency. The most popular is Zcash, which is discussed in detail
    later in the chapter. Other examples include Monero, which makes use of ring signatures
    to provide anonymous services.
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces various enhancements that have been made, or are
    proposed, in order to extend the bitcoin protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Extended protocols on top of bitcoin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several protocols have been proposed and implemented on top of bitcoin in order
    to enhance and extend the bitcoin protocol and use for various other purposes
    instead of just as a virtual currency.
  prefs: []
  type: TYPE_NORMAL
- en: Colored coins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Colored coins is a set of methods that have been developed to represent digital
    assets on the bitcoin blockchain. Coloring a bitcoin refers colloquially to updating
    it with some metadata representing a digital asset (smart property). The coin
    still works and operates as a bitcoin but additionally carries some metadata that
    represents some assets. This mechanism allows issuing and tracking specific bitcoins.
    Metadata can be recorded using the bitcoins `OP_RETURN` opcode or optionally in
    multi-signature addresses. This metadata can also be encrypted if required to
    address any privacy concerns. Colored coins can be used to represent a multitude
    of assets including but not limited to commodities, certificates, shares, bonds,
    and voting. It should also be noted that, in order to work with colored coins,
    a wallet that interprets colored coins is necessary and normal bitcoin wallets
    will not work. Colored coin wallets can be set up online using a service available
    at [https://www.coinprism.com/](https://www.coinprism.com/). Using this service,
    any type of digital asset can be created and issued via a colored coin.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of colored coins is very appealing as it does not require any modification
    to the existing bitcoin protocol and can make use of the already existing secure
    bitcoin network. In addition to the traditional representation of digital assets,
    there is also the possibility of creating *smart assets* that behave according
    to the parameters and conditions defined for them. These parameters includes time
    validation, restrictions on transferability, and fees. This opens the possibility
    of creating smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: A major use case can be the issuance of financial instruments on the blockchain.
    This will ensure low transaction fees, valid and mathematically secure proof of
    ownership, fast transferability without requiring an intermediary, and instant
    dividend pay outs to the investors.
  prefs: []
  type: TYPE_NORMAL
- en: A rich API is available for coloured coins at [http://coloredcoins.org/](http://coloredcoins.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Counterparty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another service that can be used to create custom tokens that act as
    a cryptocurrency and can be used for various purposes such as issuing digital
    assets on top of bitcoin blockchain. This is quite a powerful platform and runs
    on bitcoin blockchains at their core but has developed its own client and other
    components to support issuing digital assets. The architecture consists of a counterparty
    server, counterblock, counter wallet, and armory_utxsvr. Counterparty works based
    on the same idea as coloured coins by embedding data into regular bitcoin transactions
    but provides a much richer library and set of powerful tools to support the handling
    of digital assets. This embedding is also called embedded consensus because the
    counterparty transactions are embedded within bitcoin transactions. The method
    of embedding the data is by using `OP_RETURN` opcode in bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: The currency produced and used by counterparty is known as XCP and is used by
    smart contracts as the fee for running the contract. At the time of writing its
    price is 2.78 USD. XCPs were created by using the proof of burn method discussed
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Counterparty allows the development of smart contracts on Ethereum using solidity
    language and allows interaction with bitcoin blockchain. In order to achieve this,
    BTC Relay is used as a means to provide interoperability between Ethereum and
    bitcoin. This is a clever concept where Ethereum contracts can talk to bitcoin
    blockchain and transactions through BTC Relay. The relayers (nodes that are running
    BTC Relay) fetch the bitcoin block headers and relay them to a smart contract
    on the Ethereum network that verifies the PoW. This process verifies that a transaction
    has occurred on the bitcoin network. This is available at [http://btcrelay.org/](http://btcrelay.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, this is basically an Ethereum contract that is capable of storing
    and verifying bitcoin block headers just like bitcoin simple payment verification
    lightweight clients do by using bloom filters. SPV clients were discussed in detail
    in the previous chapter. The idea can be visualized with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counterparty](img/B05975_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: BTC relay concept
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Counterparty is available at [http://counterparty.io/](http://counterparty.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Development of altcoins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Altcoin projects can be started very easily from a coding point of view by simply
    forking the bitcoin or another coin's source code but this probably is not enough.
    When a new coin project is started, there are several things that need to be considered
    in order to ensure a successful launch and the coin's longevity. Usually, the
    code base is written in C++ as was the case with bitcoin but almost any language
    can be used to develop coin projects, for example Golang or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code or forking the code for an existing coin is the trivial part, the
    challenging issue is how to start a new currency so that new investors and users
    can be attracted to it. Generally, the following steps are taken in order to start
    a new coin project.
  prefs: []
  type: TYPE_NORMAL
- en: From a technical point of view, in the case of forking the code of another coin,
    for example bitcoin, there are various parameters that can be changed to effectively
    create a new coin. These parameters are required to be *tweaked* or introduced
    in order to create a new coin. These parameters can include but are not limited
    to the following.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a choice of consensus algorithm: **Proof of Work** (**PoW**) as used
    in bitcoin or **Proof of Stake** (**PoS**), as in Peercoin.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is either SHA256, Scrypt, X11, X13, X15, or any other hashing algorithm
    that is adequate for use as a consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty adjustment algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various options are available in this category to provide difficulty retargeting
    mechanisms. The most prominent examples are KGW, DGW, Nite's Gravity Wave, and
    DigiShield. Also all these algorithms can be tweaked based on requirements to
    produce different results; therefore many variants are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-block time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the time elapsed between the generation of each block. For bitcoin the
    blocks are generated every 10 minutes, for litecoin it's 2.5 minutes. Any value
    can be used but an appropriate value is usually between a few minutes; if the
    generation time is too fast it might destabilize the blockchain, if it's too slow
    it may not attract many users.
  prefs: []
  type: TYPE_NORMAL
- en: Block rewards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A block reward is for the miner who solves the mining puzzle and is allowed
    to have a Coinbase transaction that contains the reward. This used to be 50 coins
    in bitcoin initially and now many altcoins set this parameter to a very high number;
    for example in Dogecoin it is 10,000, currently.
  prefs: []
  type: TYPE_NORMAL
- en: Reward halving rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another important factor; in bitcoin it is halved every 4 years and
    now is set to 12.5 bitcoins. It's a variable number that can be set to any time
    period or none at all depending on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Block size and transaction size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another important factor that determines how high or low the transaction
    rate can be on the network. Block sizes in bitcoin are limited to 1 MB but in
    altcoins it can vary depending on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Interest rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property applies only to PoS systems where the owner of the coins can earn
    interest at a rate defined by the network in return for the amount of coins that
    are held on the network as a PoS to protect the network.
  prefs: []
  type: TYPE_NORMAL
- en: Coin age
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This parameter defines how long the coin has to remain unspent in order for
    it to become eligible to be considered stakeworthy.
  prefs: []
  type: TYPE_NORMAL
- en: Total supply of coins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This number sets the total limit of the coins that can ever be generated. For
    example in bitcoin the limit is 21 million, whereas in Dogecoin it's unlimited.
    This limit is fixed by the block reward and halving schedule discussed above.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options to create your own virtual currency: forking existing
    established cryptocurrency source code or writing a new one from scratch. The
    latter option is less popular but the first option is easier and has allowed the
    creation of many virtual currencies over the last few years. Fundamentally, the
    idea is that first a cryptocurrency source code is forked and then appropriate
    changes are made at different strategic locations in the source code to effectively
    create a new currency.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, readers are introduced to some altcoin projects. It is
    not possible to cover all alternative currencies in this chapter, but a few selected
    coins are discussed below. Selection is based on longevity, market cap, and innovation.
    Each coin is discussed from different angles such as theoretical foundations,
    trading, and mining.
  prefs: []
  type: TYPE_NORMAL
- en: Namecoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namecoin is the first fork of the bitcoin source code. The key idea behind Namecoin
    is not to produce an altcoin but instead to provide improved decentralization,
    censorship resistance, privacy, security, and faster decentralized naming. Decentralized
    naming services are intended to provide a response to inherent limitations such
    as slowness and centralized control in the traditional **Domain Name System**
    (**DNS**) protocols used on the Internet. Namecoin is also the first solution
    to Zooko's triangle, which was briefly discussed in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Namecoin is used to essentially provide a service to register a key/value pair.
    One major use case of Namecoin is that it can provide a decentralized **Transport
    Layer Security** (**TLS**) certificate validation mechanism, driven by blockchain-based
    distributed and decentralized consensus.
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the same technology introduced with bitcoin, but with its own
    blockchain and wallet software. The source code for the Namecoin core is available
    at [https://github.com/namecoin/namecoin-core](https://github.com/namecoin/namecoin-core).
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Namecoin provides the following three services:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure storage and transfer of names (keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attachment of some value to the names by attaching up to 520 bytes of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production of a digital currency (Namecoin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Namecoin also for the first time introduced merged mining, which allows a miner
    to mine on more than one chain simultaneously. The idea is simple but very effective:
    miners create a Namecoin block and produce a hash of that block. Then the hash
    is added to a bitcoin block and miners solve that block at equal to or greater
    than the Namecoin block difficulty in order to prove that enough work has been
    contributed towards solving the Namecoin block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely the Coinbase transaction is used to include the hash of the
    transactions from Namecoin (or any other altcoin). The mining task is to solve
    bitcoin blocks whose Coinbase scripSig contains a hash pointer to Namecoin (or
    any other altcoin) block. This is shown in the diagram below. If a miner manages
    to solve a hash at the bitcoin blockchain difficulty level, the bitcoin block
    is built and becomes part of the bitcoin network. In this case, the Namecoin hash
    is ignored by the bitcoin blockchain. On the other hand, if a miner solves a block
    at Namecoin blockchain difficulty level a new block is created in the Namecoin
    blockchain. The core benefit of this scheme is that all the computational power
    spent by the miners contributes towards securing both Namecoin and bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Namecoin](img/B05975_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Merged mining diagram
  prefs: []
  type: TYPE_NORMAL
- en: Trading Namecoins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current market cap of Namecoin is £2,736,537 as per [https://coinmarketcap.com/](https://coinmarketcap.com/)
    and it can be bought and sold at various exchanges such as [https://cryptonit.net/](https://cryptonit.net/).
    Various other exchanges can be found via a simple online search.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Namecoins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Namecoins can be mined independently, they are usually mined as
    part of bitcoin mining by utilizing the merged mining technique as explained above.
    This way Namecoin can be mined as a by-product of bitcoin mining. Solo mining
    is no longer profitable as is evident from the following difficulty graph; instead
    it is recommended to merge-mine, use a mining pool, or even use a cryptocurrency
    exchange to buy Namecoin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Namecoins](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Namecoin difficulty as shown at: https://bitinfocharts.com/comparison/difficulty-nmc.html'
  prefs: []
  type: TYPE_NORMAL
- en: Various mining pools such [https://slushpool.com](https://slushpool.com/) also
    offer the option of merged mining. This allows a miner to mine primarily bitcoin
    but also as a result earn Namecoin too.
  prefs: []
  type: TYPE_NORMAL
- en: Another method that can be used to quickly get some Namecoins is to swap your
    existing coins with Namecoins, for example, if you already have some bitcoins
    or an other cryptocurrency that can be used to exchange with Namecoin. An online
    service, [https://shapeshift.io/](https://shapeshift.io/), is available that provides
    this service. This service allows conversion from one cryptocurrency to another,
    using a simple user-friendly interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, paying BTC to receive NMC is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Namecoins](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once **Start Transaction** is clicked, the transaction starts and instructs
    the user to send the bitcoins to a specific bitcoin address. When the user sends
    the required amount, the conversion process starts as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Namecoins](img/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the process completes, the transactions can be viewed in the Namecoin
    wallet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining Namecoins](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It may take some time to confirm the transactions; until that time it is not
    possible to use the Namecoins to manage names. Once Namecoins are available in
    the wallet, the **Manage Names** option can be used to generate Namecoin records.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Namecoin records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namecoin records are in the form of key and value pairs. A name is a lower-case
    string of the form `d/examplename` whereas a value is a case-sensitive, UTF-8
    encoded JSON object with a maximum of 520 bytes. The name should be RFC1035 ([https://tools.ietf.org/html/rfc1035](https://tools.ietf.org/html/rfc1035))-compliant.
    A general namecoin name can be an arbitrary binary string up to 255 bytes long
    with, 1024-bits of associated identifying information. A record on a Namecoin
    chain is only valid for around 200 days or 36,000 blocks after which it needs
    to be renewed. Namecoin also introduced .bit top level domains that can be registered
    using Namecoin and can be browsed using specialized Namecoin-enabled resolvers.
    Namecoin wallet software as shown in the following screenshot can be used to register
    `.bit` domain names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name is entered and, after the **Submit** button is pressed, it will ask
    for configuration information such as DNS, IP, or Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating Namecoin records](img/image_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, **masteringblockchain** will register
    as `masteringblockchain.bit` on the Namecoin blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating Namecoin records](img/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Litecoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Litecoin is a fork of the bitcoin source code released in 2011\. It uses Scrypt
    as PoW, originally introduced in the Tenebrix coin. Litecoin allows for faster
    transactions as compared to bitcoin due to its faster block generation time of
    2.5 minutes. Also difficulty readjustment is achieved every 3.5 days roughly due
    to faster block generation time. The total coin supply is 84 million.
  prefs: []
  type: TYPE_NORMAL
- en: Scrypt is a sequentially memory hard function that is the first alternative
    to the SHA-256-based PoW algorithm. It was originally proposed as a password-based
    key derivation function `PBKDF`. The key idea is that if the function requires
    large number of memory to run then custom hardware such as ASICs will require
    more VLSI area, which would be unfeasible to build. The Scrypt algorithm requires
    a large array of pseudo random bits to be held in memory and a key is derived
    from this in a pseudo random fashion. The algorithm is based on a phenomenon called
    **Time-Memory Tradeoff** (**TMTO**). If memory requirements are relaxed then it
    results in increased computational cost. Put another way, TMTO shortens the running
    time of a programme if more memory is given to it. This tradeoff makes it unfeasible
    for an attacker to gain more memory because it's expensive and difficult to implement
    on custom hardware, or if the attacker chooses to not increase memory, then it
    results in the algorithm running slowly due to high processing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrypt uses the following parameters to generate a derived key (Kd):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Passphrase`: This is a string of characters to hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Salt`: This is a random string that is provided to Scrypt functions (generally
    all hash functions) in order to provide a defence against brute-force dictionary
    attacks using rainbow tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N`: This is a memory/CPU cost parameter that must be a power of 2 > 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P`: The parallelization parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R`: The block size parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dkLen`: The intended length of the derived key in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formally, this function can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kd = scrypt (P, S, N, P, R, dkLen)*'
  prefs: []
  type: TYPE_NORMAL
- en: Before applying the core Scrypt function, the algorithm takes `P` and `S` as
    input and applies **PBKDF2** and SHA-256-based HMAC. Then the output is fed to
    an algorithm called **ROMix,** which internally uses the Blockmix algorithm utilizing
    the Salsa20/8 core stream cipher to fill up the memory which requires large memory
    to operate, thus enforcing the sequentially memory hard property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this step of the algorithm is finally fed to the `PBKDF2` function
    again in order to produce a derived key. This process is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Litecoin](img/B05975_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scrypt algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Scrypt is used in litecoin mining with specific parameters where N= 1024, R
    = 1, P=1, and S= random 80 bytes producing a 256-bit output.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears that, due to the selection of these parameters, the development
    of ASICs for Scrypt for litecoin mining turned out to be not very difficult. In
    an ASIC for litecoin mining, a sequential logic can be developed that takes the
    data and nonce as input and applies the **PBKDF2** algorithm with **HMAC-SHA256**; then
    the resultant bit stream is fed into the `SALSA20/8` function which produces a
    hash that again is fed down to the `PBKDF2` and `HMAC-256` functions to produce
    a 256-bit hash output. As is the case with bitcoin PoW, in Scrypt also if the
    output hash is less that the target hash (already passed as input at the start,
    stored in memory, and checked with every iteration) then the function terminates;
    otherwise, the nonce is incremented and the process is repeated again until a hash
    is found that is lower than the difficulty target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Litecoin](img/B05975_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scrypt ASIC design simplified flowchart
  prefs: []
  type: TYPE_NORMAL
- en: '**Trading Litecoin**: As with other coins, trading litecoin is easily carried
    out on various online exchanges. The current market cap of litecoin is £161,239,005\.
    The current price of litecoin is £3.25/LTC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mining**: Litecoin mining can be carried out solo or in pools. At the moment,
    ASICs for Scrypt are available that are commonly used to mine litecoin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Litecoin mining on a CPU is no longer profitable as is the case with many other
    digital currencies. There are online cloud mining providers and ASIC miners available
    that can be used to mine litecoin. Litecoin mining started from the CPU, progressed
    through GPU mining rigs, and eventually now has reached a point where specialized
    ASIC miners such as Asic Scrypt Miner Wolf available from EhsMiner are now required
    to be used in the hope of being able to make some coins. Generally, it is true
    that even with ASICs it is better to mine in pools instead of solo as solo mining
    is not as profitable as mining in pools due to the proportional rewards scheme
    used by mining pools. These miners are capable of producing a hashing rate of
    2 Gh/s for Scrypt algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software source code and wallet**: The source code for litecoin is available
    at [https://github.com/litecoin-project/litecoin](https://github.com/litecoin-project/litecoin).
    The litecoin wallet can be downloaded from [https://litecoin.org/](https://litecoin.org/)
    and can be used just like the bitcoin core client software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primecoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primecoin is the first digital currency on the market that introduced a useful
    PoW, as opposed to bitcoin's SHA256-based PoW. Primecoin uses searching prime
    numbers as a PoW. Not all types of prime number meet the requirements to be selected
    as PoW. Three types of prime numbers (known as Cunningham chain of first kind,
    Cunningham chain of second kind, and bi-twin chains) meet the requirements of
    a PoW algorithm to be used in cryptocurrencies. The difficulty is dynamically
    adjusted via a continuous difficulty evaluation scheme in Primecoin blockchain.
    The efficient verification of PoW based on prime numbers is also of high importance,
    because if verification is slow then PoW is not suitable. Therefore prime chains
    are selected as a PoW because finding prime chains gets difficult as the chain
    increases in length whereas verification remains quick enough to warrant being
    used as an efficient PoW algorithm. It is also important that once a PoW has been
    verified on a block it must not be reusable on another block. This is accomplished
    in Primecoin by a combination of *Proof of Work certificates* and hashing it with
    the header of the parent block in the child block. The PoW certificate is produced
    by linking the prime chain to the block header hash. It also requires that the
    block header's origin is divisible by the block header hash. If it is, it is divided
    and after division the quotient is used as a PoW certificate. Another property
    of the adjustable difficulty of PoW algorithms is met by introducing difficulty
    adjustment every block instead of every 2,016, as is the case with bitcoin. This
    is a *smoother* approach as compared to bitcoin and allows readjustment in the
    case of sudden increases in hash power. Also the total number of coins generated
    is community-driven and there is no concrete limit on the number of coins Primecoin
    can generate.
  prefs: []
  type: TYPE_NORMAL
- en: Trading Primecoin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primecoins can be traded on major virtual currency trading exchanges. The current
    market cap of Primecoin is £828,002 at the time of writing. It is not very large
    but, due to the fact that Primecoin is based on a novel idea and there is a dedicated
    community behind it, this continues to hold some market share.
  prefs: []
  type: TYPE_NORMAL
- en: '![Trading Primecoin](img/image_05_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mining guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to download a wallet. Primecoin supports native mining within
    the wallet, just like original bitcoin clients, but also can be mined on the cloud
    via various online mining service providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick Windows guide is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download the Primecoin wallet from: [http://primecoin.io/index.php](http://primecoin.io/index.php).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the wallet is installed and synched with the network, mining can be started
    by following the next step. A debug window can be opened in the Primecoin wallet
    by clicking on the **Help** menu and selecting the **Debug** window menu item.
    Additional help can be invoked through typing `help` in the console window:![Mining
    guide](img/image_05_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug window used to enable the Primecoin mining function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the preceding commands are successfully executed mining will start in solo
    mode. This may not be very profitable but the miner can use mining pools available
    online:![Mining guide](img/image_05_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Primecoin wallet software, synching with the network
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Primecoin source code is available at [https://github.com/primecoin/primecoin](https://github.com/primecoin/primecoin).
    Although it''s a novel concept and the PoW that Primecoin has introduced does
    have scientific significance, it seems that no active development is being carried
    out to further develop Primecoin. Readers can further explore Primecoin by reading
    the Primecoin white paper by *Sunny King* (pseudonym) at: [http://primecoin.io/bin/primecoin-paper.pdf](http://primecoin.io/bin/primecoin-paper.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Zcash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zcash was launched on 28th of October, 2016\. This is the first currency that
    uses a specific type of zero knowledge proofs known as **zero-knowledge Succinct
    Non-interactive Arguments of Knowledge** (**zk-SNARKs**) to provide complete privacy
    to the user. These proofs are very short and easy to verify; however, setting
    up the initial public parameters is a complex process. The latter include two
    keys: the proving key and verifying key. The process requires sampling some random
    numbers in order to construct the public parameters. The issue is that these random
    numbers, also called *toxic waste*, must be destroyed after the parameter generation
    in order to prevent counterfeiting of Zcash. For this purpose, the Zcash team
    came up with a multi-party computation protocol to generate the required public
    parameters in a collaborative manner from independent locations to ensure that
    *toxic waste* is not created. Due to the fact that these public parameters are
    required to be created by the Zcash team, it means that the participants in the
    ceremony are trusted. This is the reason why the ceremony was very open and conducted
    by making use of a multi-party computation mechanism. This mechanism has a property
    whereby all of the participants in the ceremony will have to be compromised in
    order to compromise the final parameters. When the ceremony is completed all participants
    physically destroy the equipment used for private key generation. This action
    eliminates any trace of the participants'' part of the private key on the equipment.'
  prefs: []
  type: TYPE_NORMAL
- en: zk-SNARKs must satisfy the properties of completeness, soundness, succinctness,
    and non-interactivity. *Completeness* means that there is a definite strategy
    for a prover to satisfy a verifier that an assertion is true. On the other hand,
    *soundness* means that no prover can convince the verifier that a false statement
    is true. *Succinctness* means that messages passed between the prover and verifier
    are very small in size. Finally, the property non-interactive means that the verification
    of correctness of an assertion can be carried out without any interaction or very
    little interaction. Also, being a zero knowledge proof, the property of *zero-knowledge* (discussed
    in [Chapter 3](ch03.html "Chapter 3. Cryptography and Technical Foundations"),
    *Cryptography and Technical Foundations*) needs to be met too.
  prefs: []
  type: TYPE_NORMAL
- en: Zcash developers have introduced the concept of a **Decentralized Anonymous
    Payments scheme** (**DAP scheme**) that is used in the Zcash network to enable
    direct and private payments. The transactions reveal no information about the
    origin, destination, and amount of the payments. There are two types of addresses
    available in Zcash, z-addr and t-addr. Z addresses are based on zero knowledge
    proofs and provide privacy protection whereas T addresses are similar to those
    of bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zcash uses an efficient PoW scheme named **Asymmetric PoW** (**Equihash**),
    which is based on the Generalized Birthday Problem. It allows very efficient verification.
    It is a memory-hard and ASIC-resistant function. A novel idea (initial slow mining)
    has been introduced with Zcash, which means that the block reward increases gradually
    over a period of time until it reaches the 20,000^(th) block. This allows for
    initial scaling of the network and experimentation by early miners, and adjustment
    by Zcash developers if required. The slow start did have an impact on price due
    to scarcity as the price of ZEC on its first day of launch reached roughly 25,000
    USD. A slightly modified version of the Digishield difficulty adjustment algorithm
    has been implemented in Zcash. The formula is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(next difficulty) = (last difficulty) x SQRT [ (150 seconds) / (last solve
    time) ]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A snapshot of various attributes of Zcash (after an initial slow start) is
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Zcash](img/5975_table2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trading Zcash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Zcash can be bought on major digital currency exchanges. At the time of writing,
    the price of Zcash is very high. As shown in the following graph, the price soared
    as high as approximately 10 bitcoins per Zcash. Some exchanges carried out orders
    as high as 2,500 BTC per ZEC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trading Zcash](img/image_05_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mining guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple methods to mine Zcash. Currently, CPU and GPU mining are
    possible. Various commercial cloud mining pools also offer contracts for mining
    Zcash. In order to perform solo mining using a CPU, the following steps can be
    followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install prerequisites using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the prerequisites are already installed, a message will display indicating
    that components are already the newest version. If not already installed or older
    than the latest package, then the installation will continue, the required packages
    will be downloaded, and the installation will be completed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, run the commands to clone Zcash from `git` as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will clone the Zcash git repository locally. The output is shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Mining guide](img/image_05_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The next step is to download proving and verifying keys, by using the following
    command from the screenshot:![Mining guide](img/image_05_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this command runs it will download around 911 MBs of keys into the `~/.zcash-params/`
    directory. The directory contains files for proving and verifying keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the preceding commands are completed successfully, the source code can
    be built using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will produce very long output; if everything goes well it will produce
    a `zcashd` binary file. Note that this command takes `nproc` as the parameter,
    which is basically a command that finds the number of cores or processors in the
    system and displays that number. If you don't have that command then replace `nproc`
    with the number of processors in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Once the build is completed, the next step is to configure Zcash. This is achieved
    by creating a configuration file with the name `zcash.conf` in the `~/.zcash/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample configuration file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration enables various features. The first line adds the
    mainnet node and enables mainnet connectivity. `rpcuser` and `rpcpassword` are
    the username and password for the RPC interface. `gen = 1` is used to enable mining.
    `genproclimit` is the number of processors that can be used for mining. The last
    line enables a faster mining solver; this is not required if you want to use standard
    CPU mining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now Zcash can be started using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once started this will allow interaction with the RPC interface via the Zcash-cli
    command-line interface. This is almost the same as the bitcoin command-line interface.
    Once the Zcash daemon is up-and-running, various commands can be run to query
    different attributes of Zcash. Transactions can be viewed locally by using the
    CLI or via a blockchain explorer. A blockchain explorer for Zcash is available
    at: [https://explorer.zcha.in/](https://explorer.zcha.in/).'
  prefs: []
  type: TYPE_NORMAL
- en: Address generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New Z addresses can be generated using the command below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the Zcash-cli command with the `getinfo` parameter produces the output
    shown in the following screenshot. It displays valuable information such as blocks,
    difficulty, and balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Address generation](img/image_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot displaying the output of getinfo
  prefs: []
  type: TYPE_NORMAL
- en: 'New T addresses can be generated using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: GPU mining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other than CPU mining, a GPU mining option is also available. There is no official
    GPU miner yet; however open source developers have produced various proofs of
    concepts and working miners. The Zcash Company held an open competition to encourage
    developers to build and submit CPU and GPU miners. No winning entry has been announced
    as of the time of writing. Readers can get more information by visiting the website,
    [https://zcashminers.org/](https://zcashminers.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another mining: using cloud mining contracts available from various
    online cloud mining providers. The cloud mining service providers perform mining
    on the customers'' behalf. In addition to cloud mining contracts, miners can use
    their own equipment to mine via mining pools using stratum or other protocols.
    One key example is Zcash pool by nice hash. Using this pool, miners can sell their
    hash power. An example of building and using a CPU miner on a Zcash mining pool
    is shown as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and compiling nheqminer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following steps can be used to download and compile `nheqminer` on an Ubuntu
    Linux distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the steps are completed successfully, nhequminer can be run using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Nhequminer releases are available for Windows at: [https://github.com/nicehash/nheqminer/releases](https://github.com/nicehash/nheqminer/releases).'
  prefs: []
  type: TYPE_NORMAL
- en: Nheqminer takes several parameters such as location (`-l`), username (`-u`),
    and the number of threads to be used for mining (`-t`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample run of Windows miner for Zcash is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and compiling nheqminer](img/image_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the BTC address to receive pay-outs for selling hash power
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and compiling nheqminer](img/image_05_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Zcash T address to receive pay-outs for selling hash power
  prefs: []
  type: TYPE_NORMAL
- en: This completes the introduction to Zcash; readers can explore more about Zcash
    online as it is very volatile at the moment and things can change very quickly.
    One thing is for sure; Zcash's zero knowledge proofs are a major innovation and
    they pave the way for future applications that require inherent privacy, such
    as banking, medicine, or the law.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, readers have been introduced to the overall cryptocurrency
    landscape. A few altcoins have been discussed in detail, especially Zcash and
    Namecoin. Cryptocurrencies are a very active area for research, especially around
    scalability, privacy, and security aspects. Some research has also been conducted
    in order to invent new difficulty retargeting algorithms in order to thwart the
    threat of centralization in cryptocurrencies. Further research can be carried
    out in the areas of privacy and specially scalability. Readers now should be able
    to appreciate the concept of altcoins and various motivations behind them. Some
    practical aspects, such as mining and starting a new currency project, have also
    been discussed, which hopefully will give readers a strong foundation and enable
    them to further explore these areas. Altcoins are a fascinating field of research
    and open a lot of possibilities for a decentralized future.
  prefs: []
  type: TYPE_NORMAL
