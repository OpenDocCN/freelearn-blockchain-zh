- en: Building a Wallet Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wallet service is used to send and receive funds. Major challenges for building
    a wallet service are security and trust. Users must feel that their funds are
    secure and the administrator of the wallet service doesn't steal their funds.
    The wallet service we will build in this chapter will tackle both these issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Difference between online and offline wallets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using hooked-web3-provider and ethereumjs-tx to make it easier to create and
    sign transactions using accounts not managed by an Ethereum node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what a HD wallet is and also its uses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HD wallet and a transaction signer using `lightwallet.js`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a wallet service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference between online and offline wallets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wallet is a collection of accounts, and an account is a combination of an
    address and its associated private key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A wallet is said to be an online wallet when it is connected to the Internet.
    For example, wallets stored in geth, any website/database, and so on are called
    online wallets. Online wallets are also called hot wallets, web wallets, hosted
    wallets, and so on. Online wallets are not recommended at least when storing large
    amounts of ether or storing ether for a long time because they are risky. Also,
    depending on where the wallet is stored, it may require trusting a third party.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: For example, most of the popular wallet services store the private keys of the
    wallets with themselves and allow you to access the wallet via an e-mail and password,
    so basically, you don't have actual access to the wallet, and if they want, they
    can steal the funds in the wallets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A wallet is said to be an offline wallet when it is not connected to the Internet.
    For example, wallets stored in pen drives, papers, text files, and so on. Offline
    wallets are also called cold wallets. Offline wallets are more secure than online
    wallets because to steal funds, someone will need physical access to the storage.
    The challenges with offline storage is that you need to find a location that you
    won't delete accidentally or forget, or nobody else can have access to. Many people
    store the wallet in paper and keep the paper in a safe locker if they want to
    hold some funds safely for a very long time. If you want to frequently send funds
    from your account, then you can store it in a password-protected pen drive and
    also in a safe locker. It is a little risker to store wallets in a digital device
    only because digital devices can corrupt anytime and you may lose access to your
    wallet; that's why along with storing in a pen drive, you should also put it in
    a safe locker. You can also find a better solution depending on your needs, but
    just make sure it's safe and that you accidentally don't lose access to it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: hooked-web3-provider and ethereumjs-tx libraries
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all the examples of Web3.js library's `sendTransaction()` method
    we saw were using the `from` address that's present in the Ethereum node; therefore,
    the Ethereum node was able to sign the transactions before broadcasting. But if
    you have the private key of a wallet stored somewhere else, then geth cannot find
    it. Therefore, in this case, you will need to use the `web3.eth.sendRawTransaction()`
    method to broadcast transactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '`web3.eth.sendRawTransaction()` is used to broadcast raw transactions, that
    is, you will have to write code to create and sign raw transactions. The Ethereum
    node will directly broadcast it without doing anything else to the transaction.
    But writing code to broadcast transactions using `web3.eth.sendRawTransaction()`
    is difficult because it requires generating the data part, creating raw transactions,
    and also signing the transactions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Hooked-Web3-Provider library provides us with a custom provider, which communicates
    with geth using HTTP; but the uniqueness of this provider is that it lets us sign
    the `sendTransaction()` calls of contract instances using our keys. Therefore,
    we don't need to create data part of the transactions anymore. The custom provider
    actually overrides the implementation of the `web3.eth.sendTransaction()` method.
    So basically, it lets us sign both the `sendTransaction()` calls of contract instances
    and also the `web3.eth.sendTransaction()` calls. The `sendTransaction()` method
    of contract instances internally generate data of the transaction and calls `web3.eth.sendTransaction()`
    to broadcast the transaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: EthereumJS is a collection of those libraries related to Ethereum. ethereumjs-tx
    is one of those that provide various APIs related to transactions. For example,
    it lets us create raw transactions, sign the raw transactions, check whether transactions
    are signed using proper keys or not, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Both of these libraries are available for Node.js and client-side JavaScript.
    Download the Hooked-Web3-Provider from [https://www.npmjs.com/package/hooked-web3-provider](https://www.npmjs.com/package/hooked-web3-provider),
    and download ethereumjs-tx from [https://www.npmjs.com/package/ethereumjs-tx](https://www.npmjs.com/package/ethereumjs-tx).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the latest version of Hooked-Web3-Provider
    is 1.0.0 and the latest version of ethereumjs-tx is 1.1.4.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use these libraries together to send a transaction from an
    account that's not managed by geth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is how the code works:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: At first, we created a `HookedWeb3Provider` instance. This is provided by the
    Hooked-Web3-Provider library. This constructor takes an object that has two properties,
    which must be provided. `host` is the HTTP URL of the node and `transaction_signer`
    is an object that the custom provider communicates with to get the transaction
    signed.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `transaction_signer` object has two properties: `hasAddress` and `signTransaction`.
    `hasAddress` is invoked to check whether the transaction can be signed, that is,
    to check whether the transaction signer has the private key of the `from` address
    account. This method receives the address and a callback. The callback should
    be called with the first argument as an error message and the second argument
    as `false` if the private key of the address is not found. And if the private
    key is found, the first argument should be `null`, and the second argument should
    be `true`.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transaction_signer`对象有两个属性：`hasAddress`和`signTransaction`。`hasAddress`被调用来检查交易是否可以签名，也就是检查交易签名者是否拥有`from`地址账户的私钥。该方法接收地址和一个回调函数。回调函数应该以错误消息作为第一个参数调用，而私钥如果未找到则应为`false`作为第二个参数。如果找到了私钥，那么第一个参数应该为`null`，第二个参数应为`true`。'
- en: If the private key for the address is found, then the custom provider invokes
    the `signTransaction` method to get the transaction signed. This method has two
    parameters, that is, the transactions parameters and a callback. Inside the method,
    at first, we convert the transaction parameters to raw transaction parameters,
    that is, the raw transaction parameters values are encoded as hexadecimal strings.
    Then we create a buffer to hold the private key. The buffer is created using the
    `EthJS.Util.toBuffer()` method, which is part of the `ethereumjs-util` library.
    The `ethereumjs-util` library is imported by the `ethereumjs-tx` library. We then
    create a raw transaction and sign it, after which we serialize and convert it
    to hexadecimal strings. Finally, we need to provide the hexadecimal string of
    the signed raw transaction to the custom provider using the callback. In case
    there is an error inside the method, then the first argument of the callback should
    be an error message.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了地址的私钥，那么自定义提供者将调用`signTransaction`方法来对交易进行签名。该方法有两个参数，即交易参数和一个回调。在方法内部，首先，我们将交易参数转换为原始交易参数，也就是将原始交易参数值编码为十六进制字符串。然后，我们创建一个缓冲区来保存私钥。该缓冲区是使用`EthJS.Util.toBuffer()`方法创建的，该方法是`ethereumjs-util`库的一部分。`ethereumjs-util`库是`ethereumjs-tx`库导入的。然后我们创建一个原始交易并对其进行签名，之后我们对其进行序列化并转换为十六进制字符串。最后，我们需要使用回调将签名的原始交易的十六进制字符串提供给自定义提供者。如果方法内部有错误，则回调的第一个参数应该是一个错误消息。
- en: Now the custom provider takes the raw transactions and broadcasts it using `web3.eth.sendRawTransaction()`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在自定义提供者获取原始交易并使用`web3.eth.sendRawTransaction()`来广播它。
- en: Finally, we call the `web3.eth.sendTransaction` function to send some ether
    to another account. Here, we need to provide all the transaction parameters except
    `nonce` because the custom provider can calculate nonce. Earlier, many of these
    were optional because we were leaving it to the Ethereum node to calculate them,
    but now as we are signing it ourselves, we need to provide all of them. The `gas`
    is always 21,000 when the transaction doesn't have any data associated with it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`web3.eth.sendTransaction`函数向另一个账户发送一些以太币。在这里，我们需要提供除了`nonce`之外的所有交易参数，因为自定义提供者可以计算nonce。之前，许多这些都是可选的，因为我们让以太坊节点来计算它们，但现在当我们自己签名时，我们需要提供所有这些。当交易没有任何与之关联的数据时，`gas`始终为21,000。
- en: '**What about the public key?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥呢？**'
- en: In the preceding code, nowhere did we mention anything about the public key
    of the signing address. You must be wondering how a miner will verify the authenticity
    of a transaction without the public key. Miners use a unique property of ECDSA,
    which allows you to calculate the public key from the message and signature. In
    a transaction, the message indicates the intention of the transaction, and the
    signature is used to find whether the message is signed using the correct private
    key. This is what makes ECDSA so special. ethereumjs-tx provides an API to verify
    transactions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们从未提及签名地址的公钥。你一定想知道矿工如何在没有公钥的情况下验证交易的真实性。矿工使用ECDSA的一个独特属性，该属性允许您从消息和签名中计算公钥。在交易中，消息指示了交易的意图，而签名用于确定消息是否使用了正确的私钥进行签名。这就是使ECDSA如此特殊的地方。ethereumjs-tx提供了一个API来验证交易。
- en: What is a hierarchical deterministic wallet?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是分层确定性钱包？
- en: A hierarchical deterministic wallet is a system of deriving addresses and keys
    from a single starting point called a seed. Deterministic indicates that for the
    same seed, the same addresses and keys will be generated, and hierarchical indicates
    that the addresses and keys will be generated in the same order. This makes it
    easier to back up and store multiple accounts, as you just have to store the seed,
    not the individual keys and addresses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分层确定性钱包是从称为种子的单个起始点派生地址和密钥的系统。 确定性意味着对于相同的种子，将生成相同的地址和密钥，并且分层意味着将以相同的顺序生成地址和密钥。
    这使得更容易备份和存储多个帐户，因为您只需要存储种子，而不需要存储单独的密钥和地址。
- en: '**Why will users need multiple accounts?**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么用户需要多个帐户？**'
- en: You must be wondering why users will need multiple accounts. The reason is to
    hide their wealth. The balance of accounts is available publicly in the blockchain.
    So, if user A shares an address with user B to receive some ether, then user B
    can check how much ether is present in that address. Therefore, users usually
    distribute their wealth across various accounts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么用户需要多个帐户。 原因是为了隐藏他们的财富。 帐户的余额是公开可见的。 因此，如果用户A与用户B共享一个地址来接收一些以太币，那么用户B可以查看该地址中有多少以太币。
    因此，用户通常会在各种帐户之间分配他们的财富。
- en: There are various types of HD wallets, which differ in terms of seed format
    and the algorithm to generate addresses and keys, for instance, BIP32, Armory,
    Coinkite, Coinb.in, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种类型的HD钱包，它们在种子格式和生成地址和密钥的算法方面有所不同，例如BIP32、Armory、Coinkite、Coinb.in等。
- en: '**What are BIP32, BIP44, and BIP39?**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是BIP32、BIP44和BIP39？**'
- en: A **Bitcoin Improvement Proposal** (**BIP**) is a design document providing
    information to the Bitcoin community, or describing a new feature for Bitcoin
    or its processes or environment. The BIP should provide a concise technical specification
    of the feature and a rationale for the feature. At the time of writing this book,
    there are 152 BIPS (Bitcoin Improvement Proposals). BIP32 and BIP39 provide information
    about an algorithm to implement an HD wallet and mnemonic seed specification respectively.
    You can learn more about these at [https://github.com/bitcoin/bips](https://github.com/bitcoin/bips).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特币改进提案**（**BIP**）是一份向比特币社区提供信息的设计文件，或者描述比特币或其流程或环境的新功能。 BIP应该提供对该功能的简明技术规范和功能的基本原理。
    在撰写本书时，有152个BIPS（比特币改进提案）。 BIP32和BIP39分别提供了有关实现HD钱包和助记种子规范的算法的信息。 您可以在[https://github.com/bitcoin/bips](https://github.com/bitcoin/bips)上了解更多信息。'
- en: Introduction to key derivation functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出密钥的功能简介
- en: Asymmetric cryptography algorithms define the nature of their keys and how the
    keys should be generated because the keys need to be related. For example, the
    RSA key generation algorithm is deterministic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密算法定义了其密钥的性质以及如何生成密钥，因为密钥需要相关联。 例如，RSA密钥生成算法是确定性的。
- en: Symmetric cryptography algorithms only define key sizes. It's up to us to generate
    the keys. There are various algorithms to generate these keys. One such algorithm
    is KDF.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法仅定义密钥大小。 生成密钥交给我们。 有各种算法来生成这些密钥。 这样的算法之一是KDF。
- en: A **key derivation function** (**KDF**) is a deterministic algorithm to derive
    a symmetric key from some secret value (such as master key, password, or passphrase).
    There are various types of KDFs, such as bcrypt, crypt, PBKDF2, scrypt, HKDF,
    and so on. You can learn more about KDFs at [https://en.wikipedia.org/wiki/Key_derivation_function](https://en.wikipedia.org/wiki/Key_derivation_function).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥派生函数**（**KDF**）是一种确定性算法，用于从某个秘密值（例如主密钥、密码或口令）派生对称密钥。 有各种类型的KDF，例如bcrypt、crypt、PBKDF2、scrypt、HKDF等。
    您可以在[https://en.wikipedia.org/wiki/Key_derivation_function](https://en.wikipedia.org/wiki/Key_derivation_function)上了解更多关于KDF的信息。'
- en: To generate multiple keys from a single secret value, you can concatenate a
    number and increment it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要从单个秘密值生成多个密钥，可以连接一个数字并递增它。
- en: A password-based key derivation function takes a password and generates a symmetric
    key. Due to the fact that users usually use weak passwords, password-based key
    derivation functions are designed to be slower and take a lot of memory to make
    it difficult to launch brute force attacks and other kinds of attacks. Password-based
    key derivation functions are used widely because it's difficult to remember secret
    keys, and storing them somewhere is risky as it can be stolen. PBKDF2 is an example
    of a password-based key derivation function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: A master key or passphrase is difficult to be cracked using a brute force attack;
    therefore, in case you want to generate a symmetric key from a master key or passphrase,
    you can use a non-password-based key derivation function, such as HKDF. HKDF is
    much faster compared to PBKDF2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Why not just use a hash function instead of KDFs?**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The output of hash functions can be used as symmetric keys. So you must be wondering
    what is the need for KDFs. Well, if you are using a master key, passphrase, or
    a strong password, you can simply use a hash function. For example, HKDF simply
    uses a hash function to generate the key. But if you cannot guarantee that users
    will use a strong password, it's better to use a password derived hash function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to LightWallet
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LightWallet is an HD wallet that implements BIP32, BIP39, and BIP44\. LightWallet
    provides APIs to create and sign transactions or encrypt and decrypt data using
    the addresses and keys generated using it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: LightWallet API is divided into four namespaces, that is, `keystore`, `signing`,
    `encryption`, and `txutils`. `signing`, `encrpytion,` and `txutils` provide APIs
    to sign transactions, asymmetric cryptography, and create transactions respectively,
    whereas a `keystore` namespace is used to create a `keystore`, generated seed,
    and so on. `keystore` is an object that holds the seed and keys encrypted. The
    `keystore` namespace implements transaction signer methods that requires signing
    the `we3.eth.sendTransaction()` calls if we are using Hooked-Web3-Provider. Therefore
    the `keystore` namespace can automatically create and sign transactions for the
    addresses that it can find in it. Actually, LightWallet is primarily intended
    to be a signing provider for the Hooked-Web3-Provider.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A `keystore` instance can be configured to either create and sign transactions
    or encrypt and decrypt data. For signing transactions, it uses the `secp256k1`
    parameter, and for encryption and decryption, it uses the `curve25519` parameter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The seed of LightWallet is a 12-word mnemonic, which is easy to remember yet
    difficult to hack. It cannot be any 12 words; instead, it should be a seed generated
    by LightWallet. A seed generated by LightWallet has certain properties in terms
    of selection of words and other things.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: HD derivation path
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HD derivation path is a string that makes it easy to handle multiple crypto
    currencies (assuming they all use the same signature algorithms), multiple blockchains,
    multiple accounts, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HD派生路径是一个字符串，它使得易于处理多个加密货币（假设它们都使用相同的签名算法）、多个区块链、多个账户等等。
- en: HD derivation path can have as many parameters as needed, and using different
    values for the parameters, we can produce different group of addresses and their
    associated keys.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HD派生路径可以具有任意多个参数，并且可以使用不同值的参数，我们可以产生不同组的地址及其相关密钥。
- en: By default, LightWallet uses the `m/0'/0'/0'` derivation path. Here, `/n'` is
    a parameter, and `n` is the parameter value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LightWallet默认使用`m/0'/0'/0'`派生路径。这里，`/n'`是一个参数，`n`是参数值。
- en: Every HD derivation path has a `curve`, and `purpose`. `purpose` can be either
    `sign` or `asymEncrypt`. `sign` indicates that the path is used for signing transactions,
    and `asymEncrypt` indicates that the path is used for encryption and decryption.
    `curve` indicates the parameters of ECC. For signing, the parameter must be `secp256k1`,
    and for asymmetric encryption, the curve must be `curve25591` because LightWallet
    forces us to use these paramters due to their benefits in those purposes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HD派生路径都有一个`curve`和`purpose`。`purpose`可以是`sign`或`asymEncrypt`。`sign`表示该路径用于签署交易，而`asymEncrypt`表示该路径用于加密和解密。`curve`指示ECC的参数。对于签名，参数必须是`secp256k1`，对于非对称加密，曲线必须是`curve25591`，因为LightWallet强制我们使用这些参数，由于其在这些用途上的好处。
- en: Building a wallet service
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建钱包服务
- en: Now we have learned enough theory about LightWallet, it's time to build a wallet
    service using LightWallet and hooked-web3-provider. Our wallet service will let
    users generate a unique seed, display addresses and their associated balance,
    and finally, the service will let users send ether to other accounts. All the
    operations will be done on the client side so that users can trust us easily.
    Users will either have to remember the seed or store it somewhere.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了足够多关于LightWallet的理论知识，是时候使用LightWallet和hooked-web3-provider构建一个钱包服务。我们的钱包服务将允许用户生成唯一的种子，显示地址及其关联余额，最后，该服务将允许用户向其他账户发送以太币。所有操作都将在客户端完成，这样用户就可以轻松地信任我们。用户要么必须记住种子，要么将其存放在某处。
- en: Prerequisites
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Before you start building the wallet service, make sure that you are running
    the geth development instance, which is mining, has the HTTP-RPC server enabled,
    allows client-side requests from any domain, and finally has account 0 unlocked.
    You can do all these by running this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建钱包服务之前，请确保您正在运行开采的geth开发实例，已启用HTTP-RPC服务器，允许来自任何域的客户端请求，并最终已解锁账户0。您可以通过运行以下命令来做到这一切：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `--rpccorsdomain` is used to allow certain domains to communicate with
    geth. We need to provide a list of domains space separated, such as `"http://localhost:8080
    https://mySite.com *"`. It also supports the `*` wildcard character. `--rpcaddr`
    indicates to which IP address the geth server is reachable. The default for this
    is `127.0.0.1`, so if it's a hosted server, you won't be able to reach it using
    the public IP address of the server. Therefore, we changed it's value to `0.0.0.0`,
    which indicates that the server can be reached using any IP address.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--rpccorsdomain`用于允许特定域与geth通信。我们需要提供一个用空格分隔的域列表，例如`"http://localhost:8080
    https://mySite.com *"`。它也支持`*`通配符字符。`--rpcaddr`表示geth服务器可到达的IP地址。默认值为`127.0.0.1`，因此如果它是托管服务器，您将无法使用服务器的公共IP地址来访问它。因此，我们将其值更改为`0.0.0.0`，表示服务器可以使用任何IP地址访问。
- en: Project structure
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: In the exercise files of this chapter, you will find two directories, that is,
    `Final` and `Initial. Final` contains the final source code of the project, whereas
    `Initial` contains the empty source code files and libraries to get started with
    building the application quickly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，您会找到两个目录，分别是`Final`和`Initial`。`Final`包含项目的最终源代码，而`Initial`包含了空的源代码文件和库，以便快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and then run the app using the `node app.js` command inside the `Final` directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Final`目录，您需要在其中运行`npm install`，然后使用`Final`目录内的`node app.js`命令运行应用。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. `package.json` contains the backend dependencies.
    Our app, `app.js`, is where you will place the backend source code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the bootstrap library. Inside `public/html`,
    you will find `index.html`, where you will place the HTML code of our app, and
    finally, in the `public/js` directory, you will find `.js` files for Hooked-Web3-Provider,
    web3js, and LightWallet. Inside `public/js`, you will also find a `main.js` file
    where you will place the frontend JS code of our app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Building the backend
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first build the backend of the app. First of all, run `npm install` inside
    the initial directory to install the required dependencies for our backend.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete backend code to run an express service and serve the `index.html`
    file and static files:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is self-explanatory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Building the frontend
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's build the frontend of the app. The frontend will consists of the major
    functionalities, that is, generating seed, displaying addresses of a seed, and
    sending ether.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the HTML code of the app. Place this code in the `index.html`
    file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: At first, we enqueue a Bootstrap 4 stylesheet.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we display an information box, where we will display various messages to
    the user.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And then we have a form with an input box and two buttons. The input box is
    used to enter the seed, or while generating new seed, the seed is displayed there.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Generate Details button is used to display addresses and Generate New Seed
    is used to generate a new unique seed. When Generate Details is clicked, we call
    the `generate_addresses()` method, and when the Generate New Seed button is clicked,
    we call the `generate_seed()` method.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, we have an empty ordered list. Here, we will dynamically display the
    addresses, their balances, and associated private keys of a seed when a user clicks
    on the Generate Details button.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have another form that takes a from address and a to address and
    the amount of ether to transfer. The from address must be one of the addresses
    that's currently displayed in the unordered list.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s write the implementation of each of the functions that the HTML
    code calls. At first, let''s write the code to generate a new seed. Place this
    code in the `main.js` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `generateRandomSeed()` method of the `keystore` namespace is used to generate
    a random seed. It takes an optional parameter, which is a string that indicates
    the extra entropy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Entropy is the randomness collected by an application for use in some algorithm
    or somewhere else that requires random data. Usually, entropy is collected from
    hardware sources, either pre-existing ones such as mouse movements or specially
    provided randomness generators.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To produce a unique seed, we need really high entropy. LightWallet is already
    built with methods to produce unique seeds. The algorithm LightWallet uses to
    produce entropy depends on the environment. But if you feel you can generate better
    entropy, you can pass the generated entropy to the `generateRandomSeed()` method,
    and it will get concatenated with the entropy generated by `generateRandomSeed()`
    internally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: After generating a random seed, we call the `generate_addresses` method. This
    method takes a seed and displays addresses in it. Before generating addresses,
    it prompts the user to ask how many addresses they want.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `generate_addresses()` method. Place this
    code in the `main.js` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how the code works:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: At first, we have a variable named `totalAddresses`, which holds a number indicating
    the total number of addresses the user wants to generate.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we check whether the `seed` parameter is defined or not. If it's undefined,
    we fetch the seed from the input field. We are doing this so that the `generate_addressess()`
    method can be used to display the information seed while generating a new seed
    and also if the user clicks on the Generate Details button.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we validate the seed using the `isSeedValid()` method of the `keystore`
    namespace.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then ask for the user's input regarding how many addresses they want to generate
    and display. And then we validate the input.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The private keys in the `keystore` namespace are always stored encrypted. While
    generating keys, we need to encrypt them, and while signing transactions, we need
    to decrypt the keys. The password for deriving a symmetric encryption key can
    be taken as input from the user or by supplying a random string as a password.
    For better user experience, we generate a random string and use it as the password.
    The symmetric key is not stored inside the `keystore` namespace; therefore, we
    need to generate the key from the password whenever we do operations related to
    the private key, such as generating keys, accessing keys, and so on.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we use the `createVault` method to create a `keystore` instance. `createVault`
    takes an object and a callback. The object can have four properties: `password`,
    `seedPharse`, `salt`, and `hdPathString`. `password` is compulsory, and everything
    else is optional. If we don''t provide a `seedPharse`, it will generate and use
    a random seed. `salt` is concatenated to the password to increase the security
    of the symmetric key as the attacker has to also find the salt along with the
    password. If the salt is not provided, it''s randomly generated. The `keystore`
    namespace holds the salt unencrypted. `hdPathString` is used to provide the default
    derivation path for the `keystore` namespace, that is, while generating addresses,
    signing transactions, and so on. If we don''t provide a derivation path, then
    this derivation path is used. If we don''t provide `hdPathString`, then the default
    value is `m/0''/0''/0''`. The default purpose of this derivation path is `sign`.
    You can create new derivation paths or overwrite the purpose of derivation paths
    present using the `addHdDerivationPath()` method of a `keystore` instance. You
    can also change the default derivation path using the `setDefaultHdDerivationPath()`
    method of a `keystore` instance. Finally, once the `keystore` namespace is created,
    the instance is returned via the callback. So here, we created a `keystore` using
    a password and seed only.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`createVault`方法创建一个`keystore`实例。`createVault`接受一个对象和一个回调函数。对象可以有四个属性：`password`、`seedPharse`、`salt`和`hdPathString`。`password`是必需的，其他全部是可选的。如果我们不提供`seedPharse`，它会生成并使用一个随机种子。`salt`被连接到密码上，以增加对称密钥的安全性，因为攻击者还必须找到盐和密码。如果未提供盐，它将被随机生成。`keystore`命名空间保存未加密的盐。`hdPathString`用于为`keystore`命名空间提供默认派生路径，即在生成地址、签署交易等中使用。如果我们不提供派生路径，将使用此派生路径。如果我们不提供`hdPathString`，则默认值为`m/0'/0'/0'`。此派生路径的默认目的是`sign`。您可以使用`keystore`实例的`addHdDerivationPath()`方法创建新的派生路径或覆盖现有派生路径的目的。您也可以使用`keystore`实例的`setDefaultHdDerivationPath()`方法更改默认派生路径。最后，一旦创建了`keystore`命名空间，实例会通过回调返回。因此，在这里，我们只使用密码和种子创建了一个`keystore`。
- en: Now we need to generate the number of addresses and their associated keys the
    user needs. As we can generate millions of addresses from a seed, `keystore` doesn't
    generate any address until we want it to because it doesn't know how many addresses
    we want to generate. After creating the `keystore`, we generate the symmetric
    key from the password using the `keyFromPassword` method. And then we call the
    `generateNewAddress()` method to generate addresses and their associated keys.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要生成用户需要的地址数量及其关联的密钥。因为我们可以从种子生成数百万个地址，所以`keystore`在我们需要它之前不会生成任何地址，因为它不知道我们要生成多少个地址。创建了`keystore`之后，我们使用`keyFromPassword`方法从密码生成对称密钥。然后我们调用`generateNewAddress()`方法生成地址及其关联的密钥。
- en: '`generateNewAddress()` takes three arguments: password derived key, number
    of addresses to generate, and derivation path. As we haven''t provided a derivation
    path, it uses the default derivation path of the keystore. If you call `generateNewAddress()`
    multiple times, it resumes from the address it created in the last call. For example,
    if you call this method twice, each time generating two addresses, you will have
    the first four addresses.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`generateNewAddress()`方法接受三个参数：从密码派生的密钥、要生成的地址数和派生路径。由于我们没有提供派生路径，它使用`keystore`的默认派生路径。如果多次调用`generateNewAddress()`，它将从上一次创建的地址处继续。例如，如果两次调用这个方法，每次生成两个地址，你将得到前四个地址。'
- en: Then we use `getAddresses()` to get all the addresses stored in the `keystore`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`getAddresses()`来获取`keystore`中存储的所有地址。
- en: We decrypt and retrieve private keys of the addresses using the `exportPrivateKey`
    method.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`exportPrivateKey`方法解密并检索地址的私钥。
- en: We use `web3.eth.getBalance()` to get balances of the address.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`web3.eth.getBalance()`来获取地址的余额。
- en: And finally, we display all the information inside the unordered list.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在无序列表中显示所有信息。
- en: Now we know how to generate the address and their private keys from a seed.
    Now let's write the implementation of the `send_ether()` method, which is used
    to send ether from one of the addresses generated from the seed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何从种子生成地址及其私钥了。现在让我们编写`send_ether()`方法的实现，该方法用于从种子生成的地址中发送以太币。
- en: 'Here is the code for this. Place this code in the `main.js` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于此的代码。将此代码放入`main.js`文件中：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the code up and until generating addresses from the seed is self explanatory.
    After that, we assign a callback to the `passwordProvider` property of `ks`. This
    callback is invoked during transaction signing to get the password to decrypt
    the private key. If we don't provide this, LightWallet prompts the user to enter
    the password. And then, we create a `HookedWeb3Provider` instance by passing the
    `keystore` as the transaction signer. Now when the custom provider wants a transaction
    to be signed, it calls the `hasAddress` and `signTransactions` methods of `ks`.
    If the address to be signed is not among the generated addresses, `ks` will give
    an error to the custom provider. And finally, we send some ether using the `web3.eth.sendTransaction`
    method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have finished building our wallet service, let''s test it to make
    sure it works as expected. First, run `node app.js` inside the initial directory,
    and then visit `http://localhost:8080` in your favorite browser. You will see
    this screen:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_001.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Generate New Seed button to generate a new seed. You will
    be prompted to enter a number indicating the number of addresses to generate.
    You can provide any number, but for testing purposes, provide a number greater
    than 1\. Now the screen will look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_002.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Now to test sending ether, you need to send some ether to one of the generated
    addresses from the coinbase account. Once you have sent some ether to one of the
    generated addresses, click on the Generate Details button to refresh the UI, although
    it''s not necessary to test sending ether using the wallet service. Make sure
    the same address is generated again. Now the screen will look something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_003.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Now in the from address field, enter the account address from the list that
    has the balance in the `from` address field. Then enter another address in the
    to address field. For testing purposes, you can enter any of the other addresses
    displayed. Then enter some ether amount that is less than or equal to the ether
    balance of the from address account. Now your screen will look something like
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_004.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Send Ether button, and you will see the transaction hash in
    the information box. Wait for sometime for it to get mined. Meanwhile, you can
    check whether the transactions got mined or not by clicking on the Generate Details
    button in a very short span of time. Once the transaction is mined, your screen
    will look something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_005.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: If everything goes the same way as explained, your wallet service is ready.
    You can actually deploy this service to a custom domain and make it available
    for use publicly. It's completely secure, and users will trust it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about three important Ethereum libraries: Hooked-Web3-Provider,
    ethereumjs-tx, and LightWallet. These libraries can be used to manage accounts
    and sign transactions outside of the Ethereum node. While developing clients for
    most kinds of DApps, you will find these libraries useful.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了三个重要的以太坊库：Hooked-Web3-Provider、ethereumjs-tx 和 LightWallet。这些库可用于在以太坊节点之外管理账户并签署交易。在开发大多数类型的
    DApp 客户端时，你会发现这些库非常有用。
- en: And finally, we created a wallet service that lets users manage their accounts
    that share private keys or any other information related to their wallet with
    the backend of the service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个钱包服务，让用户可以管理与服务后端共享私钥或与其钱包相关的任何其他信息的账户。
- en: In the next chapter, we will build a platform to build and deploy smart contracts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个平台来构建和部署智能合约。
