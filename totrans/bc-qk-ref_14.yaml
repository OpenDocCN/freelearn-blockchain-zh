- en: Smart Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of smart contracts was first conceived by researcher Nick Szabo
    in the mid 1990s. In his papers, he described smart contracts as a set of promises,
    specified in digital form, including protocols within which the parties perform
    these promises. This description can be broken into four pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols for communication and performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance of actions triggered automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, nowhere in this is the blockchain directly specified, as blockchain
    technology had not yet been invented and would not be invented for another 13
    years. However, with the invention of blockchain technology, smart contracts were
    suddenly much more achievable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts and blockchain technology are independent ideas. A blockchain
    can exist without smart contracts (Bitcoin, for instance, has no real smart contract
    ability built in), and smart contracts can be built without a blockchain. However,
    blockchain is a technology particularly well-suited for the development of smart
    contracts because it allows trustless, decentralized exchange. Essentially, the
    blockchain provides two out of the four necessary items for smart contracts: digital
    form and protocols for the communication and performance of actions between distinct
    parties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go over some of the different blockchain networks
    and their approaches to smart contract technology. In this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use smart contracts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaches to smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, the various smart contract approaches can be divided into different
    types: **Turing Complete**, **Restricted Instructions**, **Off-Chain Execution**,
    and **On-Chain Execution**, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bbbadc1-96d3-4108-adcb-29fd723c2548.png)'
  prefs: []
  type: TYPE_IMG
- en: The types of smart contracts that are executed on a system determine performance,
    what can and cannot be executed on the system, the complexity, and of course,
    the level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further, let's discuss why smart contracts are desired and even
    revolutionary.
  prefs: []
  type: TYPE_NORMAL
- en: Why smart contracts?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world before smart contracts was one that was fraught with uncertainty.
    Legal contracts, even simple ones, need not be followed, and the cost of recourse
    using most legal systems was and is extremely expensive, even in countries where
    the legal system is not corrupt. In many areas of the world, contracts are barely
    worth the paper they are written on, and are usually enforceable only by parties
    with substantial political or financial power. For weaker actors in an economic
    or political system, this is a terrible and unfair set of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The issues that we mentioned previously come primarily from the human factor.
    As long as a person is involved in the enforcement of a contract, they can be
    corrupt, lazy, misinformed, biased, and so on. A smart contract, in contrast,
    is written in code, and is meant to execute faithfully no matter what parties
    are involved. This provides the opportunity for safer, cheaper, faster, and far
    more equitable outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the key advantages of smart contracts in more depth in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Automating processes and resolutions between parties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most immediate advantage of smart contracts is that they reduce the labor
    and pain involved in even successful and faithfully carried out agreements. Take
    for example, a simple purchase order and invoice between companies. Imagine a
    company called **FakeCar Inc.** that decides they need 1,000 wheels from their
    supplier, Wheelmaster. They agree between them that each wheel will cost $20,
    with payment made when the wheels are delivered to FakeCar. At the beginning,
    the wheels might be shipped by freight, passing through multiple hands on the
    way to FakeCar. Once they arrive, FakeCar would need to scan and inspect each
    wheel, make notes, and then issue a check or wire transfer to Wheelmaster. Depending
    on the distance involved, the wheels may be in the custody of multiple companies:
    a trucking company, intercontinental shipping, another trucking company, and finally
    FakeCar''s manufacturing facility. At each stage, there is a chance of damage,
    loss, or misdelivery. Once delivered, FakeCar would need to issue a transfer to
    cover the invoice. Even if all goes well, this process can take weeks. In the
    meantime, both FakeCar and Wheelmaster have to worry whether they will get their
    wheels or their money, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at how this process might work with smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: FakeCar issues a purchase order on the blockchain for 1,000 wheels at $20 a
    wheel, valid for 1 month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wheelmaster issues a shipping request from their suppliers to deliver in one
    month, and accepts the purchase order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FakeCar funds the purchase order in a smart contract escrow; Wheelmaster can
    be assured that they will be paid if the wheels arrive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wheelmaster sees that funds are available to pay for the wheels, ships with
    a company that tracks each step on a blockchain, and accepts the terms of paying
    for any wheels that are lost. They (or their insurer) also fund a shipping escrow
    contract with enough money to cover the event of lost shipping. The contract will
    automatically refund the shipper once FakeCar signs off on the receipt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wheels are shipped and delivered, FakeCar's escrow is released, and the
    insurance bond returns to the shipping company. This happens the moment FakeCar
    registers receipt and the shipping company signs off on the change in custody.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this scenario, payments and insurance can be verified and handled instantly—even
    across international boundaries, and across cultures and languages—if all the
    parties participate in a blockchain-based ecosystem of smart contracts. The result
    is a great increase in the certainty of outcomes across all parties, and a subsequent
    increase in efficiency. For instance, if Wheelmaster can be certain that their
    invoice will be paid, then they can make business decisions with vastly more efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of writing, the first major logistics transaction using blockchain and smart
    contracts was completed on the Corda blockchain between HSBC and ING, and involved
    the shipment of soybeans from Argentina to Malaysia. According to the banks, such
    a transfer used to be very time consuming, and would take five to ten days. With
    blockchain, the whole issue of finance was handled in under 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: The use of smart contracts is still in its infancy, and yet the technology has
    already resulted in an 80–90% reduction in the cross-border friction of financial
    services. As the technology and surrounding ecosystem improves, the advantages
    may become yet more extreme.
  prefs: []
  type: TYPE_NORMAL
- en: Increased transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, one of the negative factors experienced by organizations
    worldwide is that, for many transactions, trust is a necessity. This is especially
    true in financial transactions, where purchase orders, invoices, and shipments
    move between multiple parties. The trust issues here are many. There is a question
    of not only whether someone will pay, but whether they can pay at all? Do they
    have a history of on-time payment and, if not, just how bad is their payment history?
    In many cases, buyers and sellers in any marketplace have very limited information.
    This is particularly true internationally. This is where blockchain and smart
    contracts can help.
  prefs: []
  type: TYPE_NORMAL
- en: Ending centralized data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the United States, each person has a credit score that is calculated by three
    large credit agencies. These agencies and their methods are opaque. Neither the
    buyers of this information nor the people who are reported on are allowed deep
    insight into how the score is calculated, nor are they able to update this information
    directly. A mistake by a credit agency can be devastating to someone's ability
    to finance a home or a car, costing a consumer valuable time and money. Nevertheless,
    if a consumer finds mistakes on their credit report, they must beg the issuer
    to update it, and they have few options if that organization refuses. Worse, those
    same issuers have proven bad stewards of the private financial information they
    collect. For instance, in 2017, Experian suffered a massive data breach that exposed
    the records of over 100 million people. If these agencies were replaced by a blockchain
    system and smart contracts, people would be able to see the rules and update records
    directly, without having to pay an intermediary that may or not be honest themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large companies have an advantage in the current marketplace: They can both
    afford to pay these third-party services for financial data, as well as the personnel
    and systems needed to track information themselves over time. Smaller companies
    are not granted such economies of scale, putting them at a competitive disadvantage
    and increasing their overhead, or even putting them out of business if they make
    a bad decision because they have less information. However, even larger companies
    stand to benefit, as the cost and expense of compiling this data adds up for them
    as well. As more data concerning trust becomes public and automated by smart contracts,
    the playing field will level and, hopefully, will crowd dishonest actors out of
    the marketplace. This should result in increased confidence across the market,
    along with reduced overheads and, by extension, higher profits, lower prices,
    or both.'
  prefs: []
  type: TYPE_NORMAL
- en: Increased fairness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the United States, there used to be a process known as **red lining**, where
    people of certain ethnic groups were denied loans and access to financial services—particularly
    mortgages. These unfair practices continue to some extent, as the criteria and
    process for granting loans and the way interest rates are calculated are hidden
    inside centralized organizations. This phenomenon is not contained within the
    USA; there are many areas in the world where ethnic, religious, and other biases
    distort what are meant to be objective decisions. With a smart-contract-based
    system, the rules would be public and auditable to ensure fairness and accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One approach to smart contracts is to allow full-featured software to be embedded
    either inside or alongside a blockchain, able to respond to blockchain events.
    This is an approach taken by Hyperledger Fabric, Ethereum, NEO, and other such
    companies. This approach gives maximum flexibility, as there is essentially nothing
    that cannot be written into the blockchain system. The downside of this power
    is the risk of making errors. The more options available, the more possible edge
    cases and permutations that must be tested, and the higher the risk that there
    will be an undiscovered vulnerability in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other approach to smart contracts is to greatly reduce the scope of what
    is possible in return for making things more secure and costly mistakes more difficult.
    The trade-off is currently flexibility versus security. For instance, in the Stellar
    ecosystem, smart contracts are made as sets of operations. In Stellar, there are
    only eleven operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path payment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create passive offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account merge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inflation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations themselves have multiple options and permutations, and so enable
    quite a large amount of behavior. However, it is not possible to easily use these
    operations to execute something such as the DAO, or some other on-chain governance
    organization. Instead, such functionality would have to be hosted off the chain.
    Similarly, there is no clear way in Stellar to manage the equivalent of ERC-721
    tokens, which would track the equivalent of something such as trading cards or
    even pieces of real estate. Stellar's smart contract system is geared toward the
    transfer of fungible assets, such as currencies. As a result, it can scale very
    quickly, easily handle multisignature accounts and escrow, and process transactions
    in just a few seconds with high throughput. Ethereum is more flexible, but the
    multisignature capability, the tokens themselves, and so on would need to be created
    with software written in Solidity. Ethereum is obviously more flexible, but requires
    more code, and thus runs a higher risk of defects.
  prefs: []
  type: TYPE_NORMAL
- en: Example Ethereum smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The blockchain with the most widespread use of smart contracts is Ethereum.
    Of all the smart-contract-capable networks presented here, it is not only the
    one with the largest use, but also has the largest ecosystem of public distributed
    applications. One of the reasons that Ethereum is so popular is that its representation
    of smart contracts is relatively intuitive and easy to read. In this section,
    we are going to look at a common Ethereum-based smart contract that fulfills all
    four of the preceding criteria and is relatively easy to understand: a token sale
    contract. The following code will be written in Solidity; for more details, please
    see [Chapter 13](d3b6caa1-a5ed-4147-82dc-ea5074126df2.xhtml), *Solidity 101*,
    and [Chapter 15](588b84f6-baef-4ea3-895e-bd66f523452b.xhtml), *Ethereum Development*.'
  prefs: []
  type: TYPE_NORMAL
- en: The promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first aspect of a smart contract is that it must make a set of programmatic
    promises. The reason we have chosen a token sale contract to look at is that it
    has a very simple promise to make: if you send the contract Ethereum, the contract
    will in turn automatically send your account a new token. Let''s look at some
    basic code, which is explicitly not for production; this is simplified code to
    make certain concepts clearer. This code comes from the `StandardToken` contract, part
    of the OpenZeppelin (You''ll find a link for the same in the *References* section)
    project on which this is based, which has full-featured and audited code to achieve
    the same effect, but is more complicated to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is an interface contract for an `ERC20` token, which we will save
    as a file called `ERC20.sol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will reference that token interface in our crowdsale contract, which
    will send an `ERC20` token in response to a payment in ether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simplified contract, but again, it is not sufficient for a complete,
    real-world `Crowdsale`. However, it does illustrate the key concepts for a smart
    contract. Let''s look at each piece. The `constructor` method requires a reference
    to an `ERC20` token, which is the token that will be given to buyers who send
    in Ethereum, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the way Solidity works, this contract cannot function unless a token
    has been loaded. So this is the first promise implicitly made by this code: there
    must be an `ERC20` token available for purchase. The second promise is the conversion
    rate, which is placed at the very simple 1\. For each wei (the smallest unit of
    currency in Ethereum), a person buying this token will get 1 unit of the new token.
    Ethereum has 18 decimal places, and by convention so do most tokens, so it would
    be presumed that this would make the conversion of Ethereum to this token now
    1:1\. This brings us to item #4 in the necessary aspects of a smart contract:
    automatic fulfillment. The following code handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is code, the requirement that the smart contract should be in digital
    form is obvious. The automatic aspect here is also straightforward. In Ethereum,
    `msg.value` holds the value of the ether currency that is sent as part of the
    command. When the contract receives Ethereum, it calculates the number of tokens
    the purchaser should receive and sends them: no human interaction needed, and
    no trusted party necessary or possible. Similarly, no one can intervene, as once
    it is deployed to the network, the code in Ethereum is immutable. Therefore, a
    sender who is using this smart contract can be absolutely assured that they will
    receive their tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to understand smart contracts in the domain in which they live:
    decentralized, asynchronous networks. As a result of living in this ecosystem,
    there are security considerations that are not always obvious, and can lead to
    issues. To illustrate, we are going to look into two related functions of the
    `ERC20` standard: `approve` and `transferFrom`. Here is code for the `approve`
    function from OpenZeppelin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `approve` function allows a token owner to say that they have approved
    a transfer of their token to another account. Then, in response to different events,
    a future transfer can take place. How this happens depends on the application,
    but such as the token sale, by approving a transfer, a blockchain application
    can later call `transferFrom` and move the tokens, perhaps to accept payment and
    then perform actions. Let''s look at that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The two functions work together. The user wishing to use the app uses `approve`
    to allow payment, and the app calls `transferFrom` in order to accept. But because
    of the asynchronous nature of the calls, it is possible for flaws to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an app where users can pay tokens in order to join a digital club—40
    tokens for a basic membership and 60 tokens for an enhanced membership. Users
    can also trade the tokens to other people or sell them as they wish. The ideal
    case for these two functions is where a user approves 40 tokens and the application
    registers this and calls `transferFrom` to move the 40 tokens, and then grants
    access as part of the smart contract. So far so good.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to keep in mind that each action here takes time, and the order
    of events is not fixed. What actually happens is that the user sends a message
    to the network, triggering `approve`, the application sends another message, triggering
    `transferFrom`, and then everything resolves when the block is mined. If these
    transactions are out of order (`transferFrom` executing before `approve`), the
    transaction will fail. Moreover, what if the user changes their mind and decides
    to change their approval from 40 to 60? Here is what the user intends:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: `approve` 40 (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User**: `approve` 60 (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: `transferFrom` 60 to App (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: Grant enhanced membership (block 2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the end, the user paid 60 tokens and got what they wanted. But because each
    of these events are asynchronous and the order is decided by the miners, this
    order is not guaranteed. Here, is what might happen instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: `approve` 40 (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: `transferFrom` 40 to App (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User**: `approve` 60 (block 2, as the miners did not include it in block
    1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: `transferFrom` 60 to App (Block 2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the user has paid 100 tokens without meaning to. Here is yet another permutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: `approve` 40 (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User**: `approve` 60 (block 1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: `transferFrom` 40 to app (block 2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: Grants basic membership (block 2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**App**: `transferFrom` 60 to app (block 3) | fails'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of this sequence, the user still has 20 tokens approved, and the
    attempt to get the enhanced membership has failed. While an app can and should
    be written without these issues by doing such things as allowing upgraded membership
    for 20 tokens and checking the max approval before `transferFrom` is called, this
    attention to detail is not guaranteed or automatic on the part of application
    authors.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to understand is that race conditions and ordering issues
    are extremely important in Ethereum. The user does not control the order of events
    on a blockchain, nor does an app. Instead, it is the miners that decide which
    transactions occur in which blocks and in which order. In Ethereum, it is the
    gas price that affects the priority that miners give transactions. Other influences
    can involve the maximum block gas limit, the number of transactions already in
    a block, and whether or not a miner that successfully solves a block has even
    seen the transaction on the network. For these reasons, smart contracts cannot
    assume that the order of events is what is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with threats in smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every decentralized network will have to deal with race conditions caused by
    different orderings. It is critical that smart contracts be carefully evaluated
    for possible race conditions and other attacks. To know whether a race condition
    bug is possible is as simple as knowing whether more than one function call is
    involved, directly or indirectly. In the preceding case, both the user and the
    app call functions; therefore, a race condition is possible, and so is an attack
    called front running. It is also possible to have race conditions inside a single
    method, so smart contract developers should not let their guard down.
  prefs: []
  type: TYPE_NORMAL
- en: Each network has a different model for contract execution, and as a result,
    each network had different best practices. For Ethereum, Consensys maintains a
    list of smart contract best practices at [https://consensys.github.io/smart-contract-best-practices/](https://consensys.github.io/smart-contract-best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: Before shipping any smart contract, it is strongly suggested that an organization
    write extensive unit tests and simulation tests, and then audit the smart contracts
    against the best practices for that network.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts hold tremendous power, but they do have limitations. It is important
    to note that these systems are only as good as the people building them. So far,
    many smart contract systems have failed due to unforeseen bugs and events that
    were not part of the initial design. In many cases, these were merely technical
    flaws that can at least be fixed in time. However, with the recent rush to use
    blockchain technology for everything, we are likely to start seeing more substantial
    failures as people fail to understand the limits of the technology. For blockchain
    to truly have maximum business impact, both its advantages and limitations have
    to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Data quality and mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like all systems, smart contracts are only as good as the data they act on.
    A smart contract that receives bad or incorrect information from the network will
    still execute. On blockchain systems, this can be a huge issue as most transactions
    initiated by a human or a contract are irrevocable. Thus, if information is placed
    on a blockchain that is in error, fraudulent, or has some other deficiency, then
    a smart contract will still execute faithfully. Instead of expediting the proper
    functioning of the network, the smart contract would now be assisting in propagating
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: To use the earlier example of shipping tires between FakeCar and Wheelmaster,
    what if during transit the boxes holding the tires were broken into and the tires
    replaced? If the worker at the FakeCar building scanned the boxes as received
    without checking each and every one, the smart contract would see this update
    and release escrow. The shipper would have their insurance bond returned, Wheelmaster
    would get paid, and FakeCar would still no longer have the wheels they ordered.
    To smart contract purists, this is how things should be. But in these cases, companies
    may instead refuse to use smart contracts or require additional layers of approval—essentially
    recreating the systems of old.
  prefs: []
  type: TYPE_NORMAL
- en: In designing smart contract systems, it is therefore critical that designers
    try and imagine every possible way things could go wrong. As with the DAO and
    other smart contract systems that have been used so far, small mistakes can have
    big consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Many smart contracts involve some level of human interaction. For instance,
    multisignature wallets require multiple people to authorize a transaction before
    they will execute. These touchpoints introduce the same possibility for errors
    as old systems, but with the possibility of irrevocable consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Legal validity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts do what they are programmed to do. If a smart contract is deemed
    invalid in a court, how is this resolved? The answer right now is that nobody
    really knows, but it could happen—and probably will. Most countries in the world
    have limits on what can and cannot be contractually agreed to and the terms that
    can be legally used in a contract. For instance, in the USA, there is a limit
    to the amount of interest that can be charged on certain financial products. Other
    regulations control the conditions and terms of payment in specific industries.
    Smart contracts that violate local and national laws run the risk of being canceled,
    resulting in repayment, damages, or other consequences to the participating organizations,
    and possibly even the contract authors.
  prefs: []
  type: TYPE_NORMAL
- en: Stability of meaning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the token sale contract we looked at earlier, a user can be sure that they
    will receive the tokens they purchase. What they cannot be sure of is that those
    tokens will be valuable or still be useful in the future. Moreover, if those tokens
    represent something else (access to a system, real-world assets, or something
    else), then the mere existence of the tokens does not bring any guarantees that
    this access will remain, that people will continue to accept the tokens for assets
    (see the previously mentioned issues with legal validity), and so on. With national
    currencies, the use and acceptance of that currency is mandated by a government
    with substantial power. With tokens, the acceptance and use of the token has no
    mandate. To some, this is the very appeal—that the value of a token is more trustable
    because it is built not on enforcement by a government, but by social approval
    and use.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that over time, legal frameworks and trade will become more stable,
    and this will be less of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts are agreements written into code between different parties.
    The critical aspects of smart contracts is that they contain promises that are
    in digital form. All of these promises can be executed using digital protocols
    for communication performance. The outcomes of the contracts are triggered automatically.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a solid understanding of what smart contracts
    are, how they work, and their strengths and limitations. You should be able to
    understand the dangers inherent in smart contract ecosystems and be able to gauge
    possible risks in the development of smart-contract-based systems. At a minimum,
    you should recognize the need for careful and thorough evaluation of smart contracts
    for security reasons. Remember, with smart contracts, the code is executed with
    little or no human intervention. A mistake in a smart contract means the damage
    done by the mistake will multiply as fast as the code can be run.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to dive more deeply into smart contracts with a chapter devoted
    to development in Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://firstmonday.org/ojs/index.php/fm/article/view/548](http://firstmonday.org/ojs/index.php/fm/article/view/548)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Nick Szabo, Smart Contracts: Building Blocks for Digital Markets, 1996'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.cnbc.com/2018/05/14/hsbc-makes-worlds-first-trade-finance-transaction-using-blockchain.html](https://www.cnbc.com/2018/05/14/hsbc-makes-worlds-first-trade-finance-transaction-using-blockchain.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://fortune.com/2017/12/22/experian-data-breach-alteryx-amazon-equifax/](http://fortune.com/2017/12/22/experian-data-breach-alteryx-amazon-equifax/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
