- en: Getting Started with web3.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用web3.js入门
- en: In the previous chapter, we learned how to write smart contracts and used geth's
    interactive console to deploy and broadcast transactions using web3.js. In this
    chapter, we will learn web3.js and how to import, connect to geth, and use it
    in Node.js or client-side JavaScript. We will also learn how to build a web client
    using web3.js for the smart contract that we created in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何编写智能合同，并使用geth的交互式控制台来部署和广播使用web3.js的交易。在本章中，我们将学习web3.js以及如何在Node.js或客户端JavaScript中导入、连接到geth并使用它。我们还将学习如何使用web3.js为前一章中创建的智能合同构建一个web客户端。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importing web3.js in Node.js and client-side JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js和客户端JavaScript中导入web3.js
- en: Connecting to geth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到geth
- en: Exploring the various things that can be done using web3.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用web3.js可以完成的各种事情
- en: Discovering various most used APIs of web3.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索web3.js的各种最常用的API
- en: Building a Node.js application for an ownership contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个用于所有权合同的Node.js应用程序
- en: Introduction to web3.js
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[web3.js简介](https://wiki.example.org/web3.js_introduction)'
- en: web3.js provides us with JavaScript APIs to communicate with geth. It uses JSON-RPC
    internally to communicate with geth. web3.js can also communicate with any other
    kind of Ethereum node that supports JSON-RPC. It exposes all JSON-RPC APIs as
    JavaScript APIs; that is, it doesn't just support all the Ethereum-related APIs;
    it also supports APIs related to Whisper and Swarm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js为我们提供了JavaScript API与geth进行通信。它内部使用JSON-RPC与geth通信。web3.js也可以与支持JSON-RPC的任何其他类型的以太坊节点通信。它将所有JSON-RPC
    API公开为JavaScript API；也就是说，它不仅支持所有与以太坊相关的API；它还支持与Whisper和Swarm相关的API。
- en: You will learn more and more about web3.js as we build various projects, but
    for now, let's go through some of the most used APIs of web3.js and then we will
    build a frontend for our ownership smart contract using web3.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建各种项目，你将越来越多地了解web3.js，但现在，让我们先了解一些web3.js最常用的API，然后我们将使用web3.js为我们的所有权智能合同构建一个前端。
- en: At the time of writing this, the latest version of web3.js is 0.16.0\. We will
    learn everything with respect to this version.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 撰写此文时，web3.js的最新版本为0.16.0。我们将学习与该版本相关的所有内容。
- en: web3.js is hosted at [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js) 
    and the complete documentation is hosted at [https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js托管在[https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js)，完整的文档托管在[https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API)。
- en: Importing web3.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入web3.js
- en: To use web3.js in Node.js, you can simply run `npm install web3` inside your
    project directory, and in the source code, you can import it using `require("web3");`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node.js中使用web3.js，你只需在项目目录中运行`npm install web3`，在源代码中，你可以使用`require("web3");`进行导入。
- en: To use web3.js in client-side JavaScript, you can enqueue the `web3.js` file,
    which can be found inside the `dist` directory of the project source code. Now
    you will have the `Web3` object available globally.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端JavaScript中使用web3.js，你可以将位于项目源代码的`dist`目录中的`web3.js`文件加入队列。现在你将在全局范围内可以使用`Web3`对象。
- en: Connecting to nodes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到节点
- en: web3.js can communicate with nodes using HTTP or IPC. We will use HTTP to set
    up communication with nodes. web3.js allows us to establish connections with multiple
    nodes. An instance of `web3` represents a connection with a node. The instance
    exposes the APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js可以使用HTTP或IPC与节点进行通信。我们将使用HTTP来建立与节点的通信。web3.js允许我们与多个节点建立连接。`web3`的实例表示与一个节点的连接。该实例公开API。
- en: When an app is running inside Mist, it automatically makes an instance of `web3`
    available that's connected to the mist node. The variable name of the instance
    is `web3`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在Mist中运行时，它会自动创建一个与mist节点连接的`web3`实例。实例的变量名是`web3`。
- en: 'Here is the basic code to connect to a node:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是连接到节点的基本代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At first, we check here whether the code is running inside mist by checking
    whether `web3` is `undefined` or not. If `web3` is defined, then we use the already
    available instance; otherwise, we create an instance by connecting to our custom
    node. If you want to connect to the custom node regardless of whether the app
    is running inside mist or not, then remove the `if` condition form the preceding
    code. Here, we are assuming that our custom node is running locally on port number
    `8545`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在这里检查代码是否在 mist 中运行，方法是检查`web3`是否为`undefined`。如果`web3`已定义，则使用已有的实例；否则，通过连接到我们的自定义节点来创建一个实例。如果您想无论应用程序是否在
    mist 中运行都连接到自定义节点，则从前面的代码中删除`if`条件。这里，我们假设我们的自定义节点在本地的端口号`8545`上运行。
- en: The `Web3.providers` object exposes constructors (called providers in this context)
    to establish connection and transfer messages using various protocols. `Web3.providers.HttpProvider`
    lets us establish an HTTP connection, whereas `Web3.providers.IpcProvider` lets
    us establish an IPC connection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Web3.providers` 对象公开了构造函数（在此上下文中称为提供程序），用于使用各种协议建立连接和传输消息。`Web3.providers.HttpProvider`
    允许我们建立 HTTP 连接，而`Web3.providers.IpcProvider` 允许我们建立 IPC 连接。'
- en: The `web3.currentProvider` property is automatically assigned to the current
    provider instance. After creating a web3 instance, you can change its provider
    using the `web3.setProvider()` method. It takes one argument, that is, the instance
    of the new provider.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.currentProvider`属性会自动分配给当前提供程序实例。创建 web3 实例后，您可以使用`web3.setProvider()`方法更改其提供程序。它接受一个参数，即新提供程序的实例。'
- en: Remember that geth has HTTP-RPC disabled by default. So enable it by passing
    the `--rpc` option while running geth. By default, HTTP-RPC runs on port 8545.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下 geth 禁用了 HTTP-RPC。所以在运行 geth 时通过传递`--rpc`选项来启用它。默认情况下，HTTP-RPC 在端口
    8545 上运行。
- en: '`web3` exposes a `isConnected()` method, which can be used to check whether
    it''s connected to the node or not. It returns `true` or `false` depending on
    the connection status.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 公开了一个`isConnected()`方法，用于检查是否连接到节点。根据连接状态返回`true`或`false`。'
- en: The API structure
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 结构
- en: '`web3` contains an `eth` object (`web3.eth`) specifically for Ethereum blockchain
    interactions and an `shh` object (`web3.shh`) for whisper interaction. Most APIs
    of web3.js are inside these two objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 包含一个专门用于以太坊区块链交互的`eth`对象（`web3.eth`），以及一个用于 Whisper 交互的`shh`对象（`web3.shh`）。web3.js
    的大多数 API 都在这两个对象中。'
- en: All the APIs are synchronous by default. If you want to make an asynchronous
    request, you can pass an optional callback as the last parameter to most functions.
    All callbacks use an error-first callback style.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 API 默认都是同步的。如果你想发起异步请求，你可以将一个可选的回调作为大多数函数的最后一个参数传递。所有的回调都使用错误优先的回调风格。
- en: Some APIs have an alias for asynchronous requests. For example, `web3.eth.coinbase()`
    is synchronous, whereas `web3.eth.getCoinbase()` is asynchronous.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 对异步请求有一个别名。例如，`web3.eth.coinbase()`是同步的，而`web3.eth.getCoinbase()`是异步的。
- en: 'Here is an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`getBlock` is used to get information on a block using its number or hash.
    Or, it can take a string such as `"earliest"` (the genesis block), `"latest"`
    (the top block of the blockchain), or `"pending"` (the block that''s being mined).
    If you don''t pass an argument, then the default is `web3.eth.defaultBlock`, which
    is assigned to `"latest"` by default.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBlock` 用于通过其编号或哈希获取区块的信息。或者，它可以接受字符串，如`"earliest"`（创世区块）、`"latest"`（区块链的顶部区块）或`"pending"`（正在挖掘的区块）。如果你不传递参数，则默认为`web3.eth.defaultBlock`，默认情况下分配给`"latest"`。'
- en: All the APIs that need a block identification as input can take a number, hash,
    or one of the readable strings. These APIs use `web3.eth.defaultBlock` by default
    if the value is not passed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要块标识作为输入的 API 都可以接受数字、哈希或可读字符串之一。如果未传递值，则这些 API 默认使用`web3.eth.defaultBlock`。
- en: BigNumber.js
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigNumber.js
- en: JavaScript is natively poor at handling big numbers correctly. Therefore, applications
    that require you to deal with big numbers and need perfect calculations use the
    `BigNumber.js` library to work with big numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在正确处理大数字方面是本地很差的。因此，需要处理大数字并需要完美计算的应用程序使用`BigNumber.js`库来处理大数字。
- en: web3.js also depends on BigNumber.js. It adds it automatically. web3.js always
    returns the `BigNumber` object for number values. It can take JavaScript numbers,
    number strings, and `BigNumber` instances as input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 也依赖于 BigNumber.js。它会自动添加它。web3.js 总是返回`BigNumber`对象作为数字值。它可以接受 JavaScript
    数字、数字字符串和`BigNumber`实例作为输入。
- en: 'Here is an example to demonstrate this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use the `web3.eth.getBalance()` method to get the balance of an address.
    This method returns a `BigNumber` object. We need to call `toString()` on a `BigNumber`
    object to convert it into a number string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`web3.eth.getBalance()`方法来获取地址的余额。该方法返回一个`BigNumber`对象。我们需要在`BigNumber`对象上调用`toString()`将其转换为字符串。
- en: '`BigNumber.js` fails to correctly handle numbers with more than 20 floating
    point digits; therefore, it is recommended that you store the balance in a wei
    unit and while displaying, convert it to other units. web3.js itself always returns
    and takes the balance in wei. For example, the `getBalance()` method returns the
    balance of the address in the wei unit.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigNumber.js`无法正确处理具有20位以上小数的数字；因此，建议您将余额存储在wei单位中，并在显示时将其转换为其他单位。web3.js
    本身始终以wei单位返回和接受余额。例如，`getBalance()`方法以wei单位返回地址的余额。'
- en: Unit conversion
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位转换
- en: web3.js provides APIs to convert the wei balance into any other unit and any
    other unit balance into wei.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js提供了API来将wei余额转换为任何其他单位，并将任何其他单位的余额转换为wei。
- en: 'The `web3.fromWei()` method is used to convert a wei number into any other
    unit, whereas the `web3.toWei()` method is used to convert a number in any other
    unit into wei. Here is example to demonstrate this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.fromWei()`方法用于将wei数转换为任何其他单位，而`web3.toWei()`方法用于将其他单位中的数转换为wei。这里有一个示例来演示这一点：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first line, we convert wei into ether, and in the second line, we convert
    ether into wei. The second argument in both methods can be one of these strings:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将wei转换为以太，而在第二行，我们将以太转换为wei。两种方法的第二个参数可以是以下字符串之一：
- en: '`kwei/ada`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`千wei/雅达`'
- en: '`mwei/babbage`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`兆wei/巴贝吉`'
- en: '`gwei/shannon`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gwei/夏侬`'
- en: '`szabo`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`萨博`'
- en: '`finney`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`芬尼`'
- en: '`ether`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以太币`'
- en: '`kether/grand/einstein`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`兆以太/拜尔/爱因斯坦`'
- en: '`mether`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以太`'
- en: '`gether`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`获得`'
- en: '`tether`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`泰尔`'
- en: Retrieving gas price, balance, and transaction details
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索气价、余额和交易详情
- en: 'Let''s take a look at the APIs to retrieve the gas price, the balance of an
    address, and information on a mined transaction:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下用于检索气价、地址余额以及已挖出交易信息的API：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be of this form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出形式如下：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how the preceding method works:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前述方法的工作原理：
- en: '`web3.eth.gasPrice()`: Determines the gas price by the x latest blocks'' median
    gas price.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.gasPrice()`: 通过x个最新区块的中位数气价确定气价。'
- en: '`web3.ethgetBalance()`: Returns the balance of any given address. All the hashes
    should be provided as hexadecimal strings to the web3.js APIs, not as hexadecimal
    literals. The input for the solidity `address` type should also be hexadecimal
    strings.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.ethgetBalance()`: 返回任何给定地址的余额。所有哈希应作为十六进制字符串提供给web3.js的API，而不是作为十六进制文本。对于solidity的`address`类型的输入，也应作为十六进制字符串提供。 '
- en: '`web3.eth.getTransactionReceipt()`: This is used to get details about a transaction
    using its hash. It returns a transaction receipt object if the transaction was
    found in the blockchain; otherwise, it returns null. The transaction receipt object
    contains the following properties:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.getTransactionReceipt()`: 用于利用其哈希获取有关交易的详细信息。如果在区块链中找到交易，则返回交易收据对象；否则，返回null。交易收据对象包含以下属性：'
- en: '`blockHash`: The hash of the block where this transaction was'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockHash`: 交易所在块的哈希'
- en: '`blockNumber`: The block number where this transaction was'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockNumber`: 此交易所在块的块号'
- en: '`transactionHash`: The hash of the transaction'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionHash`: 交易的哈希'
- en: '`transactionIndex`: The integer of the transactions'' index position in the
    block'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionIndex`: 指交易在块中的位置的整数'
- en: '`from`: The address of the sender'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 发送者的地址'
- en: '`to`: The address of the receiver; `null` when it''s a contract creation transaction'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 接收者的地址；如果是一个合约创建交易，则为`null`'
- en: '`cumulativeGasUsed`: The total amount of gas used when this transaction was
    executed in the block'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumulativeGasUsed`: 此交易执行时在块中使用的总的燃气量'
- en: '`gasUsed`: The amount of gas used by this specific transaction alone'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasUsed`: 该特定交易独自使用的燃气量'
- en: '`contractAddress`: The contract address created if the transaction was a contract
    creation; otherwise, null'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contractAddress`: 如果交易是一个合约创建的话，返回创建的合约地址；否则，返回null'
- en: '`logs`: The array of log objects that this transaction generated'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日志`: 此交易生成的日志对象数组'
- en: Sending ether
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送以太币
- en: 'Let''s look at how to send ether to any address. To send ether, you need to
    use the `web3.eth.sendTransaction()` method. This method can be used to send any
    kind of transaction but is mostly used to send ether because deploying a contract
    or calling a method of contract using this method is cumbersome as it requires
    you to generate the data of the transaction rather than automatically generating
    it. It takes a transaction object that has the following properties:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向任何地址发送以太币。要发送以太币，您需要使用`web3.eth.sendTransaction()`方法。该方法可用于发送任何类型的交易，但主要用于发送以太币，因为使用此方法部署合约或调用合约方法很麻烦，需要您生成交易数据而不是自动生成。它接受一个具有以下属性的交易对象：
- en: '`from`: The address for the sending account. Uses the `web3.eth.defaultAccount`
    property if not specified.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`：发送账户的地址。如果未指定，则使用`web3.eth.defaultAccount`属性。'
- en: '`to`: This is optional. It''s the destination address of the message and is
    left undefined for a contract-creation transaction.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：这是可选的。这是消息的目标地址，在合约创建交易中保持未定义。'
- en: '`value`: This is optional. The value is transferred for the transaction in
    wei as well as the endowment if it''s a contract-creation transaction.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是可选的。这是以wei为单位的交易价值以及（如果是合约创建交易）赋予的资金。'
- en: '`gas`: This is optional. It''s the amount of gas to use for the transaction
    (unused gas is refunded). If not provided, then it''s automatically determined.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gas`：这是可选的。这是用于交易的气量（未使用的气会退还）。如果未提供，则会自动确定。'
- en: '`gasPrice`: This is optional. It''s the price of gas for this transaction in
    wei, and it defaults to the mean network gas price.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasPrice`：这是可选的。这是交易的气价，以wei为单位，默认为平均网络气价。'
- en: '`data`: This is optional. It''s either a byte string containing the associated
    data of the message, or in the case of a contract-creation transaction, the initialization
    code.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是可选的。它是一个包含消息关联数据的字节字符串，或者在合约创建交易的情况下是初始化代码。'
- en: '`nonce`: This is optional. It''s an integer. Every transaction has a nonce
    associated with it. A nonce is a counter that indicates the number of transactions
    sent by the sender of the transaction. If not provided, then it is automatically
    determined. It helps prevent replay attacks. This nonce is not the nonce associated
    with a block. If we are using a nonce greater than the nonce the transaction should
    have, then the transaction is put in a queue until the other transactions arrive.
    For example, if the next transaction nonce should be 4 and if we set the nonce
    to 10, then geth will wait for the middle six transactions before broadcasting
    this transaction. The transaction with nonce 10 is called a queued transaction,
    and it''s not a pending transaction.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nonce`：这是可选的。这是一个整数。每个交易都有一个与之关联的 nonce。nonce 是一个计数器，指示发送方发送的交易数量。如果未提供，则会自动确定。它有助于防止重放攻击。这个
    nonce 不是与区块相关联的 nonce。如果我们使用的 nonce 大于交易应该具有的 nonce，则该交易将被放入队列，直到其他交易到达。例如，如果下一个交易的
    nonce 应该是 4，而我们设置了 nonce 为 10，则 geth 将等待中间的六个交易，然后再广播此交易。具有 nonce 10 的交易称为排队的交易，它不是待处理的交易。'
- en: 'Let''s look at an example of how to send ether to an address:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个向地址发送以太币的示例：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we send one ether from account number 0 to account number 1\. Make sure
    that both the accounts are unlocked using the `unlock` option while running geth.
    In the geth interactive console, it prompts for passwords, but the web3.js API
    outside of the interactive console will throw an error if the account is locked.
    This method returns the transaction hash of the transaction. You can then check
    whether the transaction is mined or not using the `getTransactionReceipt()` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从账户号为0的账户向账户号为1的账户发送1个以太币。在运行geth时确保两个账户都使用`unlock`选项解锁。在geth交互式控制台中，它会提示输入密码，但在交互式控制台之外使用的web3.js
    API如果账户被锁定会抛出错误。此方法返回交易的交易哈希。您随后可以使用`getTransactionReceipt()`方法检查交易是否已被挖掘。
- en: You can also use the `web3.personal.listAccounts()`, `web3.personal.unlockAccount(addr,
    pwd)`, and `web3.personal.newAccount(pwd)` APIs to manage accounts at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在运行时使用`web3.personal.listAccounts()`、`web3.personal.unlockAccount(addr,
    pwd)`和`web3.personal.newAccount(pwd)` API 来管理账户。
- en: Working with contracts
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与合约交互
- en: Let's learn how to deploy a new contract, get a reference to a deployed contract
    using it's address, send ether to a contract, send a transaction to invoke a contract
    method, and estimate the gas of a method call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何部署新合约，通过地址获取已部署合约的引用，向合约发送以太币，发送调用合约方法的交易，并估算方法调用的 gas。
- en: To deploy a new contract or to get a reference to an already deployed contract,
    you need to first create a contract object using the `web3.eth.contract()` method.
    It takes the contract ABI as an argument and returns the contract object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署新合约或获取已部署合约的引用，你需要首先使用`web3.eth.contract()`方法创建一个合约对象。它以合约ABI作为参数并返回合约对象。
- en: 'Here is the code to create a contract object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建合约对象的代码：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have the contract, you can deploy it using the `new` method of the
    contract object or get a reference to an already deployed contract that matches
    the ABI using the `at` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到合约，你可以使用合约对象的`new`方法部署它，或者使用`at`方法获取与ABI匹配的已部署合约的引用。
- en: 'Let''s take a look at an example of how to deploy a new contract:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个部署新合约的示例：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `new` method is called asynchronously, so the callback is fired twice
    if the transaction was created and broadcasted successfully. The first time, it's
    called after the transaction is broadcasted, and the second time, it's called
    after the transaction is mined. If you don't provide a callback, then the `proof`
    variable will have the `address` property set to `undefined`. Once the contract
    is mined, the `address` property will be set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`new`方法是异步调用的，所以如果交易已成功创建和广播，回调会被触发两次。第一次是在交易广播后调用，第二次是在交易被确认后调用。如果不提供回调函数，那么`proof`变量的`address`属性将被设置为`undefined`。一旦合约被确认，`address`属性就会被设置。
- en: In the `proof` contract, there is no constructor, but if there is a constructor,
    then the arguments for the constructor should be placed at the beginning of the
    `new` method. The object we passed contains the from address, the byte code of
    the contract, and the maximum gas to use. These three properties must be present;
    otherwise, the transaction won't be created. This object can have the properties
    that are present in the object passed to the `sendTransaction()` method, but here,
    `data` is the contract byte code and the `to` property is ignored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`proof`合约中，没有构造函数，但如果有构造函数，则构造函数的参数应放在`new`方法的开头。我们传递的对象包含了来源地址、合约的字节码和使用的最大
    gas。这三个属性必须存在；否则交易将不会被创建。这个对象可以有与传递给`sendTransaction()`方法中存在的属性相同的属性，但在这里，`data`是合约的字节码，`to`属性会被忽略。
- en: 'You can use the `at` method to get a reference to an already deployed contract.
    Here is the code to demonstrate this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`at`方法来获取一个已部署合约的引用。以下是演示的代码：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s look at how to send a transaction to invoke a method of a contract.
    Here is an example to demonstrate this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何发送调用合约方法的交易。以下示例演示了这一点：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we call the `sendTransaction` method of the object of the method namesake.
    The object passed to this `sendTransaction` method has the same properties as
    `web3.eth.sendTransaction()`, except that the `data` and `to` properties are ignored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用方法同名对象的`sendTransaction`方法。传递给`sendTransaction`方法的对象具有与`web3.eth.sendTransaction()`相同的属性，只是`data`和`to`属性会被忽略。
- en: 'If you want to invoke a method on the node itself instead of creating a transaction
    and broadcasting it, then you can use `call` instead of `sendTransaction`. Here
    is an example to demonstrate this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在节点本身上调用方法而不是创建并广播交易，那么可以使用`call`而不是`sendTransaction`。以下示例演示了这一点：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sometimes, it is necessary to find out the gas that would be required to invoke
    a method so that you can decide whether to invoke it or not. `web3.eth.estimateGas`
    can be used for this purpose. However, using `web3.eth.estimateGas()` directly
    requires you to generate the data of the transaction; therefore, we can use the
    `estimateGas()` method of the object of the method namesake. Here is an example
    to demonstrate this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要找出调用一个方法所需要的 gas，以便决定是否进行调用。可以使用`web3.eth.estimateGas`来实现此目的。然而，直接使用`web3.eth.estimateGas()`需要你生成交易数据；因此，我们可以使用方法同名对象的`estimateGas()`方法。以下示例演示了这一点：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to just send some ether to a contract without invoking any method,
    then you can simply use the `web3.eth.sendTransaction` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想向合约发送一些以太币而不调用任何方法，则可以简单地使用`web3.eth.sendTransaction`方法。
- en: Retrieving and listening to contract events
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索和监听合同事件
- en: Now let's look at how to watch for events from a contract. Watching for events
    is very important because the result of method invocations by transactions are
    usually returned by triggering events.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何监听合同的事件。监听事件非常重要，因为通过事务调用的方法的结果通常通过触发事件返回。
- en: 'Before we get into how to retrieve and watch for events, we need to learn indexed
    parameters of events. A maximum of three parameters of an event can have the `indexed`
    attribute. This attribute is used to signal the node to index it so that the app
    client can search for events with matching return values. If you don''t use the
    indexed attribute, then it will have to retrieve all the events from the node
    and filter the ones needed. For example, you can write the `logFileAddedStatus`
    event this way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究如何检索和监听事件之前，我们需要学习事件的索引参数。事件的最多三个参数可以具有`indexed`属性。此属性用于向节点发出信号，以便对其进行索引，以便应用客户端可以搜索具有匹配返回值的事件。如果不使用索引属性，则必须从节点检索所有事件并过滤所需的事件。例如，您可以以以下方式编写`logFileAddedStatus`事件：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an example to demonstrate how to listen to contract events:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，演示如何监听合同事件：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how the preceding code works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的工作原理：
- en: 'At first, we get the event object by calling the method of the event namesake
    on a contract instance. This method takes two objects as arguments, which are
    used to filter events:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过在合同实例上调用同名事件的方法来获取事件对象。此方法接受两个对象作为参数，用于过滤事件：
- en: 'The first object is used to filter events by indexed return values: for example,
    `{''valueA'': 1, ''valueB'': [myFirstAddress, mySecondAddress]}`. By default,
    all filter values are set to `null`. This means that they will match any event
    of a given type sent from this contract.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一个对象用于通过索引返回值来过滤事件：例如，`{''valueA'': 1, ''valueB'': [myFirstAddress, mySecondAddress]}`。默认情况下，所有过滤器值都设置为`null`。这意味着它们将匹配来自此合同发送的给定类型的任何事件。'
- en: 'The next object can contain three properties: `fromBlock` (the earliest block;
    by default, it is `"latest"`), `toBlock` (the latest block; by default, it is
    `"latest"`), and `address` (a list of addresses to only get logs from; by default,
    the contract address).'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的对象可以包含三个属性：`fromBlock`（最早的块；默认为`"latest"`），`toBlock`（最新的块；默认为`"latest"`）和`address`（仅从中获取日志的地址列表；默认为合同地址）。
- en: 'The `event` object exposes three methods: `get`, `watch`, and `stopWatching`.
    `get` is used to get all the events in the block range. `watch` is like `get`
    but it watches for changes after getting the events. And `stopWatching` can be
    used to stop watching for changes.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`对象公开三种方法：`get`、`watch`和`stopWatching`。`get`用于获取块范围内的所有事件。`watch`类似于`get`，但它在获取事件后监视更改。`stopWatching`可用于停止监视更改。'
- en: Then, we have the `allEvents` method of the contract instance. It is used to
    retrieve all the events of a contract.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有合同实例的`allEvents`方法。它用于检索合同的所有事件。
- en: 'Every event is represented by an object that contains the following properties:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个事件都由一个包含以下属性的对象表示：
- en: '`args`: An object with the arguments from the event'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：包含事件参数的对象'
- en: '`event`: A string representing the event name'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`：表示事件名称的字符串'
- en: '`logIndex`: An integer representing the log index position in the block'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logIndex`：表示块中日志索引位置的整数'
- en: '`transactionIndex`: An integer representing the transactions the index position
    log was created from'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionIndex`：表示创建此索引位置日志的事务的整数'
- en: '`transactionHash`: A string representing the hash of the transactions this
    log was created from'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionHash`：表示创建此日志的事务的哈希的字符串'
- en: '`address`: A string representing the address from which this log originated'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：表示此日志来源地址的字符串'
- en: '`blockHash`: A string representing the hash of the block where this log was
    in; `null` when its pending'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockHash`：表示此日志所在块的哈希的字符串；当其处于挂起状态时为`null`。'
- en: '`blockNumber`: The block number where this log was in; `null` when its pending'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockNumber`：表示此日志所在块的块号；当其处于挂起状态时为`null`。'
- en: web3.js provides a `web3.eth.filter` API to retrieve and watch for events. You
    can use this API, but the earlier method's way of handling events is much easier.
    You can learn more about it at [https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js提供了一个`web3.eth.filter`API来检索和监听事件。您可以使用此API，但较早方法处理事件的方式要简单得多。您可以在[https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter)了解更多信息。
- en: Building a client for an ownership contract
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为所有权合约构建客户端
- en: In the previous chapter, we wrote Solidity code for the ownership contract,
    and in both the previous chapter and this chapter, we learned web3.js and how
    to invoke the methods of the contract using web3.js. Now, it's time to build a
    client for our smart contract so that users can use it easily.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了所有权合约的 Solidity 代码，并且在上一章和本章中，我们学习了 web3.js，并学习了如何使用 web3.js 调用合约的方法。现在，是时候为我们的智能合约构建一个客户端，以便用户可以轻松使用它。
- en: We will build a client where a user selects a file and enters owner details
    and then clicks on Submit to broadcast a transaction to invoke the contract's
    `set` method with the file hash and the owner's details. Once the transaction
    is successfully broadcasted, we will display the transaction hash. The user will
    also be able to select a file and get the owner's details from the smart contract.
    The client will also display the recent `set` transactions mined in real time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个客户端，用户在其中选择一个文件并输入所有者详细信息，然后点击提交来广播一笔交易以调用合约的 `set` 方法，并传递文件哈希和所有者详细信息。一旦交易成功广播，我们将显示交易哈希。用户还可以选择一个文件，并从智能合约获取所有者详细信息。客户端还将实时显示最近的
    `set` 交易。
- en: We will use sha1.js to get the hash of the file on the frontend, jQuery for
    DOM manipulation, and Bootstrap 4 to create a responsive layout. We will use express.js
    and web3.js on the backend. We will use socket.io so that the backend pushes recently
    mined transactions to the frontend without the frontend requesting for data after
    every equal interval of time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端我们将使用 sha1.js 来获取文件的哈希值，使用 jQuery 进行 DOM 操作，并使用 Bootstrap 4 来创建响应式布局。在后端我们将使用
    express.js 和 web3.js。我们将使用 socket.io，这样后端就可以在每个等间隔的时间后将最近挖掘的交易推送到前端，而无需前端请求数据。
- en: web3.js can be used in the frontend. But for this application, it will be a
    security risk; that is, we are using accounts stored in geth and exposing the
    geth node URL to the frontend, which will put the ether stored in those accounts
    at risk.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 可以在前端使用。但对于这个应用程序来说，这将是一个安全风险；也就是说，我们正在使用存储在 geth 中的帐户，并将 geth 节点 URL
    暴露给前端，这将使这些帐户中的以太币处于风险之中。
- en: The project structure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'In the exercise files of this chapter, you will find two directories: `Final`
    and `Initial. Final` contains the final source code of the project, whereas `Initial`
    contains the empty source code files and libraries to get started with building
    the application quickly.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，你会找到两个目录：`Final` 和 `Initial`。`Final` 包含项目的最终源代码，而 `Initial` 包含空的源代码文件和库，以便快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and replace the hardcoded contract address in `app.js` with the contract address
    you got after deploying the contract. Then, run the app using the `node app.js`
    command inside the `Final` directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `Final` 目录，你需要在其中运行 `npm install` 并将 `app.js` 中的硬编码合约地址替换为部署合约后得到的合约地址。然后，在
    `Final` 目录中使用 `node app.js` 命令运行应用程序。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. `package.json` contains the backend dependencies
    of our app, and `app.js` is where you will place the backend source code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Initial` 目录中，你会找到一个 `public` 目录和两个名为 `app.js` 和 `package.json` 的文件。`package.json`
    包含我们应用程序的后端依赖项，`app.js` 是你将放置后端源代码的地方。
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the Bootstrap library; inside `public/html`,
    you will find `index.html`, where you will place the HTML code of our app; and
    in the `public/js` directory, you will find JS files for jQuery, sha1, and socket.io.
    Inside `public/js`, you will also find a `main.js` file, where you will place
    the frontend JS code of our app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 目录包含与前端相关的文件。在 `public/css` 目录中，你会找到 `bootstrap.min.css`，这是 Bootstrap
    库；在 `public/html` 目录中，你会找到 `index.html`，在其中放置我们应用程序的 HTML 代码；在 `public/js` 目录中，你会找到
    jQuery、sha1 和 socket.io 的 JS 文件。在 `public/js` 中，你还会找到一个 `main.js` 文件，在其中放置我们应用程序的前端
    JS 代码。'
- en: Building the backend
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: 'Let''s first build the backend of the app. First of all, run `npm install`
    inside the `Initial` directory to install the required dependencies for our backend.
    Before we get into coding the backend, make sure geth is running with rpc enabled.
    If you are running geth on a private network, then make sure mining is also enabled.
    Finally, make sure that account 0 exists and is unlocked. You can run geth on
    a private network with rpc and mining enabled and also unlocking account 0:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建应用程序的后端。首先，在`Initial`目录中运行`npm install`以安装后端所需的依赖项。在我们开始编写后端代码之前，请确保
    geth 正在运行，并启用了 rpc。如果您正在私有网络上运行 geth，则确保也启用了挖矿。最后，请确保帐户 0 存在并已解锁。您可以在启用了 rpc 和挖矿的私有网络上运行
    geth，并且还解锁帐户 0：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One final thing you need to do before getting started with coding is deploy
    the ownership contract using the code we saw in the previous chapter and copy
    the contract address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您需要做的最后一件事是使用我们在上一章中看到的代码部署所有权合约，并复制合约地址。
- en: 'Now let''s create a single server, which will serve the HTML to the browser
    and also accept `socket.io` connections:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个单一的服务器，它将向浏览器提供 HTML，并且还会接受`socket.io`连接：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are integrating both the `express` and `socket.io` servers into one
    server running on port `8080`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`express`和`socket.io`服务器集成到一个运行在端口`8080`上的服务器中。
- en: 'Now let''s create the routes to serve the static files and also the home page
    of the app. Here is the code to do this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来提供静态文件和应用程序的主页。以下是执行此操作的代码：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are using the `express.static` middleware to serve static files. We
    are asking it to find static files in the `public` directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`express.static`中间件来提供静态文件。我们要求它在`public`目录中查找静态文件。
- en: 'Now let''s connect to the `geth` node and also get a reference to the deployed
    contract so that we can send transactions and watch for events. Here is the code
    to do this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接到`geth`节点，并且获取部署的合约的引用，以便我们可以发送交易和监视事件。以下是执行此操作的代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code is self-explanatory. Just replace the contract address with the one
    you got.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是不言自明的。只需用您得到的合约地址替换代码中的合约地址即可。
- en: 'Now let''s create routes to broadcast transactions and get information about
    a file. Here is the code to do this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来广播交易并获取有关文件的信息。以下是执行此操作的代码：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `/submit` route is used to create and broadcast transactions. Once
    we get the transaction hash, we send it to the client. We are not doing anything
    to wait for the transaction to mine. The `/getInfo` route calls the get method
    of the contract on the node itself instead of creating a transaction. It simply
    sends back whatever response it got.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/submit`路由用于创建和广播交易。一旦我们得到了交易哈希，我们就将其发送给客户端。我们不会采取任何措施等待交易挖矿。`/getInfo`路由调用合约在节点本身上的
    get 方法，而不是创建交易。它只是返回它得到的任何响应。
- en: 'Now let''s watch for the events from the contract and broadcast it to all the
    clients. Here is the code to do this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们监视来自合约的事件，并将其广播给所有连接的客户端。以下是执行此操作的代码：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we check whether the status is true, and if it's true, only then do we
    broadcast the event to all the connected `socket.io` clients.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查状态是否为 true，如果是 true，那么我们才向所有连接的`socket.io`客户端广播事件。
- en: Building the frontend
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: 'Let''s begin with the HTML of the app. Put this code in the `index.html` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的 HTML 开始。将此代码放入`index.html`文件中：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is how the code works:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: At first, we display Bootstrap's file input field so that the user can select
    a file.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们显示 Bootstrap 的文件输入字段，以便用户可以选择文件。
- en: Then, we display a text field where the user can enter the owner's details.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们显示一个文本字段，用户可以输入所有者的详细信息。
- en: Then, we have two buttons. The first one is to store the file hash and the owner's
    details in the contract, and the second button is to get information on the file
    from the contract. Clicking on the Submit button triggers the `submit()` method,
    whereas clicking on the Get Info button triggers the `getInfo()` method.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有两个按钮。第一个按钮用于将文件哈希和所有者的详细信息存储在合约中，第二个按钮用于从合约中获取文件的信息。单击提交按钮会触发`submit()`方法，而单击获取信息按钮会触发`getInfo()`方法。
- en: Then, we have an alert box to display messages.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有一个警报框来显示消息。
- en: Finally, we display an ordered list to display the transactions of the contract
    that gets mined while the user is on the page.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示一个有序列表，显示用户在页面上的同时挖掘的合约的交易。
- en: 'Now let''s write the implementation for the `getInfo()` and `submit()` methods,
    establish a `socket.io` connect with the server, and listen for `socket.io` messages
    from the server. Here is the code to this. Place this code in the `main.js` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`getInfo()`和`submit()`方法编写实现代码，与服务器建立`socket.io`连接，并监听来自服务器的`socket.io`消息。以下是此代码。将此代码放入`main.js`文件中：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how the preceding code works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前述代码的工作原理：
- en: At first, we defined the `submit()` method. In the `submit` method, we make
    sure that a file is selected and the text field is not empty. Then, we read the
    content of the file as an array buffer and pass the array buffer to the `sha1()`
    method exposed by sha1.js to get the hash of content inside the array buffer.
    Once we have the hash, we use jQuery to make an AJAX request to the `/submit` route
    and then we display the transaction hash in the alert box.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了`submit()`方法。在`submit`方法中，我们确保已选择文件并且文本字段不为空。然后，我们将文件内容读取为数组缓冲区，并将数组缓冲区传递给
    sha1.js 公开的`sha1()`方法以获取数组缓冲区内部内容的哈希。一旦我们有了哈希，我们就使用 jQuery 发出 AJAX 请求到`/submit`路由，然后我们在警告框中显示交易哈希。
- en: We define the `getInfo()` method next. It first makes sure that a file is selected.
    Then, it generates the hash like the one it generated earlier and makes a request
    to the `/getInfo` endpoint to get information about that file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来定义`getInfo()`方法。首先确保已选择文件。然后，生成像之前生成的哈希一样的哈希，并向`/getInfo`端点发出请求以获取有关该文件的信息。
- en: Finally, we establish a `socket.io` connection using the `io()` method exposed
    by the `socket.io` library. Then, we wait for the connect event to the trigger,
    which indicates that a connection has been established. After the connection is
    established, we listen for messages from the server and display the details about
    the transactions to the user.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket.io`库公开的`io()`方法建立了一个`socket.io`连接。然后，我们等待触发连接事件，这表明已建立连接。连接建立后，我们监听来自服务器的消息，并向用户显示有关交易的详细信息。
- en: We aren't storing the file in the Ethereum blockchain because storing files
    is very expensive as it requires a lot of gas. For our case, we actually don't
    need to store files because nodes in the network will be able to see the file;
    therefore, if the users want to keep the file content secret, then they won't
    be able to. Our application's purpose is just to prove ownership of a file, not
    to store and serve the file like a cloud service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不将文件存储在以太坊区块链中，因为存储文件非常昂贵，需要大量的 gas。对于我们的情况，实际上我们不需要存储文件，因为网络中的节点将能够看到文件；因此，如果用户想要保密文件内容，那么他们将无法做到。我们应用程序的目的只是证明对文件的所有权，而不是像云服务一样存储和提供文件。
- en: Testing the client
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端
- en: 'Now run the `app.js` node to run the application server. Open you favorite
    browser and visit `http://localhost:8080/`. You will see this output in the browser:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`app.js`节点以运行应用程序服务器。打开您喜欢的浏览器并访问`http://localhost:8080/`。您将在浏览器中看到以下输出：
- en: '![](img/image_04_001.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_001.png)'
- en: 'Now select a file and enter the owner''s name and click on Submit. The screen
    will change to this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择一个文件，输入所有者的姓名，然后单击提交。屏幕将更改为以下内容：
- en: '![](img/image_04_002.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_002.png)'
- en: 'Here, you can see that the transaction hash is displayed. Now wait until the
    transaction is mined. Once the transaction is mined, you will be able to see the
    transaction in the live transactions list. Here is how the screen would look:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到交易哈希已显示。现在等待交易被挖掘。一旦交易被挖掘，您将能够在实时交易列表中看到该交易。屏幕将如下所示：
- en: '![](img/image_04_003.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_003.png)'
- en: 'Now select the same file again and click on the Get Info button. You will see
    this output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次选择相同的文件，然后单击获取信息按钮。您将看到以下输出：
- en: '![](img/image_04_004.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_004.png)'
- en: Here, you can see the timestamp and the owner's details. Now we have finished
    building the client for our first DApp.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到时间戳和所有者的详细信息。现在我们已经完成了第一个 DApp 的客户端构建。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about the fundamentals of web3.js with examples.
    We learned how to connect to a node, basic APIs, sending various kinds of transactions,
    and watching for events. Finally, we built a proper production use client for
    our ownership contract. Now you will be comfortable with writing smart contracts
    and building UI clients for them in order to ease their use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了使用示例的 web3.js 的基础知识。我们学习了如何连接到节点，基本的 API，发送各种类型的交易以及监听事件。最后，我们为我们的所有权合同构建了一个适当的生产用客户端。现在，您将能够舒适地编写智能合约并为其构建
    UI 客户端以便简化使用。
- en: In the next chapter, we will build a wallet service, where users can create
    and manage Ethereum Wallets easily, and that too is offline. We will specifically
    use the LightWallet library to achieve this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个钱包服务，用户可以轻松创建和管理以太坊钱包，而且还可以离线进行。我们将专门使用 LightWallet 库来实现这一目标。
