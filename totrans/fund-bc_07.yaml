- en: Diving into Blockchain - Proof of Ownership
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入区块链 - 拥有证明
- en: In this chapter, we'll be introduced to the wider applications of blockchain
    by creating a proof of ownership application. Throughout this chapter, we'll discuss
    the concept of smart contracts within blockchain in order to implement this application.
    Since we've already introduced the concepts of blockchain in the earlier chapters
    of this book, this chapter will mainly focus on the high-level details of smart
    contracts, namely proof of ownership and the creation of a decentralized application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建一个拥有证明应用程序来介绍区块链的更广泛应用。在本章中，我们将讨论区块链内智能合约的概念，以便实施此应用程序。由于我们已经在本书的前几章介绍了区块链的概念，本章主要将关注智能合约的高级细节，即拥有证明和去中心化应用程序的创建。
- en: 'We''re going to focus on the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Creating a proof of ownership application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建拥有证明应用程序
- en: The concept of smart contracts within blockchain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链内智能合约的概念
- en: How to choose a smart contract platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择智能合约平台
- en: Exploring the NEO blockchain platform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 NEO 区块链平台
- en: Creating a decentralized application (proof of ownership) in NEO blockchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 NEO 区块链中创建去中心化应用程序（拥有证明）
- en: Exploring the Ethereum blockchain platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索以太坊区块链平台
- en: Creating a decentralized application (proof of ownership) in Ethereum blockchain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以太坊区块链中创建去中心化应用程序（拥有证明）
- en: In the world of assets, it is necessary to keep track of each and every one
    of them if you want to claim and prove ownership of them. But assets are created
    by different entities in different parts of the world, and there is no single
    protocol for managing assets because each entity has its own system of asset management.
    For example, if Alice has a house and a car in a city, and she wants to sell both
    the house and car to Bob because she is planning to move out of the city, she
    has to go through different procedures to transfer ownership to Bob – she has
    to deal with the land registry for the house, the road transport department for
    the car.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在资产的世界中，如果你想要声明和证明拥有它们，就必须跟踪每一个资产。但是资产是由世界各地的不同实体创建的，并且没有一个单一的协议来管理资产，因为每个实体都有自己的资产管理系统。例如，如果爱丽丝在一个城市拥有一所房子和一辆车，并且她想把房子和车都卖给鲍勃，因为她打算搬出这个城市，她必须通过不同的程序将所有权转让给鲍勃
    - 她必须处理房地产登记处的房屋，交通部门的汽车。
- en: In addition, she also appoints an attorney, because the procedure is quite complex.
    She is only able to finally transfer ownership of the car and the house to Bob
    after dealing with the registration office, the attorney, and the notaries. The
    protocol involved in the registration and management of the different assets meant
    Alice had to deal with different entities to perform a simple task.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，她还任命了一名律师，因为这个程序相当复杂。只有在处理注册办公室、律师和公证员之后，她才能最终将车和房屋的所有权转让给鲍勃。注册和管理不同资产的协议意味着爱丽丝必须与不同的实体打交道来执行一个简单的任务。
- en: The current asset management system requires approval from certain trusted authorities.
    The main reason for the involvement of a trusted authority is the fact that the
    assets exist within a trustless society. Different entities create their own set
    of procedures to deal with assets. Some of the entities may be using outdated
    technology, making it hard to use as the user has to deal with some traditional
    procedures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的资产管理系统需要来自某些受信任的权威的批准。受信任的权威参与的主要原因是资产存在于一个无信任的社会中。不同的实体创建自己的一套处理资产的程序。其中一些实体可能正在使用过时的技术，使得用户不得不处理一些传统的程序，这样很难使用。
- en: The proof of ownership solution proposed in this chapter will use blockchain
    to build a decentralized application to mitigate all the issues faced by a centralized
    asset management system. We'll use digital identity, assets, and smart contracts
    to create a completely decentralized asset management system with the help of
    blockchain technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提出的拥有证明解决方案将使用区块链来构建一个去中心化的应用程序，以缓解集中式资产管理系统所面临的所有问题。我们将利用数字身份、资产和智能合约来借助区块链技术创建一个完全去中心化的资产管理系统。
- en: Digital assets and identity
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字资产和身份
- en: Digital assets are programmable assets that exist in digital format. These assets
    can have their own value (digital tokens) or could virtually represent existing
    physical assets (ownership of vehicle). Digital assets have been used since the
    beginning of the digital age, but until now they have always existed in an environment
    where management was centralized. The invention of blockchain has allowed digital
    assets to exist in a decentralized network, where no trusted intermediary is needed
    to register or trade an asset. Removing the intermediaries means users don't have
    to pay any additional charges while trading assets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数字资产是以数字格式存在的可编程资产。这些资产可以拥有自己的价值（数字代币），或者可以虚拟代表现有的实物资产（车辆所有权）。数字资产自数字时代开始就已经被使用，但直到现在它们一直存在于管理集中的环境中。区块链的发明使数字资产得以存在于去中心化网络中，无需信任的中介来注册或交易资产。去除中介意味着用户在交易资产时无需支付任何额外费用。
- en: Digital identity is essential to digital assets when dealing with asset ownership.
    It represents the identity of any individual or organization in a digital format.
    Digital identity is based on the **public key infrastructure** (**PKI**) and provides
    accurate identity management for the user. Unlike traditional identity documents,
    which could easily be forged, digital identity requires the user to authenticate
    via a digital signature to prove their identity. This system often uses a secured
    key infrastructure, which cannot be compromised easily.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数字身份对于处理资产所有权时至关重要。它代表了以数字格式存在的任何个人或组织的身份。数字身份基于**公钥基础设施**（**PKI**），为用户提供准确的身份管理。与容易伪造的传统身份文件不同，数字身份要求用户通过数字签名进行身份验证以证明其身份。这个系统通常使用安全的密钥基础设施，不容易被破坏。
- en: We discussed claiming digital assets in the earlier chapters; you'll remember
    we covered the creation of an identity for the user with which the user would
    be able to claim an asset using a secret key. A similar approach will be used
    here to create and manage the digital identity of the user in the platform that
    we will use to build the application in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章我们讨论了索取数字资产的问题；你会记得我们讲解了为用户创建身份，用户将能够使用秘密密钥来索取资产。类似的方法将被用来在我们将用于构建本章应用程序的平台中创建和管理用户的数字身份。
- en: Proof of ownership
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权证明
- en: Every asset in the world is owned by some entity. Ownership of a part of an
    asset might not be feasible to prove, either due to the fact that part of the
    ownership record is missing or due to the ambiguity in the existing record's data.
    Although ownership is proved digitally, or by other means, by the entities, in
    most cases, the ownership information is not consistent across all the systems.
    Proving ownership by keeping a digital record is the best solution, and digital
    assets and identities play a huge role in this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上的每一项资产都归某个实体所有。由于部分所有权记录缺失或现有记录数据的模糊性，资产的部分所有权可能无法证明。尽管所有权是通过数字方式或其他方式由实体证明的，在大多数情况下，所有权信息在所有系统中并不一致。通过保持数字记录来证明所有权是最佳解决方案，数字资产和身份在其中扮演了重要角色。
- en: Digital assets, along with digital identities, provide a convenient way to claim
    ownership of any goods because assets are registered digitally along with the
    user's identity. Whenever users need to verify and prove ownership of an asset,
    they can provide their identity details along with the asset that they are trying
    to claim. Users might often need to verify their identity by either providing
    some secret information or authenticating using secret information. The identity
    verification process depends on the third party that built the asset management
    system. In our previous example, where Alice wanted to sell her house and car
    to Bob, she would need to provide identity information to the land registry and
    transport departments that could then be verified by comparing it against the
    records on their system. The drawback of this kind of proof of ownership system
    is that there is no proper protocol maintained across different organizations.
    This is why identity management isn't secure across every system, and why organizations
    still use traditional systems, such as hard copies of the user's identity, to
    verify identities without a proper authentication mechanism, which could be easily
    exploited by bad actors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数字资产与数字身份一起为主张对任何商品的所有权提供了一种方便的方式，因为资产与用户的身份一起在数字上注册。每当用户需要验证和证明资产的所有权时，他们可以提供他们的身份详细信息以及他们正在试图索赔的资产。用户经常需要通过提供一些秘密信息或使用秘密信息进行身份验证来验证他们的身份。身份验证过程取决于建立资产管理系统的第三方。在我们之前的示例中，Alice想要将她的房子和车卖给Bob，她需要向土地登记处和交通部门提供身份信息，然后可以通过与他们系统上的记录进行比较来进行验证。这种所有权证明系统的缺点是没有在不同组织之间保持适当的协议。这就是为什么身份管理在每个系统中都不安全的原因，以及为什么组织仍然使用传统系统，例如用户身份的硬拷贝，来验证身份而没有适当的身份验证机制，这很容易被不良行为者利用。
- en: A completely secure proof of ownership system could be created by using a digital
    identity, which uses strong authentication to prove a user's identity. Most existing
    systems that implement this proof of ownership model are centralized, which requires
    the centralized body to be trusted. Although this provenance model solves the
    problem, it needs the user to completely trust the third-party organization to
    prove and verify the ownership. Creating a decentralized proof of ownership system
    using blockchain is the only well-known solution that could solve all the problems
    regarding asset management and proof of ownership. Blockchain is the most suitable
    technology for asset management due to its immutability and traceability, as once
    some information about an asset has been appended to a blockchain, it cannot be
    undone. The traceability makes it easy to verify any transactions, and also allows
    a transaction to be restricted with a specialized blockchain if privacy is a concern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完全安全的所有权证明系统可以通过使用数字身份来创建，该身份使用强身份验证来证明用户的身份。大多数实现此所有权证明模型的现有系统都是集中式的，这需要对集中式机构的信任。尽管这种出处模型解决了问题，但它需要用户完全信任第三方组织来证明和验证所有权。使用区块链创建分散的所有权证明系统是唯一已知的解决方案，可以解决有关资产管理和所有权证明的所有问题。由于其不可变性和可追溯性，区块链是资产管理的最合适技术，因为一旦某个资产的某些信息被附加到区块链上，就无法撤销。可追溯性使得验证任何交易变得容易，并且如果隐私是一个问题，还允许使用专用区块链限制交易。
- en: Although proof of ownership could be achieved using a blockchain in a decentralized
    network, some complex agreements between participants of trades may exist in some
    cases. These agreements are formed between the parties by creating contracts.
    A concept known as **smart contracts** is used to perform this in a decentralized
    network. We will be using this to create a decentralized proof of ownership application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在分散网络中可以使用区块链实现所有权证明，但在某些情况下，交易参与者之间可能存在一些复杂的协议。这些协议是通过创建合同而形成的。一个称为**智能合约**的概念用于在分散网络中执行此操作。我们将使用此功能来创建分散的所有权证明应用程序。
- en: One of the best examples of a decentralized proof of ownership application is
    **Everledger**, which built a proof of ownership model for the supply chain of
    the diamond market ([https://diamonds.everledger.io](https://diamonds.everledger.io)).
    Everledger provides a global digital blockchain ledger to keep track of the ownership
    history of assets. It tries to prevent fraud in the diamond industry, which is
    estimated to be in the billions of dollars annually.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts are created between parties to enforce an agreement and to ensure
    that the participants cannot deny the agreement later. A smart contract is a protocol
    that allows contracts to be verified and enforced in a self-executing manner.
    In simple terms, it executes a contract agreed between parties whenever the conditions
    of the contract are met, without anyone's intervention. The term, smart contract,
    was coined by Nick Szabo, a cryptographer, in 1994\. Although the smart contract
    was conceptualized in the early 1990s to automate the execution of traditional
    contracts, it wasn't implemented in a public network until the adoption of Bitcoin's
    underlying blockchain technology.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: It was the Byzantine fault-tolerant consensus algorithms that made the execution
    of smart contracts possible in a decentralized public network. A number of existing
    blockchain platforms provide support for **Turing complete** programming languages,
    which makes it easier to create the logic required to build a smart contract.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A programming language is said to be Turing complete if it can be used to simulate
    a Turing machine. Bitcoin's scripting language was intentionally made Turing incomplete
    to keep the Bitcoin transaction as simple as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Since smart contracts are created and deployed in the blockchain, they will
    benefit from all the features that blockchain provides. None of the contacts stored
    in the blockchain can be tampered with by anyone once they have been accepted
    and deployed by the parties, due to their immutability. In addition to this, deploying
    a smart contract in a blockchain gives complete transparency as anyone can verify
    the existence of the contract at any time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts also have several other additional benefits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster deployment and execution**: Preparing a contract in the traditional
    way would require the user to spend hours of time preparing paperwork and processing
    it. A smart contract is nothing but a set of instructions that automate these
    tasks, which removes many unnecessary steps.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-efficient deployment and execution**: Creating and executing smart contracts
    on a blockchain is cheaper than with traditional contracts, which need the involvement
    of intermediaries to be processed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure management**: All the contracts created in a blockchain are managed
    securely. This is the inherent nature of the blockchain.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replicated proofs**: Due to the decentralized public ledger in the network,
    each contract resides on every node of the network, providing multiple backups.
    It is impossible to lose a contract on a blockchain network.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制证明**：由于网络中的去中心化公共账本，每个合约都驻留在网络的每个节点上，提供多重备份。在区块链网络上不可能丢失合约。'
- en: '**Accurate execution**: Smart contracts are created with a set of instructions
    that execute consistently on every node in the blockchain network. This ensures
    that smart contracts always operate accurately. Due to the Byzantine fault-tolerant
    nature of blockchain, the network will ignore any faulty executions of the contract.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确执行**：智能合约以一组指令创建，在区块链网络中的每个节点上一致执行。这确保智能合约始终准确运行。由于区块链的拜占庭容错特性，网络将忽略合约的任何错误执行。'
- en: Choosing the smart contract platform
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择智能合约平台
- en: Smart contracts are self-executing contracts that can be deployed using any
    blockchain application that supports the execution of basic scripts in its transactions.
    Most blockchain platforms support a domain-specific language. We have already
    come across the language used in Bitcoin transactions, which is called **Script**,
    a stack-based language with limited capabilities. Although Script is a Turing-incomplete
    language, it only has a few options that can be used to create complex transactions.
    It can create multi-signature transactions, payment channels, and atomic cross-chain
    trading. In addition to this, Bitcoin can create a transaction with a lock time.
    A transaction can be created but locked for a certain amount of time in case the
    creator wants to invalidate the transaction before the lock time expires. Although
    Bitcoin's Script language provides enough flexibility to create a complex transaction,
    it isn't suitable for creating complex contracts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是自动执行的合约，可以通过支持在其交易中执行基本脚本的任何区块链应用部署。大多数区块链平台支持领域特定语言。我们已经了解了比特币交易中使用的语言，称为**Script**，这是一种功能有限的基于堆栈的语言。尽管Script是一种图灵不完全的语言，但只有少数选项可以用于创建复杂交易。它可以创建多重签名交易，付款通道和原子跨链交易。此外，比特币可以创建一个带有锁定时间的交易。可以创建交易，但在某段时间内锁定，以防创建者希望在锁定时间到期之前使交易无效。尽管比特币的Script语言提供了足够的灵活性来创建复杂交易，但不适合创建复杂合约。
- en: Many blockchain platforms have been created since then that provide advanced
    scripting capabilities using their own domain-specific language, such as **Solidity**
    by Ethereum and **Plutus** by Cardano. In addition to this, most platforms have
    their own runtime environment, which is where the compiled smart contract is executed.
    The runtime environment is similar to the one used in general-purpose programming
    languages such as Java. Smart contracts will run on a virtual machine, which is
    similar to a **Java Virtual Machine** (**JVM**). The blockchain virtual machine
    provides a way to execute untrusted code in the public network. These virtual
    machines also provide security against attacks such as **denial-of-service** (**DoS**)
    attacks, which is a necessary feature in systems that execute untrusted code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时以来，已经创建了许多区块链平台，这些平台提供使用自己的领域特定语言的高级脚本功能，例如以太坊的**Solidity**和卡尔达诺的**Plutus**。此外，大多数平台都有自己的运行时环境，编译后的智能合约在其中执行。运行时环境类似于通用编程语言（如Java）中使用的环境。智能合约将在虚拟机上运行，类似于**Java虚拟机**（**JVM**）。区块链虚拟机提供一种在公共网络中执行不受信任代码的方式。这些虚拟机还可以提供对抗攻击（如**拒绝服务**（**DoS**）攻击）的安全性，这是在执行不受信任代码的系统中必不可少的功能。
- en: 'Some of the blockchain platforms that provide these services are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这些服务的一些区块链平台如下：
- en: '**EOS**: A smart contract platform and decentralized operating system that
    aims to solve the scalability issues in blockchain by conducting millions of transactions
    per second.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EOS**：一种智能合约平台和去中心化操作系统，旨在通过每秒进行数百万次交易来解决区块链的可扩展性问题。'
- en: '**Ethereum**: This is the most prominent smart contract platform. It implements
    a nearly Turing-complete language on its blockchain. It uses a domain-specific
    language called Solidity, which is compiled and executed on the **Ethereum Virtual
    Machine** (**EVM**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以太坊**：这是最著名的智能合约平台。它在其区块链上实现了一个几乎图灵完备的语言。它使用一个名为Solidity的领域特定语言，在**以太坊虚拟机**（**EVM**）上编译和执行。'
- en: '**Hyperledger Fabric**: This is a permissioned blockchain project under the
    Hyperledger projects hosted by The Linux Foundation. It allows execution of smart
    contracts called **chaincode**. It also allows a consensus mechanism to be plugged
    in as a component.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hyperledger Fabric**：这是由Linux Foundation主办的Hyperledger项目下的一个许可区块链项目。它允许执行称为**链码**的智能合约。它还允许共识机制作为组件插入。'
- en: '**NEO**: This is a blockchain platform that allows smart contract to be written
    in several general-purpose programming languages, such as C#, Python, and JavaScript.
    We will cover NEO blockchain in detail in the next section.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEO**：这是一个区块链平台，允许智能合约用几种通用编程语言编写，例如C＃、Python和JavaScript。我们将在下一节详细介绍NEO区块链。'
- en: '**NXT**: This is a public blockchain platform that executes a limited selection
    of templates for smart contracts. It doesn''t have much scope for the creation
    of complex contracts.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NXT**：这是一个公共区块链平台，执行了有限的智能合约模板选择。它并没有太多的空间来创建复杂的合约。'
- en: Selecting a platform to create a smart contract depends on the type of application
    that needs to be built, required performance, smart contract language, and many
    other things. It is important to consider all the requirements before selecting
    the platform. As far as our proof of ownership application is concerned, it needs
    a platform that can handle digital assets and digital identity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建智能合约的平台取决于需要构建的应用类型、所需的性能、智能合约语言以及许多其他因素。在选择平台之前考虑所有的要求是很重要的。就我们的所有权证明应用而言，它需要一个能处理数字资产和数字身份的平台。
- en: NEO blockchain provides a convenient way to handle digital identity and assets.
    In addition to this, the smart contracts can be coded in a general-purpose programming
    language to build the decentralized applications. We will create our smart contract
    in the Python programming language so that we need not master any additional programming
    language. Ethereum is one more platform where a wide range of use cases can be
    implemented conveniently. We will implement our proof of ownership use case in
    both the platforms since they are the most widely used blockchain platforms, and
    the introduction to both of these platforms will provide a solid foundation for
    decentralized application development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NEO区块链提供了处理数字身份和资产的便利方式。除此之外，智能合约可以用通用编程语言编写，以构建去中心化应用程序。我们将用Python编程语言创建我们的智能合约，这样我们就不需要掌握任何额外的编程语言。以太坊是另一个平台，可以便捷地实现各种用例。我们将在这两个平台上实现我们的所有权证明用例，因为它们是最常用的区块链平台，同时对这两个平台的介绍将为去中心化应用程序开发打下坚实的基础。
- en: In the coming sections, we are going to dive into both NEO and Ethereum blockchain
    platforms, along with proof of ownership implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨NEO和以太坊区块链平台，以及所有权证明的实现。
- en: NEO blockchain
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO区块链
- en: NEO is a blockchain platform and cryptocurrency that facilitates the creation
    and management of digital assets and smart contracts. The NEO project was originally
    launched in 2014 under the name of AntShares, until it changed its name in June,
    2017\. All the development resources were provided by founder, Da Hongfei, from
    his business blockchain solution company, called Onchain. The main motive of the
    NEO project is to achieve a **smart economy** with the help of digital assets,
    digital identity, and smart contracts in a distributed network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NEO是一个区块链平台和加密货币，能够促进数字资产和智能合约的创建和管理。NEO项目最初于2014年以AntShares的名义发布，直到2017年6月更名为NEO。所有的开发资源都是由创始人达·宏飞的区块链解决方案公司Onchain提供的。NEO项目的主要目的是在分布式网络中实现**智能经济**，借助数字资产、数字身份和智能合约。
- en: The platform uses two kinds of token, called NEO and GAS. Unlike Bitcoin, a
    NEO token is a non-divisible token, which means that the minimum unit of NEO is
    1\. Holding the NEO tokens gives the right to vote during the consensus mechanism,
    which is explained in the, *Consensus algorithm* section. Holding the NEO token
    generates a new token called GAS, which is used to pay for the transaction fee.
    A GAS token is like a fuel that is essential if you want to deploy and execute
    any smart contract on the blockchain. A total of 100 million NEO tokens are generated
    in the genesis block. But the corresponding 100 million GAS tokens will be generated
    gradually in about 22 years.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台使用两种类型的代币，称为NEO和GAS。与比特币不同，NEO代币是不可分割的，这意味着NEO的最小单位为1. 持有NEO代币可以在共识机制中行使投票权，该机制在*共识算法*部分有解释。持有NEO代币会产生一种名为GAS的新代币，用于支付交易费。GAS代币就像燃料一样，如果你想在区块链上部署和执行任何智能合约，就必不可少。创世区块中发行了1亿个NEO代币。但相应的1亿个GAS代币将在大约22年内逐渐发行。
- en: Building blocks of a NEO blockchain
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO区块链的构建块
- en: A NEO blockchain uses two important elements of a decentralized network to create
    a decentralized application and therefore construct a smart economy. These are
    digital assets and digital identity, which are the building blocks of any blockchain
    application. These concepts, along with smart contracts, are essential to the
    creation of any proof of ownership application, as mentioned earlier in the chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NEO区块链使用了去中心化网络的两个重要元素，以创建去中心化应用程序，因此构建了智能经济。这些元素是数字资产和数字身份，它们是任何区块链应用程序的基石。这些概念，连同智能合约，在之前的章节中已经提到，对于任何所有权证明应用程序的创建是至关重要的。
- en: 'NEO provides a convenient way of creating and managing the digital assets in
    a decentralized NEO blockchain network. NEO provides two different types of asset:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NEO提供了在去中心化NEO区块链网络中创建和管理数字资产的便利方式。NEO提供了两种不同类型的资产：
- en: Global assets
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局资产
- en: Contract assets
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约资产
- en: Global assets are recorded in the system and can be identified by all the clients
    and smart contracts. NEO and GAS tokens are global assets. Contract assets are
    bound to specific contracts and cannot be identified by other contracts. Only
    certain compatible clients will be able to access the contract assets. NEP-5-based
    assets are an example of contract assets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 全局资产记录在系统中，并且所有客户端和智能合约都能识别。NEO和GAS代币是全局资产。合约资产与特定合约绑定，不能被其他合约识别。只有某些兼容的客户端才能访问合约资产。基于NEP-5的资产就是合约资产的一个例子。
- en: NEP-5 a is standard specified by NEO to create cryptographic tokens. The standard
    helps the developers to maintain a template while building applications related
    to tokens. NEP-5 tokens are similar to the ERC-20 tokens used in Ethereum. We
    will later implement a use case using the NEP-5 token in [Chapter 12](55ed2989-ecca-46ca-8546-74a12da98715.xhtml),
    *Blockchain Use Cases*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NEP-5是NEO指定的用于创建加密代币的标准。该标准帮助开发人员在构建与代币相关的应用程序时保持模板。NEP-5代币类似于以太坊中使用的ERC-20代币。我们将在[第12章](55ed2989-ecca-46ca-8546-74a12da98715.xhtml)中实施使用NEP-5代币的用例，*区块链使用案例*。
- en: NEO provides a way to handle connections between physical and digital assets
    in a blockchain with the help of digital identity. NEO implements the **X.509**
    public key certificate issuance standard to create digital identities. With the
    help of blockchain, NEO can replace the **Online Certificate Status Protocol**
    (**OCSP**) to manage and record the X.509 **Certificate Revocation List** (**CRL**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: NEO利用数字身份在区块链中处理物理资产和数字资产之间的连接。NEO实现了**X.509**公钥证书颁发标准来创建数字身份。借助区块链，NEO可以取代**在线证书状态协议**（**OCSP**）来管理和记录X.509
    **证书吊销列表**（**CRL**）。
- en: NEO technology
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO技术
- en: NEO provides several functionalities to function as a scalable blockchain platform.
    A few of the technologies used in NEO are discussed here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: NEO提供了几种功能来作为可扩展的区块链平台运行。下面讨论了NEO中使用的一些技术。
- en: Consensus algorithm
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法
- en: NEO uses **Delegated Byzantine Fault Tolerance** (**dBFT**), a modified Byzantine
    fault-tolerant consensus algorithm. It is a mechanism that allows all the blockchain
    participants to reach a consensus through proxy voting. A special group of nodes
    called bookkeepers reach a consensus in order to generate new blocks in the network.
    These bookkeepers are elected by NEO token holders through voting. The dBFT algorithm
    has a fault tolerance of *f =* ⌊ *(n-1) / 3* ⌋ of *n* nodes, that is, roughly
    33% of the nodes. It is nearly impossible to revoke the blocks and transactions
    once they are generated and confirmed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'NEO使用**委托拜占庭容错**（**dBFT**），这是一种改进的拜占庭容错共识算法。它是一种允许区块链参与者通过代理投票达成共识的机制。一组特殊的节点，称为记账人，通过投票达成共识以在网络中生成新区块。这些记账人是由NEO代币持有人通过投票选举产生的。dBFT算法具有*f
    =* ⌊ *(n-1) / 3* ⌋ of *n*节点的容错能力，即约33%的节点。一旦生成和确认了区块和交易，几乎不可能撤销它们。 '
- en: It takes around 15 to 20 seconds to generate a block in NEO, and it provides
    a throughput of 1,000 transactions per second, which is very high compared to
    Proof of Work-based implementations. NEO applications can be easily scaled due
    to their high transaction throughput.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在NEO中生成一个区块大约需要15到20秒，而且它的吞吐量为每秒1000笔交易，与基于工作量证明的实现相比，这是非常高的。由于其高的交易吞吐量，NEO的应用可以轻松扩展。
- en: NEO smart contract
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO智能合约
- en: Smart contracts are one of the features that highlight the NEO blockchain. Writing
    smart contracts in a NEO blockchain system is a fairly simple process compared
    to other smart contract platforms, mainly due to the support it has for a huge
    number of general-purpose languages in which smart contracts could be created.
    Unlike Ethereum, NEO doesn't need a domain-specific language to create and execute
    smart contracts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是NEO区块链突出特点之一。在NEO区块链系统中编写智能合约相对于其他智能合约平台来说是一个相当简单的过程，主要是因为它支持大量通用目的语言，可用于创建智能合约。与以太坊不同，NEO不需要特定领域的语言来创建和执行智能合约。
- en: NEO has a lightweight virtual machine that is similar to the JVM for Java. NEO's
    virtual machine executes smart contract instructions in sequence. NEO virtual
    machines only execute the instructions that are compiled by the NEO compilers.
    NEO plans to support compilers for languages such as C#, Java, C, C++, Go, JavaScript,
    Python, and Ruby; although not all of them have been implemented, development
    is underway to provide support for most languages. In addition to these compilers,
    NEO currently supports IDE plugins for Java and C#. This helps developers to create
    smart contracts without changing their development ecosystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: NEO拥有一个轻量级的虚拟机，类似于Java中的JVM。NEO的虚拟机按顺序执行智能合约指令。NEO虚拟机只执行由NEO编译器编译的指令。NEO计划支持C＃，Java，C，C
    ++，Go，JavaScript，Python和Ruby等语言的编译器；尽管并非所有语言都已实现，但正在进行开发以支持大多数语言。除了这些编译器，NEO目前还支持Java和C＃的IDE插件。这有助于开发人员在不改变开发生态系统的情况下创建智能合约。
- en: Additional NEO projects
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他NEO项目
- en: 'NEO is a growing community with a lot of projects in its roadmap; you''ll find
    a sample of the most popular ones in the following list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NEO是一个不断发展的社区，其路线图中有许多项目；你会在以下列表中找到最受欢迎的一些样本：
- en: '**NeoX**: This feature of NEO will allow asset exchange across different chains.
    It will provide atomic asset exchange protocols to ensure that a transaction is
    either completely processed or completely rejected. Even an incompatible blockchain
    will be able to communicate through NeoX as long as it provides some basic smart
    contract functionality. Since NeoX will help to achieve cross-chain collaboration,
    a single smart contract could perform operations on two chains.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NeoX**：NEO的这一特性将允许不同链之间的资产交换。它将提供原子资产交换协议，以确保交易要么完全处理，要么完全拒绝。即使是不兼容的区块链，只要提供一些基本的智能合约功能，也可以通过NeoX进行通信。由于NeoX将帮助实现跨链协作，一个智能合约可以在两条链上执行操作。'
- en: '**NeoFS**: This is a distributed storage mechanism that will use a **distributed
    hash table** (**DHT**) technology. Each document will be indexed by the digest
    of its content. Large documents are divided into blocks and distributed across
    the blockchain nodes. NeoFS plans to incentivize the nodes with tokens for storing
    documents that need higher reliability. NeoFS nodes can be used to store old block
    data from the NEO blockchain to reduce the load on full nodes.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NeoFS**：这是一种将使用 **分布式哈希表** (**DHT**) 技术的分布式存储机制。 每个文档将以其内容的摘要索引。 大型文档被分割成块并分布在区块链节点之间。
    NeoFS 计划为存储需要更高可靠性的文档的节点提供代币奖励。 NeoFS 节点可用于存储 NEO 区块链的旧块数据，以减轻完整节点的负载。'
- en: '**NeoQS**: NEO plans to solve the challenge posed by quantum computing on cryptographic
    algorithms. NeoQS plans to develop quantum-safe cryptographic mechanisms.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NeoQS**：NEO 计划解决量子计算对加密算法的挑战。 NeoQS 计划开发量子安全的加密机制。'
- en: Although all these projects are under development, the roadmap of NEO looks
    very promising. Both NeoFS and NeoQS will provide a research update in the third
    quarter of 2018, whereas NeoX is expected to run initial tests during the last
    quarter of 2018.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些项目都在开发中，但 NEO 的路线图看起来非常有前景。 NeoFS 和 NeoQS 将于2018年第三季度提供研究更新，而 NeoX 预计将在2018年最后一个季度进行初步测试。
- en: NEO nodes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO 节点
- en: Like any other blockchain platform, NEO also has nodes that hold the complete
    history of blockchain, which are called full nodes. These full nodes form the
    backbone of the network, and they communicate using the P2P protocol.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他区块链平台一样，NEO 也有保存完整区块链历史记录的节点，称为完整节点。 这些完整节点构成了网络的骨干，并且它们使用 P2P 协议进行通信。
- en: Getting started
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: NEO supports two variants of full nodes, one with a graphical user interface
    and another with just command-line support. The graphical user interface variant,
    called **NEO-GUI**, provides all the functionalities an end user requires. **NEO-CLI**
    is intended for developers who want to use the basic wallet functionality and
    APIs. It is quite straightforward to get started with either variant. We will
    be mostly dealing with NEO-CLI because it is more developer friendly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: NEO 支持两种变体的完整节点，一种具有图形用户界面，另一种仅支持命令行。 名为 **NEO-GUI** 的图形用户界面变体提供了用户所需的所有功能。
    **NEO-CLI** 针对想要使用基本钱包功能和 API 的开发人员。 使用任何一个变体都非常简单。 我们将主要处理 NEO-CLI，因为它更适合开发人员。
- en: Setting up a full node
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置完整节点
- en: 'The original NEO-CLI implementation is written in C#, and the source code can
    be found at [https://github.com/neo-project/neo-cli](https://github.com/neo-project/neo-cli).
    This implementation requires a user node with .NET Core installed to run the compiled
    binary. The repository explains how to set up .NET Core in different environments.
    A **dynamic link library** (**DLL**) file in the source code needs to be executed
    to run the NEO-CLI. Once .NET Core is installed on your system, the following
    command starts an NEO-CLI full node process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 NEO-CLI 实现是用 C# 编写的，源代码可以在 [https://github.com/neo-project/neo-cli](https://github.com/neo-project/neo-cli)
    找到。 这个实现需要一个已安装 .NET Core 的用户节点来运行编译的二进制文件。 该存储库说明了如何在不同环境中设置 .NET Core。 源代码中的一个
    **动态链接库** (**DLL**) 文件需要执行才能运行 NEO-CLI。 一旦在您的系统上安装了 .NET Core，以下命令就会启动 NEO-CLI
    完整节点进程：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The full node uses three different ports for JSON-RPC (`10332`), P2P via TCP
    (`10333`), and P2P via WebSocket (`10334`). JSON-RPC has an HTTPS version (`10331`),
    in addition to this. NEO uses a different set of ports for test nets and private
    nets. It uses similar ports with the initial "1" replaced with "2" for test nets
    and "3" for private nets. We will be mostly dealing with private net nodes in
    this chapter, as we will be creating our own network to deploy the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完整节点使用三个不同的端口进行 JSON-RPC (`10332`)、通过 TCP 进行 P2P (`10333`) 和通过 WebSocket 进行
    P2P (`10334`)。 除此之外，JSON-RPC 还有一个 HTTPS 版本 (`10331`)。 NEO 对测试网和私有网使用不同的端口集。 它使用初始的
    "1" 替换为 "2" 用于测试网和 "3" 用于私有网。 在本章中，我们将主要处理私有网节点，因为我们将创建自己的网络来部署应用程序。
- en: 'The JSON-RPC interface of the node can be exposed by running the following
    command with the `/rpc` flag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下带有 `/rpc` 标志的命令来暴露节点的 JSON-RPC 接口：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'NEO-CLI opens an interactive interface in which the user can perform all blockchain
    node and wallet operations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NEO-CLI 打开一个交互式界面，用户可以在其中执行所有区块链节点和钱包操作：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user has to either create a wallet or open an existing one before executing
    any commands to manage the wallet or node. The following command inside the shell
    creates and opens a wallet in the NEO-CLI shell:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何管理钱包或节点的命令之前，用户必须创建一个钱包或打开一个现有的钱包。在 NEO-CLI shell 中，以下命令创建并打开一个钱包：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The user needs to provide a password to secure the wallet, and this password
    will be used to unlock the wallet every time. The user can perform any wallet,
    transaction, or block operation after opening the wallet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要提供一个密码来保护钱包，每次解锁钱包都会使用这个密码。用户可以在打开钱包后执行任何钱包、交易或区块操作。
- en: You can refer the NEO-CLI documentation at [http://docs.neo.org/en-us/node/cli/cli.html](http://docs.neo.org/en-us/node/cli/cli.html)
    for all the commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 [http://docs.neo.org/en-us/node/cli/cli.html](http://docs.neo.org/en-us/node/cli/cli.html)
    查看 NEO-CLI 文档中的所有命令。
- en: NEO-CLI has support for testing, building, and deploying smart contracts in
    a blockchain, but currently, it doesn't support smart contracts being written
    in a variety of programming languages. NEO-CLI only provides a compiler for .NET
    and Java. We need a third-party compiler to create a smart contract in any other
    programming language. **neo-python** is one such project. It is backed by the
    City of Zion organization, which consists of a rich set of developers contributing
    actively. We will be using the neo-python project to build our application in
    this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: NEO-CLI 支持在区块链中测试、构建和部署智能合约，但目前不支持用多种编程语言编写智能合约。NEO-CLI 只提供 .NET 和 Java 的编译器。我们需要第三方编译器来在任何其他编程语言中创建智能合约。**neo-python**
    就是这样一个项目。它由 City of Zion 组织支持，该组织由一群积极贡献的开发人员组成。我们将在本章中使用 neo-python 项目来构建我们的应用程序。
- en: Setting up a neo-python environment
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 neo-python 环境
- en: The neo-python project provides an NEO node and an SDK that enables developers
    to create, test, deploy, and execute smart contracts on the NEO blockchain using
    Python. This project supports all the functionalities you need to manage assets
    in the wallet and blockchain nodes. This project aims to port the NEO-CLI implementation
    completely.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: neo-python 项目提供了一个 NEO 节点和一个 SDK，使开发人员可以使用 Python 在 NEO 区块链上创建、测试、部署和执行智能合约。该项目支持你在钱包和区块链节点中管理资产所需的所有功能。该项目旨在完全移植
    NEO-CLI 实现。
- en: To set up neo-python, you need to install the Python 3.6 interpreter. neo-python
    can be installed on any platform, although it requires some platform-specific
    steps to be performed. neo-python needs the `leveldb` and `openssl` libraries
    to be installed before it is installed itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 neo-python，您需要安装 Python 3.6 解释器。neo-python 可以安装在任何平台上，尽管需要执行一些特定于平台的步骤。在安装
    neo-python 之前，需要安装 `leveldb` 和 `openssl` 库。
- en: The complete documentation of neo-python, from a quickstart to building complex
    smart contracts, can be found at [https://neo-python.readthedocs.io](https://neo-python.readthedocs.io).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从快速入门到构建复杂智能合约，neo-python 的完整文档可以在 [https://neo-python.readthedocs.io](https://neo-python.readthedocs.io)
    找到。
- en: 'The neo-python package can be installed from **PyPI**, just like any other
    Python package, or from the source repository. Once the installation is complete,
    neo-python''s interactive shell can be launched with the `np-prompt` command.
    Its shell interface, as shown in the following block, is similar to that of NEO-CLI:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: neo-python 软件包可以像任何其他 Python 软件包一样从 **PyPI** 安装，也可以从源代码库安装。安装完成后，可以使用 `np-prompt`
    命令启动 neo-python 的交互式 shell。其 shell 界面如下所示，与 NEO-CLI 类似：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: neo-python can also be installed from the source by cloning the repository from
    [https://github.com/CityOfZion/neo-python](https://github.com/CityOfZion/neo-python)
    and installing the neo-python package in development mode. The neo-python shell
    can then be launched with an `np-prompt` command or simply by running the Python
    script `neo/bin/prompt.py`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: neo-python 也可以通过从 [https://github.com/CityOfZion/neo-python](https://github.com/CityOfZion/neo-python)
    克隆存储库并以开发模式安装 neo-python 软件包来安装。然后可以使用 `np-prompt` 命令启动 neo-python shell，或者简单地运行
    Python 脚本 `neo/bin/prompt.py`。
- en: Any commands can be executed on the shell after opening a wallet, in a similar
    way to NEO-CLI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开钱包后，可以像在 NEO-CLI 上一样执行任何命令。
- en: Although all operations performed on NEO-CLI can be executed in neo-python as
    well, some of the command syntax is different from NEO-CLI commands. Type `help`
    in the neo-python shell to list all the commands.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 NEO-CLI 上执行的所有操作在 neo-python 中也可以执行，但有些命令语法与 NEO-CLI 命令不同。在 neo-python shell
    中键入 `help` 列出所有命令。
- en: Setting up a JSON-RPC interface for the node
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置节点的 JSON-RPC 接口
- en: 'As specified in an earlier section while setting up a node, an NEO node acts
    as a JSON-RPC server so that it can communicate using the RPC interface. The JSON-RPC
    server can be instantiated in NEO-CLI by adding the `/rpc` flag, as mentioned
    earlier. You need to launch a different process to create an RPC server in neo-python:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如在设置节点时的前一节所指定的，NEO 节点充当 JSON-RPC 服务器，以便可以使用 RPC 接口进行通信。可以通过在 NEO-CLI 中添加 `/rpc`
    标志来实例化 JSON-RPC 服务器，如前所述。您需要启动一个不同的进程来在 neo-python 中创建 RPC 服务器：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just like Bitcoin''s JSON-RPC interface, NEO provides an RPC endpoint for each
    of its APIs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像比特币的 JSON-RPC 接口一样，NEO 为其每个 API 提供了一个 RPC 终端点：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of the frontend application uses JSON-RPC to communicate with the decentralized
    applications and the blockchain itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前端应用程序使用 JSON-RPC 与去中心化应用程序和区块链本身通信。
- en: '**neon-js**, maintained by City of Zion, provides JavaScript libraries that
    use the RPC interface exposed by the NEO node to communicate with the blockchain.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**neon-js** 由 City of Zion 维护，提供了使用 NEO 节点公开的 RPC 接口与区块链通信的 JavaScript 库。'
- en: NEO network
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO 网络
- en: 'NEO uses a networking protocol to establish connections and communicate with
    each node in a duplex mode. The nodes in the network are categorized into two
    types based on their responsibilities: the validating nodes (bookkeeping nodes)
    and the ordinary peer nodes. Peer nodes help broadcast blocks and unconfirmed
    transactions after they''ve been validated, whereas bookkeeping nodes generate
    new blocks. NEO follows a similar networking protocol as Bitcoin to initiate connection
    and exchange blocks between the peers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: NEO 使用网络协议来建立连接并与每个节点双工通信。网络中的节点根据其责任被分类为两种类型：验证节点（记账节点）和普通对等节点。对等节点在它们被验证后帮助广播区块和未确认的交易，而记账节点生成新的区块。NEO
    遵循与比特币类似的网络协议，以启动连接并在对等节点之间交换区块。
- en: 'When we launch a NEO shell through NEO-CLI or neo-python, the node will join
    the network that is specified in the default configuration. A neo-python node
    can belong to either the main, test, or private network. The NEO node will join
    a test network if it is launched without specifying the network. The following
    command launches the node in a private network specified in the private network
    protocol configuration file, which can be found in `neo/data/`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 NEO-CLI 或 neo-python 启动 NEO shell 时，节点将加入默认配置中指定的网络。neo-python 节点可以属于主网、测试网或私有网络。如果启动时未指定网络，则
    NEO 节点将加入测试网络。以下命令将节点启动在私有网络中，该私有网络协议配置文件位于 `neo/data/` 中：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will be using a private network to perform all the neo-python operations
    in this chapter. The node could also be initiated by explicitly specifying a network
    configuration file with a `-c` flag.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用私有网络执行所有 neo-python 操作。可以通过显式指定网络配置文件并使用 `-c` 标志来启动节点。
- en: Test network
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网络
- en: The NEO test network is similar to the mainnet. In the test network, users can
    develop, deploy, and execute programs. Instead of spending real GAS and NEO tokens,
    users can use test tokens, which don't have real value. Every other operation
    performed on the testnet is the same as on the mainnet. So, this is the perfect
    environment for developers to test applications before deploying them on the mainnet. Since
    the testnet is an active network with participants from around the world, the
    supply of NEO and GAS tokens is limited, and you will not be provided with any
    tokens when joining the network, just like in the mainnet. As a minimum of 500
    GAS is required to deploy a smart contract, a user can either obtain this from
    other testnet users or apply for it at [https://neo.org/Testnet/Create](https://neo.org/Testnet/Create).
    Smart contracts can be deployed to the network once the user has enough GAS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: NEO 测试网络类似于主网。在测试网络中，用户可以开发、部署和执行程序。用户可以使用没有实际价值的测试代币，而不是花费真实的 GAS 和 NEO 代币。在测试网上执行的每个其他操作与在主网上执行的操作相同。因此，这是开发人员在部署到主网之前测试应用程序的理想环境。由于测试网是一个来自世界各地的参与者的活跃网络，NEO
    和 GAS 代币的供应是有限的，当您加入网络时，将不会提供任何代币，就像在主网上一样。由于部署智能合约需要至少 500 GAS，用户可以从其他测试网用户那里获取这些
    GAS，或者在 [https://neo.org/Testnet/Create](https://neo.org/Testnet/Create) 申请。用户在拥有足够
    GAS 后可以将智能合约部署到网络上。
- en: Private network
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有网络
- en: A private network is a collection of NEO nodes that achieve blockchain state
    consensus on their own. These NEO nodes are completely disconnected from the public
    nodes of the mainnet or testnet. A private network is ideal for creating a blockchain
    network inside an organization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 私有网络是一组 NEO 节点，它们自行实现区块链状态一致性。这些 NEO 节点与主网或测试网的公共节点完全隔离。私有网络非常适合在组织内部创建区块链网络。
- en: A private NEO network needs at least four nodes to achieve consensus. A private
    NEO network can be deployed in a local area network, and also, several nodes can
    be deployed on a single device by creating virtual machines. Even the nodes of
    a private network require GAS to create and deploy smart contracts in a private
    blockchain. A private node can extract all the NEO and GAS tokens from the network
    by creating a multi-party signature address from all the consensus nodes. The
    NEO and GAS can then be transferred from the contact address to a normal address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 NEO 网络需要至少四个节点才能达成共识。私有 NEO 网络可以部署在局域网中，并且还可以通过创建虚拟机在单个设备上部署多个节点。即使私有网络的节点也需要
    GAS 来在私有区块链中创建和部署智能合约。私有节点可以通过从所有共识节点创建多方签名地址来提取网络中的所有 NEO 和 GAS 代币。然后可以将 NEO
    和 GAS 从联系地址转移到普通地址。
- en: 'A small private network with limited consensus nodes can be created by deploying
    a turnkey Docker image, which is hosted at [https://hub.docker.com/r/cityofzion/neo-privatenet](https://hub.docker.com/r/cityofzion/neo-privatenet).
    This Docker image deploys four NEO validating nodes, and it has pre-claimed all
    100 million NEO and 16,600 GAS tokens. Any user joining the network can use the
    wallet that contains all the tokens to deploy smart contracts. The private network
    can be launched with just a couple of commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署托管在 [https://hub.docker.com/r/cityofzion/neo-privatenet](https://hub.docker.com/r/cityofzion/neo-privatenet)
    的即插即用 Docker 镜像，可以创建具有有限共识节点的小型私有网络。此 Docker 镜像部署了四个 NEO 验证节点，并预领取了所有1亿 NEO 和
    16,600 GAS 代币。加入网络的任何用户都可以使用包含所有代币的钱包部署智能合约。只需几个命令即可启动私有网络：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Docker image will create a container that has four nodes exposing both P2P
    (20333-20336) ports and RPC ports (30333-30336).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像将创建一个包含四个节点的容器，同时公开 P2P（20333-20336）端口和 RPC 端口（30333-30336）。
- en: Any neo-python node that is in the same network can then add these four nodes
    as its seed nodes and start syncing the private network blockchain. Users can
    then use the wallet that contains all the network tokens to create transactions
    and deploy smart contracts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同网络中的任何 neo-python 节点都可以将这四个节点添加为其种子节点，并开始同步私有网络区块链。然后用户可以使用包含所有网络代币的钱包创建交易和部署智能合约。
- en: NEO transactions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO 交易
- en: 'Each node on the NEO network can create transactions and perform operations
    in the NEO blockchain. The node has to open the wallet to create a transaction
    and broadcast it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: NEO 网络上的每个节点都可以在 NEO 区块链中创建交易并执行操作。节点必须打开钱包才能创建交易并进行广播：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `wallet` command in neo-python provides you with complete information about
    the opened wallet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: neo-python 中的 `wallet` 命令为您提供有关已打开钱包的完整信息：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The wallet maintains updated details after the validation of each and every
    transaction. The `addresses` field contains details of all the keys held by the
    wallet. The opened wallet has only one key, whose public address is `AK2nJJpJr6o664CWJKi1QRXjqeic2zRp8y`.
    The `balances` field inside the `addresses` field shows the current NEO and GAS
    tokens claimed by the node. In the `balances` field, `0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b`
    represents transaction ID of the NEO tokens, and `0x602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7`
    is for the GAS tokens. NEO uses these as standard IDs for NEO and GAS tokens.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包在每笔交易验证后维护更新的详细信息。`addresses` 字段包含钱包持有的所有密钥的详细信息。已打开的钱包仅有一个密钥，其公共地址为 `AK2nJJpJr6o664CWJKi1QRXjqeic2zRp8y`。`addresses`
    字段内的 `balances` 字段显示节点当前拥有的 NEO 和 GAS 代币。在 `balances` 字段中，`0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b`
    表示 NEO 代币的交易 ID，而 `0x602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7`
    是 GAS 代币的交易 ID。NEO 将这些用作 NEO 和 GAS 代币的标准 ID。
- en: 'Unlike Bitcoin nodes, NEO nodes can create several different types of transaction
    to support all the operations performed in the blockchain. The following table
    depicts different types of transactions that can be created in a NEO network:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币节点不同，NEO 节点可以创建多种不同类型的交易来支持区块链中执行的所有操作。以下表格描述了可以在 NEO 网络中创建的不同类型的交易：
- en: '| **Name** | **Description** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `MinerTransaction` | Assign byte fees |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `MinerTransaction` | 分配字节费用 |'
- en: '| `IssueTransaction` | Issuance of asset |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `IssueTransaction` | 发行资产 |'
- en: '| `ClaimTransaction` | Claim NEO coins |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `ClaimTransaction` | 领取 NEO 币 |'
- en: '| `EnrollmentTransaction` | Enrolment for validator |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `EnrollmentTransaction` | 注册为验证者 |'
- en: '| `VotingTransaction` | Vote for validator |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `VotingTransaction` | 为验证者投票 |'
- en: '| `RegisterTransaction` | Asset register |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `RegisterTransaction` | 资产注册 |'
- en: '| `ContractTransaction` | Contract transaction |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ContractTransaction` | 合约交易 |'
- en: '| `AgencyTransaction` | Order transaction |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `AgencyTransaction` | 订单交易 |'
- en: Table. 7.1\. Transaction types in NEO
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 7.1\. NEO 中的交易类型
- en: Each type of transaction will have exclusive fields to store more information
    about the transaction. For example, `MinerTransaction` has an additional field
    to store `nonce`, which is a random number.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的交易都将具有专用字段来存储有关交易的更多信息。例如，`MinerTransaction` 有一个额外的字段来存储 `nonce`，它是一个随机数。
- en: Transferring an asset
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产转移
- en: 'Nodes can use transactions to perform operations on NEO assets. The transactions
    are created by the node using its private key, which is situated in the wallet.
    The user can perform any operation on the asset once the wallet is opened. A `send`
    command in neo-python transfers the asset by taking the asset ID, the recipient
    address, and the amount. The `send` command creates a transaction and relays it
    to the network so that it is included in the blockchain:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以使用交易对 NEO 资产执行操作。交易由节点使用其在钱包中的私钥创建。一旦打开钱包，用户就可以对资产执行任何操作。neo-python 中的 `send`
    命令通过接收资产 ID、接收地址和金额来转移资产。`send` 命令创建一个交易并将其中继到网络，以便将其包含在区块链中：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The created transaction is a `ContractTransaction`, and the details show that
    it houses `vout` and `vin` fields, whose functions are similar to the fields found
    in Bitcoin transactions. The `vin` field points to the transactions whose unspent
    outputs are referenced, and `vout` consists of newly created unspent outputs.
    The first output is the amount transacted by the user, and the second one is the
    change in output. Unlike Bitcoin transactions, the verification script is found
    under a separate script field:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的交易是一种 `ContractTransaction`，详细信息显示它包含 `vout` 和 `vin` 字段，其功能类似于比特币交易中的字段。`vin`
    字段指向被引用其未花费输出的交易，而 `vout` 由新创建的未花费输出组成。第一个输出是用户交易的金额，第二个是输出的变化。与比特币交易不同，验证脚本在一个单独的
    script 字段下找到：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a decentralized application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个去中心化应用程序
- en: Now that we have looked into some of the basic functionalities of the NEO platform,
    we are ready to create our first decentralized application using the NEO blockchain.
    Smart contracts are the backbone of creating a decentralized application using
    NEO. We will become familiar with smart contracts by creating a hello world application
    before creating a decentralized proof of ownership application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 NEO 平台的一些基本功能，我们准备使用 NEO 区块链创建我们的第一个去中心化应用程序。智能合约是使用 NEO 创建去中心化应用程序的基础。在创建去中心化所有权证明应用程序之前，我们将通过创建一个
    hello world 应用程序来熟悉智能合约。
- en: Basic smart contract
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本智能合约
- en: 'First, we will create a simple Python script that returns a concatenated string
    to greet the user:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的 Python 脚本，返回一个连接的字符串来向用户问候：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The contract script uses the `concat` method provided by `boa` to concatenate
    two strings. Every smart contract should have a function called `main`, which
    will be the entry point. The smart contract needs to be compiled into byte code,
    which can be executed in the NeoVM. The contract can be compiled by the neo-python
    shell using the neo-boa compiler as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 合约脚本使用 `boa` 提供的 `concat` 方法来连接两个字符串。每个智能合约都应该有一个名为 `main` 的函数，这将是入口点。智能合约需要编译成字节码，可以在
    NeoVM 中执行。合约可以通过 neo-python shell 使用 neo-boa 编译器编译，如下所示：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `build` command is supplied with a `test` argument to test the sample outcome.
    The code immediately after the `test` flag represents the data type for the parameter
    and the return type. The preceding code stipulates that the contract function
    accepts a string parameter and returns a string value. The following table lists
    all the available data types and their codes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 命令带有一个 `test` 参数，用于测试样本结果。`test` 标志之后的代码表示参数和返回类型的数据类型。前面的代码规定了合约函数接受一个字符串参数并返回一个字符串值。下表列出了所有可用的数据类型及其代码：'
- en: '| **Data types** | **Code** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **代码** |'
- en: '| Signature | `0x00` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Signature | `0x00` |'
- en: '| Boolean | `0x01` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `0x01` |'
- en: '| Integer | `0x02` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Integer | `0x02` |'
- en: '| Hash160 | `0x03` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Hash160 | `0x03` |'
- en: '| Hash256 | `0x04` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Hash256 | `0x04` |'
- en: '| ByteArray | `0x05` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 字节数组 | `0x05` |'
- en: '| PublicKey | `0x06` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 公钥 | `0x06` |'
- en: '| String | `0x07` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `0x07` |'
- en: '| Array | `0x10` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `0x10` |'
- en: '| Interop Interface | `0xf0` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 互操作接口 | `0xf0` |'
- en: '| Void | `0xff` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 空 | `0xff` |'
- en: Table 7.2\. Data types used by contract parameters
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2。合约参数使用的数据类型
- en: 'The first Boolean values following the data types stipulate whether the contract
    requires local storage, and the second Boolean value indicates whether the contract
    has a dynamic invocation to other smart contracts whose addresses are known only
    during execution. Any input to the contract follows these arguments during the
    build process. The test invocation will show the result, along with the GAS required
    to invoke the contract. The result shows that the output is of a `string` type,
    along with the value. Most importantly, the `build` call generates the contract
    instructions in byte code by creating an AVM file that will be stored in the same
    directory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，跟随数据类型后面的第一个布尔值规定合约是否需要本地存储，第二个布尔值指示合约是否动态调用其他智能合约，其地址仅在执行期间才知道。 在构建过程中，合约的任何输入都遵循这些参数。测试调用将显示结果，以及调用合约所需的
    GAS。 结果显示输出是 `string` 类型，以及它的值。 最重要的是，`build` 调用通过创建 AVM 文件将合约指令生成为字节码，并存储在同一目录中：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The generated AVM file needs to be imported to the NeoVM and then relayed to
    the blockchain network. The following `import` call performs contract importing.
    The `import` command takes parameters that are similar to the ones specified during
    the build process:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 AVM 文件需要导入到 NeoVM，然后中继到区块链网络。以下的 `import` 调用执行合约导入。 `import` 命令接受类似于构建过程中指定的参数：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The user needs to enter the details of the smart contract before it is created
    and relayed to the network:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要在创建和中继到网络之前输入智能合约的详细信息：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A script hash, along with the contract script, will be generated once the smart
    contract is created. The script hash represents the contract, and it can be used
    by everyone in the network to invoke the smart contract.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建智能合约，将生成脚本哈希以及合约脚本。脚本哈希代表合约，并且可以由网络中的所有人用来调用智能合约。
- en: The GAS utilized in a transaction depends on the type of smart contract operation,
    and the system calls used in the smart contract. The cost of creating a smart
    contract is 100 GAS plus the additional fees of the system calls. If the smart
    contract needs a storage area, it costs an additional 400 GAS. Our earlier smart
    contract deployment used only 100 GAS to create the smart contract as there was
    no local storage required.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 交易中使用的 GAS 取决于智能合约操作类型和智能合约中使用的系统调用。 创建智能合约的成本为 100 GAS 加上系统调用的额外费用。 如果智能合约需要存储空间，则需要额外花费
    400 GAS。 我们之前的智能合约部署只使用了 100 GAS 来创建智能合约，因为没有需要本地存储的东西。
- en: 'neo-python provides a `testinvoke` command, which can be used to test contract
    hashes that have already deployed in the blockchain. The `testinvoke` call will
    not be relayed to the network unless it is accepted by the user. It accepts only
    the script hash of the contract and its parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: neo-python 提供了一个 `testinvoke` 命令，可以用于在区块链上已部署的合约哈希上进行测试。除非用户接受，否则 `testinvoke`
    调用不会被中继到网络。它只接受合约的脚本哈希和其参数：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `testinvoke` call can be executed once the node updates its local blockchain
    to include the relayed contract that was created earlier. Here is the output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点更新其本地区块链以包含之前创建的中继合约，就可以执行 `testinvoke` 调用。以下是输出：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`testinvoke` invokes the contract from the blockchain and returns the computed
    result in an array of hexadecimal strings. The hexadecimal result `''48656c6c6f20416c696365''`
    translates to "Hello Alice," which is the desired output.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`testinvoke` 从区块链中调用合约，并以十六进制字符串数组的形式返回计算结果。十六进制结果 `''48656c6c6f20416c696365''`
    转换为 "Hello Alice"，这是期望的输出。'
- en: Proof of ownership application
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权证明应用
- en: We have already looked into the benefits of creating a proof of ownership application
    in a decentralized application earlier on in this chapter; now we're going to
    move on and create a proof of ownership application using NEO smart contracts
    in order to perform asset management in the decentralized network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经详细讨论了在本章早期在分散应用中创建所有权证明应用的好处；现在我们将继续创建一个使用 NEO 智能合约来执行资产管理的所有权证明应用，以在分散网络中执行。
- en: 'We created a Proof of Existence application to prove the existence of a document
    in [Chapter 6](3156a0a8-4aa4-416c-a04f-c08c9f50f087.xhtml), *Diving into Blockchain
    – Proof of Existence*. In this section, we will create an asset management system
    to register and prove the ownership of documents in this section. The goal is
    to create the following asset management functionalities:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个“存在证明”应用程序来证明[第6章](3156a0a8-4aa4-416c-a04f-c08c9f50f087.xhtml)中文档的存在，*深入区块链
    - 存在证明*。在本节中，我们将创建一个资产管理系统来注册和证明本节中文档的所有权。目标是创建以下资产管理功能：
- en: Asset registration
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产注册
- en: Asset querying
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产查询
- en: Asset removal
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产移除
- en: Asset transfer
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产转移
- en: We will implement all the functionalities in a smart contract to prove the ownership
    of the document.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在智能合约中实现所有功能以证明文档的所有权。
- en: Creating the smart contract
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建智能合约
- en: Smart contracts created using Python contain a `main` function as the entry
    point. This function accepts two parameters. The first parameter accepts the type
    of operation, and all the additional arguments are passed to the second parameter
    in a list. The `operation` parameter accepts `register`, `query`, `delete`, and
    `transfer` so that it can perform asset management functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python创建的智能合约包含`main`函数作为入口点。此函数接受两个参数。第一个参数接受操作类型，所有附加参数都传递给第二个参数的列表。`operation`参数接受`register`、`query`、`delete`和`transfer`，以便执行资产管理功能。
- en: 'The `main` function of the smart contract parses the `operation` parameter
    and invokes the respective function in the smart contract to perform operations
    on the asset. The `main` function parses the `args` parameter and assigns the
    first item of the list to `asset_id`, and the others to `owner`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的`main`函数解析`operation`参数，并调用智能合约中的相应函数以对资产执行操作。`main`函数解析`args`参数，并将列表的第一项分配给`asset_id`，其他项分配给`owner`：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `register_asset` function takes `asset_id` and the owner address and creates
    an entry of the ownership in the blockchain. `CheckWitness` is a NEO runtime functionality
    check that checks whether the owner''s address matches the address of the user
    that invoked the contract. The contract returns `False` if the asset owner who
    is to be registered is not the same as the user who invoked the contract. The
    contract verifies whether that `asset_id` is already registered by invoking the
    NEO storage library `Get` method. Finally, the asset is registered to the owner
    by storing the asset id and the owner details in a key/value pair using the `Put`
    storage method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`register_asset`函数接受`asset_id`和所有者地址，并在区块链中创建所有权条目。`CheckWitness`是一个NEO运行时功能检查，检查所有者地址是否与调用合同的用户地址匹配。如果要注册的资产所有者与调用合同的用户不同，则合同返回`False`。合同通过调用NEO存储库的`Get`方法来验证是否已经注册了`asset_id`。最后，通过使用`Put`存储方法将资产ID和所有者详细信息存储在键/值对中，将资产注册给所有者：'
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: NEO provides storage functionality in the blockchain by storing data in a key/value
    pair. Smart contracts have to specify whether the script needs contract storage
    space during deployment. Using storage costs extra GAS during the deployment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: NEO通过在区块链中存储数据的方式提供存储功能，采用键/值对。智能合约必须在部署时指定脚本是否需要合约存储空间。在部署期间使用存储会额外消耗 GAS。
- en: 'The `query_asset` function queries the local storage to check whether the asset
    is already registered by the user. It returns the owner address if the asset is
    found:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_asset`函数查询本地存储以检查用户是否已经注册了资产。如果找到资产，则返回所有者地址：'
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following function needs `asset_id` and the address of the asset recipient
    in order to transfer the asset. As the first step, it verifies the existence of
    the asset by checking the storage using the `Get` method. It then checks whether
    the asset owner is the same as the invoker. The contract also verifies that the
    recipient address is a valid address. Finally, the asset is updated with the new
    owner using the `Put` storage method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能需要`asset_id`和资产接收者地址以便转移资产。作为第一步，它通过使用`Get`方法检查存储来验证资产的存在。然后检查资产所有者是否与调用者相同。合同还验证了接收者地址是否是有效地址。最后，使用`Put`存储方法更新资产的新所有者：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `delete_asset` method implements similar functionality as `transfer_asset`,
    with the difference being that it deletes the asset instead of updating it. The
    `Delete` function call is used to delete the stored key/value pair from storage:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_asset` 方法实现与 `transfer_asset` 类似的功能，不同之处在于它删除资产而不是更新它。`Delete` 函数调用用于从存储中删除存储的键值对:'
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have implemented all the basic functionalities of asset management,
    we will execute the contract using the neo-python shell in the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经实现了资产管理的所有基本功能，我们将在下一部分中使用neo-python shell执行合约。
- en: Executing the smart contract
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行智能合约
- en: The smart contract is executed with similar steps as shown in the earlier section
    where we deployed the basic smart contract. The only differences are the parameters
    supplied to the contract and the corresponding return data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的执行步骤与我们部署基本智能合约的之前部分类似。唯一的区别是提供给合约的参数和相应的返回数据不同。
- en: 'As mentioned earlier, we will create a proof of ownership application to keep
    track of the documents. Each document can be uniquely identified by its digest.
    We will use the SHA256 hash value of the document as the asset ID. Let''s consider
    a file that has the following content. The files are usually stored with an additional
    new line character that is not visible in raw text output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '正如前面提到的，我们将创建一个所有权证明应用来跟踪文件。每个文件可以通过其摘要唯一标识。我们将使用文件的SHA256哈希值作为资产ID。让我们考虑一个具有以下内容的文件。这些文件通常存储有一个额外的看不见的换行符:'
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the following digest represents the SHA256 hash value of the file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '以下摘要表示文件的SHA256哈希值:'
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s use the hash value as the asset ID to uniquely identify each document.
    The contract is built in the neo-python shell using the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们使用哈希值作为资产ID来唯一标识每个文件。合同在neo-python shell中使用以下命令构建:'
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `build` procedure has `0710` as a parameter type, which denotes that it
    takes one string (`07`) and one array (`10`) as parameters. And `05` indicates
    that it has a return type of `byte array`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 过程以 `0710` 作为参数类型，表示它以一个字符串 (`07`) 和一个数组 (`10`) 作为参数。`05` 表示它具有`字节数组`返回类型。'
- en: 'The contract can then be deployed using the created AVM file after a successful
    build:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '成功构建后，可以使用创建的AVM文件部署合约:'
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The transaction needs an additional 400 GAS as the smart contract needs the
    local storage. The total GAS consumed would be `500`, as shown in the preceding
    code block.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约需要本地存储，交易需要额外的 400 GAS。总共消耗的 GAS 将为 `500`，如前面的代码块所示。
- en: The contract can be executed once the contract transaction is included in the
    blockchain and is synchronized in the local blockchain. Let's use the `testinvoke` command
    to test our created smart contract.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合约交易包含在区块链中并在本地区块链中同步，合约就可以执行。让我们使用 `testinvoke` 命令来测试我们创建的智能合约。
- en: 'Let''s register a document using the same SHA256 value mentioned previously
    as the asset ID. The `register` operation is invoked with a list of arguments
    consisting of the hash value and the address of the user invoking the smart contract:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们使用先前提到的相同的SHA256值作为资产ID注册文件。注册操作调用一个参数列表，包括哈希值和调用智能合约的地址:'
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the transaction is invoked and relayed to the network, other operations
    can be performed on the asset. Let''s now transfer the document''s ownership to
    a new owner by invoking the `transfer` operation and specifying the recipient
    address in the list:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易被调用并传递到网络上，其他操作就可以在资产上执行。现在让我们通过调用 `transfer` 操作并在列表中指定接收者地址来将文件所有权转让给新所有者：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The document ownership can be verified at any time by invoking the query operation
    and passing the asset ID:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以随时通过调用查询操作并传递资产ID来验证文件所有权：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The query returns a byte array that has a hexadecimal string. The hexadecimal
    result represents the address `AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`. Since the
    document's ownership was transferred to the new owner, the result shows the updated
    owner of the document.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回一个具有十六进制字符串的字节数组。十六进制结果表示地址 `AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`。由于文件的所有权已转移给新所有者，结果显示文件的更新所有者。
- en: We have now finished creating a smart contract to demonstrate a proof of ownership
    system that keeps track of the ownership of documents. Once the smart contract
    is deployed in a blockchain, it will stay there forever. The user has to only
    deal with the smart contract invocation. The RPC interface of the NEO node provides
    a convenient way to communicate with the blockchain. We will now look into how
    to conveniently communicate with the blockchain by creating an interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建智能合约的过程，以演示一个跟踪文档所有权的系统。一旦智能合约在区块链上部署，它将永远留在那里。用户只需处理智能合约的调用。NEO节点的RPC接口提供了一种方便的方式来与区块链进行通信。现在，我们将看看如何通过创建一个接口来方便地与区块链进行通信。
- en: Interface for the application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的界面
- en: The NEO community has a created few JavaScript libraries to interface with the
    NEO blockchain. We will be using a popular library called neon-js ([https://github.com/CityOfZion/neon-js](https://github.com/CityOfZion/neon-js)),
    which is backed by the City of Zion community.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: NEO社区创建了一些JavaScript库，用于与NEO区块链进行交互。我们将使用一个名为neon-js的流行库([https://github.com/CityOfZion/neon-js](https://github.com/CityOfZion/neon-js))，该库得到了City
    of Zion社区的支持。
- en: 'The following script creates an interface to query the owner of the asset for
    our proof of ownership application:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本创建了一个接口，用于查询我们所有权证明应用程序中资产的所有者：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The interface created using the neon-js library builds a script for the smart
    contract using the `Neon.create.script` method. It then uses the RPC interface
    to invoke the smart contract script. After that, `queryAsset` returns the address
    of the user who owns the document asset.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用neon-js库创建的接口使用`Neon.create.script`方法构建了智能合约脚本。然后，它使用RPC接口调用智能合约脚本。之后，`queryAsset`返回拥有文档资产的用户地址。
- en: Creating an interface to the blockchain smart contract is a crucial part of
    building a fully fledged decentralized application. The interface also creates
    a convenient way to communicate with the blockchain nodes, which enhances the
    user experience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与区块链智能合约的接口是构建完整去中心化应用程序的关键部分。该接口还为与区块链节点通信提供了便捷的方式，从而增强了用户体验。
- en: Ethereum blockchain
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊区块链
- en: Ethereum is a public blockchain that was proposed by Vitalik Buterin in late
    2013 and was released to the public in 2015\. Ethereum was one of the initial
    blockchain platforms that were created to help programmers to develop and deploy
    decentralized applications using smart contracts. Ethereum has a rich set of frameworks
    and libraries to develop, test, and deploy applications. We will cover the development
    and deployment of proof of ownership applications using the Ethereum platform
    in this section. Refer to [Chapter 8](02eed23a-0a39-4a19-8d88-a72a810ddb0d.xhtml),
    *Blockchain Projects*, for more details regarding the Ethereum ecosystem.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是一个公共区块链，由Vitalik Buterin于2013年末提出，并于2015年向公众发布。以太坊是最初创建的区块链平台之一，旨在帮助程序员使用智能合约开发和部署去中心化应用程序。以太坊拥有丰富的框架和库，用于开发、测试和部署应用程序。本节我们将介绍使用以太坊平台开发和部署所有权证明应用程序的开发和部署。有关以太坊生态系统的更多详细信息，请参阅[第8章](02eed23a-0a39-4a19-8d88-a72a810ddb0d.xhtml)，*区块链项目*。
- en: Ethereum nodes
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊节点
- en: Similar to Bitcoin and NEO, there are several implementations of client software
    in different languages that can be used as an Ethereum full node. The Ethereum
    client implementation can be found in Java, JavaScript, Python, Go, and many other
    languages. The Golang implementation of Ethereum called **Go Ethereum** or **Geth**
    is the most popular among all.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与比特币和NEO类似，不同语言中存在多种客户端软件实现，可用作以太坊完整节点。以太坊客户端实现可以在Java、JavaScript、Python、Go等多种语言中找到。以太坊的Golang实现称为**Go
    Ethereum**或**Geth**，是其中最受欢迎的。
- en: Getting started
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Setting up the node is the important step to take before diving into the application
    development. Although any of the Ethereum clients can be used to set up a full
    node, we will set up the Geth client to sync and interact with the public blockchain.
    Similar to the NEO blockchain, Geth client can connect to mainnet, testnet, or
    a private network.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入应用开发之前，设置节点是必不可少的一步。尽管任何以太坊客户端都可以用来设置完整节点，我们将设置Geth客户端以与公共区块链同步并进行交互。与NEO区块链类似，Geth客户端可以连接到主网、测试网或私有网络。
- en: Setting up a node
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置节点
- en: We will set up a Geth client that can be used to sync the entire blockchain
    transactions. It also provides the JSON-RPC interface to invoke any of the methods
    supported by the client software. The JSON-RPC interface can be used to perform
    several operations including deploying and invoking smart contracts.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个 Geth 客户端，用于同步整个区块链交易。它还提供了 JSON-RPC 接口，以调用客户端软件支持的任何方法。JSON-RPC 接口可用于执行多个操作，包括部署和调用智能合约。
- en: The Geth client can be either built or installed using packages found in most
    platforms. Installation instructions for different platforms can be found at [https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在大多数平台上找到的软件包来构建或安装 Geth 客户端。不同平台的安装说明可以在 [https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum)
    找到。
- en: 'Geth provides a command-line interface that can be used to initiate the node.
    Once Geth is installed with all the dependencies, it can be launched to synchronize
    the local blockchain data with the public blockchain. The Geth client can be configured
    by supplying several parameters for the chain, transaction pool, performance tuning,
    account, networking, miner, and much more. The following command instantiates
    an Ethereum node with a few parameters: `rpc` (enable RPC server), `rpcapi` (list
    of APIs to be accessed through RPC interface), `cache` (memory assigned for internal
    caching), `rpcport` (RPC server port), and `rpcaddr` (RPC server address):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Geth 提供了一个命令行界面，可用于启动节点。一旦安装了所有依赖项的 Geth，就可以启动它以将本地区块链数据与公共区块链同步。可以通过提供几个参数来配置
    Geth 客户端，用于链、交易池、性能调优、账户、网络、矿工等。以下命令使用了几个参数来实例化以太坊节点：`rpc`（启用 RPC 服务器）、`rpcapi`（通过
    RPC 接口访问的 API 列表）、`cache`（用于内部缓存的内存分配）、`rpcport`（RPC 服务器端口）和 `rpcaddr`（RPC 服务器地址）：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The instantiated Ethereum node will try to sync the blockchain by connecting
    to mainnet peers. Alternatively, the Geth can be configured to connect to any
    of the Ethereum testnets (**Rinkeby**, **Kovan**, or **Ropsten**). The following
    command instantiates a node with the Rinkeby testnet blockchain:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化的以太坊节点将尝试通过连接到主网节点来同步区块链。或者，可以配置 Geth 来连接到以太坊测试网络（**Rinkeby**、**Kovan** 或
    **Ropsten**）。以下命令实例化了一个带有 Rinkeby 测试网络区块链的节点：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A set of Geth clients could also form their own private Ethereum network instead
    of connecting to the existing mainnet or testnet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一组 Geth 客户端也可以形成自己的私有以太坊网络，而不是连接到现有的主网或测试网。
- en: The instructions for setting up a private network using Geth client can be found
    here: [https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster](https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Geth 客户端设置私有网络的说明可以在这里找到：[https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster](https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster)。
- en: 'In this chapter, we will create a private blockchain with the help of a tool
    provided in the **Truffle** suite framework called **Ganache CLI**, which is a
    JavaScript package that can be installed using the node package manager. Make
    sure that `node` and `npm` are installed in the system before executing the following
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Truffle**套件框架中提供的工具来创建一个私有区块链，该工具称为 **Ganache CLI**，这是一个 JavaScript
    包，可以使用 node 包管理器进行安装。在执行以下命令之前，请确保系统中安装了 `node` 和 `npm`：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The private blockchain can be instantiated by launching Ganache CLI. Ganache
    CLI can be configured by specifying several parameters or launched without parameters,
    as shown in the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过启动 Ganache CLI 来实例化私有区块链。可以通过指定几个参数来配置 Ganache CLI，也可以在没有参数的情况下启动，如下所示的命令：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A successful launch will create a private blockchain along with a few accounts
    loaded with ethers that can be used to pay for the transaction fee for any of
    the transactions created. The Ganache CLI will also create a client application
    that will listen on the port 8545 by default. We will use the private blockchain
    and the application running on the port 8545 to deploy and query the smart contracts
    in the coming sections.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动将创建一个私有区块链，并加载了一些以太币的账户，可用于支付任何创建的交易的交易费用。 Ganache CLI 还将创建一个客户端应用程序，默认情况下将侦听端口
    8545。我们将使用私有区块链和运行在端口 8545 上的应用程序，在接下来的章节中部署和查询智能合约。
- en: Setting up a development environment
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Now that we have instantiated a local node with a private blockchain, we will
    set up the development environment to ease the creation and deployment of the
    decentralized application. Since we have to create a fully fledged decentralized
    application, we need to communicate with the Ethereum blockchain using scripting
    languages such as JavaScript. Ethereum provides a JavaScript library called **web3.js**
    that houses APIs to interact with the Ethereum blockchain.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了一个带有私有区块链的本地节点，我们将设置开发环境以便轻松创建和部署去中心化应用程序。由于我们需要创建一个完全成熟的去中心化应用程序，我们需要使用
    JavaScript 等脚本语言与以太坊区块链进行通信。以太坊提供了一个称为 **web3.js** 的 JavaScript 库，其中包含与以太坊区块链交互的
    API。
- en: 'The web3.js makes use of RPC calls to communicate with the Ethereum node that
    exposes the RPC interface (application port 8545). So, the web3.js can invoke
    any of the methods provided by the Ethereum node. The following code snippet can
    be executed on a node terminal:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 使用 RPC 调用与暴露 RPC 接口（应用程序端口 8545）的以太坊节点进行通信。因此，web3.js 可以调用以太坊节点提供的任何方法。以下代码片段可在节点终端上执行：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code will create a `web3` instance and then add the local node as the provider.
    When the web3.js application executed in a web browser, the `web3` object can
    be injected through bridges such as MetaMask. These `web3` instances will already
    have the provider specified in `web3.currentProvider`. We will use MetaMask while
    building the proof of ownership application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个 `web3` 实例，然后将本地节点添加为提供程序。当在 web 浏览器中执行 web3.js 应用程序时，`web3` 对象可以通过
    MetaMask 等桥接注入。在构建所有权证明应用程序时，我们将使用 MetaMask。
- en: 'Although `web3.js` provides all the methods required to interact with the blockchain,
    it doesn''t set up a complete development environment. This can be achieved with
    an Ethereum development framework called Truffle. Truffle provides a complete
    development environment along with convenient testing, deployment, and migration
    of the smart contracts. The Truffle framework can be installed using the node
    package manager:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `web3.js` 提供了与区块链交互所需的所有方法，但它没有设置完整的开发环境。这可以通过称为 Truffle 的以太坊开发框架来实现。Truffle
    提供了一个完整的开发环境，以及方便的智能合约测试、部署和迁移。可以使用节点包管理器安装 Truffle 框架：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A Truffle project can be initiated in an empty directory to build the initial
    files required for application development:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在空目录中初始化一个 Truffle 项目，以构建应用程序开发所需的初始文件：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will create three directories - `contracts` (smart contracts), `migrations`
    (deployment scripts), and `test` (test scripts) and a configuration file, `truffle.js`.
    We need to add the following configuration to the `truffle.js` file to point the
    created Truffle project to our private blockchain:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建三个目录 - `contracts`（智能合约）、`migrations`（部署脚本）和 `test`（测试脚本）以及一个配置文件，`truffle.js`。我们需要向
    `truffle.js` 文件添加以下配置，以将创建的 Truffle 项目指向我们的私有区块链：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An interactive Truffle console can be launched from the Truffle project directory:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 Truffle 项目目录启动交互式 Truffle 控制台：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `web3` object will be already instantiated in the Truffle console, and any
    of the web3 APIs can be accessed using this object. We will use the Truffle console
    to query the deployed contract in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 对象将在 Truffle 控制台中已经被实例化，并且可以使用这个对象访问任何 web3 API。我们将在下一节使用 Truffle 控制台查询部署的合约。'
- en: Creating a decentralized application
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建去中心化应用程序
- en: We can now create our first decentralized application on Ethereum platform since
    we have setup our development environment. We will get familiar with Ethereum
    smart contracts by creating and deploying a hello world application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置好了开发环境，我们现在可以在以太坊平台上创建我们的第一个去中心化应用程序。我们将通过创建并部署一个 hello world 应用程序来熟悉以太坊智能合约。
- en: Basic smart contract
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本智能合约
- en: Ethereum makes use of a domain-specific language called as Solidity to code
    the logic of the smart contract. Solidity is a high-level programming language
    that can be compiled to produce bytecode, which is then executed on the EVM.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用一种称为 Solidity 的特定领域语言来编写智能合约的逻辑。Solidity 是一种高级编程语言，可以编译生成字节码，然后在 EVM 上执行。
- en: Solidity is a statically typed programming language initially proposed by Gavin
    Wood. It was designed to be similar to ECMAScript syntax so that it can be easily
    adapted by the web developer community. More details about the Solidity programming
    language can be found at [https://solidity.readthedocs.io](https://solidity.readthedocs.io).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种由Gavin Wood最初提出的静态类型编程语言。它被设计为与ECMAScript语法类似，以便它可以被Web开发人员社区轻松适应。有关Solidity编程语言的更多细节可以在[https://solidity.readthedocs.io](https://solidity.readthedocs.io)找到。
- en: 'We''ll create a simple hello world smart contract using the Solidity programming
    language:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Solidity编程语言创建一个简单的hello world智能合约：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line of the Solidity script is the version `pragma` to indicate the
    version of the solidity program. The preceding script should not be compiled on
    a Solidity compiler whose version is earlier than 0.4.23\. Each contract is defined
    to a similar class with the contract name as the file name. All the functions
    are defined inside the contract. A constructor function can also be created with
    the same name as that of the contract. The function `greetUser` accepts a string
    of type `bytes` and returns a `bytes` string. The function also has public visibility,
    meaning it can be invoked from anywhere. The `greetUser` function will concatenate
    and return two strings.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity脚本的第一行是版本`pragma`，用于指示solidity程序的版本。前面的脚本不应该在版本早于0.4.23的Solidity编译器上编译。每个合约被定义为一个类，类名与文件名相同。所有函数都被定义在合约内部。一个构造函数也可以被创建，其名称与合同的名称相同。`greetUser`函数接受一个`bytes`类型的字符串并返回一个`bytes`字符串。函数同时具有公共可见性，意味着它可以从任何地方调用。`greetUser`函数将串联并返回两个字符串。
- en: 'We will use the Truffle framework to deploy and invoke the smart contract.
    We need to point the smart contract file to the Truffle framework by including
    the following code snippet in a new JavaScript file (`2_deploy_contracts.js`)
    inside the `migrations` folder, or by updating the existing `1_initial_migration.js`
    file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Truffle框架来部署和调用智能合约。我们需要通过在`migrations`文件夹内包括以下代码片段的JavaScript文件（`2_deploy_contracts.js`）或通过更新现有的`1_initial_migration.js`文件将智能合约文件指向Truffle框架：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The smart contract can be compiled using the following Truffle command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下Truffle命令编译智能合约：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It will generate an interface file called **application binary interface** (**ABI**)
    in the `build/contracts` folder. The generated ABI file will be in JSON format,
    and it provides the interface to interact with the contract in the Ethereum ecosystem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在`build/contracts`文件夹中生成一个名为**应用二进制接口**（**ABI**）的接口文件。生成的ABI文件将是JSON格式的，并且它提供了在以太坊生态系统中与合约交互的接口。
- en: 'The contract is then deployed to the blockchain by migrating it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过迁移将合约部署到区块链上：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The deployed contract will generate a contract address that can be used to
    interact with it. We will use the Truffle console to interact with the contract:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的合约将生成一个合约地址，可用于与之交互。我们将使用Truffle控制台与合约交互：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the preceding code snippet is executed on the Truffle console to invoke
    the `greetUser` function of the contract with `Alice` as the parameter, the contract
    will return `0x48656c6c6f20416c696365`, which is a hexadecimal string for "Hello
    Alice."
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Truffle控制台上执行前面的代码片段以使用`Alice`作为参数调用合约的`greetUser`函数时，合约将返回`0x48656c6c6f20416c696365`，这是一个代表"Hello
    Alice"的十六进制字符串。
- en: Proof of ownership application
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权证明应用
- en: We will create an application with asset management functionalities to register,
    query, remove, and transfer the asset.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有资产管理功能的应用程序，用于注册、查询、移除和转移资产。
- en: Creating the smart contract
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建智能合约
- en: The application logic is similar to that of one used in the NEO smart contract.
    But the data structure used to store the asset information is different due to
    the functionalities provided by the virtual machine. One major difference between
    NEO and Ethereum contract is that the functions in Ethereum contracts can be directly
    invoked with the help of ABI.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的逻辑类似于NEO智能合约中使用的逻辑。但由于虚拟机提供的功能，用于存储资产信息的数据结构不同。以太坊合约与NEO合约之间的一个主要区别是，以太坊合约中的函数可以直接通过ABI的帮助进行调用。
- en: 'The `ProofOfOwnership` smart contract uses a mapping data structure to store
    the asset ownership information in a key/value pair. The asset information of
    type `bytes32` is mapped to the Ethereum address of the asset owner:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProofOfOwnership`智能合约使用映射数据结构以键值对的形式存储资产所有权信息。类型为`bytes32`的资产信息映射到资产所有者的以太坊地址：'
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `registerAsset` function maps the address of the user who invoked the contract
    to the asset ID using the mapping data structure:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerAsset`函数将调用合约的用户地址与资产 ID 映射到映射数据结构中：'
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The owner of the asset can be retrieved from the stored information in the
    mapping data structure with the help of asset ID:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 资产所有者可以通过映射数据结构中存储的信息检索：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `transferAsset` function transfers the ownership to the new address after
    verifying that the current owner of the asset is same as the one who invoked the
    contract:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`transferAsset`函数在验证资产当前所有者与调用合约的用户相同时，将所有权转移到新地址：'
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `deleteAsset` function will assign an empty address to the asset when the
    owner of the asset invokes the contract:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当资产所有者调用合约时，`deleteAsset`函数将为资产分配一个空地址：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Similar to the previous smart contract deployment, the following configuration
    should be created in a new JavaScript file (`2_deploy_contracts.js`) inside the `migrations`
    folder, or the existing `1_initial_migration.js` file should be updated:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的智能合约部署类似，应在新的 JavaScript 文件（`2_deploy_contracts.js`）中创建以下配置，放在`migrations`文件夹内，或者应更新现有的`1_initial_migration.js`文件：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The smart contract can then be compiled and migrated using the Truffle framework,
    as in the previous example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约随后可以使用 Truffle 框架进行编译和迁移，就像前面的例子一样：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Executing the smart contract
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行智能合约
- en: 'Let''s consider the same example of keeping track of document ownership that
    we used earlier in NEO application. We will also use the same file with the following
    content as the asset:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在 NEO 应用程序中以前使用的跟踪文档所有权的相同例子。我们将使用相同的文件，并且具有以下内容作为资产：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will use an md5 (32 characters) hashing algorithm to calculate the asset
    ID of the file instead of SHA256 (64 characters). This is because the key (`bytes32`)
    in the mapping data structure of our contract can accept only 32 characters. The
    following is the 32-character or 128-bit hash value of the file generated by the
    md5 algorithm:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 md5（32 个字符）哈希算法来计算该文件的资产 ID，而不是使用 SHA256（64 个字符）。这是因为我们合约中映射数据结构的键（`bytes32`）只能接受
    32 个字符。以下是 md5 算法生成的文件的 32 个字符或 128 位哈希值：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once the proof of ownership smart contract is deployed to the blockchain, it
    can be invoked from the Truffle console. Let''s register the asset using the `registerAsset`
    function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有权智能合约部署到区块链上，就可以在 Truffle 控制台中调用。让我们使用`registerAsset`函数注册资产：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the invoking node has multiple accounts, a `from` address can be included
    in the function call to identify the user invoking the contract. Since the `registerAsset`
    function performs write operations, it needs GAS during the execution. The total
    GAS consumed will be shown once the transaction is created.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用节点有多个帐户，`from`地址可以包含在函数调用中，以标识调用合约的用户。由于`registerAsset`函数执行写操作，它在执行期间需要
    GAS。一旦创建交易，将显示使用的总 GAS。
- en: 'The `transferAsset` takes the asset ID along with the new owner address as
    arguments:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`transferAsset`将资产 ID 与新所有者地址作为参数：'
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can query the asset at any time to check the owner of the document:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随时查询资产，检查文档的所有者：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the query returns `0xfda013eecad647a2593aacbb3c18445f051d0f52` as the current
    owner, we have successfully executed the `transferAsset` function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询返回`0xfda013eecad647a2593aacbb3c18445f051d0f52`作为当前所有者，则我们成功执行了`transferAsset`函数。
- en: Interface for the application
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的接口
- en: A fully fledged decentralized application can be created by integrating the
    frontend application with the Ethereum blockchain. We can make use of the APIs
    provided by the `web3.js` library to interact with the blockchain network. We
    have already used the Truffle development environment to deploy and invoke the
    smart contracts. In this section, we will make use of the Truffle libraries to
    communicate with the contracts.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将前端应用程序与以太坊区块链集成，可以创建一个完整的分散式应用程序。我们可以利用`web3.js`库提供的 API 与区块链网络交互。我们已经用 Truffle
    开发环境部署和调用了智能合约。在本节中，我们将利用 Truffle 库与合约通信。
- en: The following code can be executed in any JavaScript runtime environment, such
    as Node.js. Refer to the GitHub repository of the book to find the implementation
    using the React library.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在任何 JavaScript 运行环境中执行，例如 Node.js。请参考本书的 GitHub 仓库，查找使用 React 库的实现。
- en: 'The `ProofOfOwnership.json` is the ABI file that was created during the compilation
    of the contract. This ABI is essential for communicating with the smart contract:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProofOfOwnership.json` 是在合同编译期间创建的 ABI 文件。这个 ABI 对于与智能合同通信是必不可少的：'
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the code is executed in a browser where a bridging application such as MetaMask
    is installed, a web3 object will be injected into the browser along with the provider.
    The web3 object can also be created by setting the provider as local or any other
    remote RPC server node.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在安装了 MetaMask 等桥接应用程序的浏览器中执行，web3 对象将与提供程序一起注入到浏览器中。web3 对象也可以通过将提供程序设置为本地或任何其他远程
    RPC 服务器节点来创建。
- en: The MetaMask browser add-on can be installed from [https://metamask.io](https://metamask.io).
    Once the add-on is installed, an account has to be created. The user has to point
    MetaMask to the private blockchain that was used for the development. The accounts
    created by the private blockchain (via the Ganache CLI) can be imported to the
    MetaMask wallet so that it can be used to pay for the transaction GAS.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 浏览器插件可以从 [https://metamask.io](https://metamask.io) 安装。安装插件后，必须创建一个帐户。用户必须将
    MetaMask 指向用于开发的私有区块链。由私有区块链（通过 Ganache CLI）创建的帐户可以导入到 MetaMask 钱包中，以便用于支付交易 GAS。
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A contract instance can be created from the imported ABI. This contract instance
    can then be used to invoke any of the contract functions:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从导入的 ABI 创建合同实例。然后可以使用此合同实例调用任何合同函数：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following function will invoke the `registerAsset` function of the contract
    by passing `assetID` as the argument. When the function is executed from the browser,
    MetaMask will bring up a window asking to confirm the transaction. The contract
    function will be executed after the transaction is confirmed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将通过将 `assetID` 作为参数传递来调用合同的 `registerAsset` 函数。当该函数从浏览器执行时，MetaMask 将弹出一个窗口，询问是否确认交易。在确认交易后，合同函数将被执行：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Similarly, the query function will invoke the `queryAsset` function of the
    smart contract. Since the `queryAsset` does not write to the blockchain, MetaMask
    will not create a new transaction:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，查询函数将调用智能合同的 `queryAsset` 函数。由于 `queryAsset` 不会写入区块链，MetaMask 将不会创建新的交易：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: All the other functionalities of the proof of ownership application can be implemented
    in a similar way. Refer to the GitHub repository ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain))
    for the complete frontend implementation of the application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他的产权证明应用功能都可以用类似的方式实现。参考 GitHub 仓库（[https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain)）获取应用程序的完整前端实现。
- en: Now that we have implemented the proof of ownership application using both the
    NEO and Ethereum blockchain platforms, we have enough information to build other
    applications on these platforms. Since we have also compared the functionalities
    of both the platforms, we can decide on a platform that is best suited to implement
    any use case based on the requirements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 NEO 和以太坊区块链平台实现了产权证明应用程序，我们有足够的信息来在这些平台上构建其他应用程序。由于我们还比较了两个平台的功能，我们可以根据需求决定最适合实现任何用例的平台。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have dived deep into both creating and using smart contracts,
    as well as using the NEO and Ethereum platform to build a decentralized application.
    After creating the foundations of a NEO and Ethereum blockchain, we created a
    proof of ownership system to prove the ownership of the assets.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了创建和使用智能合同，以及使用 NEO 和以太坊平台构建去中心化应用程序。在创建 NEO 和以太坊区块链的基础之上，我们创建了一个证明资产所有权的系统。
- en: This chapter has hopefully motivated you to develop decentralized applications
    by introducing you to smart contracts. In the next chapter, we'll explore the
    real-world applications of blockchain technology by exploring projects from different
    domains.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章希望通过向您介绍智能合同来激励您开发去中心化应用程序。在下一章中，我们将通过探索来自不同领域的项目，探索区块链技术的实际应用。
