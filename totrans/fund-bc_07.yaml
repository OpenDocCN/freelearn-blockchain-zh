- en: Diving into Blockchain - Proof of Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be introduced to the wider applications of blockchain
    by creating a proof of ownership application. Throughout this chapter, we'll discuss
    the concept of smart contracts within blockchain in order to implement this application.
    Since we've already introduced the concepts of blockchain in the earlier chapters
    of this book, this chapter will mainly focus on the high-level details of smart
    contracts, namely proof of ownership and the creation of a decentralized application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to focus on the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a proof of ownership application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of smart contracts within blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose a smart contract platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the NEO blockchain platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decentralized application (proof of ownership) in NEO blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Ethereum blockchain platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decentralized application (proof of ownership) in Ethereum blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the world of assets, it is necessary to keep track of each and every one
    of them if you want to claim and prove ownership of them. But assets are created
    by different entities in different parts of the world, and there is no single
    protocol for managing assets because each entity has its own system of asset management.
    For example, if Alice has a house and a car in a city, and she wants to sell both
    the house and car to Bob because she is planning to move out of the city, she
    has to go through different procedures to transfer ownership to Bob – she has
    to deal with the land registry for the house, the road transport department for
    the car.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, she also appoints an attorney, because the procedure is quite complex.
    She is only able to finally transfer ownership of the car and the house to Bob
    after dealing with the registration office, the attorney, and the notaries. The
    protocol involved in the registration and management of the different assets meant
    Alice had to deal with different entities to perform a simple task.
  prefs: []
  type: TYPE_NORMAL
- en: The current asset management system requires approval from certain trusted authorities.
    The main reason for the involvement of a trusted authority is the fact that the
    assets exist within a trustless society. Different entities create their own set
    of procedures to deal with assets. Some of the entities may be using outdated
    technology, making it hard to use as the user has to deal with some traditional
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: The proof of ownership solution proposed in this chapter will use blockchain
    to build a decentralized application to mitigate all the issues faced by a centralized
    asset management system. We'll use digital identity, assets, and smart contracts
    to create a completely decentralized asset management system with the help of
    blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Digital assets and identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital assets are programmable assets that exist in digital format. These assets
    can have their own value (digital tokens) or could virtually represent existing
    physical assets (ownership of vehicle). Digital assets have been used since the
    beginning of the digital age, but until now they have always existed in an environment
    where management was centralized. The invention of blockchain has allowed digital
    assets to exist in a decentralized network, where no trusted intermediary is needed
    to register or trade an asset. Removing the intermediaries means users don't have
    to pay any additional charges while trading assets.
  prefs: []
  type: TYPE_NORMAL
- en: Digital identity is essential to digital assets when dealing with asset ownership.
    It represents the identity of any individual or organization in a digital format.
    Digital identity is based on the **public key infrastructure** (**PKI**) and provides
    accurate identity management for the user. Unlike traditional identity documents,
    which could easily be forged, digital identity requires the user to authenticate
    via a digital signature to prove their identity. This system often uses a secured
    key infrastructure, which cannot be compromised easily.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed claiming digital assets in the earlier chapters; you'll remember
    we covered the creation of an identity for the user with which the user would
    be able to claim an asset using a secret key. A similar approach will be used
    here to create and manage the digital identity of the user in the platform that
    we will use to build the application in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every asset in the world is owned by some entity. Ownership of a part of an
    asset might not be feasible to prove, either due to the fact that part of the
    ownership record is missing or due to the ambiguity in the existing record's data.
    Although ownership is proved digitally, or by other means, by the entities, in
    most cases, the ownership information is not consistent across all the systems.
    Proving ownership by keeping a digital record is the best solution, and digital
    assets and identities play a huge role in this.
  prefs: []
  type: TYPE_NORMAL
- en: Digital assets, along with digital identities, provide a convenient way to claim
    ownership of any goods because assets are registered digitally along with the
    user's identity. Whenever users need to verify and prove ownership of an asset,
    they can provide their identity details along with the asset that they are trying
    to claim. Users might often need to verify their identity by either providing
    some secret information or authenticating using secret information. The identity
    verification process depends on the third party that built the asset management
    system. In our previous example, where Alice wanted to sell her house and car
    to Bob, she would need to provide identity information to the land registry and
    transport departments that could then be verified by comparing it against the
    records on their system. The drawback of this kind of proof of ownership system
    is that there is no proper protocol maintained across different organizations.
    This is why identity management isn't secure across every system, and why organizations
    still use traditional systems, such as hard copies of the user's identity, to
    verify identities without a proper authentication mechanism, which could be easily
    exploited by bad actors.
  prefs: []
  type: TYPE_NORMAL
- en: A completely secure proof of ownership system could be created by using a digital
    identity, which uses strong authentication to prove a user's identity. Most existing
    systems that implement this proof of ownership model are centralized, which requires
    the centralized body to be trusted. Although this provenance model solves the
    problem, it needs the user to completely trust the third-party organization to
    prove and verify the ownership. Creating a decentralized proof of ownership system
    using blockchain is the only well-known solution that could solve all the problems
    regarding asset management and proof of ownership. Blockchain is the most suitable
    technology for asset management due to its immutability and traceability, as once
    some information about an asset has been appended to a blockchain, it cannot be
    undone. The traceability makes it easy to verify any transactions, and also allows
    a transaction to be restricted with a specialized blockchain if privacy is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Although proof of ownership could be achieved using a blockchain in a decentralized
    network, some complex agreements between participants of trades may exist in some
    cases. These agreements are formed between the parties by creating contracts.
    A concept known as **smart contracts** is used to perform this in a decentralized
    network. We will be using this to create a decentralized proof of ownership application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best examples of a decentralized proof of ownership application is
    **Everledger**, which built a proof of ownership model for the supply chain of
    the diamond market ([https://diamonds.everledger.io](https://diamonds.everledger.io)).
    Everledger provides a global digital blockchain ledger to keep track of the ownership
    history of assets. It tries to prevent fraud in the diamond industry, which is
    estimated to be in the billions of dollars annually.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts are created between parties to enforce an agreement and to ensure
    that the participants cannot deny the agreement later. A smart contract is a protocol
    that allows contracts to be verified and enforced in a self-executing manner.
    In simple terms, it executes a contract agreed between parties whenever the conditions
    of the contract are met, without anyone's intervention. The term, smart contract,
    was coined by Nick Szabo, a cryptographer, in 1994\. Although the smart contract
    was conceptualized in the early 1990s to automate the execution of traditional
    contracts, it wasn't implemented in a public network until the adoption of Bitcoin's
    underlying blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: It was the Byzantine fault-tolerant consensus algorithms that made the execution
    of smart contracts possible in a decentralized public network. A number of existing
    blockchain platforms provide support for **Turing complete** programming languages,
    which makes it easier to create the logic required to build a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: A programming language is said to be Turing complete if it can be used to simulate
    a Turing machine. Bitcoin's scripting language was intentionally made Turing incomplete
    to keep the Bitcoin transaction as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Since smart contracts are created and deployed in the blockchain, they will
    benefit from all the features that blockchain provides. None of the contacts stored
    in the blockchain can be tampered with by anyone once they have been accepted
    and deployed by the parties, due to their immutability. In addition to this, deploying
    a smart contract in a blockchain gives complete transparency as anyone can verify
    the existence of the contract at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts also have several other additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster deployment and execution**: Preparing a contract in the traditional
    way would require the user to spend hours of time preparing paperwork and processing
    it. A smart contract is nothing but a set of instructions that automate these
    tasks, which removes many unnecessary steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-efficient deployment and execution**: Creating and executing smart contracts
    on a blockchain is cheaper than with traditional contracts, which need the involvement
    of intermediaries to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure management**: All the contracts created in a blockchain are managed
    securely. This is the inherent nature of the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replicated proofs**: Due to the decentralized public ledger in the network,
    each contract resides on every node of the network, providing multiple backups.
    It is impossible to lose a contract on a blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accurate execution**: Smart contracts are created with a set of instructions
    that execute consistently on every node in the blockchain network. This ensures
    that smart contracts always operate accurately. Due to the Byzantine fault-tolerant
    nature of blockchain, the network will ignore any faulty executions of the contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the smart contract platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts are self-executing contracts that can be deployed using any
    blockchain application that supports the execution of basic scripts in its transactions.
    Most blockchain platforms support a domain-specific language. We have already
    come across the language used in Bitcoin transactions, which is called **Script**,
    a stack-based language with limited capabilities. Although Script is a Turing-incomplete
    language, it only has a few options that can be used to create complex transactions.
    It can create multi-signature transactions, payment channels, and atomic cross-chain
    trading. In addition to this, Bitcoin can create a transaction with a lock time.
    A transaction can be created but locked for a certain amount of time in case the
    creator wants to invalidate the transaction before the lock time expires. Although
    Bitcoin's Script language provides enough flexibility to create a complex transaction,
    it isn't suitable for creating complex contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Many blockchain platforms have been created since then that provide advanced
    scripting capabilities using their own domain-specific language, such as **Solidity**
    by Ethereum and **Plutus** by Cardano. In addition to this, most platforms have
    their own runtime environment, which is where the compiled smart contract is executed.
    The runtime environment is similar to the one used in general-purpose programming
    languages such as Java. Smart contracts will run on a virtual machine, which is
    similar to a **Java Virtual Machine** (**JVM**). The blockchain virtual machine
    provides a way to execute untrusted code in the public network. These virtual
    machines also provide security against attacks such as **denial-of-service** (**DoS**)
    attacks, which is a necessary feature in systems that execute untrusted code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the blockchain platforms that provide these services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EOS**: A smart contract platform and decentralized operating system that
    aims to solve the scalability issues in blockchain by conducting millions of transactions
    per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethereum**: This is the most prominent smart contract platform. It implements
    a nearly Turing-complete language on its blockchain. It uses a domain-specific
    language called Solidity, which is compiled and executed on the **Ethereum Virtual
    Machine** (**EVM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyperledger Fabric**: This is a permissioned blockchain project under the
    Hyperledger projects hosted by The Linux Foundation. It allows execution of smart
    contracts called **chaincode**. It also allows a consensus mechanism to be plugged
    in as a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NEO**: This is a blockchain platform that allows smart contract to be written
    in several general-purpose programming languages, such as C#, Python, and JavaScript.
    We will cover NEO blockchain in detail in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NXT**: This is a public blockchain platform that executes a limited selection
    of templates for smart contracts. It doesn''t have much scope for the creation
    of complex contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a platform to create a smart contract depends on the type of application
    that needs to be built, required performance, smart contract language, and many
    other things. It is important to consider all the requirements before selecting
    the platform. As far as our proof of ownership application is concerned, it needs
    a platform that can handle digital assets and digital identity.
  prefs: []
  type: TYPE_NORMAL
- en: NEO blockchain provides a convenient way to handle digital identity and assets.
    In addition to this, the smart contracts can be coded in a general-purpose programming
    language to build the decentralized applications. We will create our smart contract
    in the Python programming language so that we need not master any additional programming
    language. Ethereum is one more platform where a wide range of use cases can be
    implemented conveniently. We will implement our proof of ownership use case in
    both the platforms since they are the most widely used blockchain platforms, and
    the introduction to both of these platforms will provide a solid foundation for
    decentralized application development.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we are going to dive into both NEO and Ethereum blockchain
    platforms, along with proof of ownership implementation.
  prefs: []
  type: TYPE_NORMAL
- en: NEO blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NEO is a blockchain platform and cryptocurrency that facilitates the creation
    and management of digital assets and smart contracts. The NEO project was originally
    launched in 2014 under the name of AntShares, until it changed its name in June,
    2017\. All the development resources were provided by founder, Da Hongfei, from
    his business blockchain solution company, called Onchain. The main motive of the
    NEO project is to achieve a **smart economy** with the help of digital assets,
    digital identity, and smart contracts in a distributed network.
  prefs: []
  type: TYPE_NORMAL
- en: The platform uses two kinds of token, called NEO and GAS. Unlike Bitcoin, a
    NEO token is a non-divisible token, which means that the minimum unit of NEO is
    1\. Holding the NEO tokens gives the right to vote during the consensus mechanism,
    which is explained in the, *Consensus algorithm* section. Holding the NEO token
    generates a new token called GAS, which is used to pay for the transaction fee.
    A GAS token is like a fuel that is essential if you want to deploy and execute
    any smart contract on the blockchain. A total of 100 million NEO tokens are generated
    in the genesis block. But the corresponding 100 million GAS tokens will be generated
    gradually in about 22 years.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of a NEO blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A NEO blockchain uses two important elements of a decentralized network to create
    a decentralized application and therefore construct a smart economy. These are
    digital assets and digital identity, which are the building blocks of any blockchain
    application. These concepts, along with smart contracts, are essential to the
    creation of any proof of ownership application, as mentioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'NEO provides a convenient way of creating and managing the digital assets in
    a decentralized NEO blockchain network. NEO provides two different types of asset:'
  prefs: []
  type: TYPE_NORMAL
- en: Global assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global assets are recorded in the system and can be identified by all the clients
    and smart contracts. NEO and GAS tokens are global assets. Contract assets are
    bound to specific contracts and cannot be identified by other contracts. Only
    certain compatible clients will be able to access the contract assets. NEP-5-based
    assets are an example of contract assets.
  prefs: []
  type: TYPE_NORMAL
- en: NEP-5 a is standard specified by NEO to create cryptographic tokens. The standard
    helps the developers to maintain a template while building applications related
    to tokens. NEP-5 tokens are similar to the ERC-20 tokens used in Ethereum. We
    will later implement a use case using the NEP-5 token in [Chapter 12](55ed2989-ecca-46ca-8546-74a12da98715.xhtml),
    *Blockchain Use Cases*.
  prefs: []
  type: TYPE_NORMAL
- en: NEO provides a way to handle connections between physical and digital assets
    in a blockchain with the help of digital identity. NEO implements the **X.509**
    public key certificate issuance standard to create digital identities. With the
    help of blockchain, NEO can replace the **Online Certificate Status Protocol**
    (**OCSP**) to manage and record the X.509 **Certificate Revocation List** (**CRL**).
  prefs: []
  type: TYPE_NORMAL
- en: NEO technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NEO provides several functionalities to function as a scalable blockchain platform.
    A few of the technologies used in NEO are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NEO uses **Delegated Byzantine Fault Tolerance** (**dBFT**), a modified Byzantine
    fault-tolerant consensus algorithm. It is a mechanism that allows all the blockchain
    participants to reach a consensus through proxy voting. A special group of nodes
    called bookkeepers reach a consensus in order to generate new blocks in the network.
    These bookkeepers are elected by NEO token holders through voting. The dBFT algorithm
    has a fault tolerance of *f =* ⌊ *(n-1) / 3* ⌋ of *n* nodes, that is, roughly
    33% of the nodes. It is nearly impossible to revoke the blocks and transactions
    once they are generated and confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: It takes around 15 to 20 seconds to generate a block in NEO, and it provides
    a throughput of 1,000 transactions per second, which is very high compared to
    Proof of Work-based implementations. NEO applications can be easily scaled due
    to their high transaction throughput.
  prefs: []
  type: TYPE_NORMAL
- en: NEO smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts are one of the features that highlight the NEO blockchain. Writing
    smart contracts in a NEO blockchain system is a fairly simple process compared
    to other smart contract platforms, mainly due to the support it has for a huge
    number of general-purpose languages in which smart contracts could be created.
    Unlike Ethereum, NEO doesn't need a domain-specific language to create and execute
    smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: NEO has a lightweight virtual machine that is similar to the JVM for Java. NEO's
    virtual machine executes smart contract instructions in sequence. NEO virtual
    machines only execute the instructions that are compiled by the NEO compilers.
    NEO plans to support compilers for languages such as C#, Java, C, C++, Go, JavaScript,
    Python, and Ruby; although not all of them have been implemented, development
    is underway to provide support for most languages. In addition to these compilers,
    NEO currently supports IDE plugins for Java and C#. This helps developers to create
    smart contracts without changing their development ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Additional NEO projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NEO is a growing community with a lot of projects in its roadmap; you''ll find
    a sample of the most popular ones in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NeoX**: This feature of NEO will allow asset exchange across different chains.
    It will provide atomic asset exchange protocols to ensure that a transaction is
    either completely processed or completely rejected. Even an incompatible blockchain
    will be able to communicate through NeoX as long as it provides some basic smart
    contract functionality. Since NeoX will help to achieve cross-chain collaboration,
    a single smart contract could perform operations on two chains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NeoFS**: This is a distributed storage mechanism that will use a **distributed
    hash table** (**DHT**) technology. Each document will be indexed by the digest
    of its content. Large documents are divided into blocks and distributed across
    the blockchain nodes. NeoFS plans to incentivize the nodes with tokens for storing
    documents that need higher reliability. NeoFS nodes can be used to store old block
    data from the NEO blockchain to reduce the load on full nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NeoQS**: NEO plans to solve the challenge posed by quantum computing on cryptographic
    algorithms. NeoQS plans to develop quantum-safe cryptographic mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although all these projects are under development, the roadmap of NEO looks
    very promising. Both NeoFS and NeoQS will provide a research update in the third
    quarter of 2018, whereas NeoX is expected to run initial tests during the last
    quarter of 2018.
  prefs: []
  type: TYPE_NORMAL
- en: NEO nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other blockchain platform, NEO also has nodes that hold the complete
    history of blockchain, which are called full nodes. These full nodes form the
    backbone of the network, and they communicate using the P2P protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NEO supports two variants of full nodes, one with a graphical user interface
    and another with just command-line support. The graphical user interface variant,
    called **NEO-GUI**, provides all the functionalities an end user requires. **NEO-CLI**
    is intended for developers who want to use the basic wallet functionality and
    APIs. It is quite straightforward to get started with either variant. We will
    be mostly dealing with NEO-CLI because it is more developer friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a full node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original NEO-CLI implementation is written in C#, and the source code can
    be found at [https://github.com/neo-project/neo-cli](https://github.com/neo-project/neo-cli).
    This implementation requires a user node with .NET Core installed to run the compiled
    binary. The repository explains how to set up .NET Core in different environments.
    A **dynamic link library** (**DLL**) file in the source code needs to be executed
    to run the NEO-CLI. Once .NET Core is installed on your system, the following
    command starts an NEO-CLI full node process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The full node uses three different ports for JSON-RPC (`10332`), P2P via TCP
    (`10333`), and P2P via WebSocket (`10334`). JSON-RPC has an HTTPS version (`10331`),
    in addition to this. NEO uses a different set of ports for test nets and private
    nets. It uses similar ports with the initial "1" replaced with "2" for test nets
    and "3" for private nets. We will be mostly dealing with private net nodes in
    this chapter, as we will be creating our own network to deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON-RPC interface of the node can be exposed by running the following
    command with the `/rpc` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'NEO-CLI opens an interactive interface in which the user can perform all blockchain
    node and wallet operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The user has to either create a wallet or open an existing one before executing
    any commands to manage the wallet or node. The following command inside the shell
    creates and opens a wallet in the NEO-CLI shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The user needs to provide a password to secure the wallet, and this password
    will be used to unlock the wallet every time. The user can perform any wallet,
    transaction, or block operation after opening the wallet.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer the NEO-CLI documentation at [http://docs.neo.org/en-us/node/cli/cli.html](http://docs.neo.org/en-us/node/cli/cli.html)
    for all the commands.
  prefs: []
  type: TYPE_NORMAL
- en: NEO-CLI has support for testing, building, and deploying smart contracts in
    a blockchain, but currently, it doesn't support smart contracts being written
    in a variety of programming languages. NEO-CLI only provides a compiler for .NET
    and Java. We need a third-party compiler to create a smart contract in any other
    programming language. **neo-python** is one such project. It is backed by the
    City of Zion organization, which consists of a rich set of developers contributing
    actively. We will be using the neo-python project to build our application in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a neo-python environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The neo-python project provides an NEO node and an SDK that enables developers
    to create, test, deploy, and execute smart contracts on the NEO blockchain using
    Python. This project supports all the functionalities you need to manage assets
    in the wallet and blockchain nodes. This project aims to port the NEO-CLI implementation
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: To set up neo-python, you need to install the Python 3.6 interpreter. neo-python
    can be installed on any platform, although it requires some platform-specific
    steps to be performed. neo-python needs the `leveldb` and `openssl` libraries
    to be installed before it is installed itself.
  prefs: []
  type: TYPE_NORMAL
- en: The complete documentation of neo-python, from a quickstart to building complex
    smart contracts, can be found at [https://neo-python.readthedocs.io](https://neo-python.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'The neo-python package can be installed from **PyPI**, just like any other
    Python package, or from the source repository. Once the installation is complete,
    neo-python''s interactive shell can be launched with the `np-prompt` command.
    Its shell interface, as shown in the following block, is similar to that of NEO-CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: neo-python can also be installed from the source by cloning the repository from
    [https://github.com/CityOfZion/neo-python](https://github.com/CityOfZion/neo-python)
    and installing the neo-python package in development mode. The neo-python shell
    can then be launched with an `np-prompt` command or simply by running the Python
    script `neo/bin/prompt.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Any commands can be executed on the shell after opening a wallet, in a similar
    way to NEO-CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Although all operations performed on NEO-CLI can be executed in neo-python as
    well, some of the command syntax is different from NEO-CLI commands. Type `help`
    in the neo-python shell to list all the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a JSON-RPC interface for the node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As specified in an earlier section while setting up a node, an NEO node acts
    as a JSON-RPC server so that it can communicate using the RPC interface. The JSON-RPC
    server can be instantiated in NEO-CLI by adding the `/rpc` flag, as mentioned
    earlier. You need to launch a different process to create an RPC server in neo-python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like Bitcoin''s JSON-RPC interface, NEO provides an RPC endpoint for each
    of its APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Most of the frontend application uses JSON-RPC to communicate with the decentralized
    applications and the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**neon-js**, maintained by City of Zion, provides JavaScript libraries that
    use the RPC interface exposed by the NEO node to communicate with the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: NEO network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NEO uses a networking protocol to establish connections and communicate with
    each node in a duplex mode. The nodes in the network are categorized into two
    types based on their responsibilities: the validating nodes (bookkeeping nodes)
    and the ordinary peer nodes. Peer nodes help broadcast blocks and unconfirmed
    transactions after they''ve been validated, whereas bookkeeping nodes generate
    new blocks. NEO follows a similar networking protocol as Bitcoin to initiate connection
    and exchange blocks between the peers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we launch a NEO shell through NEO-CLI or neo-python, the node will join
    the network that is specified in the default configuration. A neo-python node
    can belong to either the main, test, or private network. The NEO node will join
    a test network if it is launched without specifying the network. The following
    command launches the node in a private network specified in the private network
    protocol configuration file, which can be found in `neo/data/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will be using a private network to perform all the neo-python operations
    in this chapter. The node could also be initiated by explicitly specifying a network
    configuration file with a `-c` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Test network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NEO test network is similar to the mainnet. In the test network, users can
    develop, deploy, and execute programs. Instead of spending real GAS and NEO tokens,
    users can use test tokens, which don't have real value. Every other operation
    performed on the testnet is the same as on the mainnet. So, this is the perfect
    environment for developers to test applications before deploying them on the mainnet. Since
    the testnet is an active network with participants from around the world, the
    supply of NEO and GAS tokens is limited, and you will not be provided with any
    tokens when joining the network, just like in the mainnet. As a minimum of 500
    GAS is required to deploy a smart contract, a user can either obtain this from
    other testnet users or apply for it at [https://neo.org/Testnet/Create](https://neo.org/Testnet/Create).
    Smart contracts can be deployed to the network once the user has enough GAS.
  prefs: []
  type: TYPE_NORMAL
- en: Private network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A private network is a collection of NEO nodes that achieve blockchain state
    consensus on their own. These NEO nodes are completely disconnected from the public
    nodes of the mainnet or testnet. A private network is ideal for creating a blockchain
    network inside an organization.
  prefs: []
  type: TYPE_NORMAL
- en: A private NEO network needs at least four nodes to achieve consensus. A private
    NEO network can be deployed in a local area network, and also, several nodes can
    be deployed on a single device by creating virtual machines. Even the nodes of
    a private network require GAS to create and deploy smart contracts in a private
    blockchain. A private node can extract all the NEO and GAS tokens from the network
    by creating a multi-party signature address from all the consensus nodes. The
    NEO and GAS can then be transferred from the contact address to a normal address.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small private network with limited consensus nodes can be created by deploying
    a turnkey Docker image, which is hosted at [https://hub.docker.com/r/cityofzion/neo-privatenet](https://hub.docker.com/r/cityofzion/neo-privatenet).
    This Docker image deploys four NEO validating nodes, and it has pre-claimed all
    100 million NEO and 16,600 GAS tokens. Any user joining the network can use the
    wallet that contains all the tokens to deploy smart contracts. The private network
    can be launched with just a couple of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Docker image will create a container that has four nodes exposing both P2P
    (20333-20336) ports and RPC ports (30333-30336).
  prefs: []
  type: TYPE_NORMAL
- en: Any neo-python node that is in the same network can then add these four nodes
    as its seed nodes and start syncing the private network blockchain. Users can
    then use the wallet that contains all the network tokens to create transactions
    and deploy smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: NEO transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each node on the NEO network can create transactions and perform operations
    in the NEO blockchain. The node has to open the wallet to create a transaction
    and broadcast it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wallet` command in neo-python provides you with complete information about
    the opened wallet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The wallet maintains updated details after the validation of each and every
    transaction. The `addresses` field contains details of all the keys held by the
    wallet. The opened wallet has only one key, whose public address is `AK2nJJpJr6o664CWJKi1QRXjqeic2zRp8y`.
    The `balances` field inside the `addresses` field shows the current NEO and GAS
    tokens claimed by the node. In the `balances` field, `0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b`
    represents transaction ID of the NEO tokens, and `0x602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7`
    is for the GAS tokens. NEO uses these as standard IDs for NEO and GAS tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Bitcoin nodes, NEO nodes can create several different types of transaction
    to support all the operations performed in the blockchain. The following table
    depicts different types of transactions that can be created in a NEO network:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `MinerTransaction` | Assign byte fees |'
  prefs: []
  type: TYPE_TB
- en: '| `IssueTransaction` | Issuance of asset |'
  prefs: []
  type: TYPE_TB
- en: '| `ClaimTransaction` | Claim NEO coins |'
  prefs: []
  type: TYPE_TB
- en: '| `EnrollmentTransaction` | Enrolment for validator |'
  prefs: []
  type: TYPE_TB
- en: '| `VotingTransaction` | Vote for validator |'
  prefs: []
  type: TYPE_TB
- en: '| `RegisterTransaction` | Asset register |'
  prefs: []
  type: TYPE_TB
- en: '| `ContractTransaction` | Contract transaction |'
  prefs: []
  type: TYPE_TB
- en: '| `AgencyTransaction` | Order transaction |'
  prefs: []
  type: TYPE_TB
- en: Table. 7.1\. Transaction types in NEO
  prefs: []
  type: TYPE_NORMAL
- en: Each type of transaction will have exclusive fields to store more information
    about the transaction. For example, `MinerTransaction` has an additional field
    to store `nonce`, which is a random number.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring an asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nodes can use transactions to perform operations on NEO assets. The transactions
    are created by the node using its private key, which is situated in the wallet.
    The user can perform any operation on the asset once the wallet is opened. A `send`
    command in neo-python transfers the asset by taking the asset ID, the recipient
    address, and the amount. The `send` command creates a transaction and relays it
    to the network so that it is included in the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The created transaction is a `ContractTransaction`, and the details show that
    it houses `vout` and `vin` fields, whose functions are similar to the fields found
    in Bitcoin transactions. The `vin` field points to the transactions whose unspent
    outputs are referenced, and `vout` consists of newly created unspent outputs.
    The first output is the amount transacted by the user, and the second one is the
    change in output. Unlike Bitcoin transactions, the verification script is found
    under a separate script field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating a decentralized application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked into some of the basic functionalities of the NEO platform,
    we are ready to create our first decentralized application using the NEO blockchain.
    Smart contracts are the backbone of creating a decentralized application using
    NEO. We will become familiar with smart contracts by creating a hello world application
    before creating a decentralized proof of ownership application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a simple Python script that returns a concatenated string
    to greet the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The contract script uses the `concat` method provided by `boa` to concatenate
    two strings. Every smart contract should have a function called `main`, which
    will be the entry point. The smart contract needs to be compiled into byte code,
    which can be executed in the NeoVM. The contract can be compiled by the neo-python
    shell using the neo-boa compiler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build` command is supplied with a `test` argument to test the sample outcome.
    The code immediately after the `test` flag represents the data type for the parameter
    and the return type. The preceding code stipulates that the contract function
    accepts a string parameter and returns a string value. The following table lists
    all the available data types and their codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data types** | **Code** |'
  prefs: []
  type: TYPE_TB
- en: '| Signature | `0x00` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `0x01` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | `0x02` |'
  prefs: []
  type: TYPE_TB
- en: '| Hash160 | `0x03` |'
  prefs: []
  type: TYPE_TB
- en: '| Hash256 | `0x04` |'
  prefs: []
  type: TYPE_TB
- en: '| ByteArray | `0x05` |'
  prefs: []
  type: TYPE_TB
- en: '| PublicKey | `0x06` |'
  prefs: []
  type: TYPE_TB
- en: '| String | `0x07` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | `0x10` |'
  prefs: []
  type: TYPE_TB
- en: '| Interop Interface | `0xf0` |'
  prefs: []
  type: TYPE_TB
- en: '| Void | `0xff` |'
  prefs: []
  type: TYPE_TB
- en: Table 7.2\. Data types used by contract parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Boolean values following the data types stipulate whether the contract
    requires local storage, and the second Boolean value indicates whether the contract
    has a dynamic invocation to other smart contracts whose addresses are known only
    during execution. Any input to the contract follows these arguments during the
    build process. The test invocation will show the result, along with the GAS required
    to invoke the contract. The result shows that the output is of a `string` type,
    along with the value. Most importantly, the `build` call generates the contract
    instructions in byte code by creating an AVM file that will be stored in the same
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated AVM file needs to be imported to the NeoVM and then relayed to
    the blockchain network. The following `import` call performs contract importing.
    The `import` command takes parameters that are similar to the ones specified during
    the build process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The user needs to enter the details of the smart contract before it is created
    and relayed to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A script hash, along with the contract script, will be generated once the smart
    contract is created. The script hash represents the contract, and it can be used
    by everyone in the network to invoke the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: The GAS utilized in a transaction depends on the type of smart contract operation,
    and the system calls used in the smart contract. The cost of creating a smart
    contract is 100 GAS plus the additional fees of the system calls. If the smart
    contract needs a storage area, it costs an additional 400 GAS. Our earlier smart
    contract deployment used only 100 GAS to create the smart contract as there was
    no local storage required.
  prefs: []
  type: TYPE_NORMAL
- en: 'neo-python provides a `testinvoke` command, which can be used to test contract
    hashes that have already deployed in the blockchain. The `testinvoke` call will
    not be relayed to the network unless it is accepted by the user. It accepts only
    the script hash of the contract and its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `testinvoke` call can be executed once the node updates its local blockchain
    to include the relayed contract that was created earlier. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`testinvoke` invokes the contract from the blockchain and returns the computed
    result in an array of hexadecimal strings. The hexadecimal result `''48656c6c6f20416c696365''`
    translates to "Hello Alice," which is the desired output.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already looked into the benefits of creating a proof of ownership application
    in a decentralized application earlier on in this chapter; now we're going to
    move on and create a proof of ownership application using NEO smart contracts
    in order to perform asset management in the decentralized network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a Proof of Existence application to prove the existence of a document
    in [Chapter 6](3156a0a8-4aa4-416c-a04f-c08c9f50f087.xhtml), *Diving into Blockchain
    – Proof of Existence*. In this section, we will create an asset management system
    to register and prove the ownership of documents in this section. The goal is
    to create the following asset management functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Asset registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset querying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement all the functionalities in a smart contract to prove the ownership
    of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts created using Python contain a `main` function as the entry
    point. This function accepts two parameters. The first parameter accepts the type
    of operation, and all the additional arguments are passed to the second parameter
    in a list. The `operation` parameter accepts `register`, `query`, `delete`, and
    `transfer` so that it can perform asset management functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function of the smart contract parses the `operation` parameter
    and invokes the respective function in the smart contract to perform operations
    on the asset. The `main` function parses the `args` parameter and assigns the
    first item of the list to `asset_id`, and the others to `owner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `register_asset` function takes `asset_id` and the owner address and creates
    an entry of the ownership in the blockchain. `CheckWitness` is a NEO runtime functionality
    check that checks whether the owner''s address matches the address of the user
    that invoked the contract. The contract returns `False` if the asset owner who
    is to be registered is not the same as the user who invoked the contract. The
    contract verifies whether that `asset_id` is already registered by invoking the
    NEO storage library `Get` method. Finally, the asset is registered to the owner
    by storing the asset id and the owner details in a key/value pair using the `Put`
    storage method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: NEO provides storage functionality in the blockchain by storing data in a key/value
    pair. Smart contracts have to specify whether the script needs contract storage
    space during deployment. Using storage costs extra GAS during the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `query_asset` function queries the local storage to check whether the asset
    is already registered by the user. It returns the owner address if the asset is
    found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function needs `asset_id` and the address of the asset recipient
    in order to transfer the asset. As the first step, it verifies the existence of
    the asset by checking the storage using the `Get` method. It then checks whether
    the asset owner is the same as the invoker. The contract also verifies that the
    recipient address is a valid address. Finally, the asset is updated with the new
    owner using the `Put` storage method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete_asset` method implements similar functionality as `transfer_asset`,
    with the difference being that it deletes the asset instead of updating it. The
    `Delete` function call is used to delete the stored key/value pair from storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have implemented all the basic functionalities of asset management,
    we will execute the contract using the neo-python shell in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The smart contract is executed with similar steps as shown in the earlier section
    where we deployed the basic smart contract. The only differences are the parameters
    supplied to the contract and the corresponding return data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we will create a proof of ownership application to keep
    track of the documents. Each document can be uniquely identified by its digest.
    We will use the SHA256 hash value of the document as the asset ID. Let''s consider
    a file that has the following content. The files are usually stored with an additional
    new line character that is not visible in raw text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following digest represents the SHA256 hash value of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the hash value as the asset ID to uniquely identify each document.
    The contract is built in the neo-python shell using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `build` procedure has `0710` as a parameter type, which denotes that it
    takes one string (`07`) and one array (`10`) as parameters. And `05` indicates
    that it has a return type of `byte array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract can then be deployed using the created AVM file after a successful
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The transaction needs an additional 400 GAS as the smart contract needs the
    local storage. The total GAS consumed would be `500`, as shown in the preceding
    code block.
  prefs: []
  type: TYPE_NORMAL
- en: The contract can be executed once the contract transaction is included in the
    blockchain and is synchronized in the local blockchain. Let's use the `testinvoke` command
    to test our created smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s register a document using the same SHA256 value mentioned previously
    as the asset ID. The `register` operation is invoked with a list of arguments
    consisting of the hash value and the address of the user invoking the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the transaction is invoked and relayed to the network, other operations
    can be performed on the asset. Let''s now transfer the document''s ownership to
    a new owner by invoking the `transfer` operation and specifying the recipient
    address in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The document ownership can be verified at any time by invoking the query operation
    and passing the asset ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The query returns a byte array that has a hexadecimal string. The hexadecimal
    result represents the address `AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`. Since the
    document's ownership was transferred to the new owner, the result shows the updated
    owner of the document.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished creating a smart contract to demonstrate a proof of ownership
    system that keeps track of the ownership of documents. Once the smart contract
    is deployed in a blockchain, it will stay there forever. The user has to only
    deal with the smart contract invocation. The RPC interface of the NEO node provides
    a convenient way to communicate with the blockchain. We will now look into how
    to conveniently communicate with the blockchain by creating an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interface for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NEO community has a created few JavaScript libraries to interface with the
    NEO blockchain. We will be using a popular library called neon-js ([https://github.com/CityOfZion/neon-js](https://github.com/CityOfZion/neon-js)),
    which is backed by the City of Zion community.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script creates an interface to query the owner of the asset for
    our proof of ownership application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The interface created using the neon-js library builds a script for the smart
    contract using the `Neon.create.script` method. It then uses the RPC interface
    to invoke the smart contract script. After that, `queryAsset` returns the address
    of the user who owns the document asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface to the blockchain smart contract is a crucial part of
    building a fully fledged decentralized application. The interface also creates
    a convenient way to communicate with the blockchain nodes, which enhances the
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is a public blockchain that was proposed by Vitalik Buterin in late
    2013 and was released to the public in 2015\. Ethereum was one of the initial
    blockchain platforms that were created to help programmers to develop and deploy
    decentralized applications using smart contracts. Ethereum has a rich set of frameworks
    and libraries to develop, test, and deploy applications. We will cover the development
    and deployment of proof of ownership applications using the Ethereum platform
    in this section. Refer to [Chapter 8](02eed23a-0a39-4a19-8d88-a72a810ddb0d.xhtml),
    *Blockchain Projects*, for more details regarding the Ethereum ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to Bitcoin and NEO, there are several implementations of client software
    in different languages that can be used as an Ethereum full node. The Ethereum
    client implementation can be found in Java, JavaScript, Python, Go, and many other
    languages. The Golang implementation of Ethereum called **Go Ethereum** or **Geth**
    is the most popular among all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up the node is the important step to take before diving into the application
    development. Although any of the Ethereum clients can be used to set up a full
    node, we will set up the Geth client to sync and interact with the public blockchain.
    Similar to the NEO blockchain, Geth client can connect to mainnet, testnet, or
    a private network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will set up a Geth client that can be used to sync the entire blockchain
    transactions. It also provides the JSON-RPC interface to invoke any of the methods
    supported by the client software. The JSON-RPC interface can be used to perform
    several operations including deploying and invoking smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The Geth client can be either built or installed using packages found in most
    platforms. Installation instructions for different platforms can be found at [https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum).
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth provides a command-line interface that can be used to initiate the node.
    Once Geth is installed with all the dependencies, it can be launched to synchronize
    the local blockchain data with the public blockchain. The Geth client can be configured
    by supplying several parameters for the chain, transaction pool, performance tuning,
    account, networking, miner, and much more. The following command instantiates
    an Ethereum node with a few parameters: `rpc` (enable RPC server), `rpcapi` (list
    of APIs to be accessed through RPC interface), `cache` (memory assigned for internal
    caching), `rpcport` (RPC server port), and `rpcaddr` (RPC server address):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The instantiated Ethereum node will try to sync the blockchain by connecting
    to mainnet peers. Alternatively, the Geth can be configured to connect to any
    of the Ethereum testnets (**Rinkeby**, **Kovan**, or **Ropsten**). The following
    command instantiates a node with the Rinkeby testnet blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A set of Geth clients could also form their own private Ethereum network instead
    of connecting to the existing mainnet or testnet.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions for setting up a private network using Geth client can be found
    here: [https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster](https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a private blockchain with the help of a tool
    provided in the **Truffle** suite framework called **Ganache CLI**, which is a
    JavaScript package that can be installed using the node package manager. Make
    sure that `node` and `npm` are installed in the system before executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The private blockchain can be instantiated by launching Ganache CLI. Ganache
    CLI can be configured by specifying several parameters or launched without parameters,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A successful launch will create a private blockchain along with a few accounts
    loaded with ethers that can be used to pay for the transaction fee for any of
    the transactions created. The Ganache CLI will also create a client application
    that will listen on the port 8545 by default. We will use the private blockchain
    and the application running on the port 8545 to deploy and query the smart contracts
    in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have instantiated a local node with a private blockchain, we will
    set up the development environment to ease the creation and deployment of the
    decentralized application. Since we have to create a fully fledged decentralized
    application, we need to communicate with the Ethereum blockchain using scripting
    languages such as JavaScript. Ethereum provides a JavaScript library called **web3.js**
    that houses APIs to interact with the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web3.js makes use of RPC calls to communicate with the Ethereum node that
    exposes the RPC interface (application port 8545). So, the web3.js can invoke
    any of the methods provided by the Ethereum node. The following code snippet can
    be executed on a node terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a `web3` instance and then add the local node as the provider.
    When the web3.js application executed in a web browser, the `web3` object can
    be injected through bridges such as MetaMask. These `web3` instances will already
    have the provider specified in `web3.currentProvider`. We will use MetaMask while
    building the proof of ownership application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `web3.js` provides all the methods required to interact with the blockchain,
    it doesn''t set up a complete development environment. This can be achieved with
    an Ethereum development framework called Truffle. Truffle provides a complete
    development environment along with convenient testing, deployment, and migration
    of the smart contracts. The Truffle framework can be installed using the node
    package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A Truffle project can be initiated in an empty directory to build the initial
    files required for application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create three directories - `contracts` (smart contracts), `migrations`
    (deployment scripts), and `test` (test scripts) and a configuration file, `truffle.js`.
    We need to add the following configuration to the `truffle.js` file to point the
    created Truffle project to our private blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'An interactive Truffle console can be launched from the Truffle project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `web3` object will be already instantiated in the Truffle console, and any
    of the web3 APIs can be accessed using this object. We will use the Truffle console
    to query the deployed contract in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a decentralized application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now create our first decentralized application on Ethereum platform since
    we have setup our development environment. We will get familiar with Ethereum
    smart contracts by creating and deploying a hello world application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum makes use of a domain-specific language called as Solidity to code
    the logic of the smart contract. Solidity is a high-level programming language
    that can be compiled to produce bytecode, which is then executed on the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a statically typed programming language initially proposed by Gavin
    Wood. It was designed to be similar to ECMAScript syntax so that it can be easily
    adapted by the web developer community. More details about the Solidity programming
    language can be found at [https://solidity.readthedocs.io](https://solidity.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a simple hello world smart contract using the Solidity programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the Solidity script is the version `pragma` to indicate the
    version of the solidity program. The preceding script should not be compiled on
    a Solidity compiler whose version is earlier than 0.4.23\. Each contract is defined
    to a similar class with the contract name as the file name. All the functions
    are defined inside the contract. A constructor function can also be created with
    the same name as that of the contract. The function `greetUser` accepts a string
    of type `bytes` and returns a `bytes` string. The function also has public visibility,
    meaning it can be invoked from anywhere. The `greetUser` function will concatenate
    and return two strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Truffle framework to deploy and invoke the smart contract.
    We need to point the smart contract file to the Truffle framework by including
    the following code snippet in a new JavaScript file (`2_deploy_contracts.js`)
    inside the `migrations` folder, or by updating the existing `1_initial_migration.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The smart contract can be compiled using the following Truffle command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It will generate an interface file called **application binary interface** (**ABI**)
    in the `build/contracts` folder. The generated ABI file will be in JSON format,
    and it provides the interface to interact with the contract in the Ethereum ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract is then deployed to the blockchain by migrating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployed contract will generate a contract address that can be used to
    interact with it. We will use the Truffle console to interact with the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When the preceding code snippet is executed on the Truffle console to invoke
    the `greetUser` function of the contract with `Alice` as the parameter, the contract
    will return `0x48656c6c6f20416c696365`, which is a hexadecimal string for "Hello
    Alice."
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create an application with asset management functionalities to register,
    query, remove, and transfer the asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application logic is similar to that of one used in the NEO smart contract.
    But the data structure used to store the asset information is different due to
    the functionalities provided by the virtual machine. One major difference between
    NEO and Ethereum contract is that the functions in Ethereum contracts can be directly
    invoked with the help of ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProofOfOwnership` smart contract uses a mapping data structure to store
    the asset ownership information in a key/value pair. The asset information of
    type `bytes32` is mapped to the Ethereum address of the asset owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `registerAsset` function maps the address of the user who invoked the contract
    to the asset ID using the mapping data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The owner of the asset can be retrieved from the stored information in the
    mapping data structure with the help of asset ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transferAsset` function transfers the ownership to the new address after
    verifying that the current owner of the asset is same as the one who invoked the
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deleteAsset` function will assign an empty address to the asset when the
    owner of the asset invokes the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous smart contract deployment, the following configuration
    should be created in a new JavaScript file (`2_deploy_contracts.js`) inside the `migrations`
    folder, or the existing `1_initial_migration.js` file should be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The smart contract can then be compiled and migrated using the Truffle framework,
    as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Executing the smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the same example of keeping track of document ownership that
    we used earlier in NEO application. We will also use the same file with the following
    content as the asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use an md5 (32 characters) hashing algorithm to calculate the asset
    ID of the file instead of SHA256 (64 characters). This is because the key (`bytes32`)
    in the mapping data structure of our contract can accept only 32 characters. The
    following is the 32-character or 128-bit hash value of the file generated by the
    md5 algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the proof of ownership smart contract is deployed to the blockchain, it
    can be invoked from the Truffle console. Let''s register the asset using the `registerAsset`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If the invoking node has multiple accounts, a `from` address can be included
    in the function call to identify the user invoking the contract. Since the `registerAsset`
    function performs write operations, it needs GAS during the execution. The total
    GAS consumed will be shown once the transaction is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transferAsset` takes the asset ID along with the new owner address as
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query the asset at any time to check the owner of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If the query returns `0xfda013eecad647a2593aacbb3c18445f051d0f52` as the current
    owner, we have successfully executed the `transferAsset` function.
  prefs: []
  type: TYPE_NORMAL
- en: Interface for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fully fledged decentralized application can be created by integrating the
    frontend application with the Ethereum blockchain. We can make use of the APIs
    provided by the `web3.js` library to interact with the blockchain network. We
    have already used the Truffle development environment to deploy and invoke the
    smart contracts. In this section, we will make use of the Truffle libraries to
    communicate with the contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The following code can be executed in any JavaScript runtime environment, such
    as Node.js. Refer to the GitHub repository of the book to find the implementation
    using the React library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProofOfOwnership.json` is the ABI file that was created during the compilation
    of the contract. This ABI is essential for communicating with the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If the code is executed in a browser where a bridging application such as MetaMask
    is installed, a web3 object will be injected into the browser along with the provider.
    The web3 object can also be created by setting the provider as local or any other
    remote RPC server node.
  prefs: []
  type: TYPE_NORMAL
- en: The MetaMask browser add-on can be installed from [https://metamask.io](https://metamask.io).
    Once the add-on is installed, an account has to be created. The user has to point
    MetaMask to the private blockchain that was used for the development. The accounts
    created by the private blockchain (via the Ganache CLI) can be imported to the
    MetaMask wallet so that it can be used to pay for the transaction GAS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A contract instance can be created from the imported ABI. This contract instance
    can then be used to invoke any of the contract functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will invoke the `registerAsset` function of the contract
    by passing `assetID` as the argument. When the function is executed from the browser,
    MetaMask will bring up a window asking to confirm the transaction. The contract
    function will be executed after the transaction is confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the query function will invoke the `queryAsset` function of the
    smart contract. Since the `queryAsset` does not write to the blockchain, MetaMask
    will not create a new transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: All the other functionalities of the proof of ownership application can be implemented
    in a similar way. Refer to the GitHub repository ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain))
    for the complete frontend implementation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented the proof of ownership application using both the
    NEO and Ethereum blockchain platforms, we have enough information to build other
    applications on these platforms. Since we have also compared the functionalities
    of both the platforms, we can decide on a platform that is best suited to implement
    any use case based on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have dived deep into both creating and using smart contracts,
    as well as using the NEO and Ethereum platform to build a decentralized application.
    After creating the foundations of a NEO and Ethereum blockchain, we created a
    proof of ownership system to prove the ownership of the assets.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has hopefully motivated you to develop decentralized applications
    by introducing you to smart contracts. In the next chapter, we'll explore the
    real-world applications of blockchain technology by exploring projects from different
    domains.
  prefs: []
  type: TYPE_NORMAL
