- en: Diving into Blockchain - Proof of Ownership
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be introduced to the wider applications of blockchain
    by creating a proof of ownership application. Throughout this chapter, we'll discuss
    the concept of smart contracts within blockchain in order to implement this application.
    Since we've already introduced the concepts of blockchain in the earlier chapters
    of this book, this chapter will mainly focus on the high-level details of smart
    contracts, namely proof of ownership and the creation of a decentralized application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to focus on the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating a proof of ownership application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of smart contracts within blockchain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose a smart contract platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the NEO blockchain platform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decentralized application (proof of ownership) in NEO blockchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Ethereum blockchain platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decentralized application (proof of ownership) in Ethereum blockchain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the world of assets, it is necessary to keep track of each and every one
    of them if you want to claim and prove ownership of them. But assets are created
    by different entities in different parts of the world, and there is no single
    protocol for managing assets because each entity has its own system of asset management.
    For example, if Alice has a house and a car in a city, and she wants to sell both
    the house and car to Bob because she is planning to move out of the city, she
    has to go through different procedures to transfer ownership to Bob – she has
    to deal with the land registry for the house, the road transport department for
    the car.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In addition, she also appoints an attorney, because the procedure is quite complex.
    She is only able to finally transfer ownership of the car and the house to Bob
    after dealing with the registration office, the attorney, and the notaries. The
    protocol involved in the registration and management of the different assets meant
    Alice had to deal with different entities to perform a simple task.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The current asset management system requires approval from certain trusted authorities.
    The main reason for the involvement of a trusted authority is the fact that the
    assets exist within a trustless society. Different entities create their own set
    of procedures to deal with assets. Some of the entities may be using outdated
    technology, making it hard to use as the user has to deal with some traditional
    procedures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The proof of ownership solution proposed in this chapter will use blockchain
    to build a decentralized application to mitigate all the issues faced by a centralized
    asset management system. We'll use digital identity, assets, and smart contracts
    to create a completely decentralized asset management system with the help of
    blockchain technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Digital assets and identity
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital assets are programmable assets that exist in digital format. These assets
    can have their own value (digital tokens) or could virtually represent existing
    physical assets (ownership of vehicle). Digital assets have been used since the
    beginning of the digital age, but until now they have always existed in an environment
    where management was centralized. The invention of blockchain has allowed digital
    assets to exist in a decentralized network, where no trusted intermediary is needed
    to register or trade an asset. Removing the intermediaries means users don't have
    to pay any additional charges while trading assets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Digital identity is essential to digital assets when dealing with asset ownership.
    It represents the identity of any individual or organization in a digital format.
    Digital identity is based on the **public key infrastructure** (**PKI**) and provides
    accurate identity management for the user. Unlike traditional identity documents,
    which could easily be forged, digital identity requires the user to authenticate
    via a digital signature to prove their identity. This system often uses a secured
    key infrastructure, which cannot be compromised easily.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We discussed claiming digital assets in the earlier chapters; you'll remember
    we covered the creation of an identity for the user with which the user would
    be able to claim an asset using a secret key. A similar approach will be used
    here to create and manage the digital identity of the user in the platform that
    we will use to build the application in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every asset in the world is owned by some entity. Ownership of a part of an
    asset might not be feasible to prove, either due to the fact that part of the
    ownership record is missing or due to the ambiguity in the existing record's data.
    Although ownership is proved digitally, or by other means, by the entities, in
    most cases, the ownership information is not consistent across all the systems.
    Proving ownership by keeping a digital record is the best solution, and digital
    assets and identities play a huge role in this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Digital assets, along with digital identities, provide a convenient way to claim
    ownership of any goods because assets are registered digitally along with the
    user's identity. Whenever users need to verify and prove ownership of an asset,
    they can provide their identity details along with the asset that they are trying
    to claim. Users might often need to verify their identity by either providing
    some secret information or authenticating using secret information. The identity
    verification process depends on the third party that built the asset management
    system. In our previous example, where Alice wanted to sell her house and car
    to Bob, she would need to provide identity information to the land registry and
    transport departments that could then be verified by comparing it against the
    records on their system. The drawback of this kind of proof of ownership system
    is that there is no proper protocol maintained across different organizations.
    This is why identity management isn't secure across every system, and why organizations
    still use traditional systems, such as hard copies of the user's identity, to
    verify identities without a proper authentication mechanism, which could be easily
    exploited by bad actors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A completely secure proof of ownership system could be created by using a digital
    identity, which uses strong authentication to prove a user's identity. Most existing
    systems that implement this proof of ownership model are centralized, which requires
    the centralized body to be trusted. Although this provenance model solves the
    problem, it needs the user to completely trust the third-party organization to
    prove and verify the ownership. Creating a decentralized proof of ownership system
    using blockchain is the only well-known solution that could solve all the problems
    regarding asset management and proof of ownership. Blockchain is the most suitable
    technology for asset management due to its immutability and traceability, as once
    some information about an asset has been appended to a blockchain, it cannot be
    undone. The traceability makes it easy to verify any transactions, and also allows
    a transaction to be restricted with a specialized blockchain if privacy is a concern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Although proof of ownership could be achieved using a blockchain in a decentralized
    network, some complex agreements between participants of trades may exist in some
    cases. These agreements are formed between the parties by creating contracts.
    A concept known as **smart contracts** is used to perform this in a decentralized
    network. We will be using this to create a decentralized proof of ownership application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: One of the best examples of a decentralized proof of ownership application is
    **Everledger**, which built a proof of ownership model for the supply chain of
    the diamond market ([https://diamonds.everledger.io](https://diamonds.everledger.io)).
    Everledger provides a global digital blockchain ledger to keep track of the ownership
    history of assets. It tries to prevent fraud in the diamond industry, which is
    estimated to be in the billions of dollars annually.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts are created between parties to enforce an agreement and to ensure
    that the participants cannot deny the agreement later. A smart contract is a protocol
    that allows contracts to be verified and enforced in a self-executing manner.
    In simple terms, it executes a contract agreed between parties whenever the conditions
    of the contract are met, without anyone's intervention. The term, smart contract,
    was coined by Nick Szabo, a cryptographer, in 1994\. Although the smart contract
    was conceptualized in the early 1990s to automate the execution of traditional
    contracts, it wasn't implemented in a public network until the adoption of Bitcoin's
    underlying blockchain technology.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: It was the Byzantine fault-tolerant consensus algorithms that made the execution
    of smart contracts possible in a decentralized public network. A number of existing
    blockchain platforms provide support for **Turing complete** programming languages,
    which makes it easier to create the logic required to build a smart contract.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A programming language is said to be Turing complete if it can be used to simulate
    a Turing machine. Bitcoin's scripting language was intentionally made Turing incomplete
    to keep the Bitcoin transaction as simple as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Since smart contracts are created and deployed in the blockchain, they will
    benefit from all the features that blockchain provides. None of the contacts stored
    in the blockchain can be tampered with by anyone once they have been accepted
    and deployed by the parties, due to their immutability. In addition to this, deploying
    a smart contract in a blockchain gives complete transparency as anyone can verify
    the existence of the contract at any time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts also have several other additional benefits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster deployment and execution**: Preparing a contract in the traditional
    way would require the user to spend hours of time preparing paperwork and processing
    it. A smart contract is nothing but a set of instructions that automate these
    tasks, which removes many unnecessary steps.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-efficient deployment and execution**: Creating and executing smart contracts
    on a blockchain is cheaper than with traditional contracts, which need the involvement
    of intermediaries to be processed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure management**: All the contracts created in a blockchain are managed
    securely. This is the inherent nature of the blockchain.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replicated proofs**: Due to the decentralized public ledger in the network,
    each contract resides on every node of the network, providing multiple backups.
    It is impossible to lose a contract on a blockchain network.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accurate execution**: Smart contracts are created with a set of instructions
    that execute consistently on every node in the blockchain network. This ensures
    that smart contracts always operate accurately. Due to the Byzantine fault-tolerant
    nature of blockchain, the network will ignore any faulty executions of the contract.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the smart contract platform
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts are self-executing contracts that can be deployed using any
    blockchain application that supports the execution of basic scripts in its transactions.
    Most blockchain platforms support a domain-specific language. We have already
    come across the language used in Bitcoin transactions, which is called **Script**,
    a stack-based language with limited capabilities. Although Script is a Turing-incomplete
    language, it only has a few options that can be used to create complex transactions.
    It can create multi-signature transactions, payment channels, and atomic cross-chain
    trading. In addition to this, Bitcoin can create a transaction with a lock time.
    A transaction can be created but locked for a certain amount of time in case the
    creator wants to invalidate the transaction before the lock time expires. Although
    Bitcoin's Script language provides enough flexibility to create a complex transaction,
    it isn't suitable for creating complex contracts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Many blockchain platforms have been created since then that provide advanced
    scripting capabilities using their own domain-specific language, such as **Solidity**
    by Ethereum and **Plutus** by Cardano. In addition to this, most platforms have
    their own runtime environment, which is where the compiled smart contract is executed.
    The runtime environment is similar to the one used in general-purpose programming
    languages such as Java. Smart contracts will run on a virtual machine, which is
    similar to a **Java Virtual Machine** (**JVM**). The blockchain virtual machine
    provides a way to execute untrusted code in the public network. These virtual
    machines also provide security against attacks such as **denial-of-service** (**DoS**)
    attacks, which is a necessary feature in systems that execute untrusted code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the blockchain platforms that provide these services are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**EOS**: A smart contract platform and decentralized operating system that
    aims to solve the scalability issues in blockchain by conducting millions of transactions
    per second.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethereum**: This is the most prominent smart contract platform. It implements
    a nearly Turing-complete language on its blockchain. It uses a domain-specific
    language called Solidity, which is compiled and executed on the **Ethereum Virtual
    Machine** (**EVM**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyperledger Fabric**: This is a permissioned blockchain project under the
    Hyperledger projects hosted by The Linux Foundation. It allows execution of smart
    contracts called **chaincode**. It also allows a consensus mechanism to be plugged
    in as a component.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hyperledger Fabric**：这是由Linux Foundation主办的Hyperledger项目下的一个许可区块链项目。它允许执行称为**链码**的智能合约。它还允许共识机制作为组件插入。'
- en: '**NEO**: This is a blockchain platform that allows smart contract to be written
    in several general-purpose programming languages, such as C#, Python, and JavaScript.
    We will cover NEO blockchain in detail in the next section.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEO**：这是一个区块链平台，允许智能合约用几种通用编程语言编写，例如C＃、Python和JavaScript。我们将在下一节详细介绍NEO区块链。'
- en: '**NXT**: This is a public blockchain platform that executes a limited selection
    of templates for smart contracts. It doesn''t have much scope for the creation
    of complex contracts.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NXT**：这是一个公共区块链平台，执行了有限的智能合约模板选择。它并没有太多的空间来创建复杂的合约。'
- en: Selecting a platform to create a smart contract depends on the type of application
    that needs to be built, required performance, smart contract language, and many
    other things. It is important to consider all the requirements before selecting
    the platform. As far as our proof of ownership application is concerned, it needs
    a platform that can handle digital assets and digital identity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建智能合约的平台取决于需要构建的应用类型、所需的性能、智能合约语言以及许多其他因素。在选择平台之前考虑所有的要求是很重要的。就我们的所有权证明应用而言，它需要一个能处理数字资产和数字身份的平台。
- en: NEO blockchain provides a convenient way to handle digital identity and assets.
    In addition to this, the smart contracts can be coded in a general-purpose programming
    language to build the decentralized applications. We will create our smart contract
    in the Python programming language so that we need not master any additional programming
    language. Ethereum is one more platform where a wide range of use cases can be
    implemented conveniently. We will implement our proof of ownership use case in
    both the platforms since they are the most widely used blockchain platforms, and
    the introduction to both of these platforms will provide a solid foundation for
    decentralized application development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NEO区块链提供了处理数字身份和资产的便利方式。除此之外，智能合约可以用通用编程语言编写，以构建去中心化应用程序。我们将用Python编程语言创建我们的智能合约，这样我们就不需要掌握任何额外的编程语言。以太坊是另一个平台，可以便捷地实现各种用例。我们将在这两个平台上实现我们的所有权证明用例，因为它们是最常用的区块链平台，同时对这两个平台的介绍将为去中心化应用程序开发打下坚实的基础。
- en: In the coming sections, we are going to dive into both NEO and Ethereum blockchain
    platforms, along with proof of ownership implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨NEO和以太坊区块链平台，以及所有权证明的实现。
- en: NEO blockchain
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO区块链
- en: NEO is a blockchain platform and cryptocurrency that facilitates the creation
    and management of digital assets and smart contracts. The NEO project was originally
    launched in 2014 under the name of AntShares, until it changed its name in June,
    2017\. All the development resources were provided by founder, Da Hongfei, from
    his business blockchain solution company, called Onchain. The main motive of the
    NEO project is to achieve a **smart economy** with the help of digital assets,
    digital identity, and smart contracts in a distributed network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NEO是一个区块链平台和加密货币，能够促进数字资产和智能合约的创建和管理。NEO项目最初于2014年以AntShares的名义发布，直到2017年6月更名为NEO。所有的开发资源都是由创始人达·宏飞的区块链解决方案公司Onchain提供的。NEO项目的主要目的是在分布式网络中实现**智能经济**，借助数字资产、数字身份和智能合约。
- en: The platform uses two kinds of token, called NEO and GAS. Unlike Bitcoin, a
    NEO token is a non-divisible token, which means that the minimum unit of NEO is
    1\. Holding the NEO tokens gives the right to vote during the consensus mechanism,
    which is explained in the, *Consensus algorithm* section. Holding the NEO token
    generates a new token called GAS, which is used to pay for the transaction fee.
    A GAS token is like a fuel that is essential if you want to deploy and execute
    any smart contract on the blockchain. A total of 100 million NEO tokens are generated
    in the genesis block. But the corresponding 100 million GAS tokens will be generated
    gradually in about 22 years.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台使用两种类型的代币，称为NEO和GAS。与比特币不同，NEO代币是不可分割的，这意味着NEO的最小单位为1. 持有NEO代币可以在共识机制中行使投票权，该机制在*共识算法*部分有解释。持有NEO代币会产生一种名为GAS的新代币，用于支付交易费。GAS代币就像燃料一样，如果你想在区块链上部署和执行任何智能合约，就必不可少。创世区块中发行了1亿个NEO代币。但相应的1亿个GAS代币将在大约22年内逐渐发行。
- en: Building blocks of a NEO blockchain
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO区块链的构建块
- en: A NEO blockchain uses two important elements of a decentralized network to create
    a decentralized application and therefore construct a smart economy. These are
    digital assets and digital identity, which are the building blocks of any blockchain
    application. These concepts, along with smart contracts, are essential to the
    creation of any proof of ownership application, as mentioned earlier in the chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NEO区块链使用了去中心化网络的两个重要元素，以创建去中心化应用程序，因此构建了智能经济。这些元素是数字资产和数字身份，它们是任何区块链应用程序的基石。这些概念，连同智能合约，在之前的章节中已经提到，对于任何所有权证明应用程序的创建是至关重要的。
- en: 'NEO provides a convenient way of creating and managing the digital assets in
    a decentralized NEO blockchain network. NEO provides two different types of asset:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NEO提供了在去中心化NEO区块链网络中创建和管理数字资产的便利方式。NEO提供了两种不同类型的资产：
- en: Global assets
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局资产
- en: Contract assets
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合约资产
- en: Global assets are recorded in the system and can be identified by all the clients
    and smart contracts. NEO and GAS tokens are global assets. Contract assets are
    bound to specific contracts and cannot be identified by other contracts. Only
    certain compatible clients will be able to access the contract assets. NEP-5-based
    assets are an example of contract assets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 全局资产记录在系统中，并且所有客户端和智能合约都能识别。NEO和GAS代币是全局资产。合约资产与特定合约绑定，不能被其他合约识别。只有某些兼容的客户端才能访问合约资产。基于NEP-5的资产就是合约资产的一个例子。
- en: NEP-5 a is standard specified by NEO to create cryptographic tokens. The standard
    helps the developers to maintain a template while building applications related
    to tokens. NEP-5 tokens are similar to the ERC-20 tokens used in Ethereum. We
    will later implement a use case using the NEP-5 token in [Chapter 12](55ed2989-ecca-46ca-8546-74a12da98715.xhtml),
    *Blockchain Use Cases*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NEP-5是NEO指定的用于创建加密代币的标准。该标准帮助开发人员在构建与代币相关的应用程序时保持模板。NEP-5代币类似于以太坊中使用的ERC-20代币。我们将在[第12章](55ed2989-ecca-46ca-8546-74a12da98715.xhtml)中实施使用NEP-5代币的用例，*区块链使用案例*。
- en: NEO provides a way to handle connections between physical and digital assets
    in a blockchain with the help of digital identity. NEO implements the **X.509**
    public key certificate issuance standard to create digital identities. With the
    help of blockchain, NEO can replace the **Online Certificate Status Protocol**
    (**OCSP**) to manage and record the X.509 **Certificate Revocation List** (**CRL**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: NEO利用数字身份在区块链中处理物理资产和数字资产之间的连接。NEO实现了**X.509**公钥证书颁发标准来创建数字身份。借助区块链，NEO可以取代**在线证书状态协议**（**OCSP**）来管理和记录X.509
    **证书吊销列表**（**CRL**）。
- en: NEO technology
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO技术
- en: NEO provides several functionalities to function as a scalable blockchain platform.
    A few of the technologies used in NEO are discussed here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: NEO提供了几种功能来作为可扩展的区块链平台运行。下面讨论了NEO中使用的一些技术。
- en: Consensus algorithm
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法
- en: NEO uses **Delegated Byzantine Fault Tolerance** (**dBFT**), a modified Byzantine
    fault-tolerant consensus algorithm. It is a mechanism that allows all the blockchain
    participants to reach a consensus through proxy voting. A special group of nodes
    called bookkeepers reach a consensus in order to generate new blocks in the network.
    These bookkeepers are elected by NEO token holders through voting. The dBFT algorithm
    has a fault tolerance of *f =* ⌊ *(n-1) / 3* ⌋ of *n* nodes, that is, roughly
    33% of the nodes. It is nearly impossible to revoke the blocks and transactions
    once they are generated and confirmed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'NEO使用**委托拜占庭容错**（**dBFT**），这是一种改进的拜占庭容错共识算法。它是一种允许区块链参与者通过代理投票达成共识的机制。一组特殊的节点，称为记账人，通过投票达成共识以在网络中生成新区块。这些记账人是由NEO代币持有人通过投票选举产生的。dBFT算法具有*f
    =* ⌊ *(n-1) / 3* ⌋ of *n*节点的容错能力，即约33%的节点。一旦生成和确认了区块和交易，几乎不可能撤销它们。 '
- en: It takes around 15 to 20 seconds to generate a block in NEO, and it provides
    a throughput of 1,000 transactions per second, which is very high compared to
    Proof of Work-based implementations. NEO applications can be easily scaled due
    to their high transaction throughput.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在NEO中生成一个区块大约需要15到20秒，而且它的吞吐量为每秒1000笔交易，与基于工作量证明的实现相比，这是非常高的。由于其高的交易吞吐量，NEO的应用可以轻松扩展。
- en: NEO smart contract
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEO智能合约
- en: Smart contracts are one of the features that highlight the NEO blockchain. Writing
    smart contracts in a NEO blockchain system is a fairly simple process compared
    to other smart contract platforms, mainly due to the support it has for a huge
    number of general-purpose languages in which smart contracts could be created.
    Unlike Ethereum, NEO doesn't need a domain-specific language to create and execute
    smart contracts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是NEO区块链突出特点之一。在NEO区块链系统中编写智能合约相对于其他智能合约平台来说是一个相当简单的过程，主要是因为它支持大量通用目的语言，可用于创建智能合约。与以太坊不同，NEO不需要特定领域的语言来创建和执行智能合约。
- en: NEO has a lightweight virtual machine that is similar to the JVM for Java. NEO's
    virtual machine executes smart contract instructions in sequence. NEO virtual
    machines only execute the instructions that are compiled by the NEO compilers.
    NEO plans to support compilers for languages such as C#, Java, C, C++, Go, JavaScript,
    Python, and Ruby; although not all of them have been implemented, development
    is underway to provide support for most languages. In addition to these compilers,
    NEO currently supports IDE plugins for Java and C#. This helps developers to create
    smart contracts without changing their development ecosystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: NEO拥有一个轻量级的虚拟机，类似于Java中的JVM。NEO的虚拟机按顺序执行智能合约指令。NEO虚拟机只执行由NEO编译器编译的指令。NEO计划支持C＃，Java，C，C
    ++，Go，JavaScript，Python和Ruby等语言的编译器；尽管并非所有语言都已实现，但正在进行开发以支持大多数语言。除了这些编译器，NEO目前还支持Java和C＃的IDE插件。这有助于开发人员在不改变开发生态系统的情况下创建智能合约。
- en: Additional NEO projects
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他NEO项目
- en: 'NEO is a growing community with a lot of projects in its roadmap; you''ll find
    a sample of the most popular ones in the following list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NEO是一个不断发展的社区，其路线图中有许多项目；你会在以下列表中找到最受欢迎的一些样本：
- en: '**NeoX**: This feature of NEO will allow asset exchange across different chains.
    It will provide atomic asset exchange protocols to ensure that a transaction is
    either completely processed or completely rejected. Even an incompatible blockchain
    will be able to communicate through NeoX as long as it provides some basic smart
    contract functionality. Since NeoX will help to achieve cross-chain collaboration,
    a single smart contract could perform operations on two chains.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NeoX**：NEO的这一特性将允许不同链之间的资产交换。它将提供原子资产交换协议，以确保交易要么完全处理，要么完全拒绝。即使是不兼容的区块链，只要提供一些基本的智能合约功能，也可以通过NeoX进行通信。由于NeoX将帮助实现跨链协作，一个智能合约可以在两条链上执行操作。'
- en: '**NeoFS**: This is a distributed storage mechanism that will use a **distributed
    hash table** (**DHT**) technology. Each document will be indexed by the digest
    of its content. Large documents are divided into blocks and distributed across
    the blockchain nodes. NeoFS plans to incentivize the nodes with tokens for storing
    documents that need higher reliability. NeoFS nodes can be used to store old block
    data from the NEO blockchain to reduce the load on full nodes.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NeoQS**: NEO plans to solve the challenge posed by quantum computing on cryptographic
    algorithms. NeoQS plans to develop quantum-safe cryptographic mechanisms.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although all these projects are under development, the roadmap of NEO looks
    very promising. Both NeoFS and NeoQS will provide a research update in the third
    quarter of 2018, whereas NeoX is expected to run initial tests during the last
    quarter of 2018.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: NEO nodes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other blockchain platform, NEO also has nodes that hold the complete
    history of blockchain, which are called full nodes. These full nodes form the
    backbone of the network, and they communicate using the P2P protocol.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NEO supports two variants of full nodes, one with a graphical user interface
    and another with just command-line support. The graphical user interface variant,
    called **NEO-GUI**, provides all the functionalities an end user requires. **NEO-CLI**
    is intended for developers who want to use the basic wallet functionality and
    APIs. It is quite straightforward to get started with either variant. We will
    be mostly dealing with NEO-CLI because it is more developer friendly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a full node
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original NEO-CLI implementation is written in C#, and the source code can
    be found at [https://github.com/neo-project/neo-cli](https://github.com/neo-project/neo-cli).
    This implementation requires a user node with .NET Core installed to run the compiled
    binary. The repository explains how to set up .NET Core in different environments.
    A **dynamic link library** (**DLL**) file in the source code needs to be executed
    to run the NEO-CLI. Once .NET Core is installed on your system, the following
    command starts an NEO-CLI full node process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The full node uses three different ports for JSON-RPC (`10332`), P2P via TCP
    (`10333`), and P2P via WebSocket (`10334`). JSON-RPC has an HTTPS version (`10331`),
    in addition to this. NEO uses a different set of ports for test nets and private
    nets. It uses similar ports with the initial "1" replaced with "2" for test nets
    and "3" for private nets. We will be mostly dealing with private net nodes in
    this chapter, as we will be creating our own network to deploy the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON-RPC interface of the node can be exposed by running the following
    command with the `/rpc` flag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'NEO-CLI opens an interactive interface in which the user can perform all blockchain
    node and wallet operations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user has to either create a wallet or open an existing one before executing
    any commands to manage the wallet or node. The following command inside the shell
    creates and opens a wallet in the NEO-CLI shell:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The user needs to provide a password to secure the wallet, and this password
    will be used to unlock the wallet every time. The user can perform any wallet,
    transaction, or block operation after opening the wallet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: You can refer the NEO-CLI documentation at [http://docs.neo.org/en-us/node/cli/cli.html](http://docs.neo.org/en-us/node/cli/cli.html)
    for all the commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: NEO-CLI has support for testing, building, and deploying smart contracts in
    a blockchain, but currently, it doesn't support smart contracts being written
    in a variety of programming languages. NEO-CLI only provides a compiler for .NET
    and Java. We need a third-party compiler to create a smart contract in any other
    programming language. **neo-python** is one such project. It is backed by the
    City of Zion organization, which consists of a rich set of developers contributing
    actively. We will be using the neo-python project to build our application in
    this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a neo-python environment
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The neo-python project provides an NEO node and an SDK that enables developers
    to create, test, deploy, and execute smart contracts on the NEO blockchain using
    Python. This project supports all the functionalities you need to manage assets
    in the wallet and blockchain nodes. This project aims to port the NEO-CLI implementation
    completely.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: To set up neo-python, you need to install the Python 3.6 interpreter. neo-python
    can be installed on any platform, although it requires some platform-specific
    steps to be performed. neo-python needs the `leveldb` and `openssl` libraries
    to be installed before it is installed itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The complete documentation of neo-python, from a quickstart to building complex
    smart contracts, can be found at [https://neo-python.readthedocs.io](https://neo-python.readthedocs.io).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The neo-python package can be installed from **PyPI**, just like any other
    Python package, or from the source repository. Once the installation is complete,
    neo-python''s interactive shell can be launched with the `np-prompt` command.
    Its shell interface, as shown in the following block, is similar to that of NEO-CLI:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: neo-python can also be installed from the source by cloning the repository from
    [https://github.com/CityOfZion/neo-python](https://github.com/CityOfZion/neo-python)
    and installing the neo-python package in development mode. The neo-python shell
    can then be launched with an `np-prompt` command or simply by running the Python
    script `neo/bin/prompt.py`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Any commands can be executed on the shell after opening a wallet, in a similar
    way to NEO-CLI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Although all operations performed on NEO-CLI can be executed in neo-python as
    well, some of the command syntax is different from NEO-CLI commands. Type `help`
    in the neo-python shell to list all the commands.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a JSON-RPC interface for the node
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As specified in an earlier section while setting up a node, an NEO node acts
    as a JSON-RPC server so that it can communicate using the RPC interface. The JSON-RPC
    server can be instantiated in NEO-CLI by adding the `/rpc` flag, as mentioned
    earlier. You need to launch a different process to create an RPC server in neo-python:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just like Bitcoin''s JSON-RPC interface, NEO provides an RPC endpoint for each
    of its APIs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of the frontend application uses JSON-RPC to communicate with the decentralized
    applications and the blockchain itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**neon-js**, maintained by City of Zion, provides JavaScript libraries that
    use the RPC interface exposed by the NEO node to communicate with the blockchain.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: NEO network
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NEO uses a networking protocol to establish connections and communicate with
    each node in a duplex mode. The nodes in the network are categorized into two
    types based on their responsibilities: the validating nodes (bookkeeping nodes)
    and the ordinary peer nodes. Peer nodes help broadcast blocks and unconfirmed
    transactions after they''ve been validated, whereas bookkeeping nodes generate
    new blocks. NEO follows a similar networking protocol as Bitcoin to initiate connection
    and exchange blocks between the peers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'When we launch a NEO shell through NEO-CLI or neo-python, the node will join
    the network that is specified in the default configuration. A neo-python node
    can belong to either the main, test, or private network. The NEO node will join
    a test network if it is launched without specifying the network. The following
    command launches the node in a private network specified in the private network
    protocol configuration file, which can be found in `neo/data/`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will be using a private network to perform all the neo-python operations
    in this chapter. The node could also be initiated by explicitly specifying a network
    configuration file with a `-c` flag.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Test network
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NEO test network is similar to the mainnet. In the test network, users can
    develop, deploy, and execute programs. Instead of spending real GAS and NEO tokens,
    users can use test tokens, which don't have real value. Every other operation
    performed on the testnet is the same as on the mainnet. So, this is the perfect
    environment for developers to test applications before deploying them on the mainnet. Since
    the testnet is an active network with participants from around the world, the
    supply of NEO and GAS tokens is limited, and you will not be provided with any
    tokens when joining the network, just like in the mainnet. As a minimum of 500
    GAS is required to deploy a smart contract, a user can either obtain this from
    other testnet users or apply for it at [https://neo.org/Testnet/Create](https://neo.org/Testnet/Create).
    Smart contracts can be deployed to the network once the user has enough GAS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Private network
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A private network is a collection of NEO nodes that achieve blockchain state
    consensus on their own. These NEO nodes are completely disconnected from the public
    nodes of the mainnet or testnet. A private network is ideal for creating a blockchain
    network inside an organization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A private NEO network needs at least four nodes to achieve consensus. A private
    NEO network can be deployed in a local area network, and also, several nodes can
    be deployed on a single device by creating virtual machines. Even the nodes of
    a private network require GAS to create and deploy smart contracts in a private
    blockchain. A private node can extract all the NEO and GAS tokens from the network
    by creating a multi-party signature address from all the consensus nodes. The
    NEO and GAS can then be transferred from the contact address to a normal address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'A small private network with limited consensus nodes can be created by deploying
    a turnkey Docker image, which is hosted at [https://hub.docker.com/r/cityofzion/neo-privatenet](https://hub.docker.com/r/cityofzion/neo-privatenet).
    This Docker image deploys four NEO validating nodes, and it has pre-claimed all
    100 million NEO and 16,600 GAS tokens. Any user joining the network can use the
    wallet that contains all the tokens to deploy smart contracts. The private network
    can be launched with just a couple of commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Docker image will create a container that has four nodes exposing both P2P
    (20333-20336) ports and RPC ports (30333-30336).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Any neo-python node that is in the same network can then add these four nodes
    as its seed nodes and start syncing the private network blockchain. Users can
    then use the wallet that contains all the network tokens to create transactions
    and deploy smart contracts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: NEO transactions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each node on the NEO network can create transactions and perform operations
    in the NEO blockchain. The node has to open the wallet to create a transaction
    and broadcast it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `wallet` command in neo-python provides you with complete information about
    the opened wallet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The wallet maintains updated details after the validation of each and every
    transaction. The `addresses` field contains details of all the keys held by the
    wallet. The opened wallet has only one key, whose public address is `AK2nJJpJr6o664CWJKi1QRXjqeic2zRp8y`.
    The `balances` field inside the `addresses` field shows the current NEO and GAS
    tokens claimed by the node. In the `balances` field, `0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b`
    represents transaction ID of the NEO tokens, and `0x602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7`
    is for the GAS tokens. NEO uses these as standard IDs for NEO and GAS tokens.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Bitcoin nodes, NEO nodes can create several different types of transaction
    to support all the operations performed in the blockchain. The following table
    depicts different types of transactions that can be created in a NEO network:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `MinerTransaction` | Assign byte fees |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `IssueTransaction` | Issuance of asset |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `ClaimTransaction` | Claim NEO coins |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `EnrollmentTransaction` | Enrolment for validator |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `VotingTransaction` | Vote for validator |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `RegisterTransaction` | Asset register |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `ContractTransaction` | Contract transaction |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `AgencyTransaction` | Order transaction |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: Table. 7.1\. Transaction types in NEO
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Each type of transaction will have exclusive fields to store more information
    about the transaction. For example, `MinerTransaction` has an additional field
    to store `nonce`, which is a random number.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Transferring an asset
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nodes can use transactions to perform operations on NEO assets. The transactions
    are created by the node using its private key, which is situated in the wallet.
    The user can perform any operation on the asset once the wallet is opened. A `send`
    command in neo-python transfers the asset by taking the asset ID, the recipient
    address, and the amount. The `send` command creates a transaction and relays it
    to the network so that it is included in the blockchain:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The created transaction is a `ContractTransaction`, and the details show that
    it houses `vout` and `vin` fields, whose functions are similar to the fields found
    in Bitcoin transactions. The `vin` field points to the transactions whose unspent
    outputs are referenced, and `vout` consists of newly created unspent outputs.
    The first output is the amount transacted by the user, and the second one is the
    change in output. Unlike Bitcoin transactions, the verification script is found
    under a separate script field:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a decentralized application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked into some of the basic functionalities of the NEO platform,
    we are ready to create our first decentralized application using the NEO blockchain.
    Smart contracts are the backbone of creating a decentralized application using
    NEO. We will become familiar with smart contracts by creating a hello world application
    before creating a decentralized proof of ownership application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Basic smart contract
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a simple Python script that returns a concatenated string
    to greet the user:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The contract script uses the `concat` method provided by `boa` to concatenate
    two strings. Every smart contract should have a function called `main`, which
    will be the entry point. The smart contract needs to be compiled into byte code,
    which can be executed in the NeoVM. The contract can be compiled by the neo-python
    shell using the neo-boa compiler as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `build` command is supplied with a `test` argument to test the sample outcome.
    The code immediately after the `test` flag represents the data type for the parameter
    and the return type. The preceding code stipulates that the contract function
    accepts a string parameter and returns a string value. The following table lists
    all the available data types and their codes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data types** | **Code** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| Signature | `0x00` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `0x01` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| Integer | `0x02` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| Hash160 | `0x03` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| Hash256 | `0x04` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| ByteArray | `0x05` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| PublicKey | `0x06` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| String | `0x07` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| Array | `0x10` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| Interop Interface | `0xf0` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| Void | `0xff` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: Table 7.2\. Data types used by contract parameters
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Boolean values following the data types stipulate whether the contract
    requires local storage, and the second Boolean value indicates whether the contract
    has a dynamic invocation to other smart contracts whose addresses are known only
    during execution. Any input to the contract follows these arguments during the
    build process. The test invocation will show the result, along with the GAS required
    to invoke the contract. The result shows that the output is of a `string` type,
    along with the value. Most importantly, the `build` call generates the contract
    instructions in byte code by creating an AVM file that will be stored in the same
    directory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The generated AVM file needs to be imported to the NeoVM and then relayed to
    the blockchain network. The following `import` call performs contract importing.
    The `import` command takes parameters that are similar to the ones specified during
    the build process:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The user needs to enter the details of the smart contract before it is created
    and relayed to the network:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A script hash, along with the contract script, will be generated once the smart
    contract is created. The script hash represents the contract, and it can be used
    by everyone in the network to invoke the smart contract.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The GAS utilized in a transaction depends on the type of smart contract operation,
    and the system calls used in the smart contract. The cost of creating a smart
    contract is 100 GAS plus the additional fees of the system calls. If the smart
    contract needs a storage area, it costs an additional 400 GAS. Our earlier smart
    contract deployment used only 100 GAS to create the smart contract as there was
    no local storage required.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'neo-python provides a `testinvoke` command, which can be used to test contract
    hashes that have already deployed in the blockchain. The `testinvoke` call will
    not be relayed to the network unless it is accepted by the user. It accepts only
    the script hash of the contract and its parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `testinvoke` call can be executed once the node updates its local blockchain
    to include the relayed contract that was created earlier. Here is the output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`testinvoke` invokes the contract from the blockchain and returns the computed
    result in an array of hexadecimal strings. The hexadecimal result `''48656c6c6f20416c696365''`
    translates to "Hello Alice," which is the desired output.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership application
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already looked into the benefits of creating a proof of ownership application
    in a decentralized application earlier on in this chapter; now we're going to
    move on and create a proof of ownership application using NEO smart contracts
    in order to perform asset management in the decentralized network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a Proof of Existence application to prove the existence of a document
    in [Chapter 6](3156a0a8-4aa4-416c-a04f-c08c9f50f087.xhtml), *Diving into Blockchain
    – Proof of Existence*. In this section, we will create an asset management system
    to register and prove the ownership of documents in this section. The goal is
    to create the following asset management functionalities:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Asset registration
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset querying
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset removal
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset transfer
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement all the functionalities in a smart contract to prove the ownership
    of the document.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Creating the smart contract
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts created using Python contain a `main` function as the entry
    point. This function accepts two parameters. The first parameter accepts the type
    of operation, and all the additional arguments are passed to the second parameter
    in a list. The `operation` parameter accepts `register`, `query`, `delete`, and
    `transfer` so that it can perform asset management functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function of the smart contract parses the `operation` parameter
    and invokes the respective function in the smart contract to perform operations
    on the asset. The `main` function parses the `args` parameter and assigns the
    first item of the list to `asset_id`, and the others to `owner`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `register_asset` function takes `asset_id` and the owner address and creates
    an entry of the ownership in the blockchain. `CheckWitness` is a NEO runtime functionality
    check that checks whether the owner''s address matches the address of the user
    that invoked the contract. The contract returns `False` if the asset owner who
    is to be registered is not the same as the user who invoked the contract. The
    contract verifies whether that `asset_id` is already registered by invoking the
    NEO storage library `Get` method. Finally, the asset is registered to the owner
    by storing the asset id and the owner details in a key/value pair using the `Put`
    storage method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: NEO provides storage functionality in the blockchain by storing data in a key/value
    pair. Smart contracts have to specify whether the script needs contract storage
    space during deployment. Using storage costs extra GAS during the deployment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The `query_asset` function queries the local storage to check whether the asset
    is already registered by the user. It returns the owner address if the asset is
    found:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following function needs `asset_id` and the address of the asset recipient
    in order to transfer the asset. As the first step, it verifies the existence of
    the asset by checking the storage using the `Get` method. It then checks whether
    the asset owner is the same as the invoker. The contract also verifies that the
    recipient address is a valid address. Finally, the asset is updated with the new
    owner using the `Put` storage method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `delete_asset` method implements similar functionality as `transfer_asset`,
    with the difference being that it deletes the asset instead of updating it. The
    `Delete` function call is used to delete the stored key/value pair from storage:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_asset` 方法实现与 `transfer_asset` 类似的功能，不同之处在于它删除资产而不是更新它。`Delete` 函数调用用于从存储中删除存储的键值对:'
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have implemented all the basic functionalities of asset management,
    we will execute the contract using the neo-python shell in the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经实现了资产管理的所有基本功能，我们将在下一部分中使用neo-python shell执行合约。
- en: Executing the smart contract
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行智能合约
- en: The smart contract is executed with similar steps as shown in the earlier section
    where we deployed the basic smart contract. The only differences are the parameters
    supplied to the contract and the corresponding return data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的执行步骤与我们部署基本智能合约的之前部分类似。唯一的区别是提供给合约的参数和相应的返回数据不同。
- en: 'As mentioned earlier, we will create a proof of ownership application to keep
    track of the documents. Each document can be uniquely identified by its digest.
    We will use the SHA256 hash value of the document as the asset ID. Let''s consider
    a file that has the following content. The files are usually stored with an additional
    new line character that is not visible in raw text output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '正如前面提到的，我们将创建一个所有权证明应用来跟踪文件。每个文件可以通过其摘要唯一标识。我们将使用文件的SHA256哈希值作为资产ID。让我们考虑一个具有以下内容的文件。这些文件通常存储有一个额外的看不见的换行符:'
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the following digest represents the SHA256 hash value of the file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '以下摘要表示文件的SHA256哈希值:'
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s use the hash value as the asset ID to uniquely identify each document.
    The contract is built in the neo-python shell using the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们使用哈希值作为资产ID来唯一标识每个文件。合同在neo-python shell中使用以下命令构建:'
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `build` procedure has `0710` as a parameter type, which denotes that it
    takes one string (`07`) and one array (`10`) as parameters. And `05` indicates
    that it has a return type of `byte array`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 过程以 `0710` 作为参数类型，表示它以一个字符串 (`07`) 和一个数组 (`10`) 作为参数。`05` 表示它具有`字节数组`返回类型。'
- en: 'The contract can then be deployed using the created AVM file after a successful
    build:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '成功构建后，可以使用创建的AVM文件部署合约:'
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The transaction needs an additional 400 GAS as the smart contract needs the
    local storage. The total GAS consumed would be `500`, as shown in the preceding
    code block.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约需要本地存储，交易需要额外的 400 GAS。总共消耗的 GAS 将为 `500`，如前面的代码块所示。
- en: The contract can be executed once the contract transaction is included in the
    blockchain and is synchronized in the local blockchain. Let's use the `testinvoke` command
    to test our created smart contract.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合约交易包含在区块链中并在本地区块链中同步，合约就可以执行。让我们使用 `testinvoke` 命令来测试我们创建的智能合约。
- en: 'Let''s register a document using the same SHA256 value mentioned previously
    as the asset ID. The `register` operation is invoked with a list of arguments
    consisting of the hash value and the address of the user invoking the smart contract:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们使用先前提到的相同的SHA256值作为资产ID注册文件。注册操作调用一个参数列表，包括哈希值和调用智能合约的地址:'
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the transaction is invoked and relayed to the network, other operations
    can be performed on the asset. Let''s now transfer the document''s ownership to
    a new owner by invoking the `transfer` operation and specifying the recipient
    address in the list:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易被调用并传递到网络上，其他操作就可以在资产上执行。现在让我们通过调用 `transfer` 操作并在列表中指定接收者地址来将文件所有权转让给新所有者：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The document ownership can be verified at any time by invoking the query operation
    and passing the asset ID:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以随时通过调用查询操作并传递资产ID来验证文件所有权：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The query returns a byte array that has a hexadecimal string. The hexadecimal
    result represents the address `AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`. Since the
    document's ownership was transferred to the new owner, the result shows the updated
    owner of the document.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回一个具有十六进制字符串的字节数组。十六进制结果表示地址 `AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`。由于文件的所有权已转移给新所有者，结果显示文件的更新所有者。
- en: We have now finished creating a smart contract to demonstrate a proof of ownership
    system that keeps track of the ownership of documents. Once the smart contract
    is deployed in a blockchain, it will stay there forever. The user has to only
    deal with the smart contract invocation. The RPC interface of the NEO node provides
    a convenient way to communicate with the blockchain. We will now look into how
    to conveniently communicate with the blockchain by creating an interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Interface for the application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NEO community has a created few JavaScript libraries to interface with the
    NEO blockchain. We will be using a popular library called neon-js ([https://github.com/CityOfZion/neon-js](https://github.com/CityOfZion/neon-js)),
    which is backed by the City of Zion community.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script creates an interface to query the owner of the asset for
    our proof of ownership application:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The interface created using the neon-js library builds a script for the smart
    contract using the `Neon.create.script` method. It then uses the RPC interface
    to invoke the smart contract script. After that, `queryAsset` returns the address
    of the user who owns the document asset.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface to the blockchain smart contract is a crucial part of
    building a fully fledged decentralized application. The interface also creates
    a convenient way to communicate with the blockchain nodes, which enhances the
    user experience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is a public blockchain that was proposed by Vitalik Buterin in late
    2013 and was released to the public in 2015\. Ethereum was one of the initial
    blockchain platforms that were created to help programmers to develop and deploy
    decentralized applications using smart contracts. Ethereum has a rich set of frameworks
    and libraries to develop, test, and deploy applications. We will cover the development
    and deployment of proof of ownership applications using the Ethereum platform
    in this section. Refer to [Chapter 8](02eed23a-0a39-4a19-8d88-a72a810ddb0d.xhtml),
    *Blockchain Projects*, for more details regarding the Ethereum ecosystem.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum nodes
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to Bitcoin and NEO, there are several implementations of client software
    in different languages that can be used as an Ethereum full node. The Ethereum
    client implementation can be found in Java, JavaScript, Python, Go, and many other
    languages. The Golang implementation of Ethereum called **Go Ethereum** or **Geth**
    is the most popular among all.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up the node is the important step to take before diving into the application
    development. Although any of the Ethereum clients can be used to set up a full
    node, we will set up the Geth client to sync and interact with the public blockchain.
    Similar to the NEO blockchain, Geth client can connect to mainnet, testnet, or
    a private network.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a node
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will set up a Geth client that can be used to sync the entire blockchain
    transactions. It also provides the JSON-RPC interface to invoke any of the methods
    supported by the client software. The JSON-RPC interface can be used to perform
    several operations including deploying and invoking smart contracts.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The Geth client can be either built or installed using packages found in most
    platforms. Installation instructions for different platforms can be found at [https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth provides a command-line interface that can be used to initiate the node.
    Once Geth is installed with all the dependencies, it can be launched to synchronize
    the local blockchain data with the public blockchain. The Geth client can be configured
    by supplying several parameters for the chain, transaction pool, performance tuning,
    account, networking, miner, and much more. The following command instantiates
    an Ethereum node with a few parameters: `rpc` (enable RPC server), `rpcapi` (list
    of APIs to be accessed through RPC interface), `cache` (memory assigned for internal
    caching), `rpcport` (RPC server port), and `rpcaddr` (RPC server address):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The instantiated Ethereum node will try to sync the blockchain by connecting
    to mainnet peers. Alternatively, the Geth can be configured to connect to any
    of the Ethereum testnets (**Rinkeby**, **Kovan**, or **Ropsten**). The following
    command instantiates a node with the Rinkeby testnet blockchain:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A set of Geth clients could also form their own private Ethereum network instead
    of connecting to the existing mainnet or testnet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The instructions for setting up a private network using Geth client can be found
    here: [https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster](https://github.com/ethereum/go-ethereum/wiki/Setting-up-private-network-or-local-cluster).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a private blockchain with the help of a tool
    provided in the **Truffle** suite framework called **Ganache CLI**, which is a
    JavaScript package that can be installed using the node package manager. Make
    sure that `node` and `npm` are installed in the system before executing the following
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The private blockchain can be instantiated by launching Ganache CLI. Ganache
    CLI can be configured by specifying several parameters or launched without parameters,
    as shown in the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A successful launch will create a private blockchain along with a few accounts
    loaded with ethers that can be used to pay for the transaction fee for any of
    the transactions created. The Ganache CLI will also create a client application
    that will listen on the port 8545 by default. We will use the private blockchain
    and the application running on the port 8545 to deploy and query the smart contracts
    in the coming sections.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have instantiated a local node with a private blockchain, we will
    set up the development environment to ease the creation and deployment of the
    decentralized application. Since we have to create a fully fledged decentralized
    application, we need to communicate with the Ethereum blockchain using scripting
    languages such as JavaScript. Ethereum provides a JavaScript library called **web3.js**
    that houses APIs to interact with the Ethereum blockchain.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The web3.js makes use of RPC calls to communicate with the Ethereum node that
    exposes the RPC interface (application port 8545). So, the web3.js can invoke
    any of the methods provided by the Ethereum node. The following code snippet can
    be executed on a node terminal:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code will create a `web3` instance and then add the local node as the provider.
    When the web3.js application executed in a web browser, the `web3` object can
    be injected through bridges such as MetaMask. These `web3` instances will already
    have the provider specified in `web3.currentProvider`. We will use MetaMask while
    building the proof of ownership application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `web3.js` provides all the methods required to interact with the blockchain,
    it doesn''t set up a complete development environment. This can be achieved with
    an Ethereum development framework called Truffle. Truffle provides a complete
    development environment along with convenient testing, deployment, and migration
    of the smart contracts. The Truffle framework can be installed using the node
    package manager:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A Truffle project can be initiated in an empty directory to build the initial
    files required for application development:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will create three directories - `contracts` (smart contracts), `migrations`
    (deployment scripts), and `test` (test scripts) and a configuration file, `truffle.js`.
    We need to add the following configuration to the `truffle.js` file to point the
    created Truffle project to our private blockchain:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An interactive Truffle console can be launched from the Truffle project directory:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `web3` object will be already instantiated in the Truffle console, and any
    of the web3 APIs can be accessed using this object. We will use the Truffle console
    to query the deployed contract in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Creating a decentralized application
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now create our first decentralized application on Ethereum platform since
    we have setup our development environment. We will get familiar with Ethereum
    smart contracts by creating and deploying a hello world application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Basic smart contract
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum makes use of a domain-specific language called as Solidity to code
    the logic of the smart contract. Solidity is a high-level programming language
    that can be compiled to produce bytecode, which is then executed on the EVM.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a statically typed programming language initially proposed by Gavin
    Wood. It was designed to be similar to ECMAScript syntax so that it can be easily
    adapted by the web developer community. More details about the Solidity programming
    language can be found at [https://solidity.readthedocs.io](https://solidity.readthedocs.io).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a simple hello world smart contract using the Solidity programming
    language:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line of the Solidity script is the version `pragma` to indicate the
    version of the solidity program. The preceding script should not be compiled on
    a Solidity compiler whose version is earlier than 0.4.23\. Each contract is defined
    to a similar class with the contract name as the file name. All the functions
    are defined inside the contract. A constructor function can also be created with
    the same name as that of the contract. The function `greetUser` accepts a string
    of type `bytes` and returns a `bytes` string. The function also has public visibility,
    meaning it can be invoked from anywhere. The `greetUser` function will concatenate
    and return two strings.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Truffle framework to deploy and invoke the smart contract.
    We need to point the smart contract file to the Truffle framework by including
    the following code snippet in a new JavaScript file (`2_deploy_contracts.js`)
    inside the `migrations` folder, or by updating the existing `1_initial_migration.js`
    file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The smart contract can be compiled using the following Truffle command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It will generate an interface file called **application binary interface** (**ABI**)
    in the `build/contracts` folder. The generated ABI file will be in JSON format,
    and it provides the interface to interact with the contract in the Ethereum ecosystem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract is then deployed to the blockchain by migrating it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The deployed contract will generate a contract address that can be used to
    interact with it. We will use the Truffle console to interact with the contract:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the preceding code snippet is executed on the Truffle console to invoke
    the `greetUser` function of the contract with `Alice` as the parameter, the contract
    will return `0x48656c6c6f20416c696365`, which is a hexadecimal string for "Hello
    Alice."
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Proof of ownership application
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create an application with asset management functionalities to register,
    query, remove, and transfer the asset.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Creating the smart contract
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application logic is similar to that of one used in the NEO smart contract.
    But the data structure used to store the asset information is different due to
    the functionalities provided by the virtual machine. One major difference between
    NEO and Ethereum contract is that the functions in Ethereum contracts can be directly
    invoked with the help of ABI.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProofOfOwnership` smart contract uses a mapping data structure to store
    the asset ownership information in a key/value pair. The asset information of
    type `bytes32` is mapped to the Ethereum address of the asset owner:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `registerAsset` function maps the address of the user who invoked the contract
    to the asset ID using the mapping data structure:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The owner of the asset can be retrieved from the stored information in the
    mapping data structure with the help of asset ID:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `transferAsset` function transfers the ownership to the new address after
    verifying that the current owner of the asset is same as the one who invoked the
    contract:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `deleteAsset` function will assign an empty address to the asset when the
    owner of the asset invokes the contract:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Similar to the previous smart contract deployment, the following configuration
    should be created in a new JavaScript file (`2_deploy_contracts.js`) inside the `migrations`
    folder, or the existing `1_initial_migration.js` file should be updated:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The smart contract can then be compiled and migrated using the Truffle framework,
    as in the previous example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Executing the smart contract
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the same example of keeping track of document ownership that
    we used earlier in NEO application. We will also use the same file with the following
    content as the asset:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will use an md5 (32 characters) hashing algorithm to calculate the asset
    ID of the file instead of SHA256 (64 characters). This is because the key (`bytes32`)
    in the mapping data structure of our contract can accept only 32 characters. The
    following is the 32-character or 128-bit hash value of the file generated by the
    md5 algorithm:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once the proof of ownership smart contract is deployed to the blockchain, it
    can be invoked from the Truffle console. Let''s register the asset using the `registerAsset`
    function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the invoking node has multiple accounts, a `from` address can be included
    in the function call to identify the user invoking the contract. Since the `registerAsset`
    function performs write operations, it needs GAS during the execution. The total
    GAS consumed will be shown once the transaction is created.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transferAsset` takes the asset ID along with the new owner address as
    arguments:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can query the asset at any time to check the owner of the document:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the query returns `0xfda013eecad647a2593aacbb3c18445f051d0f52` as the current
    owner, we have successfully executed the `transferAsset` function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Interface for the application
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fully fledged decentralized application can be created by integrating the
    frontend application with the Ethereum blockchain. We can make use of the APIs
    provided by the `web3.js` library to interact with the blockchain network. We
    have already used the Truffle development environment to deploy and invoke the
    smart contracts. In this section, we will make use of the Truffle libraries to
    communicate with the contracts.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The following code can be executed in any JavaScript runtime environment, such
    as Node.js. Refer to the GitHub repository of the book to find the implementation
    using the React library.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProofOfOwnership.json` is the ABI file that was created during the compilation
    of the contract. This ABI is essential for communicating with the smart contract:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the code is executed in a browser where a bridging application such as MetaMask
    is installed, a web3 object will be injected into the browser along with the provider.
    The web3 object can also be created by setting the provider as local or any other
    remote RPC server node.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The MetaMask browser add-on can be installed from [https://metamask.io](https://metamask.io).
    Once the add-on is installed, an account has to be created. The user has to point
    MetaMask to the private blockchain that was used for the development. The accounts
    created by the private blockchain (via the Ganache CLI) can be imported to the
    MetaMask wallet so that it can be used to pay for the transaction GAS.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A contract instance can be created from the imported ABI. This contract instance
    can then be used to invoke any of the contract functions:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following function will invoke the `registerAsset` function of the contract
    by passing `assetID` as the argument. When the function is executed from the browser,
    MetaMask will bring up a window asking to confirm the transaction. The contract
    function will be executed after the transaction is confirmed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Similarly, the query function will invoke the `queryAsset` function of the
    smart contract. Since the `queryAsset` does not write to the blockchain, MetaMask
    will not create a new transaction:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: All the other functionalities of the proof of ownership application can be implemented
    in a similar way. Refer to the GitHub repository ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain))
    for the complete frontend implementation of the application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented the proof of ownership application using both the
    NEO and Ethereum blockchain platforms, we have enough information to build other
    applications on these platforms. Since we have also compared the functionalities
    of both the platforms, we can decide on a platform that is best suited to implement
    any use case based on the requirements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have dived deep into both creating and using smart contracts,
    as well as using the NEO and Ethereum platform to build a decentralized application.
    After creating the foundations of a NEO and Ethereum blockchain, we created a
    proof of ownership system to prove the ownership of the assets.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has hopefully motivated you to develop decentralized applications
    by introducing you to smart contracts. In the next chapter, we'll explore the
    real-world applications of blockchain technology by exploring projects from different
    domains.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
