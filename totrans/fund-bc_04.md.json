["```\nclass Server(object): \n\n    def __init__(self): \n\n        self.app = Sanic() \n        self.blockchain = Blockchain() \n        self.sockets = [] \n        self.app.add_route(self.blocks, '/blocks', methods=['GET']) \n        self.app.add_route(self.mine_block, '/mineBlock', methods=['POST']) \n        self.app.add_route(self.peers, '/peers', methods=['GET']) \n        self.app.add_route(self.add_peer, '/addPeer', methods=['POST']) \n        self.app.add_websocket_route(self.p2p_handler, '/') \n```", "```\n    async def mine_block(self, request): \n        try: \n            newBlock = self.blockchain.generate_next_block(request.json[\"data\"]) \n        except KeyError as e: \n            return json({\"status\": False, \"message\": \"pass value in data key\"}) \n        self.blockchain.add_block(newBlock) \n        await self.broadcast(self.response_latest_msg()) \n        return json(newBlock) \n```", "```\n     async def blocks(self, request): \n         return json(self.blockchain.blocks) \n```", "```\n    async def add_peer(self, request): \n\n        asyncio.ensure_future(self.connect_to_peers\n([request.json[\"peer\"]]),        \n        loop=asyncio.get_event_loop()) \n        return json({\"status\": True}) \n```", "```\n    async def peers(self, request): \n        peers = map(lambda x: \"{}:{}\".format(x.remote_address[0], x.remote_address[1]), self.sockets) \n        return json(peers)] \n\n    async def connect_to_peers(self, newPeers): \n        for peer in newPeers: \n            logger.info(peer) \n            try: \n                ws = await websockets.connect(peer) \n\n                await self.init_connection(ws) \n            except Exception as e: \n                logger.info(str(e)) \n```", "```\n    async def p2p_handler(self, request, ws): \n        logger.info('listening websocket p2p port on: %d' % port) \n        try: \n            await self.init_connection(ws) \n        except (ConnectionClosed): \n            await self.connection_closed(ws) \n```", "```\n    async def connection_closed(self, ws): \n\n        logger.critical(\"connection failed to peer\") \n        self.sockets.remove(ws) \n```", "```\n    async def init_connection(self, ws): \n\n        self.sockets.append(ws) \n        await ws.send(JSON.dumps(self.query_chain_length_msg())) \n\n        while True: \n            await self.init_message_handler(ws) \n```", "```\n    async def init_message_handler(self, ws): \n        data = await ws.recv() \n        message = JSON.loads(data) \n        logger.info('Received message: {}'.format(data)) \n\n        await { \n            QUERY_LATEST: self.send_latest_msg, \n            QUERY_ALL: self.send_chain_msg, \n            RESPONSE_BLOCKCHAIN: self.handle_blockchain_response \n        }[message[\"type\"]](ws, message) \n```", "```\n    async def send_latest_msg(self, ws, *args): \n        await ws.send(JSON.dumps(self.response_latest_msg())) \n\n    async def send_chain_msg(self, ws, *args): \n\n        await ws.send(JSON.dumps(self.response_chain_msg())) \n```", "```\n    def response_chain_msg(self): \n        return { \n            'type': RESPONSE_BLOCKCHAIN, \n            'data': JSON.dumps([block.dict() for block in self.blockchain.blocks])} \n```", "```\n    def response_latest_msg(self): \n\n        return { \n            'type': RESPONSE_BLOCKCHAIN, \n            'data': JSON.dumps([self.blockchain.get_latest_block().dict()]) \n        } \n```", "```\n    def query_chain_length_msg(self): \n\n        return {'type': QUERY_LATEST} \n\n    def query_all_msg(self): \n\n        return {'type': QUERY_ALL} \n```", "```\n    async def handle_blockchain_response(self, ws, message): \n        received_blocks = sorted(JSON.loads(message[\"data\"]), key=lambda k: k['index']) \n        latest_block_received = received_blocks[-1] \n        latest_block_held = self.blockchain.get_latest_block() \n\n        if latest_block_received[\"index\"] > latest_block_held.index: \n            logger.info('blockchain possibly behind. We got: ' + str(latest_block_held.index) \n                  + ' Peer got: ' + str(latest_block_received[\"index\"])) \n```", "```\n            if latest_block_held.hash == latest_block_received[\"previous_hash\"]: \n                logger.info(\"We can append the received block to our chain\") \n\n                self.blockchain.blocks.append\n(Block(**latest_block_received)) \n                await self.broadcast(self.response_latest_msg()) \n```", "```\n            elif len(received_blocks) == 1: \n                logger.info(\"We have to query the chain from our peer\") \n                await self.broadcast(self.query_all_msg()) \n            else: \n                logger.info(\"Received blockchain is longer than current blockchain\") \n                await self.replace_chain(received_blocks) \n```", "```\n    async def replace_chain(self, newBlocks): \n\n        try: \n            if self.blockchain.is_valid_chain(newBlocks) and len(newBlocks) > len(self.blockchain.blocks): \n                logger.info('Received blockchain is valid. Replacing current blockchain with ' 'received blockchain') \n                self.blockchain.blocks = [Block(**block) for block in newBlocks] \n                await self.broadcast(self.response_latest_msg()) \n            else: \n                logger.info('Received blockchain invalid') \n        except Exception as e: \n            logger.info(\"Error in replace chain\" + str(e)) \n```", "```\n    async def broadcast(self, message): \n\n        for socket in self.sockets: \n            await socket.send(JSON.dumps(message)) \n```", "```\n    def is_valid_new_block(self, new_block, previous_block): \n```", "```\n        if previous_block.index + 1 != new_block.index: \n            logger.warning('invalid index') \n            return False \n```", "```\n        if previous_block.hash != new_block.previous_hash: \n            logger.warning('invalid previous hash') \n            return False \n```", "```\n        if self.calculate_hash_for_block(new_block) != new_block.hash: \n            logger.info(type(new_block.hash) + ' ' + type(self.calculate_hash_for_block(new_block))) \n            logger.warning('invalid hash: ' + self.calculate_hash_for_block(new_block) + ' ' + new_block.hash) \n            return False \n        return True \n```", "```\n    def is_valid_chain(self, blockchain_to_validate): \n        if self.calculate_hash_for_block(Block(**blockchain_to_validate[0])) != self.get_genesis_block().hash: \n            return False \n```", "```\n        temp_blocks = [Block(**blockchain_to_validate[0])] \n        for currentBlock in blockchain_to_validate[1:]: \n            if self.is_valid_new_block(Block(**currentBlock), temp_blocks[-1]): \n                temp_blocks.append(Block(**currentBlock)) \n            else: \n                return False \n        return True \n```", "```\nif __name__ == '__main__': \n\n    server = Server() \n    server.app.add_task(server.connect_to_peers(initialPeers)) \n    server.app.run(host='0.0.0.0', port=port, debug=True) \n```", "```\n[ \n  { \n    \"data\": \"my genesis block!!\", \n    \"hash\": \n \"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\", \n    \"index\": 0, \n    \"previous_hash\": \"0\", \n    \"timestamp\": 1465154705 \n  } \n] \n```", "```\n[ \n  { \n    \"data\": \"my genesis block!!\", \n    \"hash\": \n \"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\", \n    \"index\": 0, \n    \"previous_hash\": \"0\", \n    \"timestamp\": 1465154705 \n  }, \n  { \n    \"data\": \"created at node2\", \n    \"hash\": \n \"29630fab36aa1e3abf85b62aee8f84b08438b90e9e19f39d18766cc9208b585c\", \n    \"index\": 1, \n    \"previous_hash\": \n \"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\", \n    \"timestamp\": \"1522069707\" \n  } \n] \n```"]