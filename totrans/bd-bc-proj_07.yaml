- en: Building a Betting App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary for smart contracts to access data from other dapps
    or from the World Wide Web. But it's really complicated to let smart contracts
    access outside data due to technical and consensus challenges. Therefore, currently,
    Ethereum smart contracts don't have native support to access outside data. But
    there are third-party solutions for Ethereum smart contracts to access data from
    some popular dapps and from the World Wide Web. In this chapter, we will learn
    how to use Oraclize to make HTTP requests from Ethereum smart contracts to access
    data from the World Wide Web. We will also learn how to access files stored in
    IPFS, use the strings library to work with strings, and so on. We will learn all
    this by building a football-betting smart contract and a client for it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How does Oraclize work?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Oraclize's various data sources and how do each of them work?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does consensus work in Oraclize?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Oraclize in Ethereum smart contracts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using strings the `Solidity` library to make it easy to work with strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a football betting app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Oraclize
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oraclize is a service that aims to enable smart contracts to access data from
    other blockchains and the World Wide Web. This service is currently live on bitcoin
    and Ethereum's testnet and mainnet. What makes Oraclize so special is that you
    don't need to trust it because it provides proof of authenticity of all data it
    provides to smart contracts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our aim is to learn how Ethereum smart contracts can use the
    Oraclize service to fetch data from the World Wide Web.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the process by which an Ethereum smart contract can fetch data
    from other blockchains and the World Wide Web using Oraclize.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data that exists outside of the Ethereum blockchain, an Ethereum smart
    contract needs to send a query to Oraclize, mentioning the data source (representing
    where to fetch the data from) and the input for the data source (representing
    what to fetch).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Sending a query to Oraclize Oraclize means sending a contract call (that is,
    an internal transaction) to the Oraclize contract present in the Ethereum blockchain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Oraclize server keeps looking for new incoming queries to its smart contract.
    Whenever it sees a new query, it fetches the result and sends it back to your
    contract by calling the `_callback` method of your contract.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Data sources
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of sources from which Oraclize lets smart contracts fetch data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: The URL data source provides you with the ability to make an HTTP GET
    or POST request, that is, fetch data from the WWW.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WolframAlpha`: The `WolframAlpha` data source provides you with the ability
    to submit a query to the `WolframAlpha` knowledge engine and get the answer.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blockchain`: The `blockchain` data source provides you with ability to access
    data from other `blockchains`. Possible queries that can be submitted to the `blockchain`
    data source are `bitcoin blockchain height`, `litecoin hashrate`, `bitcoin difficulty`,
    `1NPFRDJuEdyqEn2nmLNaWMfojNksFjbL4S balance`, and so on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPFS`: The `IPFS` data source provides you with the ability to fetch the content
    of a file stored in `IPFS`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nested`: The `nested` data source is a metadata source; it does not provide
    access to additional services. It was designed to provide a simple aggregation
    logic, enabling a single query to leverage sub-queries based on any available
    data source and producing a single string as a result; for example:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[WolframAlpha] temperature in ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`Computation`: The `computation` data source enables the auditable execution
    of a given application into a secure off-chain context; that is, it lets us fetch
    the result of an off-chain execution of an application. This application has to
    print the query result on the last line (on the standard output) before its quits.
    The execution context has to be described by a Dockerfile, where building and
    running it should start your main application straight away. The Dockerfile initialization
    plus your application execution should terminate as soon as possible: the maximum
    execution timeout is 5 minutes on an `AWS t2.micro` instance. Here, we are considering
    an `AWS t2.micro` instance because that''s what Oraclize will use to execute the
    application. As the input for the data source is the IPFS multihash of a ZIP archive
    containing such files (Dockerfile plus any external file dependencies, and the
    Dockerfile has to be placed in the archive root), you should take care of preparing
    this archive and pushing it to IPFS beforehand.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These data sources are available at the time of writing this book. But many
    more data sources are likely to be available in the future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Proof of authenticity
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Oraclize is a trusted service, you may still want to check whether
    the data returned by Oraclize is authentic or not, that is, whether it was manipulated
    by Oraclize or someone else in transit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, Oraclize provides the TLSNotary proof of result that's returned
    from the URL, blockchain, and nested and computation data sources. This proof
    is not available for `WolframAlpha` and `IPFS` data sources. Currently, Oraclize
    only supports the TLSNotary proof, but in the future, they may support some other
    ways to authenticate. Currently, the TLSNotary proof needs to be validated manually,
    but Oraclize is already working on on-chain proof verification; that is, your
    smart contract code can verify the TLSNotary proof on its own while receiving
    the data from Oraclize so that this data is discarded if the proof turns out to
    be invalid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: This tool ([https://github.com/Oraclize/proof-verification-tool](https://github.com/oraclize/proof-verification-tool))
    is an open source tool provided by Oraclize to validate the TLSNotary proof in
    case you want to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how TLSNotary works is not required to use Oraclize or to verify
    the proof. The tool to validate the TLSNotary proof is open source; therefore,
    if it contains any malicious code, then it can easily be caught, so this tool
    can be trusted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a high-level overview of how TLSNotary works. To understand how
    TLSNotary works, you need to first understand how TLS works. The TLS protocol
    provides a way for the client and server to create an encrypted session so that
    no one else can read or manipulate what is transferred between the client and
    server. The server first sends its certificate (issued to the domain owner by
    a trusted CA) to the client. The certificate will contain the public key of the
    server. The client uses the CA's public key to decrypt the certificate so that
    it can verify that the certificate is actually issued by the CA and get the server's
    public key. Then, the client generates a symmetric encryption key and a MAC key
    and encrypts them using the server's public key and sends it to the server. The
    server can only decrypt this message as it has the private key to decrypt it.
    Now the client and server share the same symmetric and MAC keys and no one else
    knows about these keys and they can start sending and receiving data from each
    other. The symmetric key is used to encrypt and decrypt the data where the MAC
    key and the symmetric key together are used to generate a signature for the encrypted
    message so that in case the message is modified by an attacker, the other party
    can know about it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: TLSNotary is a modification of TLS, which is used by Oraclize to provide cryptography
    proof showing that the data they provided to your smart contract was really the
    one the data source gave to Oraclize at a specific time. Actually the TLSNotary
    protocol is an open source technology, developed and used by the PageSigner project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: TLSNotary works by splitting the symmetric key and the MAC key among three parties,
    that is, the server, an auditee, and an auditor. The basic idea of TLSNotary is
    that the auditee can prove to the auditor that a particular result was returned
    by the server at a given time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: So here is an overview of how exactly TLSNotary lets us achieve this. The auditor
    calculates the symmetric key and MAC key and gives only the symmetric key to the
    auditee. The MAC key is not needed by the auditee as the MAC signature check ensures
    that the TLS data from the server was not modified in transit. With the symmetric
    encryption key, the auditee can now decrypt data from the server. Because all
    messages are "signed" by the bank using the MAC key and only the server and the
    auditor know the MAC key, a correct MAC signature can serve as proof that certain
    messages came from the bank and were not spoofed by the auditee.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是TLSNotary如何实现这一点的概述。审计员计算对称密钥和MAC密钥，然后仅将对称密钥提供给受审者。由于MAC签名检查确保了服务器传输的TLS数据未被修改，因此受审者不需要MAC密钥。有了对称加密密钥，受审者现在可以解密服务器的数据。因为所有消息都是由银行使用MAC密钥“签名”的，而且只有服务器和审计员知道MAC密钥，正确的MAC签名可以作为证明某些消息来自银行且未被受审者伪造的证据。
- en: In the case of the Oraclize service, Oraclize is the auditee, while a locked-down
    AWS instance of a specially designed, open source Amazon machine image acts as
    the auditor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oraclize服务的情况下，Oraclize是受审者，而一个特制的、开源的Amazon机器映像的受限AWS实例充当审计员。
- en: The proof data they provide are the signed attestations of this AWS instance
    that a proper TLSnotary proof did occur. They also provide some additional proof
    regarding the software running in the AWS instance, that is, whether it has been
    modified since being initialized.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供的证据数据是此AWS实例的签名证明，证明了一个正确的TLSnotary证明确实发生了。他们还提供了一些关于在AWS实例中运行的软件的额外证据，即它是否自初始化以来已被修改。
- en: Pricing
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价
- en: The first Oraclize query call coming from any Ethereum address is completely
    free of charge. Oraclize calls are free when used on testnets! This works for
    moderate usage in test environments only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以太坊地址发起的第一个Oraclize查询调用完全免费。在测试网络上使用Oraclize调用是免费的！这仅适用于测试环境中的适度使用。
- en: From the second call onward, you have to pay in ether for queries. While sending
    a query to Oraclize (that is, while making an internal transaction call), a fee
    is deducted by transferring ether from the calling contract to the Oraclize contract.
    The amount of ether to deduct depends on the data source and proof type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二次调用开始，你必须支付以太币来进行查询。当向Oraclize发送查询（即进行内部交易调用）时，通过将以太币从调用合约转移到Oraclize合约来扣除费用。要扣除的以太币数量取决于数据源和证明类型。
- en: 'Here is a table that shows the number of ether that is deducted while sending
    a query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了发送查询时扣除的以太币数量：
- en: '| **Data source** | **Without proof** | **With TLSNotary proof** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **数据源** | **无证明** | **使用TLSNotary证明** |'
- en: '| URL | $0.01 | $0.05 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| URL | $0.01 | $0.05 |'
- en: '| Blockchain | $0.01 | $0.05 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 区块链 | $0.01 | $0.05 |'
- en: '| WolframAlpha | $0.03 | $0.03 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| WolframAlpha | $0.03 | $0.03 |'
- en: '| IPFS | $0.01 | $0.01 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| IPFS | $0.01 | $0.01 |'
- en: So if you are making a HTTP request and you want the TLSNotary proof too, then
    the calling contract must have an ether worth of $0.05; otherwise, an exception
    is thrown.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在发起一个HTTP请求，并且想要TLSNotary证明，那么调用的合约必须有价值$0.05的以太币；否则，将抛出异常。
- en: Getting started with the Oraclize API
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Oraclize API入门
- en: For a contract to use the Oraclize service, it needs to inherit the `usingOraclize`
    contract. You can find this contract at [https://github.com/Oraclize/Ethereum-api](https://github.com/oraclize/ethereum-api).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使合约使用Oraclize服务，需要继承`usingOraclize`合约。你可以在[https://github.com/oraclize/ethereum-api](https://github.com/oraclize/ethereum-api)找到这个合约。
- en: The `usingOraclize` contract acts as the proxy for the `OraclizeI` and `OraclizeAddrResolverI`
    contracts. Actually, `usingOraclize` makes it easy to make calls to the `OraclizeI`
    and `OraclizeAddrResolverI` contracts, that is, it provides simpler APIs. You
    can also directly make calls to the `OraclizeI` and `OraclizeAddrResolverI` contracts
    if you feel comfortable. You can go through the source code of these contracts
    to find all the available APIs. We will only learn the most necessary ones.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`usingOraclize`合约充当`OraclizeI`和`OraclizeAddrResolverI`合约的代理。实际上，`usingOraclize`使调用`OraclizeI`和`OraclizeAddrResolverI`合约变得容易，也就是说，它提供了更简单的API。如果你感觉自如，你也可以直接调用`OraclizeI`和`OraclizeAddrResolverI`合约。你可以查看这些合约的源代码，找到所有可用的API。我们只会学习最必要的API。'
- en: Let's look at how to set proof type, set proof storage location, make queries,
    find the cost of a query, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置证明类型、设置证明存储位置、进行查询、找到查询的成本等等。
- en: Setting the proof type and storage location
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置证明类型和存储位置
- en: Whether you need the TLSNotary proof from Oraclize or not, you have to specify
    the proof type and proof storage location before making queries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否需要来自 Oraclize 的 TLSNotary 证明，你都必须在发出查询之前指定证明类型和证明存储位置。
- en: 'If you don''t want proof, then put this code in your contract:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要证明，那么将这段代码放入你的合约中：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you want proof, then put this code in your contract:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要证明，那么将这段代码放入你的合约中：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Currently, `proofStorage_IPFS` is the only proof storage location available;
    that is, TLSNotary proof is only stored in `IPFS`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`proofStorage_IPFS`是唯一可用的证明存储位置；也就是说，TLSNotary 证明只存储在`IPFS`中。
- en: You may execute any of these methods just once, for instance, in the constructor
    or at any other time if, for instance, you need the proof for certain queries
    only.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以仅执行这些方法之一，例如，在构造函数中或在其他任何时候，例如，如果你只需要某些查询的证明。
- en: Sending queries
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送查询
- en: To send a query to Oraclize, you will need to call the `oraclize_query` function.
    This function expects at least two arguments, that is, the data source and the
    input for the given data source. The data source argument is not case-sensitive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 Oraclize 发送查询，你需要调用`oraclize_query`函数。该函数至少需要两个参数，即数据源和给定数据源的输入。数据源参数不区分大小写。
- en: 'Here are some basic examples of the `oraclize_query` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`oraclize_query`函数的一些基本示例：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how the preceding code works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的工作原理：
- en: If the first argument is a string, it is assumed to be the data source and the
    second argument is assumed to be the input for the data source. In the first call,
    the data source is `WolframAlpha` and the search query we sent to it was `random
    number between 0 and 100`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数是一个字符串，则假定它是数据源，第二个参数则假定是数据源的输入。在第一次调用中，数据源是`WolframAlpha`，我们发送给它的搜索查询是`random
    number between 0 and 100`。
- en: In the second call, we make an `HTTP GET` request to the `URL` present in the
    second argument.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次调用中，我们向第二个参数中的`URL`发出一个`HTTP GET`请求。
- en: In the third call, we fetch the content of the `QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU` file
    from `IPFS`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三次调用中，我们从`IPFS`中获取`QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU`文件的内容。
- en: If two consecutive arguments after the data source are strings, then it's assumed
    to be a POST request. In the last call, we make an `HTTP POST` request to `https://xyz.io/makePayment`
    and the `POST` request body content is the string in the third argument. Oraclize
    is intelligent enough to detect the content-type header based on the string format.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据源之后的两个连续参数都是字符串，则假定它是一个 POST 请求。在最后一次调用中，我们向`https://xyz.io/makePayment`发出一个`HTTP
    POST`请求，而`POST`请求主体内容是第三个参数中的字符串。Oraclize 能够根据字符串格式检测到内容类型头部。
- en: Scheduling queries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时查询
- en: If you want Oraclize to execute your query at a scheduled future time, just
    specify the delay (in seconds) from the current time as the first argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 Oraclize 在将来的某个预定时间执行你的查询，只需将延迟时间（以秒为单位）从当前时间作为第一个参数指定。
- en: 'Here is an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding query will be executed by Oraclize `60` seconds after it's been
    seen. So if the first argument is a number, then it's assumed that we are scheduling
    a query.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将在被看到后的 60 秒内由 Oraclize 执行。因此，如果第一个参数是一个数字，则假定我们正在安排一个查询。
- en: Custom gas
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义燃气
- en: The transaction originating from Oraclize to your `__callback` function costs
    gas, just like any other transaction. You need to pay Oraclize the gas cost. The
    ether oraclize_query charges to make a query are also used to provide gas while
    calling the `__callback` function. By default, Oraclize provides 200,000 gas while
    calling the `__callback` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Oraclize 到你的`__callback`函数的交易需要燃气，就像任何其他交易一样。你需要支付给 Oraclize 燃气成本。oraclize_query
    收取用于发出查询的以太币，同时也用于在调用`__callback`函数时提供燃气。默认情况下，Oraclize 在调用`__callback`函数时提供 200,000
    gas。
- en: This return gas cost is actually in your control since you write the code in
    the `__callback` method and as such, can estimate it. So, when placing a query
    with Oraclize, you can also specify how much the `gasLimit` should be on the `__callback`
    transaction. Note, however, that since Oraclize sends the transaction, any unspent
    gas is returned to Oraclize, not you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的燃气成本实际上是由你控制的，因为你在`__callback`方法中编写代码，因此可以估算出来。因此，当向 Oraclize 发出查询时，你还可以指定`__callback`交易的`gasLimit`应该是多少。然而，请注意，由于
    Oraclize 发送交易，任何未使用的 gas 都会退还给 Oraclize，而不是你。
- en: 'If the default, and minimum, value of 200,000 gas is not enough, you can increase
    it by specifying a different `gasLimit` in this way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认值和最小值的 200,000 gas 不够用，你可以通过以下方式增加它：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, you can see that if the last argument is a number, then it's assumed to
    be the custom gas. In the preceding code, Oraclize will use a 500k `gasLimit`
    for the callback transaction instead of 200k. Because we are asking Oraclize to
    provide more gas, Oraclize will deduct more ether (depending on how much gas is
    required) while calling `oraclize_query`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you offer too low a `gasLimit`, and your `__callback` method is
    long, you may never see a callback. Also note that the custom gas has to be more
    than 200k.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once your result is ready, Oraclize will send a transaction back to your contract
    address and invoke one of these three methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: either `__callback(bytes32 myid, string result)`. `Myid` is a unique ID for
    every query. This ID is returned by the `oraclize_query` method. If you have multiple
    `oraclize_query` calls in your contract, then this is used to match the query
    this result is for.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you requested for the TLS Notary proof, this is the result: `__callback(bytes32
    myid, string result, bytes proof)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last resort, if the other methods are absent, the fallback function is
    `function()`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the `__callback` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Parsing helpers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result returned from an HTTP request can be HTML, JSON, XML, binary, and
    so on. In Solidity, it is difficult and expensive to parse the result. Due to
    this, Oraclize provides parsing helpers to let it handle the parsing on its servers,
    and you get only the part of the result that you need.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To ask Oraclize to parse the result, you need to wrap the URL with one of these
    parsing helpers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`xml(..)` and `json(..)` helpers let you ask Oraclize to only return part of
    the JSON or XML-parsed response; for example, take a look at the following:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to get the whole response back, you use the `URL` data source with
    the `api.kraken.com/0/public/Ticker?pair=ETHUSD` URL argument
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If all you want is the last-price field, you need to use the JSON parsing call
    as `json(api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `html(..).xpath(..)` helper is useful for HTML scraping. Just specify the
    XPATH you want as the `xpath(..)` argument; for example, take a look at the following:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fetch the text of a specific tweet, use `html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class,
    'tweet-text')]/text())`.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `binary(..)` helper is useful in getting binary files such as certificate
    files:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fetch only a portion of the binary file, you can use `slice(offset,length)`;
    the first parameter is the offset, while the second one is the length of the slice
    you want back (both in bytes).
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Fetch only the first 300 bytes from a binary CRL, `binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)`.
    The binary helper must be used with the slice option, and only binary files (not
    encoded) are accepted.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If and when the server is not responding or is unreachable, we will send you
    an empty response. You can test queries using [http://app.Oraclize.it/home/test_query](http://app.oraclize.it/home/test_query).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Getting the query price
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you would like to know how much a query would cost before making the actual
    query, then you can use the `Oraclize.getPrice()` function to get the amount of
    wei required. The first argument it takes is the data source, and the second argument
    is optional, which is the custom gas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: One popular use case of this is to notify the client to add ether to the contract
    if there isn't enough to make the query.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting queries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may not want to reveal the data source and/or the input for
    the data source. For example: you may not want to reveal the API key in the URL
    if there is any. Therefore, Oraclize provides a way to store queries encrypted
    in the smart contract and only Oraclize''s server has the key to decrypt it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Oraclize provides a Python tool ([https://github.com/Oraclize/encrypted-queries](https://github.com/oraclize/encrypted-queries)),
    which can be used to encrypt the data source and/or the data input. It generates
    a non-deterministic encrypted string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI command to encrypt an arbitrary string of text is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The long hexadecimal string you see is the public key of Oraclize's server.
    Now you can use the output of the preceding command in place of the data source
    and/or the input for the data source.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent the misuse of encrypted queries (that is, replay attacks)
    the first contract querying Oraclize with a specific encrypted query becomes its
    rightful owner. Any other contract reusing the exact same string will not be allowed
    to use it and will receive an empty result. As a consequence, remember to always
    generate a newly encrypted string when redeploying contracts using encrypted queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the data source
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another data source called decrypt. It is used to decrypt an encrypted
    string. But this data source doesn't return any result; otherwise, anyone would
    have the ability to decrypt the data source and input for the data source.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It was specifically designed to be used within the nested data source to enable
    partial query encryption. It is its only use case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Oraclize web IDE
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oraclize provides a web IDE, using which you can write, compile, and test Oraclize-based
    applications. You can find it at [http://dapps.Oraclize.it/browser-Solidity/](http://dapps.oraclize.it/browser-solidity/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If you visit the link, then you will notice that it looks exactly the same as
    browser Solidity. And it's actually browser Solidity with one extra feature. To
    understand what that feature is, we need to understand browser Solidity more in
    depth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Browser Solidity not only lets us write, compile, and generate web3.js code
    for our contracts, but it also lets us test those contracts there itself. Until
    now, in order to test our contract, we were setting up an Ethereum node and sending
    transactions to it. But browser Solidity can execute contracts without connecting
    to any node and everything happens in memory. It achieves this using ethereumjs-vm,
    which is a JavaScript implementation of EVM. Using ethereumjs-vm, you can create
    our own EVM and run byte code. If we want, we can configure browser Solidity to
    use the Ethereum node by providing the URL to connect to. The UI is very informative;
    therefore, you can try all these by yourself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: What's special about the Oraclize web IDE is that it deploys the Oraclize contract
    in the in-memory execution environment so that you don't have to connect to the
    testnet or mainnet node, but if you use browser Solidity, then you have to connect
    to the testnet or mainnet node to test Oraclize APIs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: You can find more resources related to integrating Oraclize at [https://dev.Oraclize.it/](https://dev.oraclize.it/).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Working with strings
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with strings in Solidity is not as easy as working with strings in other
    high-level programming languages, such as JavaScript, Python, and so on. Therefore,
    many Solidity programmers have come up with various libraries and contracts to
    make it easy to work with strings.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The `strings` library is the most popular strings utility library. It lets us
    join, concatenate, split, compare, and so on by converting a string to something
    called a slice. A slice is a struct that holds the length of the string and the
    address of the string. Since a slice only has to specify an offset and a length,
    copying and manipulating slices is a lot less expensive than copying and manipulating
    the strings they reference.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: To further reduce gas costs, most functions on slice that need to return a slice
    modify the original one instead of allocating a new one; for instance, `s.split(".")`
    will return the text up to the first `"."`, modifying s to only contain the remainder
    of the string after the `"."`. In situations where you do not want to modify the
    original slice, you can make a copy with `.copy()`, for example, `s.copy().split(".")`.
    Try and avoid using this idiom in loops; since Solidity has no memory management,
    it will result in allocating many short-lived slices that are later discarded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Functions that have to copy string data will return strings rather than slices;
    these can be cast back to slices for further processing if required.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples of working with strings using the `strings` library:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is self-explanatory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that return two slices come in two versions: a nonallocating version
    that takes the second slice as an argument, modifying it in place, and an allocating
    version that allocates and returns the second slice; for example, let''s take
    a look at the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can learn more about the strings library at [https://github.com/Arachnid/Solidity-stringutils](https://github.com/Arachnid/solidity-stringutils).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Building the betting contract
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our betting application, two people can choose to bet on a football match
    with one person supporting the home team and the other person supporting the away
    team. They both should bet the same amount of money, and the winner takes all
    the money. If the match is a draw, then they both will take back their money.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We will use the FastestLiveScores API to find out the result of matches. It
    provides a free API, which lets us make 100 requests per hour for free. First,
    go ahead and create an account and then generate an API key. To create an account,
    visit [https://customer.fastestlivescores.com/register](https://customer.fastestlivescores.com/register),
    and once the account is created, you will have the API key visible at [https://customer.fastestlivescores.com/](https://customer.fastestlivescores.com/).
    You can find the API documentation at [https://docs.crowdscores.com/](https://docs.crowdscores.com/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: For every bet between two people in our application, a betting contract will
    be deployed. The contract will contain the match ID retrieved from the `FastestLiveScores`
    API, the amount of wei each of the parties need to invest, and the addresses of
    the parties. Once both parties have invested in the contract, they will find out
    the result of the match. If the match is not yet finished, then they will try
    to check the result after every 24 hours.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the contract:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The contract code is self-explanatory. Now compile the preceding code using
    `solc.js` or browser Solidity depending on whatever you are comfortable with.
    You will not need to link the `strings` library because all the functions in it
    are set to the `internal` visibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In browser Solidity, when specifying to import a library or contract from the
    HTTP URL, make sure that it's hosted on GitHub; otherwise, it won't fetch it.
    In that GitHub file URL, make sure that you remove the protocol as well as `blob/{branch-name}`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Building a client for the betting contract
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make it easy to find match's IDs, deploy, and invest in contracts, we need
    to build a UI client. So let's get started with building a client, which will
    have two paths, that is, the home path to deploy contracts and bet on matches
    and the other path to find the list of matches. We will let users deploy and bet
    using their own offline accounts so that the entire process of betting happens
    in a decentralized manner and nobody can cheat.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start building our client, make sure that you have testnet synced
    because Oraclize works only on Ethereum''s testnet/mainnet and not on private
    networks. You can switch to testnet and start downloading the testnet blockchain
    by replacing the `--dev` option with the `--testnet` option. For example, take
    a look at the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Projecting the structure
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the exercise files of this chapter, you will find two directories, that is,
    Final and Initial. Final contains the final source code of the project, whereas
    Initial contains the empty source code files and libraries to get started with
    building the application quickly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，您将找到两个目录，即Final和Initial。Final包含项目的最终源代码，而Initial包含空的源代码文件和库，以快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and then run the app using the `node app.js` command inside the Final directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Final`目录，您需要在其中运行`npm install`，然后使用`Final`目录内的`node app.js`命令运行应用程序。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. The `package.json` file contains the backend
    dependencies of our app, and `app.js` is where you will place the backend source
    code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Initial`目录中，您将找到一个`public`目录和两个名为`app.js`和`package.json`的文件。`package.json`文件包含我们应用程序的后端依赖关系，`app.js`是您将放置后端源代码的地方。
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the bootstrap library. Inside `public/html`,
    you will find the `index.html` and `matches.ejs` files, where you will place the
    HTML code of our app, and in the `public/js` directory, you will find js files
    for web3.js, and ethereumjs-tx. Inside `public/js`, you will also find a `main.js`
    file, where you will place the frontend JS code of our app. You will also find
    the Oraclize Python tool to encrypt queries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`目录包含与前端相关的文件。在`public/css`内，您将找到`bootstrap.min.css`，这是bootstrap库。在`public/html`内，您将找到`index.html`和`matches.ejs`文件，您将在其中放置我们应用程序的HTML代码，并且在`public/js`目录内，您将找到web3.js和ethereumjs-tx的js文件。在`public/js`内，您还会找到一个`main.js`文件，您将在其中放置我们应用程序的前端JS代码。您还将在Oraclize
    Python工具中找到加密查询的内容。'
- en: Building the backend
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: Let's first build the backend of the app. First of all, run `npm install` inside
    the Initial directory to install the required dependencies for our backend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构建应用程序的后端。首先，在Initial目录内运行`npm install`以安装后端所需的依赖。
- en: 'Here is the backend code to run an express service and serve the `index.html`
    file and static files and set the view engine:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行express服务并提供`index.html`文件和静态文件并设置视图引擎的后端代码：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is self-explanatory. Now let''s proceed further. Our app
    will have another page, which will display a list of recent matches with matches''
    IDs and result if a match has finished. Here is the code for the endpoint:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们继续进行。我们的应用程序将有另一个页面，其中将显示最近的比赛列表，包括比赛的ID和结果（如果比赛已结束）。以下是端点的代码：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are making the API request to fetch the list of recent matches and
    then we are passing the result to the `matches.ejs` file so that it can render
    the result in a user-friendly UI. The API results give us the match start time
    as a timestamp; therefore, we are using moment to convert it to a human readable
    format. We make this request from the backend and not from the frontend so that
    we don't expose the API key to the users.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在进行API请求以获取最近比赛的列表，然后将结果传递给`matches.ejs`文件，以便它可以在用户友好的UI中渲染结果。API结果以时间戳形式给出比赛开始时间；因此，我们正在使用moment将其转换为可读的人类格式。我们从后端而不是从前端发出此请求，以便我们不会向用户公开API密钥。
- en: Our backend will provide an API to the frontend, using which the frontend can
    encrypt the query before deploying the contract. Our application will not prompt
    users to create an API key, as it would be a bad UX practice. The application's
    developer controlling the API key will cause no harm as the developer cannot modify
    the result from the API servers; therefore, users will still trust the app even
    after the application's developer knows the API key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端将向前端提供API，通过该API前端可以在部署合约之前加密查询。我们的应用程序不会提示用户创建API密钥，因为这将是不良的UX实践。应用程序的开发人员控制API密钥不会造成任何伤害，因为开发人员无法修改API服务器的结果；因此，即使应用程序的开发人员知道API密钥，用户仍将信任该应用程序。
- en: 'Here is code for the encryption endpoint:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是加密端点的代码：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have already seen how to use this tool. To run this endpoint successfully,
    make sure that Python is installed on your system. Even if Python is installed,
    this endpoint may show errors, indicating that Python's cryptography and base58
    modules aren't installed. So make sure you install these modules if the tool prompts
    you to.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用此工具。为了成功运行此端点，请确保在您的系统上安装了 Python。即使安装了 Python，此端点也可能显示错误，指示未安装 Python
    的密码学和 base58 模块。因此，如果工具提示您安装这些模块，请确保您安装了这些模块。
- en: Building the frontend
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: Now let's build the frontend of our application. Our frontend will let users
    see the list of recent matches, deploy the betting contract, bet on a game, and
    let them see information about a betting contract.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建应用程序的前端。我们的前端将让用户看到最近比赛的列表，部署投注合约，对游戏进行投注，并让他们看到有关投注合约的信息。
- en: 'Let''s first implement the `matches.ejs` file, which will display the list
    of recent matches. Here is the code for this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现`matches.ejs`文件，该文件将显示最近比赛的列表。这是这个文件的代码：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is self-explanatory. Now let's write the HTML code for our
    home page. Our home page will display three forms. The first form is to deploy
    a betting contract, the second form is to invest in a betting contract, and the
    third form is to display information on a deployed betting contract.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们为我们的首页编写 HTML 代码。我们的首页将显示三个表单。第一个表单用于部署一个投注合约，第二个表单用于投资一个投注合约，第三个表单用于显示已部署投注合约的信息。
- en: 'Here is the HTML code for the home page. Place this code in the `index.html`
    page:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是首页的 HTML 代码。将此代码放在`index.html`页面中：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is self-explanatory. Now let''s write JavaScript code to
    actually deploy the contract, invest in contracts, and display information on
    contracts. Here is the code for all this. Place this code in the `main.js` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。现在让我们编写 JavaScript 代码来实际部署合约，在合约上投资，并显示有关合约的信息。以下是所有这些的代码。将此代码放在`main.js`文件中：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is how the preceding code works:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前代码的工作原理：
- en: At first, we store the contract byte code and ABI in the `bettingContractByteCode`
    and `bettingContractABI` variables, respectively.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将合约的字节码和 ABI 存储在`bettingContractByteCode`和`bettingContractABI`变量中。
- en: Then, we are create a `Web3` instance, which is connected to our testnet node.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个连接到我们的测试网节点的`Web3`实例。
- en: Then, we have the `getAJAXObject` function (a cross-browser compatible function),
    which returns an AJAX object.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`getAJAXObject`函数（一个跨浏览器兼容的函数），它返回一个 AJAX 对象。
- en: Then, we attach a `submit` event listener to the first form, which is used to
    deploy the contract. In the event listener's callback, we make a request to the
    `getURL` endpoint by passing `matchId` to get the encrypted query string. And
    then, we generate the data to deploy the contract. Then, we find out the `gasRequired`.
    We use the function object's estimateGas method to calculate the gas required,
    but you can use the web3.eth.estimateGas method too. They both differ in terms
    of arguments; that is, in the preceding case, you don't need to pass the transaction
    data. Remember that `estimateGas` will return the block gas limit if the function
    call throws an exception. Then, we calculate the nonce. Here, we just use the
    `getTransactionCount` method instead of the actual procedure we learned earlier.
    We do this just for simplification of the code. Then, we create the raw transaction,
    signing it and broadcasting it. Once the transaction is mined, we display the
    contract address.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`submit`事件侦听器附加到第一个表单上，该表单用于部署合约。在事件侦听器的回调中，我们通过传递`matchId`来向`getURL`端点发出请求，以获取加密的查询字符串。然后，我们生成用于部署合约的数据。然后，我们找出`gasRequired`。我们使用函数对象的`estimateGas`方法来计算所需的
    gas，但您也可以使用`web3.eth.estimateGas`方法。它们在参数方面有所不同；即，在前面的情况下，您不需要传递交易数据。请记住，如果函数调用引发异常，`estimateGas`将返回块
    gas 限制。然后，我们计算 nonce。在这里，我们只是使用`getTransactionCount`方法而不是我们之前学到的实际过程。我们之所以这样做，只是为了简化代码。然后，我们创建原始交易，对其进行签名并广播。一旦交易被挖掘，我们将显示合约地址。
- en: Then, we attach a `submit` event listener for the second form, which is used
    to invest in a contract. Here, we generate the `data` part of the transaction,
    calculating the gas required, creating the raw transaction, signing it, and broadcasting
    it. While calculating the gas required for the transaction, we pass the contract
    address from the account address and value object properties as it's a function
    call, and the gas differs depending on the value, the from address, and contract
    address. Remember that while finding the gas required to call a contract's function,
    you can pass the `to`, `from`,and `value` properties because gas depends on these
    values.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have a `submit` event listener for the third form, that is, to display
    information on a deployed betting contract.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the client
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have finished building our betting platform, it's time to test it.
    Before testing, make sure the testnet blockchain is completely downloaded and
    is looking for new incoming blocks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Now using our wallet service we built earlier, generate three account. Add one
    ether to each of the accounts using [http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run `node app.js` inside the `Initial` directory and then visit `http://localhost:8080/matches`,
    and you will see what is shown in this screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_001.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can copy any match ID. Let''s assume you want to test with the first
    match, that is, 123945\. Now visit [`http://localhost:8080`](http://localhost:8080)
    and you will see what is shown in this screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_002.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Now deploy the contract by filling the input fields in the first form and clicking
    on the Deploy button, as shown here. Use your first account to deploy the contract.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_003.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Now bet on the contract''s home team from the second account and the `away
    team` from the third account , as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_004.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Now put the contract address on the third form and click on the Find button
    to see the details about the contract. You will see something similar to what
    is shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_005.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Once both the transactions are mined, check the details of the contract again,
    and you will see something similar to what is shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_006.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the contract doesn't have any ether and all the ether
    was transferred to the account that put the bet on the home team.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Oraclize and the `strings` library in depth.
    We used them together to build a decentralized betting platform. Now you can go
    ahead and customize the contract and the client based on your requirements. To
    enhance the app, you can add events to the contract and display notifications
    on the client. The objective was to understand the basic architecture of a decentralized
    betting app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build enterprise-level Ethereum smart
    contracts using truffle by building our own crypto currency.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 truffle 构建企业级以太坊智能合约，通过构建我们自己的加密货币。
