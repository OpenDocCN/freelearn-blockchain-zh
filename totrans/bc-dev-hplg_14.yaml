- en: Overview of Solidity Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Solidity** is a smart contract programming language. It was developed by
    Gavin Wood, Christian Reitwiessner, Alex Beregszaszi, and several Ethereum core
    contributors. It is a JavaScript-like, general-purpose language designed to target
    the **Ethereum virtual machine** (**EVM**). Solidity is one of four languages
    in the Ethereum protocol at the same level of abstraction, the others being Serpent
    (similar to Python), **LLL** (**Lisp-like language**), Vyper (experimental), and
    Mutan (deprecated). The community has slowly converged on solidity. Usually, if
    anyone today talks about smart contracts in Ethereum, they implicitly mean solidity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is solidity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for the solidity development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common smart contract patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study – crowdfunding campaign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is solidity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity is a statically typed contract language that contains state variables,
    functions, and common data types. Developers are able to write decentralized applications
    (DApps) that implement business logic functions in a smart contract. The contract
    verifies and enforces the constraints at compile time, as opposed to runtime.
    Solidity is compiled to EVM executable byte code. Once compiled, the contracts
    are uploaded to the Ethereum network. The blockchain will assign an address to
    the smart contract. Any permissioned user on the blockchain network can call a
    contract function to execute the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical flow diagram showing the process from writing contract code
    to deploying and running it on the Ethereum network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0f65a84-129e-4c66-84a5-9bb401c3d4c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Tools for solidity development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contract development is still in its infancy. Creating such contracts
    and interacting with them in a convenient manner can be done in a multitude of
    ways.  The following powerful tools can be used to build, monitor, and deploy
    your smart contracts for development on the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: Browser-based IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at onlien browser based tools such as Remix
    and EthFiddle.
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remix is a powerful, open source, smart contract tool that helps you write
    solidity code just from the browser. It supports compile, run, analysis, testing,
    and debugger options. The following three types of environments are available
    with Remix when developing and testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript VM**: Remix comes with five Ethereum accounts, and each account
    is deposited with 100 ethers as default. This is convenient for testing smart
    contracts in the development phase. Mining is not required as it is done automatically.
    This option is a good choice when you are a beginner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Injected Web3**: This option will directly invoke injected browser web3 instances
    such as MetaMask, an Ethereum network browser extension. MetaMask provides you
    with many functions and features, and, like regular Ethereum wallets, it allows
    you to interact with DApps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web3 provider**: Remix also supports Web3 provider. The web3.js library is
    the official Ethereum JavaScript API. It is used to interact with Ethereum smart
    contracts. You can connect to the blockchain network through web3j API. Web3j
    supports three different providers: HTTPProvider, WebsocketProvider, and IpcProvider.
    In Remix Web3, you can give the HTTP URL to connect the remote blockchain instance.
    The URL can point to your local private blockchain, test-net, and other instance
    endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by using the Remix solidity IDE:  [https://remix.ethereum.org](https://remix.ethereum.org).
    The following is the screenshot for the UI of Remix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f8a62a2-d60c-43d5-b345-5b6855820378.png)'
  prefs: []
  type: TYPE_IMG
- en: EthFiddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EthFiddle is a very simple solidity browser-based development tool. You can
    quickly test and debug smart contract code, and share a permalink to your code.
    One feature that makes EthFiddle stand out is its potential to perform security
    audits. The following screenshot shows the software interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9894b6e-cef9-4e81-b194-7cc5b6e3eef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Interface of EthFiddle software
  prefs: []
  type: TYPE_NORMAL
- en: Here is the EthFiddle solidity IDE link:  [https://ethfiddle.com](https://ethfiddle.com).
  prefs: []
  type: TYPE_NORMAL
- en: Command-line development management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command-line tools are server-side Ethereum tools used to create a basic
    structure of a DApp project.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Truffle is a popular development environment and testing framework, and is
    an asset pipeline for Ethereum. Truffle''s major features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in smart contract compilation, linking, deployment, and binary management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Automated contract testing with Mocha and Chai s Truffle site link: http'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scriptable deployment and migrations framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network management for deploying to many public and private networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive console for direct contract communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss in more detail in the next chapter, and we will use Truffle
    to development DApp for ERC20 token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is Truffle''s site link: [https://truffleframework.com/](https://truffleframework.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with the most basic smart contract example,  `HelloWorld.sol`, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solidity's file extension is `.sol`.  It is similar to `.js` for JavaScript
    files, and `.html` for HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Layout of a solidity source file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A solidity source file is typically composed of the following constructs: pragma,
    comments, and import.'
  prefs: []
  type: TYPE_NORMAL
- en: Pragma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line containing the keyword pragma simply says that the source code
    file will not compile with a compiler earlier than version 0.4.24\. Anything newer
    does not break functionality. The `^` symbol implies another condition—the source
    file will not work either on compilers beyond version 0.5.0.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments are used to make the source code easier for humans to understand the
    function of the program. Multi-line comments are used for large text descriptions
    of code. Comments are ignored by the compiler. Multi-line comments start with
    `/*` and end with `*/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HelloWorld` example, there are comments for the `set` and `get` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: The `setNewGreeting (string _newGreeting) {}` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@param`: This is used to indicate what parameters are being passed to a method,
    and what value they''re expected to have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The import keyword in solidity is very similar to JavaScript's past version,
    ES6\. It is used to import libraries and other related features into your solidity
    source file. Solidity does not support export statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few import examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line shown will create a global symbol called `symbolName`, containing
    the global symbol's member from the import file: `solidityFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another solidity-specific syntax equivalent to the preceding import is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import multiple symbols, and name some of the symbols as alias,
    demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example where an ERC20 token is created using the zeppelin solidity
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the example shown in the preceding code snippet, we imported the `SafeMath`
    library from Zeppelin and applied it to `uint256`.
  prefs: []
  type: TYPE_NORMAL
- en: Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When importing a solidity file, the file path follows a few simple syntax rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Absolute paths: `/folder1/ folder2/xxx.sol` starting from `/`, the path location
    is from same solidity file location to the imported files. In our ERC 20 example,
    this is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual project structure appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f449d45d-fe7a-40a3-8a9e-5726e8103b22.png)'
  prefs: []
  type: TYPE_IMG
- en: Relative paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`../folder1/folder2/xxx.sol`: these paths are interpreted relative to the location
    of the current file, `.` as the current directory, and `..` as the parent directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the solidity path, it is possible to specify path prefix remappings. As
    an example, if you want to import `github.com/ethereum/dapp-bin/library`, you
    can first clone the GitHub library to `/usr/local/dapp-bin/library`, and then
    run the compiler command, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our solidity file, you can use the following `import` statement. It
    will remap to `/usr/local/dapp-bin/library/stringUtils.sol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will read the files from there.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A contract includes the following constructs: state variables, data type, functions,
    events, modifiers, enum, struct, and mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: State variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State variables are values that are permanently stored in contract storage,
    and are used to maintain the contract's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity is a statically typed language. Developers familiar with language such
    as JavaScript and Python will find Solidity syntax easy to pick up. Each variable
    needs to specify the data type. The variable, which will always be passed by value,
    is called value types, it is built-in or predefined data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value types in solidity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Types** | **Operators** | **Example** | **Note** |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | !, &&, &#124;&#124;, ==, != | `bool a = true;` | The Booleans are
    true or false expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` (int8 to int256) | Comparison operators:<=, <, ==, !=, >=, >,Bit operators:
    &, &#124;, ^, +, -, unary -, unary +, *, /, %, **, <<, >> | `int a = 1;` | Signed
    integer, signed of 8 up to 256 bits, in the step of 8. |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint` (uint8 to uint256) | Comparison operators: <=, <, ==, !=, >=, >Bit
    operators: &, &#124;, ^, +, -, unary -, unary +, *, /, %, **, <<, >> | `uint maxAge
    = 100;` | Unsigned  integer, unsigned of 8 up to 256 bits, in the step of 8. |'
  prefs: []
  type: TYPE_TB
- en: '| Address | <=, <, ==, !=, >= ,> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| Holds a 20 byte value (size of an Ethereum address). |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.balance` |  | `address.balance()` | Addresses members and <indexentry
    content="value types, solidity:.balance">returns the balance of the address in
    Wei. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.transfer` |  | `beneficiary.transfer(highestBid)` | Addresses
    members and sends ether (in units of Wei) to an address. If the transfer operation
    fails, it `<indexentry content="value types, solidity:.transfer">`throws an exception,
    and all of the changes in a transaction are reverted. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.send` |  | `msg.sender.send(amount)` | Addresses members and send
    ether (in units of Wei) to an address. If the send operation fails, it returns
    false. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.call` |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Executed code of another contract, returns false in the event of failure,
    forwards all available gas, adjustable, should be used when you need to control
    how much gas to forward. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.delegatecall` |  | `, _library.delegatecall(msg.data);` | Executed
    code of another contract, but with the state (storage) of the calling contract.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fixed size byte array(bytes1, bytes2, …, bytes32) | Comparison operators:
    <=, <, ==, !=, >=, >,Bit operators: &, &#124;, ^ ,~,<<, >>,get array data : array[index]
    | `uint8[5] memory traits = [1,2,3,4,5];` | Fixed size byte arrays are defined
    using the keyword byteN, the N being any number from 1 to 32, it limits the size,
    it will be a lot cheaper and will save you gas. |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamically-sized array bytes string |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| Solidity supports a dynamically-sized byte array and a dynamically-sized
    UTF-8-encoded string. |'
  prefs: []
  type: TYPE_TB
- en: '| Hexadecimal literals |  | `hex"1AF34A"` | Hexadecimal literals are prefixed
    with the keyword hex and are enclosed in single or double quotes. |'
  prefs: []
  type: TYPE_TB
- en: '| Address literals |  | `0x5eD8Cee6b63b1c6AFce``3AD7c92f4fD7E1B8fAd9F` | It
    is hexadecimal literals that pass the address checksum test. |'
  prefs: []
  type: TYPE_TB
- en: '| String literals |  | `"Hello”` | String literals are normally written with
    either single or double quotes. |'
  prefs: []
  type: TYPE_TB
- en: Enum type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enum is a type with a restricted set of constants values. Here is an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Struct type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A struct is a type that contains named fields. New types can be declared using
    struct. Here is an example in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mappings act as hash tables that consist of key types and corresponding value
    type pairs. Here is an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are the executable units of code within a contract. Here is a function
    structure in solidity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function can pass input parameters. The input parameters are declared the same
    way as variables are.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous `HelloWorld` example, we define `setNewGreeting` using the
    input parameter, `string _newGreeting`.  Here is an example of this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity access modifiers are used to provide access control in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of access modifiers available in Solidity, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Accessible from this contract, inherited contracts, and externally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: Accessible only from this contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Accessible only from this contract and contracts inheriting from
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External**: Cannot be accessed internally, only externally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output parameters can be declared after the `return` keyword, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In solidity, `pure` functions are functions that are promised not to modify,
    or read the state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the function modifier is defined as view, it indicates that the function
    will not change the storage state.
  prefs: []
  type: TYPE_NORMAL
- en: If the function modifier is defined as pure, it indicates that the function
    will not read the storage state.
  prefs: []
  type: TYPE_NORMAL
- en: If the function modifier is defined as constant, it indicates that the function
    won't modify the contract storage.
  prefs: []
  type: TYPE_NORMAL
- en: If the function modifier is defined as payable, modifier can receive funds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `buy` function has a payable modifier, which makes
    sure you can send ethers to the `buy` function. A function without any name, and
    annotated with a payable keyword, is called a payable fallback function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In solidity, the modifier is used to change the behavior of a function. They
    can automatically check a condition prior to executing the function. Here is an
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Events are used to track the execution of a transaction sent to a contract.
    There are convenient interfaces with the EVM logging facilities. Here is an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The constructor method is a special method for creating and initializing a contract.
    In solidity v0.4.23, Solidity introduced this new constructor notation and the
    old one was deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Constant state variables, unit, and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The value of a constant cannot change through reassignment, and it can't be
    redeclared after compile time. In solidity, a state variable can be declared as
    constant. It does not allow reassignment to blockchain data (for example, this
    `.balance`, `block.blockhash`), or execution data (`tx.gasprice`), or make calls
    to external contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table out the solidity global variables and their built-in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Global variables / functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `msg.sender(address)` | `msg.sender` is the address currently interacting
    with the contract call message. |'
  prefs: []
  type: TYPE_TB
- en: '| `msg.data(bytes)` | `msg.data` is the address currently interacting with
    the contract complete call. The data is in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `msg.value(unit)` | `msg.value` is the address currently interacting with
    the number of Wei sent with message as per the contract. |'
  prefs: []
  type: TYPE_TB
- en: '| `msg.sig` | `msg.sig` is the address currently interacting with the contract
    that returns the first four bytes of the call data. |'
  prefs: []
  type: TYPE_TB
- en: '| `gasleft() returns (uint256)` | API to check the gas remaining. |'
  prefs: []
  type: TYPE_TB
- en: '| `tx.origin` | API to check the sender of the transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `tx.gasprice` | API to check the gas price of the transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `now` | Get current unix timestamp. |'
  prefs: []
  type: TYPE_TB
- en: '| `block.number` | API to retrieve the current block number. |'
  prefs: []
  type: TYPE_TB
- en: '| `block.difficulty` | API to retrieve the current block difficulty. |'
  prefs: []
  type: TYPE_TB
- en: '| `block.blockhash(uint blockNumber) returns (bytes32)` | API to get the hash
    of the given block; the result only returned the 256 most recent blocks. |'
  prefs: []
  type: TYPE_TB
- en: '| `block.gasLimit(unit)` | API to get the current block gas limit. |'
  prefs: []
  type: TYPE_TB
- en: '| `block.coinbase ()` | Returns the current block miner''s address. |'
  prefs: []
  type: TYPE_TB
- en: '| `keccak256(...);` | Returns (bytes32) compute the Ethereum-SHA-3 (Keccak-256)
    hash of the (tightly packed) arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `sha3(...)` | Returns (bytes32): an alias to keccak256. |'
  prefs: []
  type: TYPE_TB
- en: '| `assert(bool condition)` | `assert` can be used to check for conditions.
    It indicates something that should never be false under any circumstances. Furthermore, `assert` uses
    the `0xfe` opcode to cause an error condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `require(bool condition)` | The `require` function should be used to ensure
    valid conditions. It can return false when the user enters something inappropriate.
    Furthermore, `require()` uses the `0xfd` opcode to cause an error condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `revert()` | `revert` will still undo all state changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.balance` | It checks the balance of the address in Wei (uint256).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.send(uint256 amount) returns (bool)` | API sends the amount of
    Wei to address and returns false in the event failure. |'
  prefs: []
  type: TYPE_TB
- en: '| `<address>.transfer(uint256 amount)` | API transfer the amount of Wei to
    the address, and throws error when transfer fails. |'
  prefs: []
  type: TYPE_TB
- en: '| `this` | The current contract, explicitly convertible to address. |'
  prefs: []
  type: TYPE_TB
- en: '| `super` | The contract one level higher in the inheritance hierarchy. |'
  prefs: []
  type: TYPE_TB
- en: '| `selfdestruct(address recipient)` | `self-destruct` will destroy the current
    contract, and storage associated with it is removed from the Ethereum''s world
    state. |'
  prefs: []
  type: TYPE_TB
- en: '| `suicide(address recipient)` | An alias to self-destruct. |'
  prefs: []
  type: TYPE_TB
- en: Ether units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity ether  is dividable into Wei, Kwei, Mwei, Gwei, Szabo, Finney, Kether,
    Mether, Gether, and Tether. The following are the conversion units:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 ether = 1,000 Finney
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Finney = 1,000 Szabo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Szabo = 1,000 Mwei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Mwei = 1,000 Kwei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Kwei = 1,000 Wei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A solidity time unit is dividable into seconds, minutes, hours, days, weeks,
    and years. The following are the conversion units:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 = 1 second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 minute = 60 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 hour = 60 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 day = 24 hours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 week = 7 days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 year = 365 days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance, abstract, and interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the most widely used programming languages (such as C++, Java, Go, and
    Python, and so on) support **object-oriented programming** (**OOP**) and support
    inheritance, encapsulation, abstraction, and polymorphism. Inheritance enables
    code reuse and extensibility. Solidity supports multiple inheritance in the form
    of copying code, which includes polymorphism. Even if a contract inherits from
    multiple other contracts, only a single contract is created on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In solidity, inheritance is pretty similar to classic oriented-object programming
    languages. Here are a number of examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Dog inherits from `Mammal`, whose parent contract is `Animal`. When calling
    `Dog.run()`, it will call its parent method `run()` and return ten. When calling
    name, `Dog.name()` will override its patent method and return the output from
    `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: In solidity, a method without a body (no implementation) is known as an abstract
    method. A contract that contains an abstract method cannot be instantiated, but
    can be used as a base.
  prefs: []
  type: TYPE_NORMAL
- en: If a contract inherits from an abstract contract, then the contract must implement
    all the abstract methods of abstract parent class, or it has to be declared abstract
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dog has a concrete `color()` method, which is a concrete contract and can be
    compiled, but the parent contract—mammal, and the grandparent contract—animal,
    are still abstract contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces in solidity are similar to abstract contracts; they are implicitly
    abstract and cannot have implementations. An abstract contract can have instance
    methods that implement a default behavior. There are more restrictions in interfaces,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cannot inherit other contracts or interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot define constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot define variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot define structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot define enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the contract is an interface, `contract B` implements
    `interface A`, and has a concrete `doSomething()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Common smart contract patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some common design and programming patterns
    for the smart contract programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Access restriction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access restriction is a solidity security pattern.  It only allows authorized
    parties to access certain functions. Due to the public nature of the blockchain,
    all data on the blockchain is visible to anyone. It is critical to declare your
    contract function, state with restricted access control, and provide security
    against unauthorized access to smart contract functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows the access restrict pattern applied  to a contract.
    We first define a parent class called `Ownable` with `onlyOwner`, `changeOwner`,
    and `onlyAfter` function modifiers.  Other contracts can inherit from this contract
    to use defined access restriction. `SampleContract` inherits from `Ownable` contract
    and therefore, only the owner can access `setValue` function. Furthermore,  `forceOwnerChange`
    may only be called two weeks after the contract creation time with 50 ether cost,
    and only the owner has permission to execute the function.
  prefs: []
  type: TYPE_NORMAL
- en: State machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'State machine is a behavior design pattern.  It allows a contract to alter
    its behavior when it''s internal state changes. A smart contract function call
    typically moves a contract state from one stage to the next stage. The basic operation
    of a state machine has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: It traverses through a sequence of states, where the next state is determined
    by the present state, and input conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides sequences of outputs based upon state transitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s develop a simple state machine. We will use washing
    dishes as an example. The process typically is *scrub, rinse, dry, scrub, rinse,
    dry*. We defined state machine stages as an enumerated type.  As this is an extensive
    use case, only the state machine related code is presented. Any logic for detailed
    action implementation, such as `rinse()`, `dry()` and so on are omitted. See the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We define function modifier `atStage` to check if the current state allows the
    stage to run the function. Furthermore, `transitionNext` modifier will call the
    internal method `nextStage()` to move state to next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a smart contract has been deployed on the Ethereum network, it is immutable
    and public to everyone. Many of the smart contract functions are account payment
    related; therefore, security and testing become absolutely essential for a contract
    before being deployed on the main network. Following are security practices that
    will help you better design and write flawless Ethereum smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Keep contract simple and modular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to keep your smart contract small, simple, and modularized. Complicated
    code is difficult to read, understand, and debug, it is also error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Use well-written library tools where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Limit the amount of local variables.
  prefs: []
  type: TYPE_NORMAL
- en: Move unrelated functionality to other contracts or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Use the checks-effects-interactions pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be very careful when interacting with other external contracts, it should be
    the last step in your function. It can introduce several unexpected risks or errors.
    External calls may execute malicious code. These kinds of calls should be considered
    as potential security risks and avoided if possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The line `msg.sender.call.value(userBalances[msg.sender])` is an external call,
    when `withdrawBalance` is called, it will send ether with the `address.call.value()`.
    The hacker can attack fund contracts by triggering the hack fallback function,
    which can call the `withdrawBalance` method again. This will allow the attacker
    to refund multiple times, draining all ether in accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding contract vulnerabilities is called reentrancy. To avoid this,
    you can use the checks-effects-interactions pattern, shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We first need to identify which part of the function involves external calls, `uint
    amt = userBalances[msg.sender]; userBalances[msg.sender] =0;`.
  prefs: []
  type: TYPE_NORMAL
- en: The function reads `userBalances` value, and assigns it to a local variable,
    then it resets  `userBalances`. These steps are to make sure message sender can
    only transfer to their own account, but can't make any changes to state variables.
    The balance of a user will be reduced before the ether is actually transferred
    to user. If any error occurs during the transfer, the whole transaction will be
    reverted, including the reduction transfer amount of balance in the state variable.
    This approach can be described as *optimistic accounting*, because effects are
    written down as completed, before they actually take place.
  prefs: []
  type: TYPE_NORMAL
- en: DoS with block gas limit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ethereum blockchain transaction can only process a certain amount of gas
    due to the block gas limit, so be careful to look without fixed limited integration.
    When a number of iteration costs go beyond the gas limit, the transaction will
    fail and the contract can be stalled at a certain point. In this case, attackers
    may potentially attack the contract, and manipulate the gas.
  prefs: []
  type: TYPE_NORMAL
- en: Handle errors in external calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, solidity has some low-level call methods: `address.call()`,
    `address.callcode()`, `address.delegatecall()`, and `address.send()`. These methods
    only return false when the call encounters an exception. So handling errors in
    external calls is very important in contracts, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Case study – crowdfunding campaign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement and deploy the smart contract for the crowdfunding
    campaign use case.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of crowd funding is a process of raising funds for a project or venture
    from the masses. Investors receive tokens that represent a share of the startup
    they invested. The project sets up a predefined goal and a deadline for reaching
    it. Once a project misses the goal, the investments are returned, which reduces
    the risk for investors. This decentralized fundraising model can supplant the
    fund need for startup, and there is no need for a centralized trusted platform.
    Investors will only pay the gas fees if the fund returns. Any project contributor
    gets a token, and they can trade, sell, or keep these tokens. In a certain stage,
    the token can be used in exchange for real products as the physical reward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define struct and events, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Define modifiers, shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define smart contract functions, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's use Remix to test our campaign. We select the JavaScript VM option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the campaign by clicking the Deploy button with the following input.
    This will start our campaign by means of the call constructor. We assign the first
    account as the project owner. The minimum funds raised is 30 ether, deadline set
    to five minutes for testing purposes. Put the following input code in the text
    box beside the Deploy button. Here are input parameters for constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot for the Remix editor screen for this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4d027c2-6637-4f10-9b6c-9876b24fa365.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix editor screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the second account and, in the Remix value input field, enter `20`
    ether, and then click (fallback) button. This will add `20` ether to totalRaised.
    To check project information, click project button, and you should see that the
    totalRaised is 20 ethers now. Enter `0` uint in the contributions input field,
    and we can a see second account contribution address, and a fund amount of 20
    ethers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3614c015-62b9-4099-946b-fba6759773ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix value input field
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the third account, enter `15` ethers in the Value field to add funds
    for the project. Click (fallback), and we can see the project total fund raised
    to 35 ethers. At this moment, the project has achieved the campaign goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f05c6fd-a8ec-432a-a509-5233fd19db17.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding funds to the project
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to project owner, which is the first account, and click checkGoalReached. We
    can see that the transaction has been successfully executed. In the logs, the
    project status is updated to "successful". `LogProjectPaid` is triggered. If we
    check Remix account 1, 2, 3, the project owner account now contains a total in
    the region of 135 ethers. Our campaign smart contract was successfully tested
    in Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be3db4a2-282e-45b3-a275-03e6b1093f95.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Successfully testing the campaign in smart contract
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic features of solidity programming. We also
    overviewed current popular smart contract development tools. By exploring common
    patterns and security best practices, we learned how to write better code to avoid
    contract vulnerabilities. Finally, we wrote a crowd funding campaign contract,
    and used Remix to deploy and test our example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a Decentralize application (DApp) for crowdfunding.
  prefs: []
  type: TYPE_NORMAL
