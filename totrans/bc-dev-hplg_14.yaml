- en: Overview of Solidity Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 编程概述
- en: '**Solidity** is a smart contract programming language. It was developed by
    Gavin Wood, Christian Reitwiessner, Alex Beregszaszi, and several Ethereum core
    contributors. It is a JavaScript-like, general-purpose language designed to target
    the **Ethereum virtual machine** (**EVM**). Solidity is one of four languages
    in the Ethereum protocol at the same level of abstraction, the others being Serpent
    (similar to Python), **LLL** (**Lisp-like language**), Vyper (experimental), and
    Mutan (deprecated). The community has slowly converged on solidity. Usually, if
    anyone today talks about smart contracts in Ethereum, they implicitly mean solidity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity** 是一种智能合约编程语言。它由 Gavin Wood、Christian Reitwiessner、Alex Beregszaszi
    和几位以太坊核心贡献者开发。它是一种类似 JavaScript 的通用语言，旨在针对 **以太坊虚拟机**（**EVM**）。Solidity 是以太坊协议中的四种语言之一，与
    Serpent（类似于 Python）、**LLL**（**类 Lisp 语言**）、Vyper（实验性）和 Mutan（已弃用）处于同一抽象层级。社区逐渐趋同于
    Solidity。通常，今天任何人谈论以太坊的智能合约时，都隐含地指的是 Solidity。'
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What is solidity?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Solidity？
- en: Tools for the solidity development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity 开发环境工具
- en: Introduction to smart contracts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约简介
- en: Common smart contract patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见智能合约模式
- en: Smart contract security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约安全
- en: Case study – crowdfunding campaign
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 – 众筹活动
- en: What is solidity?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Solidity？
- en: Solidity is a statically typed contract language that contains state variables,
    functions, and common data types. Developers are able to write decentralized applications
    (DApps) that implement business logic functions in a smart contract. The contract
    verifies and enforces the constraints at compile time, as opposed to runtime.
    Solidity is compiled to EVM executable byte code. Once compiled, the contracts
    are uploaded to the Ethereum network. The blockchain will assign an address to
    the smart contract. Any permissioned user on the blockchain network can call a
    contract function to execute the smart contract.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是一种静态类型的合约语言，包含状态变量、函数和常见数据类型。开发者可以编写实现智能合约中业务逻辑函数的去中心化应用程序（DApps）。合约在编译时验证和强制约束，而不是在运行时。Solidity
    被编译成 EVM 可执行字节码。一旦编译完成，合约被上传到以太坊网络。区块链将为智能合约分配一个地址。区块链网络上的任何有权限的用户都可以调用合约函数来执行智能合约。
- en: 'Here is a typical flow diagram showing the process from writing contract code
    to deploying and running it on the Ethereum network:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的流程图，展示了从编写合约代码到在以太坊网络上部署和运行的过程：
- en: '![](img/b0f65a84-129e-4c66-84a5-9bb401c3d4c9.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0f65a84-129e-4c66-84a5-9bb401c3d4c9.png)'
- en: Tools for solidity development environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 开发环境工具
- en: Smart contract development is still in its infancy. Creating such contracts
    and interacting with them in a convenient manner can be done in a multitude of
    ways.  The following powerful tools can be used to build, monitor, and deploy
    your smart contracts for development on the Ethereum platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约开发仍处于起步阶段。创建这样的合约并以方便的方式与之交互可以通过多种方式实现。以下强大的工具可用于在以太坊平台上构建、监视和部署您的智能合约开发。
- en: Browser-based IDE
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于浏览器的集成开发环境（IDE）
- en: In this section, we will be looking at onlien browser based tools such as Remix
    and EthFiddle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分，我们将看看像 Remix 和 EthFiddle 这样的在线浏览器工具。
- en: Remix
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remix
- en: 'Remix is a powerful, open source, smart contract tool that helps you write
    solidity code just from the browser. It supports compile, run, analysis, testing,
    and debugger options. The following three types of environments are available
    with Remix when developing and testing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是一个强大的、开源的智能合约工具，可以帮助你直接从浏览器中编写 Solidity 代码。它支持编译、运行、分析、测试和调试选项。在开发和测试时，Remix
    提供了以下三种环境：
- en: '**JavaScript VM**: Remix comes with five Ethereum accounts, and each account
    is deposited with 100 ethers as default. This is convenient for testing smart
    contracts in the development phase. Mining is not required as it is done automatically.
    This option is a good choice when you are a beginner.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript VM**：Remix 自带五个以太坊账户，每个账户默认存入 100 以太币。这对于在开发阶段测试智能合约非常方便。不需要进行挖矿，因为这是自动完成的。当你是一个初学者时，这个选项是一个不错的选择。'
- en: '**Injected Web3**: This option will directly invoke injected browser web3 instances
    such as MetaMask, an Ethereum network browser extension. MetaMask provides you
    with many functions and features, and, like regular Ethereum wallets, it allows
    you to interact with DApps.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入的 Web3**：此选项将直接调用注入的浏览器 web3 实例，如 MetaMask，以太坊网络浏览器扩展。MetaMask 提供了许多功能和特性，就像普通的以太坊钱包一样，它允许您与
    DApp 进行交互。'
- en: '**Web3 provider**: Remix also supports Web3 provider. The web3.js library is
    the official Ethereum JavaScript API. It is used to interact with Ethereum smart
    contracts. You can connect to the blockchain network through web3j API. Web3j
    supports three different providers: HTTPProvider, WebsocketProvider, and IpcProvider.
    In Remix Web3, you can give the HTTP URL to connect the remote blockchain instance.
    The URL can point to your local private blockchain, test-net, and other instance
    endpoints.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web3提供者**：Remix 还支持 Web3 提供者。web3.js 库是官方的以太坊 JavaScript API。它用于与以太坊智能合约进行交互。您可以通过
    web3j API 连接到区块链网络。Web3j 支持三种不同的提供者：HTTPProvider、WebsocketProvider 和 IpcProvider。在
    Remix Web3 中，您可以提供 HTTP URL 来连接远程区块链实例。该 URL 可以指向您的本地私有区块链、测试网和其他实例端点。'
- en: 'Start by using the Remix solidity IDE:  [https://remix.ethereum.org](https://remix.ethereum.org).
    The following is the screenshot for the UI of Remix:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 Remix solidity IDE：[https://remix.ethereum.org](https://remix.ethereum.org)。以下是
    Remix 的 UI 截图：
- en: '![](img/8f8a62a2-d60c-43d5-b345-5b6855820378.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f8a62a2-d60c-43d5-b345-5b6855820378.png)'
- en: EthFiddle
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EthFiddle
- en: 'EthFiddle is a very simple solidity browser-based development tool. You can
    quickly test and debug smart contract code, and share a permalink to your code.
    One feature that makes EthFiddle stand out is its potential to perform security
    audits. The following screenshot shows the software interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: EthFiddle 是一个非常简单的 solidity 基于浏览器的开发工具。您可以快速测试和调试智能合约代码，并分享代码的永久链接。使 EthFiddle
    突出的一个功能是其进行安全审计的潜力。以下截图显示了软件界面：
- en: '![](img/b9894b6e-cef9-4e81-b194-7cc5b6e3eef1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9894b6e-cef9-4e81-b194-7cc5b6e3eef1.png)'
- en: Interface of EthFiddle software
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: EthFiddle 软件界面
- en: Here is the EthFiddle solidity IDE link:  [https://ethfiddle.com](https://ethfiddle.com).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 EthFiddle solidity IDE 的链接：[https://ethfiddle.com](https://ethfiddle.com)。
- en: Command-line development management tools
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行开发管理工具
- en: The command-line tools are server-side Ethereum tools used to create a basic
    structure of a DApp project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具是服务器端以太坊工具，用于创建 DApp 项目的基本结构。
- en: Truffle
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle
- en: 'Truffle is a popular development environment and testing framework, and is
    an asset pipeline for Ethereum. Truffle''s major features include the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 是一个流行的以太坊开发环境和测试框架，是以太坊的资产管道。Truffle 的主要功能包括以下内容：
- en: Built-in smart contract compilation, linking, deployment, and binary management
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置智能合约编译、连接、部署和二进制管理
- en: 'Automated contract testing with Mocha and Chai s Truffle site link: http'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mocha 和 Chai 进行自动合约测试的 Truffle 网站链接：http
- en: Scriptable deployment and migrations framework
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编写的部署和迁移框架
- en: Network management for deploying to many public and private networks
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到多个公共和私人网络的网络管理
- en: Interactive console for direct contract communication
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于直接与合同通信的交互式控制台
- en: We will discuss in more detail in the next chapter, and we will use Truffle
    to development DApp for ERC20 token
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在下一章节中进行更详细的讨论，并使用 Truffle 开发 ERC20 代币的 DApp。
- en: 'Here is Truffle''s site link: [https://truffleframework.com/](https://truffleframework.com/)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是 Truffle 的网站链接：[https://truffleframework.com/](https://truffleframework.com/)
- en: Introduction to smart contracts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约简介
- en: 'Let''s begin with the most basic smart contract example,  `HelloWorld.sol`, shown
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的智能合约示例`HelloWorld.sol`开始，如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Solidity's file extension is `.sol`.  It is similar to `.js` for JavaScript
    files, and `.html` for HTML templates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 的文件扩展名是`.sol`。它类似于 JavaScript 文件的`.js`，以及 HTML 模板的`.html`。
- en: Layout of a solidity source file
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: solidity 源文件布局
- en: 'A solidity source file is typically composed of the following constructs: pragma,
    comments, and import.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 solidity 源文件通常由以下结构组成：pragma、注释和导入。
- en: Pragma
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pragma
- en: The first line containing the keyword pragma simply says that the source code
    file will not compile with a compiler earlier than version 0.4.24\. Anything newer
    does not break functionality. The `^` symbol implies another condition—the source
    file will not work either on compilers beyond version 0.5.0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含关键字 pragma 的源代码文件简单地指出该文件不会与版本早于 0.4.24 的编译器一起编译。任何新版本也不会破坏功能。符号 `^` 暗示另一个条件
    - 源文件也不会适用于版本大于 0.5.0 的编译器。
- en: Comments
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Comments are used to make the source code easier for humans to understand the
    function of the program. Multi-line comments are used for large text descriptions
    of code. Comments are ignored by the compiler. Multi-line comments start with
    `/*` and end with `*/`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注释用于使源代码更容易让人类理解程序的功能。多行注释用于对代码进行大文本描述。编译器会忽略注释。多行注释以 `/*` 开始，以 `*/` 结束。
- en: 'In the `HelloWorld` example, there are comments for the `set` and `get` methods:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HelloWorld` 示例中，对 `set` 和 `get` 方法有注释：
- en: 'Method: The `setNewGreeting (string _newGreeting) {}` function'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`setNewGreeting(string _newGreeting) {}` 函数
- en: '`@param`: This is used to indicate what parameters are being passed to a method,
    and what value they''re expected to have'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@param`：这用于指示将哪些参数传递给方法，以及它们预期的值是什么'
- en: Import
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: The import keyword in solidity is very similar to JavaScript's past version,
    ES6\. It is used to import libraries and other related features into your solidity
    source file. Solidity does not support export statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 中的 import 关键字与 JavaScript 的过去版本 ES6 非常相似。它用于将库和其他相关功能导入到您的 solidity
    源文件中。Solidity 不支持 export 语句。
- en: 'Here are a few import examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些导入示例：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding line shown will create a global symbol called `symbolName`, containing
    the global symbol's member from the import file: `solidityFile`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行将创建一个名为 `symbolName` 的全局符号，其中包含从导入文件 `solidityFile` 中的全局符号成员。
- en: 'Another solidity-specific syntax equivalent to the preceding import is the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与前述导入相当的 solidity 特定语法是以下内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also import multiple symbols, and name some of the symbols as alias,
    demonstrated as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以导入多个符号，并将其中一些符号命名为别名，如下所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an example where an ERC20 token is created using the zeppelin solidity
    libraries:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 zeppelin solidity 库创建 ERC20 代币的示例：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the example shown in the preceding code snippet, we imported the `SafeMath`
    library from Zeppelin and applied it to `uint256`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述代码片段中显示的示例，我们从 Zeppelin 导入了 `SafeMath` 库，并将其应用于 `uint256`。
- en: Paths
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: 'When importing a solidity file, the file path follows a few simple syntax rules:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入一个 solidity 文件时，文件路径遵循一些简单的语法规则：
- en: 'Absolute paths: `/folder1/ folder2/xxx.sol` starting from `/`, the path location
    is from same solidity file location to the imported files. In our ERC 20 example,
    this is shown as follows:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径：`/folder1/ folder2/xxx.sol` 从 `/` 开始，路径位置是从相同的 solidity 文件位置到导入的文件。在我们的
    ERC 20 示例中，如下所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The actual project structure appears as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际项目结构如下所示：
- en: '![](img/f449d45d-fe7a-40a3-8a9e-5726e8103b22.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f449d45d-fe7a-40a3-8a9e-5726e8103b22.png)'
- en: Relative paths
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对路径
- en: '`../folder1/folder2/xxx.sol`: these paths are interpreted relative to the location
    of the current file, `.` as the current directory, and `..` as the parent directory.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`../folder1/folder2/xxx.sol`：这些路径是相对于当前文件的位置进行解释的，`.` 表示当前目录，`..` 表示上级目录。'
- en: 'In the solidity path, it is possible to specify path prefix remappings. As
    an example, if you want to import `github.com/ethereum/dapp-bin/library`, you
    can first clone the GitHub library to `/usr/local/dapp-bin/library`, and then
    run the compiler command, shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 solidity 路径中，可以指定路径前缀重映射。例如，如果要导入 `github.com/ethereum/dapp-bin/library`，可以先将
    GitHub 库克隆到 `/usr/local/dapp-bin/library`，然后运行如下所示的编译器命令：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, in our solidity file, you can use the following `import` statement. It
    will remap to `/usr/local/dapp-bin/library/stringUtils.sol`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 solidity 文件中，您可以使用以下 `import` 语句。它将重映射到 `/usr/local/dapp-bin/library/stringUtils.sol`：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler will read the files from there.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将从那里读取文件。
- en: Structure of a contract
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合约的结构
- en: 'A contract includes the following constructs: state variables, data type, functions,
    events, modifiers, enum, struct, and mapping.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 合约包括以下构造：状态变量，数据类型，函数，事件，修饰符，枚举，结构和映射。
- en: State variables
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态变量
- en: State variables are values that are permanently stored in contract storage,
    and are used to maintain the contract's state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变量是永久存储在合约存储中的值，并用于维护合约的状态。
- en: 'The following is an example of the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码示例：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Data type
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: Solidity is a statically typed language. Developers familiar with language such
    as JavaScript and Python will find Solidity syntax easy to pick up. Each variable
    needs to specify the data type. The variable, which will always be passed by value,
    is called value types, it is built-in or predefined data types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是一种静态类型语言。熟悉 JavaScript 和 Python 等语言的开发人员会发现 Solidity 语法很容易上手。每个变量都需要指定数据类型。永远传递的变量称为值类型，它是内置或预定义的数据类型。
- en: 'The value types in solidity are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 中的值类型如下：
- en: '| **Types** | **Operators** | **Example** | **Note** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **运算符** | **示例** | **注意** |'
- en: '| `Bool` | !, &&, &#124;&#124;, ==, != | `bool a = true;` | The Booleans are
    true or false expressions. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | !、&&、&#124;&#124;、==、!= | `bool a = true;` | 布尔表达式为 true 或 false。
    |'
- en: '| `Int` (int8 to int256) | Comparison operators:<=, <, ==, !=, >=, >,Bit operators:
    &, &#124;, ^, +, -, unary -, unary +, *, /, %, **, <<, >> | `int a = 1;` | Signed
    integer, signed of 8 up to 256 bits, in the step of 8. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Int`（int8 到 int256） | 比较运算符：<=、<、==、!=、>=、>、位运算符：&、&#124;、^、+、-、一元 -、一元
    +、*、/、%、**、<<、>> | `int a = 1;` | 有符号整数，从 8 到 256 位，步长为 8。 |'
- en: '| `Uint` (uint8 to uint256) | Comparison operators: <=, <, ==, !=, >=, >Bit
    operators: &, &#124;, ^, +, -, unary -, unary +, *, /, %, **, <<, >> | `uint maxAge
    = 100;` | Unsigned  integer, unsigned of 8 up to 256 bits, in the step of 8. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Uint`（uint8 到 uint256） | 比较运算符：<=、<、==、!=、>=、>位运算符：&、&#124;、^、+、-、一元 -、一元
    +、*、/、%、**、<<、>> | `uint maxAge = 100;` | 无符号整数，从 8 到 256 位，步长为 8。 |'
- en: '| Address | <=, <, ==, !=, >= ,> |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 地址 | <=、<、==、!=、>=、> |'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Holds a 20 byte value (size of an Ethereum address). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 保存 20 字节值（以太坊地址的大小）。 |'
- en: '| `<address>.balance` |  | `address.balance()` | Addresses members and <indexentry
    content="value types, solidity:.balance">returns the balance of the address in
    Wei. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.balance` |  | `address.balance()` | 地址成员，并返回地址的以太币余额。 |'
- en: '| `<address>.transfer` |  | `beneficiary.transfer(highestBid)` | Addresses
    members and sends ether (in units of Wei) to an address. If the transfer operation
    fails, it `<indexentry content="value types, solidity:.transfer">`throws an exception,
    and all of the changes in a transaction are reverted. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.transfer` |  | `beneficiary.transfer(highestBid)` | 地址成员，并向地址发送以太币（以
    Wei 为单位）。如果转账操作失败，则抛出异常，并撤销交易中的所有更改。 |'
- en: '| `<address>.send` |  | `msg.sender.send(amount)` | Addresses members and send
    ether (in units of Wei) to an address. If the send operation fails, it returns
    false. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.send` |  | `msg.sender.send(amount)` | 地址成员，并向地址发送以太币（以 Wei 为单位）。如果发送操作失败，则返回
    false。 |'
- en: '| `<address>.call` |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.call` |  |'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Executed code of another contract, returns false in the event of failure,
    forwards all available gas, adjustable, should be used when you need to control
    how much gas to forward. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 另一个合约的执行代码，在失败的情况下返回 false，转发所有可用的 gas，可调节，当您需要控制要转发多少 gas 时应该使用。 |'
- en: '| `<address>.delegatecall` |  | `, _library.delegatecall(msg.data);` | Executed
    code of another contract, but with the state (storage) of the calling contract.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.delegatecall` |  | `, _library.delegatecall(msg.data);` | 执行另一个合约的代码，但使用调用合约的状态（存储）。
    |'
- en: '| Fixed size byte array(bytes1, bytes2, …, bytes32) | Comparison operators:
    <=, <, ==, !=, >=, >,Bit operators: &, &#124;, ^ ,~,<<, >>,get array data : array[index]
    | `uint8[5] memory traits = [1,2,3,4,5];` | Fixed size byte arrays are defined
    using the keyword byteN, the N being any number from 1 to 32, it limits the size,
    it will be a lot cheaper and will save you gas. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 固定大小的字节数组（bytes1、bytes2、...、bytes32） | 比较运算符：<=、<、==、!=、>=、>、位运算符：&、&#124;、^、~、<<、>>、获取数组数据：array[index]
    | `uint8[5] memory traits = [1,2,3,4,5];` | 使用关键字 byteN 定义固定大小的字节数组，其中 N 是从 1
    到 32 的任意数字，它限制了大小，会更便宜，也会节省 gas。 |'
- en: '| Dynamically-sized array bytes string |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 动态大小的数组 bytes string |  |'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Solidity supports a dynamically-sized byte array and a dynamically-sized
    UTF-8-encoded string. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Solidity 支持动态大小的字节数组和动态大小的 UTF-8 编码字符串。 |'
- en: '| Hexadecimal literals |  | `hex"1AF34A"` | Hexadecimal literals are prefixed
    with the keyword hex and are enclosed in single or double quotes. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制字面量 |  | `hex"1AF34A"` | 十六进制字面量以关键字 hex 为前缀，并用单引号或双引号括起来。 |'
- en: '| Address literals |  | `0x5eD8Cee6b63b1c6AFce``3AD7c92f4fD7E1B8fAd9F` | It
    is hexadecimal literals that pass the address checksum test. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 地址字面量 |  | `0x5eD8Cee6b63b1c6AFce3AD7c92f4fD7E1B8fAd9F` | 它是经过地址校验和测试的十六进制字面量。
    |'
- en: '| String literals |  | `"Hello”` | String literals are normally written with
    either single or double quotes. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 字符串字面量 |  | `"Hello"` | 字符串字面量通常用单引号或双引号写。 |'
- en: Enum type
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'Enum is a type with a restricted set of constants values. Here is an example,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种带有一组受限制的常量值的类型。以下是示例：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Struct type
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体类型
- en: 'A struct is a type that contains named fields. New types can be declared using
    struct. Here is an example in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是一种包含命名字段的类型。可以使用结构体声明新类型。以下是代码示例：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mapping
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Mappings act as hash tables that consist of key types and corresponding value
    type pairs. Here is an example, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 映射充当由键类型和相应值类型对组成的哈希表。以下是示例：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are the executable units of code within a contract. Here is a function
    structure in solidity, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是合同内代码的可执行单元。以下是Solidity中函数的结构：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Input parameters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入参数
- en: Function can pass input parameters. The input parameters are declared the same
    way as variables are.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以传递输入参数。输入参数的声明方式与变量相同。
- en: 'In the previous `HelloWorld` example, we define `setNewGreeting` using the
    input parameter, `string _newGreeting`.  Here is an example of this step:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个`HelloWorld`示例中，我们使用输入参数`string _newGreeting`定义了`setNewGreeting`。以下是此步骤的示例：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Access modifiers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Solidity access modifiers are used to provide access control in Solidity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity访问修饰符用于在Solidity中提供访问控制。
- en: 'There are four types of access modifiers available in Solidity, listed as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中有四种类型的访问修饰符，列举如下：
- en: '**Public**: Accessible from this contract, inherited contracts, and externally'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：可以从此合同、继承的合同和外部访问'
- en: '**Private**: Accessible only from this contract'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**：只能从此合同访问'
- en: '**Internal**: Accessible only from this contract and contracts inheriting from
    it'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internal**：只能从此合同和继承自它的合同访问'
- en: '**External**: Cannot be accessed internally, only externally'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**External**：无法在内部访问，仅可外部访问'
- en: Output parameters
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出参数
- en: 'The output parameters can be declared after the `return` keyword, as shown
    in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出参数可以在`return`关键字之后声明，如下所示的代码片段：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In solidity, `pure` functions are functions that are promised not to modify,
    or read the state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，`pure`函数是承诺不修改或读取状态的函数。
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the function modifier is defined as view, it indicates that the function
    will not change the storage state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数修饰符定义为view，则表示该函数不会更改存储状态。
- en: If the function modifier is defined as pure, it indicates that the function
    will not read the storage state.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数修饰符定义为pure，则表示该函数不会读取存储状态。
- en: If the function modifier is defined as constant, it indicates that the function
    won't modify the contract storage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数修饰符定义为constant，则表示该函数不会修改合同存储。
- en: If the function modifier is defined as payable, modifier can receive funds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数修饰符定义为payable，则修饰符可以接收资金。
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the `buy` function has a payable modifier, which makes
    sure you can send ethers to the `buy` function. A function without any name, and
    annotated with a payable keyword, is called a payable fallback function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`buy`函数具有可支付修饰符，这确保您可以向`buy`函数发送以太。没有任何名称，并用可支付关键字注释的函数称为可支付回退函数。
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Modifiers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'In solidity, the modifier is used to change the behavior of a function. They
    can automatically check a condition prior to executing the function. Here is an
    example, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，修饰符用于更改函数的行为。它们可以在执行函数之前自动检查条件。以下是示例：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Events
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are used to track the execution of a transaction sent to a contract.
    There are convenient interfaces with the EVM logging facilities. Here is an example,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事件用于跟踪发送到合同的交易的执行情况。有与EVM日志记录设施方便的接口。以下是示例：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Constructor
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: The constructor method is a special method for creating and initializing a contract.
    In solidity v0.4.23, Solidity introduced this new constructor notation and the
    old one was deprecated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是创建和初始化合同的特殊方法。在Solidity v0.4.23中，Solidity引入了这种新的构造函数表示法，旧的构造函数已被弃用。
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Constant state variables, unit, and functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量状态变量、单位和函数
- en: The value of a constant cannot change through reassignment, and it can't be
    redeclared after compile time. In solidity, a state variable can be declared as
    constant. It does not allow reassignment to blockchain data (for example, this
    `.balance`, `block.blockhash`), or execution data (`tx.gasprice`), or make calls
    to external contracts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的值不能通过重新分配来更改，并且在编译时间后不能重新声明。在 solidity 中，状态变量可以声明为常量。它不允许重新分配到区块链数据（例如，`this.balance`，`block.blockhash`）或执行数据（`tx.gasprice`），或调用外部合约。
- en: 'The following table out the solidity global variables and their built-in functions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 solidity 全局变量及其内建函数：
- en: '| **Global variables / functions** | **Description** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **全局变量 / 函数** | **描述** |'
- en: '| `msg.sender(address)` | `msg.sender` is the address currently interacting
    with the contract call message. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `msg.sender(address)` | `msg.sender` 是当前与合约调用消息交互的地址。 |'
- en: '| `msg.data(bytes)` | `msg.data` is the address currently interacting with
    the contract complete call. The data is in bytes. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `msg.data(bytes)` | `msg.data` 是当前与合约进行交互的地址的完整调用。数据以字节形式呈现。 |'
- en: '| `msg.value(unit)` | `msg.value` is the address currently interacting with
    the number of Wei sent with message as per the contract. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `msg.value(unit)` | `msg.value` 是当前与合约交互的地址，根据合约发送的消息的 Wei 数量。 |'
- en: '| `msg.sig` | `msg.sig` is the address currently interacting with the contract
    that returns the first four bytes of the call data. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `msg.sig` | `msg.sig` 是当前与合约交互的地址，返回调用数据的前四个字节。 |'
- en: '| `gasleft() returns (uint256)` | API to check the gas remaining. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `gasleft() returns (uint256)` | API 用于检查剩余的燃气。 |'
- en: '| `tx.origin` | API to check the sender of the transaction. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `tx.origin` | API 用于检查交易的发送方。 |'
- en: '| `tx.gasprice` | API to check the gas price of the transaction. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `tx.gasprice` | API 用于检查交易的燃气价格。 |'
- en: '| `now` | Get current unix timestamp. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `now` | 获取当前的 Unix 时间戳。 |'
- en: '| `block.number` | API to retrieve the current block number. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `block.number` | API 用于检索当前区块编号。 |'
- en: '| `block.difficulty` | API to retrieve the current block difficulty. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `block.difficulty` | API 用于检索当前区块的难度。 |'
- en: '| `block.blockhash(uint blockNumber) returns (bytes32)` | API to get the hash
    of the given block; the result only returned the 256 most recent blocks. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `block.blockhash(uint blockNumber) returns (bytes32)` | API 用于获取给定区块的哈希；结果仅返回最近的
    256 个区块。 |'
- en: '| `block.gasLimit(unit)` | API to get the current block gas limit. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `block.gasLimit(unit)` | API 用于获取当前区块的燃气限制。 |'
- en: '| `block.coinbase ()` | Returns the current block miner''s address. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `block.coinbase ()` | 返回当前区块矿工的地址。 |'
- en: '| `keccak256(...);` | Returns (bytes32) compute the Ethereum-SHA-3 (Keccak-256)
    hash of the (tightly packed) arguments. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `keccak256(...);` | 返回（bytes32）：计算（紧密打包的）参数的 Ethereum-SHA-3（Keccak-256）哈希。
    |'
- en: '| `sha3(...)` | Returns (bytes32): an alias to keccak256. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `sha3(...)` | 返回（bytes32）：keccak256 的别名。 |'
- en: '| `assert(bool condition)` | `assert` can be used to check for conditions.
    It indicates something that should never be false under any circumstances. Furthermore, `assert` uses
    the `0xfe` opcode to cause an error condition. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `assert(bool condition)` | `assert` 用于检查条件。它表示在任何情况下都不应该为假的东西。此外，`assert`
    使用 `0xfe` 操作码来引发错误条件。 |'
- en: '| `require(bool condition)` | The `require` function should be used to ensure
    valid conditions. It can return false when the user enters something inappropriate.
    Furthermore, `require()` uses the `0xfd` opcode to cause an error condition. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `require(bool condition)` | 应该使用 `require` 函数来确保有效的条件。当用户输入不当的内容时，它可能返回 false。此外，`require()`
    使用 `0xfd` 操作码来引发错误条件。 |'
- en: '| `revert()` | `revert` will still undo all state changes. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `revert()` | `revert` 仍然会撤消所有状态更改。 |'
- en: '| `<address>.balance` | It checks the balance of the address in Wei (uint256).
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.balance` | 它检查地址的 Wei 余额（uint256）。 |'
- en: '| `<address>.send(uint256 amount) returns (bool)` | API sends the amount of
    Wei to address and returns false in the event failure. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.send(uint256 amount) returns (bool)` | API 将 Wei 量发送到地址，并在失败时返回
    false。 |'
- en: '| `<address>.transfer(uint256 amount)` | API transfer the amount of Wei to
    the address, and throws error when transfer fails. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `<address>.transfer(uint256 amount)` | API 将 Wei 量转移到地址，并在转移失败时抛出错误。 |'
- en: '| `this` | The current contract, explicitly convertible to address. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `this` | 当前合约，显式转换为地址。 |'
- en: '| `super` | The contract one level higher in the inheritance hierarchy. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `super` | 继承层次结构中更高一级的合约。 |'
- en: '| `selfdestruct(address recipient)` | `self-destruct` will destroy the current
    contract, and storage associated with it is removed from the Ethereum''s world
    state. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `selfdestruct(address recipient)` | `self-destruct` 将销毁当前合约，并从以太坊的世界状态中删除与之相关的存储。
    |'
- en: '| `suicide(address recipient)` | An alias to self-destruct. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `suicide(address recipient)` | `self-destruct` 的别名。 |'
- en: Ether units
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太单位
- en: 'Solidity ether  is dividable into Wei, Kwei, Mwei, Gwei, Szabo, Finney, Kether,
    Mether, Gether, and Tether. The following are the conversion units:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 中的以太可分为 Wei、Kwei、Mwei、Gwei、Szabo、Finney、Kether、Mether、Gether 和 Tether。以下是转换单位：
- en: 1 ether = 1,000 Finney
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 ether = 1,000 Finney
- en: 1 Finney = 1,000 Szabo
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Finney = 1,000 Szabo
- en: 1 Szabo = 1,000 Mwei
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Szabo = 1,000 Mwei
- en: 1 Mwei = 1,000 Kwei
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Mwei = 1,000 Kwei
- en: 1 Kwei = 1,000 Wei
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Kwei = 1,000 Wei
- en: Time units
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间单位
- en: 'A solidity time unit is dividable into seconds, minutes, hours, days, weeks,
    and years. The following are the conversion units:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Solidity 时间单位可分为秒、分钟、小时、天、周和年。以下是转换单位：
- en: 1 = 1 second
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 = 1 秒
- en: 1 minute = 60 seconds
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 分钟 = 60 秒
- en: 1 hour = 60 minutes
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 小时 = 60 分钟
- en: 1 day = 24 hours
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 天 = 24 小时
- en: 1 week = 7 days
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 周 = 7 天
- en: 1 year = 365 days
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 年 = 365 天
- en: Inheritance, abstract, and interface
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承、抽象和接口
- en: Many of the most widely used programming languages (such as C++, Java, Go, and
    Python, and so on) support **object-oriented programming** (**OOP**) and support
    inheritance, encapsulation, abstraction, and polymorphism. Inheritance enables
    code reuse and extensibility. Solidity supports multiple inheritance in the form
    of copying code, which includes polymorphism. Even if a contract inherits from
    multiple other contracts, only a single contract is created on the blockchain.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 许多最广泛使用的编程语言（如 C++、Java、Go 和 Python 等）支持**面向对象编程**（**OOP**），并支持继承、封装、抽象和多态。继承使代码重用和可扩展性成为可能。Solidity
    支持通过复制代码的方式实现多重继承，其中包括多态性。即使合约从多个其他合约继承，也只会在区块链上创建一个单一合约。
- en: 'In solidity, inheritance is pretty similar to classic oriented-object programming
    languages. Here are a number of examples, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中，继承与经典的面向对象编程语言非常相似。以下是一些示例：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Dog inherits from `Mammal`, whose parent contract is `Animal`. When calling
    `Dog.run()`, it will call its parent method `run()` and return ten. When calling
    name, `Dog.name()` will override its patent method and return the output from
    `Dog`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Dog 从 `Mammal` 继承，其父合约是 `Animal`。调用 `Dog.run()` 时，将调用其父方法 `run()` 并返回十。调用 name，`Dog.name()`
    将覆盖其父方法并返回 `Dog` 的输出。
- en: In solidity, a method without a body (no implementation) is known as an abstract
    method. A contract that contains an abstract method cannot be instantiated, but
    can be used as a base.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中，没有主体（无实现）的方法称为抽象方法。包含抽象方法的合约无法实例化，但可以用作基类。
- en: If a contract inherits from an abstract contract, then the contract must implement
    all the abstract methods of abstract parent class, or it has to be declared abstract
    as well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个合约从抽象合约继承，那么合约必须实现抽象父类的所有抽象方法，或者它也必须声明为抽象。
- en: Dog has a concrete `color()` method, which is a concrete contract and can be
    compiled, but the parent contract—mammal, and the grandparent contract—animal,
    are still abstract contracts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Dog 有一个具体的 `color()` 方法，这是一个具体的合约，可以编译，但父合约—mammal，和祖父合约—animal，仍然是抽象合约。
- en: 'Interfaces in solidity are similar to abstract contracts; they are implicitly
    abstract and cannot have implementations. An abstract contract can have instance
    methods that implement a default behavior. There are more restrictions in interfaces,
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 中的接口类似于抽象合约；它们隐式地是抽象的，不能有实现。抽象合约可以具有实例方法，实现默认行为。接口中有更多的限制，如下所示：
- en: Cannot inherit other contracts or interfaces
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能继承其他合约或接口
- en: Cannot define constructor
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能定义构造函数
- en: Cannot define variables
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能定义变量
- en: Cannot define structs
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能定义结构体
- en: Cannot define enums
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能定义枚举
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the contract is an interface, `contract B` implements
    `interface A`, and has a concrete `doSomething()` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，合约是一个接口，`contract B` 实现了 `interface A`，并且有一个具体的 `doSomething()` 方法。
- en: Common smart contract patterns
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的智能合约模式
- en: In this section, we will discuss some common design and programming patterns
    for the smart contract programming language.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论智能合约编程语言的一些常见设计和编程模式。
- en: Access restriction
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问限制
- en: Access restriction is a solidity security pattern.  It only allows authorized
    parties to access certain functions. Due to the public nature of the blockchain,
    all data on the blockchain is visible to anyone. It is critical to declare your
    contract function, state with restricted access control, and provide security
    against unauthorized access to smart contract functionality.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 限制访问是一种 solidity 安全模式。它只允许授权方访问特定功能。由于区块链的公开性质，区块链上的所有数据对任何人都是可见的。关键是声明你的合约函数、受限访问控制的状态，并提供对智能合约功能的未经授权访问的安全性。
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding example shows the access restrict pattern applied  to a contract.
    We first define a parent class called `Ownable` with `onlyOwner`, `changeOwner`,
    and `onlyAfter` function modifiers.  Other contracts can inherit from this contract
    to use defined access restriction. `SampleContract` inherits from `Ownable` contract
    and therefore, only the owner can access `setValue` function. Furthermore,  `forceOwnerChange`
    may only be called two weeks after the contract creation time with 50 ether cost,
    and only the owner has permission to execute the function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了访问限制模式应用于合约。我们首先定义了一个名为`Ownable`的父类，其中包含`onlyOwner`、`changeOwner`和`onlyAfter`函数修饰符。其他合约可以继承自此合约以使用定义的访问限制。`SampleContract`继承自`Ownable`合约，因此只有所有者可以访问`setValue`函数。此外，`forceOwnerChange`只能在合同创建后两周内以50以太币的成本进行调用，只有所有者才有权限执行该功能。
- en: State machine
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机
- en: 'State machine is a behavior design pattern.  It allows a contract to alter
    its behavior when it''s internal state changes. A smart contract function call
    typically moves a contract state from one stage to the next stage. The basic operation
    of a state machine has two parts:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一种行为设计模式。它允许合约在其内部状态改变时改变其行为。智能合约函数调用通常会将合约状态从一个阶段移动到下一个阶段。状态机的基本操作包括两个部分：
- en: It traverses through a sequence of states, where the next state is determined
    by the present state, and input conditions.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历一系列状态，其中下一个状态由当前状态和输入条件决定。
- en: It provides sequences of outputs based upon state transitions.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据状态迁移提供输出序列。
- en: 'To illustrate this, let''s develop a simple state machine. We will use washing
    dishes as an example. The process typically is *scrub, rinse, dry, scrub, rinse,
    dry*. We defined state machine stages as an enumerated type.  As this is an extensive
    use case, only the state machine related code is presented. Any logic for detailed
    action implementation, such as `rinse()`, `dry()` and so on are omitted. See the
    following example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们开发一个简单的状态机。我们以洗碗为例。通常的过程是*擦洗，冲洗，晾干，擦洗，冲洗，晾干*。我们将状态机阶段定义为一个枚举类型。由于这是一个广泛的用例，此处仅介绍了与状态机相关的代码。省略了任何详细动作实现的逻辑，如`rinse()`、`dry()`等。请参见以下示例：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We define function modifier `atStage` to check if the current state allows the
    stage to run the function. Furthermore, `transitionNext` modifier will call the
    internal method `nextStage()` to move state to next stage.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了函数修饰符`atStage`来检查当前状态是否允许该阶段运行函数。此外，`transitionNext`修饰符将调用内部方法`nextStage()`来将状态移动到下一个阶段。
- en: Smart contract security
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约安全
- en: Once a smart contract has been deployed on the Ethereum network, it is immutable
    and public to everyone. Many of the smart contract functions are account payment
    related; therefore, security and testing become absolutely essential for a contract
    before being deployed on the main network. Following are security practices that
    will help you better design and write flawless Ethereum smart contracts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约部署在以太坊网络上，它就是不可变的，并且对所有人都是公开的。许多智能合约功能与账户支付相关；因此，在部署到主网络之前，安全性和测试对合约都至关重要。以下是有助于您更好地设计和编写无瑕疵以太坊智能合约的安全实践。
- en: Keep contract simple and modular
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持合约简单和模块化
- en: Try to keep your smart contract small, simple, and modularized. Complicated
    code is difficult to read, understand, and debug, it is also error-prone.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量保持您的智能合约小、简单和模块化。复杂的代码很难阅读、理解和调试，并且容易出错。
- en: Use well-written library tools where possible.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用写好的库工具。
- en: Limit the amount of local variables.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 限制本地变量的数量。
- en: Move unrelated functionality to other contracts or libraries.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将不相关功能移动到其他合约或库中。
- en: Use the checks-effects-interactions pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用检查-效果-交互模式
- en: Be very careful when interacting with other external contracts, it should be
    the last step in your function. It can introduce several unexpected risks or errors.
    External calls may execute malicious code. These kinds of calls should be considered
    as potential security risks and avoided if possible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他外部合约交互时要非常小心，这应该是你的函数中的最后一步。它可能引入几个意外的风险或错误。外部调用可能执行恶意代码。如果可能的话，应该考虑这些调用作为潜在的安全风险，并尽量避免。
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The line `msg.sender.call.value(userBalances[msg.sender])` is an external call,
    when `withdrawBalance` is called, it will send ether with the `address.call.value()`.
    The hacker can attack fund contracts by triggering the hack fallback function,
    which can call the `withdrawBalance` method again. This will allow the attacker
    to refund multiple times, draining all ether in accounts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 行`msg.sender.call.value(userBalances[msg.sender])`是一个外部调用，在调用`withdrawBalance`时，它将使用`address.call.value()`发送以太。黑客可以通过触发攻击回退函数来攻击资金合约，这将再次调用`withdrawBalance`方法。这将允许攻击者多次退款，耗尽账户中的所有以太。
- en: 'The preceding contract vulnerabilities is called reentrancy. To avoid this,
    you can use the checks-effects-interactions pattern, shown in the following example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述合约漏洞称为递归调用。为了避免这种情况，您可以使用检查-效果-交互模式，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We first need to identify which part of the function involves external calls, `uint
    amt = userBalances[msg.sender]; userBalances[msg.sender] =0;`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确定函数的哪一部分涉及到外部调用，`uint amt = userBalances[msg.sender]; userBalances[msg.sender]
    =0;`。
- en: The function reads `userBalances` value, and assigns it to a local variable,
    then it resets  `userBalances`. These steps are to make sure message sender can
    only transfer to their own account, but can't make any changes to state variables.
    The balance of a user will be reduced before the ether is actually transferred
    to user. If any error occurs during the transfer, the whole transaction will be
    reverted, including the reduction transfer amount of balance in the state variable.
    This approach can be described as *optimistic accounting*, because effects are
    written down as completed, before they actually take place.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数读取 `userBalances` 的值，并将其分配给一个本地变量，然后重置 `userBalances`。这些步骤是为了确保消息发送者只能向自己的帐户转账，但不能对状态变量进行任何更改。在实际转账到用户之前，用户的余额将减少。如果在转账过程中发生任何错误，整个交易将被撤销，包括状态变量中余额减少的转账金额。这种方法可以被描述为
    *乐观会计*，因为在实际发生之前，效果已被写入完成。
- en: DoS with block gas limit
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用区块燃气限制的 DoS 攻击
- en: The Ethereum blockchain transaction can only process a certain amount of gas
    due to the block gas limit, so be careful to look without fixed limited integration.
    When a number of iteration costs go beyond the gas limit, the transaction will
    fail and the contract can be stalled at a certain point. In this case, attackers
    may potentially attack the contract, and manipulate the gas.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链交易由于区块燃气限制只能处理一定数量的燃气，因此要小心观察是否有固定的限制集成。当一系列迭代的成本超出燃气限制时，交易将失败，并且合约可能会在某一点被停滞。在这种情况下，攻击者可能会攻击合约，并操纵燃气。
- en: Handle errors in external calls
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理外部调用中的错误
- en: 'As we discussed earlier, solidity has some low-level call methods: `address.call()`,
    `address.callcode()`, `address.delegatecall()`, and `address.send()`. These methods
    only return false when the call encounters an exception. So handling errors in
    external calls is very important in contracts, as shown in the following code
    snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Solidity 有一些低级调用方法：`address.call()`、`address.callcode()`、`address.delegatecall()`
    和 `address.send()`。这些方法只在调用遇到异常时返回 false。因此，在合约中处理外部调用的错误非常重要，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Case study – crowdfunding campaign
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 - 众筹活动
- en: In this section, we will implement and deploy the smart contract for the crowdfunding
    campaign use case.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为众筹活动使用案例实现并部署智能合约。
- en: The idea of crowd funding is a process of raising funds for a project or venture
    from the masses. Investors receive tokens that represent a share of the startup
    they invested. The project sets up a predefined goal and a deadline for reaching
    it. Once a project misses the goal, the investments are returned, which reduces
    the risk for investors. This decentralized fundraising model can supplant the
    fund need for startup, and there is no need for a centralized trusted platform.
    Investors will only pay the gas fees if the fund returns. Any project contributor
    gets a token, and they can trade, sell, or keep these tokens. In a certain stage,
    the token can be used in exchange for real products as the physical reward.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 众筹的理念是从大众集资为项目或风险创业筹集资金的过程。投资者会收到代表他们投资创业公司股份的代币。项目设定了一个预定的目标和达到该目标的期限。一旦项目未达到目标，资金将被返还，这减少了投资者的风险。这种去中心化的筹资模式可以取代初创企业的资金需求，并且无需集中式的受信任平台。投资者只会在资金返还时支付gas费用。任何项目的贡献者都会得到一个代币，他们可以交易、出售或保留这些代币。在某一阶段，代币可以用来换取实际产品作为物理奖励。
- en: 'Define struct and events, shown as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 定义结构和事件，如下所示：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define modifiers, shown in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 定义修饰词，如下代码所示：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define smart contract functions, shown as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义智能合约函数，如下所示：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's use Remix to test our campaign. We select the JavaScript VM option.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Remix 来测试我们的活动。我们选择 JavaScript VM 选项。
- en: 'Initialize the campaign by clicking the Deploy button with the following input.
    This will start our campaign by means of the call constructor. We assign the first
    account as the project owner. The minimum funds raised is 30 ether, deadline set
    to five minutes for testing purposes. Put the following input code in the text
    box beside the Deploy button. Here are input parameters for constructor:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击以下输入的 Deploy 按钮来初始化活动。这将通过构造函数启动我们的活动。我们将第一个账户指定为项目所有者。最低筹资为 30 以太币，截止期限设置为五分钟用于测试目的。将以下输入代码放入
    Deploy 按钮旁边的文本框中。以下是构造函数的输入参数：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the screenshot for the Remix editor screen for this step:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该步骤 Remix 编辑器屏幕的截图：
- en: '![](img/a4d027c2-6637-4f10-9b6c-9876b24fa365.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4d027c2-6637-4f10-9b6c-9876b24fa365.png)'
- en: Remix editor screen
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 编辑器屏幕
- en: 'Switch to the second account and, in the Remix value input field, enter `20`
    ether, and then click (fallback) button. This will add `20` ether to totalRaised.
    To check project information, click project button, and you should see that the
    totalRaised is 20 ethers now. Enter `0` uint in the contributions input field,
    and we can a see second account contribution address, and a fund amount of 20
    ethers:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到第二个账户，在 Remix 的价值输入字段中输入`20`以太币，然后点击（回退）按钮。这将向 totalRaised 添加`20`以太币。要查看项目信息，点击项目按钮，你应该看到
    totalRaised 现在是 20 以太币。在捐款输入字段中输入`0`以太币，我们可以看到第二个账户的捐款地址和金额为 20 以太币：
- en: '![](img/3614c015-62b9-4099-946b-fba6759773ab.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3614c015-62b9-4099-946b-fba6759773ab.png)'
- en: Remix value input field
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的价值输入字段
- en: 'Switch to the third account, enter `15` ethers in the Value field to add funds
    for the project. Click (fallback), and we can see the project total fund raised
    to 35 ethers. At this moment, the project has achieved the campaign goal:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到第三个账户，在价值字段中输入`15`以太币，为项目增加资金。点击（回退）按钮，我们可以看到项目的总筹款量已经达到了 35 以太币。此时，项目已经实现了筹款目标：
- en: '![](img/2f05c6fd-a8ec-432a-a509-5233fd19db17.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f05c6fd-a8ec-432a-a509-5233fd19db17.png)'
- en: Adding funds to the project
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目增加资金
- en: 'Switch back to project owner, which is the first account, and click checkGoalReached. We
    can see that the transaction has been successfully executed. In the logs, the
    project status is updated to "successful". `LogProjectPaid` is triggered. If we
    check Remix account 1, 2, 3, the project owner account now contains a total in
    the region of 135 ethers. Our campaign smart contract was successfully tested
    in Remix:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回项目所有者，即第一个账户，并点击 checkGoalReached。我们可以看到交易已成功执行。在日志中，项目状态已更新为"成功"。`LogProjectPaid`
    被触发。如果我们检查 Remix 账户 1、2、3，项目所有者账户现在包含大约 135 以太币。我们的活动智能合约在 Remix 中经过了成功的测试：
- en: '![](img/be3db4a2-282e-45b3-a275-03e6b1093f95.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be3db4a2-282e-45b3-a275-03e6b1093f95.jpg)'
- en: Successfully testing the campaign in smart contract
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 成功测试了智能合约中的活动
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basic features of solidity programming. We also
    overviewed current popular smart contract development tools. By exploring common
    patterns and security best practices, we learned how to write better code to avoid
    contract vulnerabilities. Finally, we wrote a crowd funding campaign contract,
    and used Remix to deploy and test our example.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Solidity 编程的基本特性。我们还概述了当前流行的智能合约开发工具。通过探索常见模式和安全最佳实践，我们学会了如何编写更好的代码，以避免合约漏洞。最后，我们编写了一个众筹合约，并使用
    Remix 部署和测试了我们的示例。
- en: In the next chapter, we will build a Decentralize application (DApp) for crowdfunding.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个去中心化应用程序（DApp）用于众筹。
