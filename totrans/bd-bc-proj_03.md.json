["```\npragma Solidity ^0.4.2; \n\n```", "```\ncontract Sample \n{ \n    //state variables \n    uint256 data; \n    address owner; \n\n    //event definition \n    event logData(uint256 dataToLog);  \n\n    //function modifier \n    modifier onlyOwner() { \n        if (msg.sender != owner) throw; \n        _; \n    } \n\n    //constructor \n    function Sample(uint256 initData, address initOwner){ \n        data = initData; \n        owner = initOwner; \n    } \n\n    //functions \n    function getData() returns (uint256 returnedData){ \n        return data; \n    } \n\n    function setData(uint256 newData) onlyOwner{ \n        logData(newData); \n        data = newData; \n    } \n} \n\n```", "```\ncontract sample{ \n    //dynamic size array \n    //wherever an array literal is seen a new array is created. If the array literal is in state than it's stored in storage and if it's found inside function than its stored in memory \n    //Here myArray stores [0, 0] array. The type of [0, 0] is decided based on its values.  \n    //Therefore you cannot assign an empty array literal. \n    int[] myArray = [0, 0]; \n\n    function sample(uint index, int value){ \n\n        //index of an array should be uint256 type \n        myArray[index] = value; \n\n        //myArray2 holds pointer to myArray \n        int[] myArray2 = myArray; \n\n        //a fixed size array in memory \n        //here we are forced to use uint24 because 99999 is the max value and 24 bits is the max size required to hold it.  \n        //This restriction is applied to literals in memory because memory is expensive. As [1, 2, 99999] is of type uint24 therefore myArray3 also has to be the same type to store pointer to it. \n        uint24[3] memory myArray3 = [1, 2, 99999]; //array literal \n\n        //throws exception while compiling as myArray4 cannot be assigned to complex type stored in memory \n        uint8[2] myArray4 = [1, 2]; \n    } \n} \n\n```", "```\ncontract sample{ \n    //wherever a string literal is seen a new string is created. If the string literal is in state than it's stored in storage and if it's found inside function than its stored in memory \n    //Here myString stores \"\" string.  \n    string myString = \"\";  //string literal \n    bytes myRawString; \n\n    function sample(string initString, bytes rawStringInit){ \n        myString = initString; \n\n        //myString2 holds a pointer to myString \n        string myString2 = myString; \n\n        //myString3 is a string in memory  \n        string memory myString3 = \"ABCDE\"; \n\n        //here the length and content changes \n        myString3 = \"XYZ\"; \n\n        myRawString = rawStringInit; \n\n        //incrementing the length of myRawString \n        myRawString.length++; \n\n        //throws exception while compiling \n        string myString4 = \"Example\"; \n\n        //throws exception while compiling \n        string myString5 = initString; \n    } \n} \n\n```", "```\ncontract sample{ \n    struct myStruct { \n        bool myBool; \n        string myString; \n    } \n\n    myStruct s1; \n\n    //wherever a struct method is seen a new struct is created. If the struct method is in state than it's stored in storage and if it's found inside function than its stored in memory \n    myStruct s2 = myStruct(true, \"\"); //struct method syntax \n\n    function sample(bool initBool, string initString){ \n\n        //create a instance of struct \n        s1 = myStruct(initBool, initString); \n\n        //myStruct(initBool, initString) creates a instance in memory \n        myStruct memory s3 = myStruct(initBool, initString); \n    } \n} \n\n```", "```\ncontract sample { \n\n    //The integer type which can hold all enum values and is the smallest is chosen to hold enum values \n    enum OS { Windows, Linux, OSX, UNIX } \n\n    OS choice; \n\n    function sample(OS chosen){ \n        choice = chosen; \n    } \n\n    function setLinuxOS(){ \n        choice = OS.Linux; \n    } \n\n    function getChoice() returns (OS chosenOS){ \n        return choice; \n    } \n} \n\n```", "```\ncontract sample{ \n    mapping (int => string) myMap; \n\n    function sample(int key, string value){ \n        myMap[key] = value; \n\n        //myMap2 is a reference to myMap \n        mapping (int => string) myMap2 = myMap; \n    } \n} \n\n```", "```\ncontract sample { \n\n    struct Struct { \n        mapping (int => int) myMap; \n        int myNumber; \n    } \n\n    int[] myArray; \n    Struct myStruct;  \n\n    function sample(int key, int value, int number, int[] array) { \n\n        //maps cannot be assigned so while constructing struct we ignore the maps \n        myStruct = Struct(number); \n\n        //here set the map key/value \n        myStruct.myMap[key] = value; \n\n        myArray = array; \n    } \n\n    function reset(){ \n\n        //myArray length is now 0 \n        delete myArray; \n\n        //myNumber is now 0 and myMap remains as it is \n        delete myStruct; \n    } \n\n    function deleteKey(int key){ \n\n        //here we are deleting the key \n        delete myStruct.myMap[key]; \n    } \n\n} \n\n```", "```\nuint32 a = 0x12345678; \nuint16 b = uint16(a); // b will be 0x5678 now \n\n```", "```\nint256 x = 12; \n\n//y type is int256 \nvar y = x; \n\nuint256 z= 9; \n\n//exception because implicit conversion not possible \ny = z; \n\n```", "```\ncontract sample{ \n    int a = 12; \n    int[] b; \n\n    function sample() \n    { \n        //\"==\" throws exception for complex types  \n        if(a == 12) \n        { \n        } \n        else if(a == 34) \n        { \n        } \n        else \n        { \n        } \n\n        var temp = 10; \n\n        while(temp < 20) \n        { \n            if(temp == 17) \n            { \n                break; \n            } \n            else \n            { \n                continue; \n            } \n\n            temp++; \n        } \n\n        for(var iii = 0; iii < b.length; iii++) \n        { \n\n        } \n    } \n} \n\n```", "```\ncontract sample1 \n{ \n    int a; \n\n    function assign(int b) \n    { \n        a = b; \n    } \n} \n\ncontract sample2{ \n    function sample2() \n    { \n        sample1 s = new sample1(); \n        s.assign(12); \n    } \n} \n\n```", "```\ncontract sample \n{ \n    function myFunction() \n    { \n        throw; \n    } \n} \n\n```", "```\ncontract sample1 \n{ \n    int a; \n\n    //\"payable\" is a built-in modifier \n    //This modifier is required if another contract is sending Ether while calling the method \n    function sample1(int b) payable \n    { \n        a = b; \n    } \n\n    function assign(int c)  \n    { \n        a = c; \n    } \n\n    function makePayment(int d) payable \n    { \n        a = d; \n    } \n} \n\ncontract sample2{ \n\n    function hello() \n    { \n    } \n\n    function sample2(address addressOfContract) \n    { \n        //send 12 wei while creating contract instance \n        sample1 s = (new sample1).value(12)(23); \n\n        s.makePayment(22); \n\n        //sending Ether also \n        s.makePayment.value(45)(12); \n\n        //specifying the amount of gas to use \n        s.makePayment.gas(895)(12); \n\n        //sending Ether and also specifying gas \n        s.makePayment.value(4).gas(900)(12); \n\n        //hello() is internal call whereas this.hello() is external call \n        this.hello(); \n\n        //pointing a contract that's already deployed \n        sample1 s2 = sample1(addressOfContract); \n\n        s2.makePayment(112); \n\n    } \n} \n\n```", "```\ncontract sample1 \n{ \n    int public b = 78; \n    int internal c = 90; \n\n    function sample1() \n    { \n        //external access \n        this.a(); \n\n        //compiler error \n        a(); \n\n        //internal access \n        b = 21; \n\n        //external access \n        this.b; \n\n        //external access \n        this.b(); \n\n        //compiler error \n        this.b(8); \n\n        //compiler error \n        this.c(); \n\n        //internal access \n        c = 9; \n    } \n\n    function a() external  \n    { \n\n    } \n} \n\ncontract sample2 \n{ \n    int internal d = 9; \n    int private e = 90; \n} \n\n//sample3 inherits sample2 \ncontract sample3 is sample2 \n{ \n    sample1 s; \n\n    function sample3() \n    { \n        s = new sample1(); \n\n        //external access \n        s.a(); \n\n        //external access \n        var f = s.b; \n\n        //compiler error as accessor cannot used to assign a value \n        s.b = 18; \n\n        //compiler error \n        s.c(); \n\n        //internal access \n        d = 8; \n\n        //compiler error \n        e = 7; \n    } \n} \n\n```", "```\ncontract sample \n{ \n    int a = 90; \n\n    modifier myModifier1(int b) { \n        int c = b; \n        _; \n        c = a; \n        a = 8; \n    } \n\n    modifier myModifier2 { \n        int c = a; \n        _; \n    } \n\n    modifier myModifier3 { \n        a = 96; \n        return; \n        _; \n        a = 99; \n    } \n\n    modifier myModifier4 { \n        int c = a; \n        _; \n    } \n\n    function myFunction() myModifier1(a) myModifier2 myModifier3 returns (int d) \n    { \n        a = 1; \n        return a; \n    } \n} \n\n```", "```\nint c = b; \n    int c = a; \n        a = 96; \n        return; \n            int c = a; \n                a = 1; \n                return a; \n        a = 99; \nc = a; \na = 8; \n\n```", "```\ncontract sample \n{ \n    function() payable  \n    { \n        //keep a note of how much Ether has been sent by whom            \n    }     \n} \n\n```", "```\ncontract sample1 \n{ \n    function a(){} \n\n    function b(){} \n} \n\n//sample2 inherits sample1 \ncontract sample2 is sample1 \n{ \n    function b(){} \n} \n\ncontract sample3 \n{ \n    function sample3(int b) \n    { \n\n    } \n} \n\n//sample4 inherits from sample1 and sample2 \n//Note that sample1 is also parent of sample2, yet there is only a single instance of sample1  \ncontract sample4 is sample1, sample2 \n{ \n    function a(){} \n\n    function c(){ \n\n        //this executes the \"a\" method of sample3 contract \n        a(); \n\n        //this executes the 'a\" method of sample1 contract \n        sample1.a(); \n\n        //calls sample2.b() because it's in last in the parent contracts list and therefore it overrides sample1.b() \n        b(); \n    } \n} \n\n//If a constructor takes an argument, it needs to be provided at the constructor of the child contract. \n//In Solidity child constructor doesn't call parent constructor instead parent is initialized and copied to child \ncontract sample5 is sample3(122) \n{ \n\n} \n\n```", "```\ncontract sample1 \n{ \n} \n\ncontract sample2 \n{ \n} \n\ncontract sample3 is sample2 \n{ \n} \n\ncontract sample4 is sample2 \n{ \n} \n\ncontract sample5 is sample4 \n{ \n    function myFunc() \n    { \n    } \n} \n\ncontract sample6 is sample1, sample2, sample3, sample5 \n{ \n    function myFunc() \n    { \n        //sample5.myFunc() \n        super.myFunc(); \n    } \n} \n\n```", "```\ncontract sample1 \n{ \n    function a() returns (int b); \n} \n\ncontract sample2 \n{ \n    function myFunc() \n    { \n        sample1 s = sample1(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); \n\n        //without abstract contract this wouldn't have compiled \n        s.a(); \n    } \n} \n\n```", "```\nlibrary math \n{ \n    function addInt(int a, int b) returns (int c) \n    { \n        return a + b; \n    } \n} \n\ncontract sample \n{ \n    function data() returns (int d) \n    { \n        return math.addInt(1, 2); \n    } \n} \n\n```", "```\nlibrary math \n{ \n    struct myStruct1 { \n        int a; \n    } \n\n    struct myStruct2 { \n        int a; \n    } \n\n    //Here we have to make 's' location storage so that we get a reference.  \n    //Otherwise addInt will end up accessing/modifying a different instance of myStruct1 than the one on which its invoked \n    function addInt(myStruct1 storage s, int b) returns (int c) \n    { \n        return s.a + b; \n    } \n\n    function subInt(myStruct2 storage s, int b) returns (int c) \n    { \n        return s.a + b; \n    } \n} \n\ncontract sample \n{ \n    //\"*\" attaches the functions to all the structs \n    using math for *; \n    math.myStruct1 s1; \n    math.myStruct2 s2; \n\n    function sample() \n    { \n        s1 = math.myStruct1(9); \n        s2 = math.myStruct2(9); \n\n        s1.addInt(2); \n\n        //compiler error as the first parameter of addInt is of type myStruct1 so addInt is not attached to myStruct2 \n        s2.addInt(1); \n    } \n} \n\n```", "```\ncontract sample \n{ \n    function a() returns (int a, string c) \n    { \n        return (1, \"ss\"); \n    } \n\n    function b() \n    { \n        int A; \n        string memory B; \n\n        //A is 1 and B is \"ss\" \n        (A, B) = a(); \n\n        //A is 1 \n        (A,) = a(); \n\n        //B is \"ss\" \n        (, B) = a(); \n    } \n} \n\n```", "```\n//This statement imports all global symbols from \"filename\" (and symbols imported there) into the current global scope. \"filename\" can be a absolute or relative path. It can only be a HTTP URL \nimport \"filename\"; \n\n//creates a new global symbol symbolName whose members are all the global symbols from \"filename\". \nimport * as symbolName from \"filename\"; \n\n//creates new global symbols alias and symbol2 which reference symbol1 and symbol2 from \"filename\", respectively. \nimport {symbol1 as alias, symbol2} from \"filename\"; \n\n//this is equivalent to import * as symbolName from \"filename\";. \nimport \"filename\" as symbolName; \n\n```", "```\ncontract Proof \n{ \n    struct FileDetails \n    { \n        uint timestamp; \n        string owner; \n    } \n\n    mapping (string => FileDetails) files; \n\n    event logFileAddedStatus(bool status, uint timestamp, string owner, string fileHash); \n\n    //this is used to store the owner of file at the block timestamp \n    function set(string owner, string fileHash) \n    { \n        //There is no proper way to check if a key already exists or not therefore we are checking for default value i.e., all bits are 0 \n        if(files[fileHash].timestamp == 0) \n        { \n            files[fileHash] = FileDetails(block.timestamp, owner); \n\n            //we are triggering an event so that the frontend of our app knows that the file's existence and ownership details have been stored \n            logFileAddedStatus(true, block.timestamp, owner, fileHash); \n        } \n        else \n        { \n            //this tells to the frontend that file's existence and ownership details couldn't be stored because the file's details had already been stored earlier \n            logFileAddedStatus(false, block.timestamp, owner, fileHash); \n        } \n    } \n\n    //this is used to get file information \n    function get(string fileHash) returns (uint timestamp, string owner) \n    { \n        return (files[fileHash].timestamp, files[fileHash].owner); \n    } \n} \n\n```", "```\nvar proofContract = web3.eth.contract([{\"constant\":false,\"inputs\":[{\"name\":\"fileHash\",\"type\":\"string\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"string\"},{\"name\":\"fileHash\",\"type\":\"string\"}],\"name\":\"set\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fileHash\",\"type\":\"string\"}],\"name\":\"logFileAddedStatus\",\"type\":\"event\"}]); \nvar proof = proofContract.new( \n  { \n    from: web3.eth.accounts[0],  \n    data: '60606040526......,  \n    gas: 4700000 \n  }, function (e, contract){ \n   console.log(e, contract); \n  if (typeof contract.address !== 'undefined') { \n    console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); \n  } \n}) \n\n```", "```\ngeth --dev --mine\n\n```", "```\ngeth attach\n\n```", "```\nvar contract_obj = proofContract.at(\"0x9220c8ec6489a4298b06c2183cf04fb7e8fbd6d4\"); \ncontract_obj.set.sendTransaction(\"Owner Name\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", { \n from: web3.eth.accounts[0], \n}, function(error, transactionHash){ \n  if (!err) \n    console.log(transactionHash); \n}) \n\n```", "```\ncontract_obj.get.call(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"); \n\n```", "```\n[1477591434, \"Owner Name\"] \n\n```"]