["```\nmapping(address => string) private deviceIDToLatestCID;\n```", "```\n  mapping(address => uint256) private deviceIDExists;\n```", "```\n   address[] private deviceIDs;\n```", "```\n   modifier onlyBy(address _account) {\n       require(\n           *msg*.sender == _account,\n           \"Sender not authorized to update this mapping!\"\n       );\n       _; // The \"_;\"! will be replaced by the actual function body when the modifier is used.\n   }\n```", "```\n   event MappingUpdated(address deviceID, string latestCID);\n```", "```\n   function setLatestCID(address deviceID, string memory latestCID)\n       public\n       onlyBy(deviceID)\n   {\n       deviceIDToLatestCID[deviceID] = latestCID;\n       if (deviceIDExists[deviceID] == 0) {\n           deviceIDs.push(deviceID);\n           deviceIDExists[deviceID] = 1;\n       }\n       emit MappingUpdated(deviceID, latestCID);\n   }\n```", "```\n   function getLatestCID(*address* deviceID)\n       public\n       view\n       returns (*string* memory latestCID)\n   {\n       return deviceIDToLatestCID[deviceID];\n   }\n```", "```\n   function getDeviceIDsLength() public view returns (*uint256*) {\n       return deviceIDs.length;\n   }\n```", "```\n   function getIDByIndex(uint256 index) public view returns (*address*) {\n       return deviceIDs[index];\n   }\n```", "```\nimport requests\nimport os\nimport datetime\nimport calendar\nimport time\nimport json\nfrom web3 import Web3\nimport http.client\n```", "```\nurl = 'https://www.googleapis.com/geolocation/v1/geolocate'\nmyobj = {'key': os.environ['GMAPS_API_KEY']}\n```", "```\nconn = http.client.HTTPSConnection(\"kfs2.moibit.io\")\nmoibit_url = 'https://kfs2.moibit.io/moibit/v0/'\nmoibit_header_obj = {\n   'api_key': os.environ['MOIBIT_API_KEY'],\n   'api_secret': os.environ['MOIBIT_API_SECRET'],\n   'content-type': \"application/json\"\n}\n```", "```\nblockchain_url = 'https://kovan.infura.io/v3/' + \\\n   os.environ['WEB3_INFURA_PROJECT_ID']\n```", "```\nabi = \"\"\"[{\"anonymous\": false,\"inputs\": [{\"indexed\": false,\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"},{\"indexed\": false,\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"name\": \"MappingUpdated\",\"type\": \"event\"},{\"inputs\": [{\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"},{\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"name\": \"setLatestCID\",\"outputs\": [],\"stateMutability\": \"nonpayable\",\"type\": \"function\"},{\"inputs\": [],\"name\": \"getDeviceIDsLength\",\"outputs\": [{\"internalType\": \"uint256\",\"name\": \"\",\"type\": \"uint256\"}],\"stateMutability\": \"view\",\"type\": \"function\"},{\"inputs\": [{\"internalType\": \"uint256\",\"name\": \"index\",\"type\": \"uint256\"}],\"name\": \"getIDByIndex\",\"outputs\": [{\"internalType\": \"address\",\"name\": \"\",\"type\": \"address\"}],\"stateMutability\": \"view\",\"type\": \"function\"},{\"inputs\": [{\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"}],\"name\": \"getLatestCID\",\"outputs\": [{\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"stateMutability\": \"view\",\"type\": \"function\"}]\"\"\"\n```", "```\nif __name__ == \"__main__\":\n   main()\n\ndef main():\n   # Fetching the Tracking ID locally, or generating a new one\n   Tracking_ID = os.environ['WALLET_ADDRESS']\n   print(\"# Setting tracking ID: \", os.environ['WALLET_ADDRESS'])\n\n   # Getting the current geo-coordinates of the device\n   print(\"# Getting the current geo-coordinates of the device from GMaps API\")\n   (latitude, longitude) = getGeoCordinates()\n\n   # Reading the current UTC based Unix timestamp of the device\n   print(\"# Reading the current UTC based Unix timestamp of the device\")\n   timestamp = getCurrentTime()\n\n   # Generate the JSON structure\n   jsonData = Marshal(Tracking_ID, latitude, longitude, timestamp)\n\n   # Updating the location history to IPFS-based MoiBit network\n   print(\"# Updating the location history to IPFS-based MoiBit network\")\n   latest_cid = updateLocationHistory(Tracking_ID, jsonData)\n\n   # Publishing the proof to Ethereum\n   print(\"# Publishing the proof to Ethereum\")\n   txnHash = CommitTxn(Tracking_ID, latest_cid)\n   print(\"https://kovan.etherscan.io/tx/\"+txnHash)\n```", "```\ndef getGeoCordinates():\n   res = requests.post(url, data=myobj)\n   geoCordinates = res.json()['location']\n   lat = *float*(\"{:.7f}\".format(geoCordinates['lat']))\n   long = *float*(\"{:.7f}\".format(geoCordinates['lng']))  return (lat, long) # Accuracy is not considered in the POC because optimizations are out of scope\n```", "```\ndef getCurrentTime():\n   dt = datetime.datetime.utcnow()\n   timestamp = time.mktime(dt.timetuple())\n   timestamp = *int*(timestamp)\n   return timestamp\n```", "```\ndef Marshal(Tracking_ID, lat, long, timestamp):\n   data = {\"id\": Tracking_ID,\n           \"latitude\": lat,\n           \"longitude\": long,\n           \"timestamp\": timestamp\n           }   return data\n```", "```\ndef checkIfFileExists(*walletAddress*):\n   print(\"checkIfFileExists(): Checking if /dictao/\" +\n         walletAddress+\".json exists.\")\n   pre_payload = {\"path\": \"/dictao/\"}\n   payload = json.dumps(pre_payload)\n  conn.request(\"POST\", moibit_url+\"listfiles\", payload, moibit_header_obj)\n   res = conn.getresponse()\n   responseObject = json.loads(res.read())\n   if res.status == 200:\n       if responseObject['data']['Entries'] == None:\n           print(\"checkIfFileExists(): /dictao/\" +\n                 walletAddress+\".json does not exist!\")\n           return False, \"\"\n       else:\n           for fileObject in responseObject['data']['Entries']:\n               if walletAddress+\".json\" == fileObject['Name']:\n                   print(\"checkIfFileExists(): Found /dictao/\"+walletAddress +\n                         \".json \"+\"with the hash \"+fileObject['Hash'])\n                   return True, fileObject['Hash']\n   print(\"checkIfFileExists(): /dictao/\" +\n         walletAddress+\".json does not exist!\")\n   return False, \"\"\n```", "```\ndef CommitTxn(id, cid):\n   print(\"CommitTxn(): Connecting to the ethereum network\")\n   w3 = Web3(Web3.HTTPProvider(blockchain_url))\n   print(\"CommitTxn(): Initializing the live contract instance at \" +\n         os.environ['PROOF_SMART_CONTRACT_ADDRESS'])\n   contract = w3.eth.contract(\n       os.environ['PROOF_SMART_CONTRACT_ADDRESS'], *abi*=abi)\n\n   print(\"CommitTxn(): Creating a raw transaction to call smart contract function setLatestCID()\")\n   nonce = w3.eth.getTransactionCount(os.environ['WALLET_ADDRESS'])\n   setLatestCID_txn = contract.functions.setLatestCID(\n       os.environ['WALLET_ADDRESS'],\n       cid,\n   ).buildTransaction({\n       'chainId': 42,\n       'gas': 3000000,\n       'gasPrice': w3.toWei('1', 'gwei'),\n       'nonce': nonce,\n   })\n   print(\"CommitTxn(): Signing the raw transaction with private key\")\n   signed_txn = w3.eth.account.sign_transaction(\n       setLatestCID_txn, *private_key*=os.environ['WALLET_PRIVATE_KEY'])\n   w3.eth.sendRawTransaction(signed_txn.rawTransaction)\n\n   tx_hash = w3.toHex(w3.keccak(signed_txn.rawTransaction))\n   tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)\n   print(\"CommitTxn(): Sucessfully updated the CID in the blockchain. Transaction receipt:\\n\", tx_receipt)\n   print(\"CommitTxn(): Checking the new/latest hash for the wallet from blockchain: \" +\n         contract.functions.getLatestCID(os.environ['WALLET_ADDRESS']).call())\n   return tx_hash\n```", "```\nimport os\nimport sys\nimport flask\nfrom flask import request, jsonify\nfrom web3 import Web3\nimport web3\nimport json\nimport http\nfrom flask_cors import CORS\nimport datetime as dt\nimport pandas as pd\nfrom sklearn.cluster import DBSCAN\n```", "```\napp = flask.Flask(__name__)\nCORS(app)\napp.config[\"DEBUG\"] = True\n```", "```\napp.run()\n```", "```\nblockchain_url = 'https://kovan.infura.io/v3/' + \\\n   os.environ['WEB3_INFURA_PROJECT_ID']\n\nabi = \"\"\"[{\"anonymous\": false,\"inputs\": [{\"indexed\": false,\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"},{\"indexed\": false,\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"name\": \"MappingUpdated\",\"type\": \"event\"},{\"inputs\": [{\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"},{\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"name\": \"setLatestCID\",\"outputs\": [],\"stateMutability\": \"nonpayable\",\"type\": \"function\"},{\"inputs\": [],\"name\": \"getDeviceIDsLength\",\"outputs\": [{\"internalType\": \"uint256\",\"name\": \"\",\"type\": \"uint256\"}],\"stateMutability\": \"view\",\"type\": \"function\"},{\"inputs\": [{\"internalType\": \"uint256\",\"name\": \"index\",\"type\": \"uint256\"}],\"name\": \"getIDByIndex\",\"outputs\": [{\"internalType\": \"address\",\"name\": \"\",\"type\": \"address\"}],\"stateMutability\": \"view\",\"type\": \"function\"},{\"inputs\": [{\"internalType\": \"address\",\"name\": \"deviceID\",\"type\": \"address\"}],\"name\": \"getLatestCID\",\"outputs\": [{\"internalType\": \"string\",\"name\": \"latestCID\",\"type\": \"string\"}],\"stateMutability\": \"view\",\"type\": \"function\"}]\"\"\"\n```", "```\nconn = http.client.HTTPSConnection(\"kfs2.moibit.io\")\nmoibit_url = 'https://kfs2.moibit.io/moibit/v0/'\nmoibit_header_obj = {\n   'api_key': os.environ['MOIBIT_API_KEY'],\n   'api_secret': os.environ['MOIBIT_API_SECRET'],\n   'content-type': \"application/json\"\n}\n```", "```\n@app.route('/', *methods*=['GET'])\ndef home():\n   return \"<h1>DICTAO - Decentralized Intelligent Contact Tracing of Animals and Objects</h1><p>This is a simple demonstration of applying blockchain, decentralized storage and AI to solve the COVID-19 crisis.</p>\"\n```", "```\n@app.errorhandler(404)\ndef page_not_found(*e*):\n   return \"The given ID could not be found\", 404\n```", "```\n@app.errorhandler(500)\ndef internal_server_error(*e*):\n   return e, 500\n```", "```\ndef getLatestCID(*id*):\n   w3 = Web3(Web3.HTTPProvider(blockchain_url))\n   contract = w3.eth.contract(\n       os.environ['PROOF_SMART_CONTRACT_ADDRESS'], *abi*=abi)\n   cid = \"\"\n   try:\n       cid = contract.functions.getLatestCID(id).call()\n   except web3.exceptions.ValidationError:\n       print(\"ID does not exist!\")\n\n       return \"\"\n   except:\n       print(\"Some other error occured!\")\n       return \"\"\n   else:\n       print(cid)\n       return cid\n```", "```\ndef getJsonDataFromMoiBit(*cid*):\n   pre_payload = {\"hash\": cid}\n   payload = json.dumps(pre_payload)\n   conn.request(\"POST\", moibit_url+\"readfilebyhash\",\n                payload, moibit_header_obj)\n   res = conn.getresponse()\n   if res.status == 200:\n       responseObject = json.loads(res.read())\n       print(\n           \"updateLocationHistory(): Appending the captured data to historic data.\")\n       return responseObject\n```", "```\ndef get_infected_ids(*input_id*):\n   basePath = os.path.dirname(os.path.abspath('live_dataset.json'))\n   dflive = pd.read_json(basePath + '/' + 'live_dataset.json')\n\n   epsilon = 0.0018288 # a radial distance of 6 feet, which is medically presribed\n   min_sample = 2\n model = DBSCAN(*eps*=epsilon, *min_samples*=2, *metric*='haversine').fit(dflive[['latitude', 'longitude']])\n   dflive['cluster'] = model.labels_.tolist()\n\n   input_id_clusters = []\n   for i in range(len(dflive)):\n       if dflive['id'][i] == input_id:\n           if dflive['cluster'][i] in input_id_clusters:\n               pass\n           else:\n               input_id_clusters.append(dflive['cluster'][i])\n\n   infected_ids = []\n   for cluster in input_id_clusters:\n       if cluster != -1:\n           ids_in_cluster = dflive.loc[dflive['cluster'] == cluster, 'id']\n           for i in range(len(ids_in_cluster)):\n               member_id = ids_in_cluster.iloc[i]\n               if (member_id not in infected_ids) and (member_id != input_id):\n                   infected_ids.append(member_id)\n               else:\n                   pass\n   return infected_ids\n```", "```\nconst express = require('express')\nconst app = express()\nconst port = 3000\napp.use(express.static('public'));\napp.get('/', (*req*, *res*) => res.send('Welcome to DICTAO: Contact tracing web app!'))\napp.listen(port, () => *console*.log(`DICTAO: Contact tracing web app listening at http://localhost:${port}`))\n```", "```\nexport GMAPS_API_KEY := \"?\"\nexport MOIBIT_API_KEY := \"?\"\nexport MOIBIT_API_SECRET := \"?\"\nexport WEB3_INFURA_PROJECT_ID := \"?\"\nexport PROOF_SMART_CONTRACT_ADDRESS := \"?\"\nexport WALLET_PRIVATE_KEY := \"?\"\nexport WALLET_ADDRESS := \"?\"\n\nrun-client:\n    python iot-client-code/python/main.py\n\nrun-web:\n    cd frontend-tracking-dashboard && node index.js\n\nrun-server:\n    python backend-contact-tracing/server.py\n\ninstall-dependencies:\n    pip install --user -r requirements.txt\n    cd frontend-tracking-dashboard && npm install\n```", "```\njust run-client\n```", "```\njust run-server\n```", "```\njust run-web\n```"]