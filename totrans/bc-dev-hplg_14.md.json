["```\npragma solidity ^0.4.24;\n\ncontract HelloWorld {\n  string public greeting;\n\n  constructor() public {\n    greeting = 'Hello World';\n  }\n\n  function setNewGreeting (string _newGreeting) public {\n    greeting = _newGreeting;\n  }\n}\n```", "```\nimport * as symbolName from “solidityFile”\n```", "```\nimport solidityFile as symbolName;\n```", "```\nimport {symbol1 as alias, symbol2} from \" solidityFile\";\n```", "```\npragma solidity ^0.4.15;\nimport 'zeppelin/contracts/math/SafeMath.sol';\n….\ncontract ExampleCoin is ERC20 {\n  //SafeMath symbol is from imported file SafeMath.sol'\n  using SafeMath for uint256;\n   …\n}\n```", "```\n      import 'zeppelin/contracts/math/SafeMath.sol';\n```", "```\nsolc github.com/ethereum/dapp-bin/library=/usr/local/dapp-bin/library\n```", "```\nimport \"github.com/ethereum/dapp-bin/library/stringUtils.sol \" as stringUtils;\n```", "```\ncontract SimpleStorage {\n    uint storedData; // State variable\n    //…\n}\n```", "```\naddress owner = msg.sender;\naddress myAddress = 0xE0f5206B…437b9;\n```", "```\nsomeAddress.call.\nvalue(1ether)\n.gas(100000) (\"register\", \"MyName\")\n```", "```\n/**bytes array **/\nbytes32[] dynamicArray\nfunction f() {\n        bytes32[] storage storageArr = dynamicArray\n        storageArr.length++;\n}\n/**string array **/\nbytes32[] public names\n```", "```\npragma solidity ^0.4.24;\n  contract ColorEnum {\n    enum Color {RED,ORANGE,YELLOW, GREEN}\n    Color color;\n    function construct() public {\n     color = Color.RED;\n    }\n    function setColor(uint _value) public {\n      color = Color(_value);\n    }\n  function getColor() public view returns (uint){\n      return uint(color);\n  }\n}\n```", "```\nstruct person {\n         uint age;\n         string fName;\n         string lName;\n         string email;\n    }\n```", "```\npragma solidity ^0.4.24;\ncontract StudentScore {\n    struct Student {\n        uint score;\n        string name;\n    }\n    mapping (address => Student) studtents;\n    address[] public studentAccts;\n    function setStudent(address _address, uint _score, string _name) public {\n        Student storage studtent = studtents[_address];\n        studtent.score = _score;\n        studtent.name = _name;\n        studentAccts.push(_address) -1;\n    }\n    function getStudents() view public returns(address[]) {\n        return studentAccts;\n    }\n    function getStudent(address _address) view public returns (uint, string) {\n        return (studtents[_address].score, studtents[_address].name);\n    }\n    function countStudents() view public returns (uint) {\n        return studentAccts.length;\n    }\n}\n```", "```\nfunction (<Input parameters>) {access modifiers} [pure|constant|view|payable] [returns (<return types>)]\n```", "```\nfunction setNewGreeting (string _newGreeting) {\n  greeting = _newGreeting;\n}\n```", "```\nfunction getColor() public view returns (uint){\n      return uint(color);\n  }\n```", "```\npure|constant|view|payable\n```", "```\n    uint amount =0;\n    function buy() public payable{\n        amount += msg.value;\n    }\n```", "```\npragma solidity ^0.4.24;\n// this is a contract, which keeps all Ether to it with not way of\n// retrieving it.\ncontract MyContract {\n    function() public payable { }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract Modifiers {\n         address public admin;\n    function construct () public {\n       admin = msg.sender;\n    }\n    //define the modifiers\n    modifier onlyAdmin() {\n        // if a condition is not met then throw an exception\n        if (msg.sender != admin) revert();\n        // or else just continue executing the function\n        _;\n    }\n    // apply modifiers\n\n    function kill() onlyAdmin public {\n         selfdestruct(admin);\n    }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract Purchase {\n    event buyEvent(address bidder, uint amount); // Event\n    function buy() public payable {\n        emit buyEvent(msg.sender, msg.value); // Triggering event\n    }\n}\n```", "```\n//new\npragma solidity ^0.4.24;\ncontract HelloWorld {\n  function constructor() public {\n    // ...\n  }\n}\n//deprecated\npragma solidity ^0.4.22;\ncontract HelloWorld {\n  function HelloWorld () public {\n    // ...\n  }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract Animal {\n    constructor() public {\n    }\n    function name() public returns (string) {\n        return  \"Animal\";\n    }\n    function color() public returns (string);\n}\ncontract Mammal is Animal {\n    int size;\n    constructor() public {\n    }\n    function name() public returns (string) {\n        return  \"Mammal\";\n    }\n    function run() public pure returns (int) {\n        return 10;\n    }\n    function color() public returns (string);\n}\ncontract Dog is Mammal {\n     function name() public returns (string) {\n        return  \"Dog\";\n    } \n    function color() public returns (string) {\n        return \"black\";\n    }\n}\n```", "```\npragma solidity ^0.4.24;\n//interface\ncontract A {\n    function doSomething() public returns (string);\n}\n//contract implements interface A\ncontract B is A {\n    function doSomething() public returns (string) {\n        return \"Hello\";\n    }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract Ownable {\n address owner;\n uint public initTime = now;\n constructor() public {\n owner = msg.sender;\n }\n //check if the caller is the owner of the contract\n modifier onlyOwner {\n require(msg.sender == owner,\"Only Owner Allowed.\" );\n _;\n }\n //change the owner of the contract\n //@param _newOwner the address of the new owner of the contract.\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function getOwner() internal constant returns (address) {\n return owner;\n }\n modifier onlyAfter(uint _time) {\n require(now >= _time,\"Function called too early.\");\n _;\n }\n modifier costs(uint _amount) {\n require(msg.value >= _amount,\"Not enough Ether provided.\" );\n _;\n if (msg.value > _amount)\n msg.sender.transfer(msg.value - _amount);\n }\n}\ncontract SampleContarct is Ownable {\n\n mapping(bytes32 => uint) myStorage;\n constructor() public {\n }\n function getValue(bytes32 record) constant public returns (uint) {\n return myStorage[record];\n }\n function setValue(bytes32 record, uint value) public onlyOwner {\n myStorage[record] = value;\n }\n function forceOwnerChange(address _newOwner) public payable\nonlyOwner onlyAfter(initTime + 2 weeks) costs(50 ether) {\n owner =_newOwner;\n initTime = now;\n }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract StateMachine { \n enum Stages {\n INIT,\n SCRUB,\n RINSE,\n DRY,\n CLEANUP\n }\n\n Stages public stage = Stages.INIT;\n modifier atStage(Stages _stage) {\n require(stage == _stage);\n _;\n }\n function nextStage() internal {\n stage = Stages(uint(stage) + 1);\n } \n modifier transitionNext() {\n _;\n nextStage();\n }\n\n function scrub() public atStage(Stages.INIT) transitionNext {\n // Implement scrub logic here\n }\n\n function rinse() public atStage(Stages.SCRUB) transitionNext {\n // Implement rinse logic here\n }\n\n function dry() public atStage(Stages.SCRUB) transitionNext {\n // Implement dry logic here\n }\n\n function cleanup() public view atStage(Stages.CLEANUP) {\n // Implement dishes cleanup\n }\n}\n```", "```\npragma solidity ^0.4.24;\n// THIS CONTRACT is INSECURE - DO NOT USE\ncontract Fund {\n    mapping(address => uint) userBalances;\nfunction withdrawBalance() public {\n     //external call\n         if (msg.sender.call.value(userBalances[msg.sender])())\n            userBalances[msg.sender] = 0;\n}\n}\ncontract Hacker {\n    Fund f;\n    uint public count;\n\n    event LogWithdrawFallback(uint c, uint balance);\n\n    function Attacker(address vulnerable) public {\n        f = Fund(vulnerable);\n    }\n    function attack() public {\n        f.withdrawBalance();\n    }\n\n    function () public payable {\n        count++;\n        emit LogWithdrawFallback(count, address(f).balance);\n        if (count < 10) {\n          f.withdrawBalance();\n        }\n    }\n  }\n}\n```", "```\npragma solidity ^0.4.24;\ncontract Fund {\n    mapping(address => uint) userBalances;\n    funct\nion withdrawBalance() public {\n         uint amt = userBalances[msg.sender];\n         userBalances[msg.sender] =0;\n         msg.sender.transfer(amt);\n    }\n}  \n```", "```\n// good\nif(!contractAddress.send(100)) {\n    // handle error\n}\ncontractAddress.send(20);//don't do this\ncontractAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\ncontractAddress.call.value(50)(bytes4(sha3(\"withdraw()\"))); // if withdraw throws an exception, the raw call() will only return false and transaction will NOT be reverted\n```", "```\npragma solidity ^0.4.24;\n\ncontract CrowdFunding {\n\n    Project public project;\n    Contribution[] public contributions;\n    //Campaign Status\n    enum Status {\n        Fundraising,\n        Fail,\n        Successful\n    }\n    event LogProjectInitialized (\n        address owner,\n        string name,\n        string website,\n        uint minimumToRaise, \n        uint duration\n    );\n    event ProjectSubmitted(address addr, string name, string url, bool initialized);\n    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n    event LogProjectPaid(address projectAddr, uint amount, Status status);\n    event Refund(address _to, uint amount);\n    event LogErr (address addr, uint amount);\n    //campaign contributors\n    struct Contribution {\n        address addr;\n        uint amount;\n    }\n    //define project\n    struct Project {\n        address addr;\n        string name;\n        string website;\n        uint totalRaised;\n        uint minimumToRaise; \n        uint currentBalance;\n        uint deadline;\n        uint completeAt;\n        Status status;\n    }\n    //initialized project\n    constructor (address _owner, uint _minimumToRaise, uint _durationProjects, \n        string _name, string _website) public payable { \n        uint minimumToRaise = _minimumToRaise * 1 ether; //convert to wei\n        uint deadlineProjects = now + _durationProjects* 1 seconds;\n        project = Project(_owner, _name, _website, 0, minimumToRaise, 0, deadlineProjects, 0, Status.Fundraising);\n        emit LogProjectInitialized(\n            _owner,\n            _name,\n            _website,\n            _minimumToRaise,\n            _durationProjects);\n    }\n```", "```\n   //check if project is at the required stage\n    modifier atStage(Status _status) {\n        require(project.status == _status,\"Only matched status allowed.\" );\n        _;\n    }\n    //check if msg.sender is project owner\n    modifier onlyOwner() {\n        require(project.addr == msg.sender,\"Only Owner Allowed.\" );\n        _;\n    }\n    //check if project pass the deadline\n    modifier afterDeadline() {\n        require(now >= project.deadline);\n        _;\n    }\n    //Wait for 6 hour after campaign completed before allowing contract destruction\n    modifier atEndOfCampain() {\n        require(!((project.status == Status.Fail || project.status == Status.Successful) && project.completeAt + 6 hours < now));\n        _;\n    }\n```", "```\n   function () public payable {\n       revert(); \n    }\n\n    /* The default fallback function is called whenever anyone sends funds to a contract */\n    function fund() public atStage(Status.Fundraising) payable {\n        contributions.push(\n            Contribution({\n                addr: msg.sender,\n                amount: msg.value\n                })\n            );\n        project.totalRaised += msg.value;\n        project.currentBalance = project.totalRaised;\n        emit LogFundingReceived(msg.sender, msg.value, project.totalRaised);\n    }\n    //checks if the goal or time limit has been reached and ends the campaign\n    function checkGoalReached() public onlyOwner afterDeadline {\n        require(project.status != Status.Successful && project.status!=Status.Fail);\n        if (project.totalRaised > project.minimumToRaise){\n            project.addr.transfer(project.totalRaised);\n            project.status = Status.Successful;\n            emit LogProjectPaid(project.addr, project.totalRaised, project.status);\n        } else {\n            project.status = Status.Fail;\n            for (uint i = 0; i < contributions.length; ++i) {\n              uint amountToRefund = contributions[i].amount;\n              contributions[i].amount = 0;\n              if(!contributions[i].addr.send(contributions[i].amount)) {\n                contributions[i].amount = amountToRefund;\n                emit LogErr(contributions[i].addr, contributions[i].amount);\n                revert();\n              } else{\n                project.totalRaised -= amountToRefund;\n                project.currentBalance = project.totalRaised;\n                emit Refund(contributions[i].addr, contributions[i].amount);\n              }\n            } \n        }\n        project.completeAt = now;\n    }\n    function destroy() public onlyOwner atEndOfCampain {\n        selfdestruct(msg.sender);\n    }\n}\n```", "```\n      0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 30, 100, \"smartchart\", \n      \"smartchart.tech\"\n```"]