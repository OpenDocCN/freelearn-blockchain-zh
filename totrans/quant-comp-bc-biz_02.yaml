- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum Computing – Key Discussion Points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a recent event, I was asked a question on the kind of problems a quantum
    computer could solve that a classical computer cannot. The audience were also
    keen to understand why quantum computers were able to do things that classical
    computers have historically struggled with. A quantum computer could potentially
    model nature and the complexities that lie within. Classical computers are yet
    to scale to that extent as bits exist in two states. The ability of quantum systems
    to exist in superpositions allows them to deal with the problems of exponential.
    In order to understand how quantum computers can, in effect, leapfrog innovations
    in several industries, it is critical to understand the fundamental principles
    of quantum physics that underlie quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these principles of quantum physics have evolved over a century, and
    have a particular weirdness about them, as they are often counter-intuitive to
    minds that have dealt with behavior and the physics of macroscopic objects. I
    have tried to capture the core principles of quantum computing (as they are understood
    today) that can explain the behavior of subatomic elements that quantum physics
    deals with. The best way to understand them in detail would be to learn the physics
    and math underlying these concepts. However, the purpose of this book is to look
    at the practical applications of quantum computing. So, I have put together real-life
    examples, and relied upon very little math and physics to explain these concepts.
    The remainder of this chapter will discuss these concepts, starting with superposition.
  prefs: []
  type: TYPE_NORMAL
- en: Superposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Superposition is one of the properties that differentiates a quantum computer
    from a classical computer. The qubits of a quantum computer can exist in 0s and
    1s and linear combinations of both of these states. A quantum computer can achieve
    a special kind of superposition that allows for exponentially more logical states
    at once. This helps in solving problems such as factoring large numbers, which
    is typically hard for classical computers to solve. Classical computers are limited
    in terms of their ability to model the number of permutations and combinations
    that cryptography needs.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the application of quantum computers in cryptography involves
    RSA encryption. RSA encryption involves two large prime numbers being multiplied to arrive
    at a larger number. The following examples should bring these challenges to life.
  prefs: []
  type: TYPE_NORMAL
- en: An exponential challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The story of the chessboard and rice brings to life the challenges in dealing
    with the exponential. When the game of chess was presented to a Sultan, he offered
    the inventor of the game any reward he pleased. The inventor proposed to get a
    grain of rice for the first square, two grains for the second, and four for the
    third and so on. With every square, the number of grains of rice would double.
    The Sultan failed to see what he was dealing with, and agreed to pay the rice
    grains.
  prefs: []
  type: TYPE_NORMAL
- en: A few days later, the inventor came back and checked with the Sultan. The Sultan's
    advisors realized that it would take a large quantity of rice to pay off the inventor.
    The 64th square of the chess board will need 2^(63) grains of rice, which is 9,223,372,036,854,775,808
    grains.
  prefs: []
  type: TYPE_NORMAL
- en: '![C:\Users\karun_000\Dropbox\Quantum Chain\Book\Chapters\shutterstock_1024490005.jpg](img/B13910_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Chess board and rice grains'
  prefs: []
  type: TYPE_NORMAL
- en: The five coins puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linear regression is one of the statistical modeling techniques used to arrive
    at the value of a dependent variable *x* from independent variables a and b. A
    function *f(x)* represents the relationship between *x*, *a*, and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: Most real-world problems are often not as simple as arriving at the dependent
    variable from a few independent variables. Often, the independent variables a
    and b are correlated. Assume a and b interact with each other and their interactions
    affect the resultant variable *x*. All possible combinations of interactions of
    a and b need to be factored into calculating *x*. Assume, instead of just two
    variables, that *x* is dependent on a larger number of variables. The possible
    interactions between these variables make the problem hard to model for traditional
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about a game involving five coins. The aim of the game is to achieve
    either the smallest or the largest possible score after tossing them. Each coin
    has a value, which can be positive or negative, and can be heads or tails, which
    also translates to be positive or negative. The overall score in the game is calculated
    by each coin's *state* (heads or tails), multiplied by the coin's value, and adding
    the score of each coin together to derive a total.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Coin Identifier** | **State (Head = +1, Tail = -1)** | **Value** | **State*
    Value** |'
  prefs: []
  type: TYPE_TB
- en: '| coin1 | 1 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| coin2 | -1 | 3 | -3 |'
  prefs: []
  type: TYPE_TB
- en: '| coin3 | 1 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| coin4 | 1 | 5 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| coin5 | -1 | -1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Total | 10 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1: Detailing the five coins puzzle'
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to get the lowest total possible total in this set up, we would
    need heads (+1) for all coins where the values are negative, and tails (-1) for
    all coins where the values are positive.
  prefs: []
  type: TYPE_NORMAL
- en: That would give us a total of -16, as shown in *Table 2*. Using the same logic,
    if I had to get the highest total, I would need heads for all coins where the
    values are positive, and tails where the values are negative, for a total of +16.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Coin Identifier** | **State (Head = +1, Tail = -1)** | **Value** | **State*
    Value** |'
  prefs: []
  type: TYPE_TB
- en: '| coin1 | -1 | 4 | -4 |'
  prefs: []
  type: TYPE_TB
- en: '| coin2 | -1 | 3 | -3 |'
  prefs: []
  type: TYPE_TB
- en: '| coin3 | -1 | 3 | -3 |'
  prefs: []
  type: TYPE_TB
- en: '| coin4 | -1 | 5 | -5 |'
  prefs: []
  type: TYPE_TB
- en: '| coin5 | -1 | 1 | -1 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Total | -16 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2: Getting the lowest possible score in the five coins puzzle'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add one more variable to the mix. Let us call it the correlation
    variable. The correlation between coin1 and coin2 can be represented by C(1,2).
    We have to consider the coins as pairs as well as individual coins. We will have
    far more variables to deal with in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, if we have to find a total with just the first two coins:'
  prefs: []
  type: TYPE_NORMAL
- en: Total = S1W1 + S2W2 + (C(1,2)*S1*S2)
  prefs: []
  type: TYPE_NORMAL
- en: However, if we wanted to identify the lowest total with just the two coins,
    we will need to trial it with both head and tail states for both the coins to
    get the minimal value for the total. That would be four states (HH, HT, TH, TT)
    for two coins. If we added yet another coin to the mix, the number of states would
    increase to eight states (HHH, HHT, HTH, THH, HTT, TTH, THT, TTT). The number
    of states to consider would be 2^N , where *N* will be the number of coins used
    to calculate the total. As we saw in the Chess example, this will quickly become
    a problem that is hard for conventional computers to solve. In a quantum computing
    world, the information of states could be stored more efficiently using superpositions.
    Qubits can be in both head and tail states at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: A quantum computer addresses a quantum representation such as this and identifies
    the states of the coins to arrive at the lowest value. The process involves starting
    the system with the qubits in superposition, and adjusting the states to turn
    off the superposition effect. As the correlation variable is fed into the system
    simultaneously, the superposition states will be turned off, and classical states
    for each of the coins will be chosen (heads or tails).
  prefs: []
  type: TYPE_NORMAL
- en: Addressing the need for exponential computing power is a considerable difference
    that quantum computing brings to the world of problem solving. In real-world scenarios
    like simulating cancer cell behavior to radio therapy, modeling stock price actions
    to market risk factors, or finding the shortest and quickest flight route from
    source to destination, quantum computing can provide several answers with varying degrees
    of confidence.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in *Chapter 14*, *Interview with Dinesh Nagarajan, Partner,
    IBM*, quantum gates act as operators that help qubits transition from one state
    to another. A quantum gate, in its basic form, is a 2 x 2 unitary matrix that
    is reversible, and preserves norms and probability amplitudes. Probability amplitude
    is a complex number that provides a relationship between the wave function of
    a quantum system and the results of observations of that system.
  prefs: []
  type: TYPE_NORMAL
- en: In simplistic terms, a qubit in a base state of 0 or 1 can be put into superposition
    or an excited state when it goes through a gate. An algorithm that uses quantum
    gates to interact with qubits and provide results is called a quantum algorithm.
    When a quantum computer is represented in a circuit diagram, the wires represent
    the flow of electrons through the circuit, and each gate represents a change in
    the pattern of movement of the electron. Therefore, quantum gates are effectively
    used to drive the system to produce a result. Unlike a classical computing algorithm,
    quantum algorithms often provide probabilistic results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaway**: There are real-world problems that are currently unsolved, or
    are solved through approximations. Once quantum computers become mainstream, some
    of these complex problems can be addressed more effectively and with greater precision.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on to the next quantum concept of entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement – spooky action at a distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quantum property of entanglement was referred to by Einstein as *Spooky
    action at a distance*. Two particles in a system are entangled if one particle
    in a system cannot be described without taking the other part into consideration.
    In a quantum computer, qubits demonstrate this property. So, the probability of
    observing the configuration of one qubit will depend on the probability of observing the
    configuration of its entangled other half. This property of qubits exists in a
    quantum system, even when the entangled pair are separated by a good distance.
    This means, if one qubit spins in a clockwise direction, its entangled pair could
    spin in a counter-clockwise direction, even when miles apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, scientists in China have demonstrated entanglement at a distance
    of up to 1,200 kilometres. Source: [https://phys.org/news/2018-01-real-world-intercontinental-quantum-enabled-micius.html](https://phys.org/news/2018-01-real-world-intercontinental-quantum-enabled-micius.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This experiment was conducted between a satellite and earth, where entangled
    particles were used to communicate instantaneously. The challenge in making entanglement
    happen over long distances is that the particles often get lost when transmitted
    through fiber optic networks. However, scientists have recently used laser beams
    on the world's first quantum-enabled satellite called Micius, to communicate using
    entangled photons across three different earth stations in China. Previous attempts
    at quantum communication were limited to a few hundred kilometres; this was primarily
    due to data channel losses that occurred in optical fibers.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from long distance communication, quantum teleportation (which is based
    on entanglement) is an important concept in cryptography. Quantum teleportation
    is the process of transmitting information between two entangled qubits that could
    be separated by a long distance. In contrast to traditional means of secure data
    transmission, this method relies on entanglement of qubits and not on complex
    encryption functions. Quantum teleportation could be significant as it could soon
    be the foundational element of a secure internet or any communication network.
    In the next section, we discuss a Bloch sphere, which helps visualize the states
    of qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Bloch sphere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Bloch sphere, named after Felix Bloch, is a three dimensional, geometric representation
    of a qubit's states as points on the surface of the sphere. It also helps us understand
    how a qubit's state changes when put through a gate (operations). As it represents
    one qubit, it is not meant to demonstrate the entanglement property, where interactions
    between multiple qubits need to be considered. This section is mathematical by
    necessity, but it will be the only section in the book that uses math to this
    extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The poles of the Bloch sphere represent the classical states of a bit: ![](img/B13910_02_001.png)
    and ![](img/B13910_02_002.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: A Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'The state of the qubit, ![](img/B13910_02_003.png), diagrammatically represented
    by a Bloch sphere, can be given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Equation 1: Quantum computing for computer scientists, N. Yanofsky and M. Mannucci,
    Cambridge Press, 2008.'
  prefs: []
  type: TYPE_NORMAL
- en: In this representation, ![](img/B13910_02_005.png) corresponds to the latitude
    and ![](img/B13910_02_006.png) corresponds to the longitude of the qubit. Any
    point in the Bloch sphere can be represented by the range of values that ![](img/B13910_02_007.png)
    and ![](img/B13910_02_008.png) can take, given by ![](img/B13910_02_009.png) and
    ![](img/B13910_02_010.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that:'
  prefs: []
  type: TYPE_NORMAL
- en: When ![](img/B13910_02_011.png), and that represents the state of the classical
    bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When ![](img/B13910_02_012.png), and that represents another state of the classical
    bit. This is because φ represents the longitude, and it is meaningless at the
    pole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If ![](img/B13910_02_013.png) took other values between 0 and ![](img/B13910_02_014.png),
    this would lead to a superposition state of the qubit. So, while the poles of
    the Bloch sphere derived from the equation represent the states of a classical
    bit, the state of a qubit can be given by any point in the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: How does the Bloch sphere represent the possible changes in states of a qubit,
    especially when they are observed? Continuing from the discussion in *Chapter
    14*, *Interview with Dinesh Nagarajan, Partner, IBM*, we know that the state of
    the qubit collapses to the classical states under observation. The angle ![](img/B13910_02_015.png)
    represents the probability with which the state of the qubit will collapse to
    either of the two states. If the arrow that represents the Bloch sphere is closer
    to the North Pole of the sphere, the state collapses to ![](img/B13910_02_016.png)
    and vice versa. In the next section, we look at one of the most impactful algorithms
    in the history of quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: Shor's algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Peter Shor and his work have perhaps had the most impact on the evolution of
    quantum computing. In 1994, he proposed a polynomial time quantum algorithm for identifying
    prime factors. Richard Feynman [1982, 1986] had already proposed the idea of quantum
    computing to be more powerful than classical computers. However, Shor was the
    first to bring to light a practical application of quantum computers. Using his
    algorithm that demonstrates identification of prime factors of a large number,
    he inspired a generation of scientist to focus on the algorithmic acceleration
    possible using quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factoring has been a mathematical challenge for a long period of time. Think
    about the number 35\. It has two prime factors: 5 and 7\. Similarly, the number
    142 has two prime factors: 11 and 13\. If there was a large odd number *N* whose
    prime factors have to be identified, we will need to divide *N* by all prime numbers
    up to ![](img/B13910_02_017.png) to identify the factors. This is a brute force
    method and is computationally intensive. Modern-day RSA cryptography relies on
    prime factoring to encrypt all our data. Passwords for our logins, credit card
    details, and other sensitive information rely on the computational difficulties
    of factoring to be safe from hackers.'
  prefs: []
  type: TYPE_NORMAL
- en: As it stands today, RSA 2048 has numbers going up to 617 decimal digits. While
    the factorization process has gone up through the RSA bit ranking, cracking an
    RSA 2048 number is a few years away. The Shor's algorithm provides a theoretical
    model to simplify factorization.
  prefs: []
  type: TYPE_NORMAL
- en: Factorization of a number can be simplified if the period of the modular exponential
    function is calculated. Let us take an example to understand the modular operation
    and the concept of period. That will help us go through the factoring algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of *a (mod b)* is the remainder when a is divided by b. A few examples
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 (mod 5) = 2
  prefs: []
  type: TYPE_NORMAL
- en: 21 (mod 7) = 0
  prefs: []
  type: TYPE_NORMAL
- en: 18 (mod 7) = 4
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to understand the concept of period. Say *N* is the number
    we need to find the factors of, and x is a co-prime to *N*. We use the following
    power function:'
  prefs: []
  type: TYPE_NORMAL
- en: x^a Mod (N)
  prefs: []
  type: TYPE_NORMAL
- en: Now, to go through the factoring algorithm, let us take an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say *N* = 91 and x = 3 (co-prime to *N*). When two numbers are co-primed, their
    **greatest common divisor** (**gcd**) is 1, applying the above power function
    to derive the period:'
  prefs: []
  type: TYPE_NORMAL
- en: 3⁰ Mod (91) = 1
  prefs: []
  type: TYPE_NORMAL
- en: 3¹ Mod (91) = 3
  prefs: []
  type: TYPE_NORMAL
- en: 3² Mod (91) = 9
  prefs: []
  type: TYPE_NORMAL
- en: 3¹ Mod (91) = 27
  prefs: []
  type: TYPE_NORMAL
- en: 3⁴ Mod (91) = 81
  prefs: []
  type: TYPE_NORMAL
- en: 3⁵ Mod (91) = 61
  prefs: []
  type: TYPE_NORMAL
- en: 3⁶ Mod (91) = 1
  prefs: []
  type: TYPE_NORMAL
- en: 3⁷ Mod (91) = 3
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the sequence starts repeating itself after six increments of
    a. This is the period, which in this case is "6". Identifying the period is a
    hard problem to solve in factorization. However, once that is done, the factors
    can be arrived at using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As r = 6, *N* =91, and x = 3 in this example, we can arrive at:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the factoring algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: gcd(28,91) or gcd(26,91) will be a non-trivial factor of 91, where gcd stands
    for *greatest common divisor*. And in this case, gcd(26,91) = 13\. Once that has
    been identified, the other factor can be identified as 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is a simple example of how the factoring algorithm works. Shor proposed
    that some of the steps in this factoring algorithm happen in a quantum computer,
    while the pre-processing and the post-processing took place in a classical computer.
    These are the steps that describe the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: In the above example, pick 3 as the co-prime to 91 using a classical
    computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: Create two quantum registers. Register 1 will h store the increments
    of a, in x^a Mod (N). Register 2 will store the results of x^a Mod (N).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: Apply Quantum Fourier transforms to register 1 and compute the
    period r = 6 in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**: Once the period is identified, find the gcd and arrive at the non-trivial
    factor of 91 using classical computers.'
  prefs: []
  type: TYPE_NORMAL
- en: Shor's algorithm provided a way to do the modular exponentiation and identify
    the period using quantum computing. Every element in the sequence x^a Mod (N)
    contributes to the amplitude of the period of the sequence. For all periods calculated,
    other than the right one, the spin of these contributions is in different directions,
    and hence cancel one another out. The true period, the contribution from the sequence,
    points in the same direction and gets chosen as the right value with a high probability.
    We will now look at Grover's algorithm, which offers an increase in search performance
    on unstructured data.
  prefs: []
  type: TYPE_NORMAL
- en: Grover's algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lov Grover published a paper in 1996 describing Grover's algorithm. The application of
    Grover's algorithm to unstructured searches provides a quadratic speed up. If
    you want to find an item in a database and if the data is not sorted, using Grover's
    algorithm implemented using quantum computers can provide better performance than
    classical computers.
  prefs: []
  type: TYPE_NORMAL
- en: When a name had to be identified from *N* names within a database, and if the
    names were sorted, a classical computer could perform a binary search to find
    the name in logarithmic time. If the names were not sorted, then the search would
    involve scanning up to the *N*-1 name to find the right one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If S[a] is the element we are trying to find from the database of *N* elements,
    using Grover''s algorithm can help solve the problem with ![](img/B13910_02_017.png)
    attempts. Qubits are prepared so that all numbers are in a uniform superposition
    using a Hadamard gate. Measuring the qubits at this stage would show that all
    results were equally likely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Achieving uniform amplitudes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following equation represents the uniform magnitude of all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, an oracle gate is applied to flip the amplitude of s[a] and leaves the
    rest unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The graph can now be represented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Flipping the amplitude string that matches'
  prefs: []
  type: TYPE_NORMAL
- en: Now the amplitude of the desired element S[a] has been flipped (to negative).
    Hence, the mean of the amplitudes ![](img/B13910_02_023.png) would have been reduced.
    This is where the Grover diffusion operator is introduced to increase the amplitude
    of S[a] absolutely.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this operator does is to flip the amplitudes at the average. This results
    in the amplitude of S[a]increasing to about ![](img/B13910_02_024.png) in magnitude.
    The amplitudes looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Flipping amplitudes at the mean'
  prefs: []
  type: TYPE_NORMAL
- en: This process of applying the oracle gate and the Grover diffusion gate is repeated
    until the amplitude is significant enough. Care must also be taken that the amplitude
    of S[a] is not too large that the mean amplitude turns negative, which in turn
    will start reducing the amplitude of S[a]. At the point when the amplitude is
    almost one, the measurement of the qubits will provide the right answer. It can
    be demonstrated that this process, when repeated for about ![](img/B13910_02_025.png),
    provides accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaway**: The Shor and Grover algorithms laid the foundations for quantum
    computing and identified practical use cases that these algorithms can help solve.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to quantum annealing, which is a technique used to address
    optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how superposition of qubits achieved by operations using gates
    can solve real-world problems. There are other methods to arrive at an optimized
    solution. Quantum annealing is the process of arriving at global minima using
    quantum fluctuations. The quantum tunneling effect can help with transition between states
    in a quantum annealer.
  prefs: []
  type: TYPE_NORMAL
- en: During the quantum annealing process, the information required for optimization
    is modeled into a physical system. This process involves codifying an optimization
    problem of several correlated variables into a physical system (represented by
    qubits in superposition).
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the problem is represented by the minimal energy state of the
    system, and the simplest function used to achieve this is called Hamiltonian.
    Quantum annealing powered by the quantum tunneling effect can address problems
    in logistics for example.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum tunneling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quantum tunneling is a quantum property where particles pass through high energy
    systems. In classical physics, when an electron encounters an electric field,
    it gets repelled if the electric field is stronger than that of the electron.
    Problems that are solved using quantum annealing rely on the quantum tunneling
    property of particles.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: An electron approaching an electric field'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: An electron repelled by the electric field'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: An electron wave moving toward an electric field'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13910_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: An electron wave tunneling through an electric field'
  prefs: []
  type: TYPE_NORMAL
- en: Tunneling is a property that was observed by Friedrich Hund in 1927\. If an
    electron, that is traveling as a wave encounters an electric field that repels
    it, there is still a probability that it will pass through the electric field
    and find itself on the other side of the field (*Figure 9*). subatomic particles
    display tunneling properties during a radioactive decay, when particles escape
    an unstable nuclei.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealing is a process that depends on the tunneling properties of particles. Let
    us look at a practical example where quantum annealing can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The traveling salesman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The traveling salesman problem is a well-documented application of quantum
    tunneling. Say we have a salesman selling goods across a country. The optimal
    route for him to go through the country would depend on the number of cities in the country.
    If the country has three cities (A, B, and C), the optimal route could be A ->
    B -> C or A -> C -> B or B -> A -> C or B -> C -> A or C -> A-> B or C -> B ->
    A. The number of possible routes (6) is dependent on the number of cities here
    (3). The number of possible routes can be given by the factorial of the number
    of cities as:'
  prefs: []
  type: TYPE_NORMAL
- en: 3! = 3 * 2 * 1 = 6
  prefs: []
  type: TYPE_NORMAL
- en: When the number of cities doubles to 6, the number of possible routes would
    be 6! = 720, which is a drastic increase. Apart from the increase in the number
    of cities, there could be other issues such as traffic jams at a point in time,
    or a road that is particularly bad. The optimal route, therefore, may not necessarily
    be the shortest route. We first need to set up the system to identify the optimal
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let's prepare the system in a quantum superposition of many possible solutions
    of the problem. The system can be now viewed as a landscape of peaks and valleys.
    Peaks are high energy states and are expensive. Valleys, on the other hand, represent
    low energy states. As we transition between one valley and another, the probability
    of each solution evolves. The lower energy options become the more likely solution,
    until the highest probability solution is identified as the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: In simulated annealing, heat is used to go over peaks and transition between
    valleys. With quantum annealers, the quantum tunneling effect allows us to *pass*
    the high energy *peaks* through tunnels instead of climbing them, as in simulated
    annealing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum annealing is driven by an external magnetic field that plays the role
    of the temperature in simulated annealing: the quantum annealing starts with a
    high magnetic field (high temperature) and ends up with a low magnetic field (low
    temperature).'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealing is the process of feeding the information required for optimization
    into a physical system. The solution to the problem will be defined by the ground
    state (lowest energy state) of the system. The function used for this process
    is called the Hamiltonian function, which manages information on the energy levels
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Hamiltonian to manage the energy levels of the system based on
    a framework of constraints. In the traveling salesman problem, we can have higher
    energy levels assigned to longer distances, bad roads, traffic jams, and road
    closures. The optimal route would be the one with the lowest energy level. Considering
    this, how do we identify the lowest energy solution?
  prefs: []
  type: TYPE_NORMAL
- en: The Hamiltonian function, and the terms we add to it to increase the energy
    levels, would create peaks and troughs in the energy space. We need to find the
    troughs without having to climb the peak energy levels. This can be achieved by
    quantum tunneling, as described above. While this allows us to move from one trough
    to the other, how can we identify the lowest trough? A quantum technique called
    adiabatic quantum computation can be used for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The term *adiabatic* comes from the theory of thermodynamics and means *without
    changing the amount of heat*. In this process, the system is initialized at the
    ground state, and then slowly evolved into more complex Hamiltonians whose ground
    states encode the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Hamiltonian encodes the correct assignment of variables by assigning an
    *energy penalty* to all of the incorrect configurations. The peaks in the landscape
    have a higher penalty and the valleys have a lower penalty. The optimal solution
    with the lowest energy level generally has an eigenvalue of 0\. We can time evolve
    the system to:'
  prefs: []
  type: TYPE_NORMAL
- en: H(s) = (1 − s) H[0] + sH[1]
  prefs: []
  type: TYPE_NORMAL
- en: At time s = 1, the Hamiltonian is H(1) = H[s], and the system will be in its
    ground state if the evolution has been slow. Eigenvalues and Eigenvectors are
    used across several real-world algorithms. They are used in modeling the physics
    of rotating bodies, oscillations of vibrating systems, and in risk modeling in
    investment banks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eigenvalues are defined below by Hoffman and Kunze (1971):'
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvalues are a special set of scalars associated with a linear system of
    equations (in other words, a matrix equation) that are sometimes also known as
    characteristic roots, characteristic values (Hoffman and Kunze 1971), proper values,
    or latent roots (Marcus and Minc 1988, p. 144).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Reference: [http://mathworld.wolfram.com/Eigenvalue.html](http://mathworld.wolfram.com/Eigenvalue.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum annealing can be used to solve optimization problems. However, we may
    not have to wait for quantum computers to use the principles of quantum annealing
    and quantum tunneling to achieve results. Fujitsu have already created a "*Quantum
    inspired digital annealer*" to solve challenging optimization problems in financial
    risk management and financial portfolio rebalancing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaway**: Quantum annealing can be used in optimizing problems across several
    industries. Finance, logistics, healthcare, and smart cities are all areas where
    this technique can be used to optimize complex problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite all these amazing possibilities with Quantum techniques, decoherence
    is a major challenge. Let's look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Decoherence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed the Quantum Slit experiment in *Chapter 1*, *Introduction to Quantum
    Computing and Blockchain*, where we saw that photons moved through the slits and
    behaved like waves (interfering with themselves), even though they were sent one
    at a time. When a particle exhibits properties of a wave, where it interferes
    with itself, it is said to be coherent. Decoherence is the loss or the suppression
    of coherence in a system.
  prefs: []
  type: TYPE_NORMAL
- en: The wave function that explains the behavior of the particle collapses when
    the state of the particle is observed. This process of decoherence, in which the
    particle that was in a superposition of states collapses to one of the two classical
    states when observed, is considered a bridge between quantum and classical physics.
    The experiment could be on an electron in superposition, and if the observer is
    measuring the z-component of the spin, the experiment will output a definite value of
    the z-component of the spin. The x-component could still remain in superposition.
    This aligns with Bohr's interpretation that properties in the quantum world come
    into existence when observed.
  prefs: []
  type: TYPE_NORMAL
- en: We know that macroscopic objects, such as human beings, do not exhibit this
    property – adopting a given state only when observed. Of course, we all exhibit
    virtuous characteristics when we know we are observed, and sometimes vice versa,
    but this is not the case with inherent attributes such as *alive* or *dead*! On
    a more serious note, how can things in the quantum world exist in multiple states
    at the same time until they are observed?
  prefs: []
  type: TYPE_NORMAL
- en: 'Erwin Schrodinger devised a thought experiment to illustrate the counter-intuitive
    nature, and seeming absurdity, of this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: A cat, radioactive material, and poison gas were placed in a box. If radioactivity
    is detected, the flask containing the poison gas would be broken and the cat would
    die. The radioactive material was small enough that radioactivity may not be detected
    for some time. Thus, at any given time, those outside of the box would be unable
    to determine whether the cat was alive or dead. Thus, by quantum logic, the cat
    could be considered to be both alive and dead!
  prefs: []
  type: TYPE_NORMAL
- en: Schrodinger questioned how this could possibly be the case within the quantum
    world, when it is clearly not the case in the macroscopic world. All quantum experiments
    thus far, however, have affirmed the theory that quantum objects do indeed appear
    capable of existing in two states until observed.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Error Correction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Quantum Error Correction** (**QEC**) is a critical process that makes the
    results of the quantum system reliable. In the initial days of quantum computing,
    correcting a quantum computer efficiently without triggering decoherence of the
    computation was considered highly non-intuitive. A lack of reliable error correction
    in a quantum system was a major roadblock because quantum algorithms use interference,
    which is fragile. This interference made quantum algorithms sensitive to imprecision
    in the system and to the coupling between the system and the rest of the world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common reasons for errors include:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation of the initial state of the system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decoherence of qubits can occur due to interactions with the environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inaccuracies in gates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imperfections in the measurement process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peter Shor and Andrew Steane developed the first set of quantum error correcting
    codes. While Peter Shor identified that 9 qubits could be put together to perform
    error correction on one qubit, Steane discovered a 7-qubit error correction methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Loss in quantum information due to interference with the environment can be
    addressed using the distribution of information. If the information is distributed
    across several qubits instead of one qubit, the information is safer. In classical
    computing, error correction using repetition code uses three bits to store copies
    of information from one bit. So, unless two of the copies are error prone, the
    information is intact. While this is a simple process in classical computers,
    with quantum computers, copying information from one qubit to another is more
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: It was Shor who proposed a method to generalize the repetition code method for
    quantum computers. The solution he proposed was to encode a qubit with the repetition
    code on the basis states.
  prefs: []
  type: TYPE_NORMAL
- en: Post-selected quantum computation was developed by Emanuel Knill, and demonstrated
    that quantum computing at scale could be achieved through error detection rather
    than error correction. The quantum computer would have error detecting circuits
    and if errors (noise) are detected to have breached a threshold, the relevant
    subroutine of the algorithm is reset and re-run. This addresses high levels of
    error tolerance but has high resource requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful method for dealing with quantum errors is to use quantum error
    correcting codes called stabilizers. These are quite useful tools for developers
    of quantum systems. The stabilizer code specification has numerous applications,
    including the design of preparation circuits, correction circuits, and fault-tolerant
    logical gates. Using stabilizers to define quantum error correction codes helps
    apply logical operations on encoded data using correction circuits. The 7-qubit
    method developed by Andrew Steane, which constructs a logical qubit using seven
    physical qubits, has the ability to correct single X or Z errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaway**: The key takeaway is that error correction in quantum computing
    is a non-trivial exercise. The complexities in QEC and the various options available
    to address them are worthy of a whole book. It is a critical aspect of quantum
    computing that has helped transform quantum computing from theories to a practical
    possibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand the interviews in this book, and the key inferences from
    them, it is essential that this chapter is well understood by the reader. For
    the same reason, I have described the concepts of quantum computing using practical
    examples, with comparisons to classical computing equivalents. There are a few
    concepts of quantum computing that are hard to grasp without delving into the
    underlying physics (if not the math). In such cases, the simplification of the
    underlying concepts of physics in this chapter would help understand the weirdness in
    the behavior of microscopic elements that make up a quantum system. The simplified
    version may make a quantum scientist cringe, but I firmly believe that simplifying
    the narrative is critical for any technology to go mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www2.physics.ox.ac.uk/sites/default/files/ErrorCorrectionSteane06.pdf](https://www2.physics.ox.ac.uk/sites/default/files/ErrorCorrectionSteane06.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://journals.jps.jp/doi/full/10.7566/JPSJ.88.061009](https://journals.jps.jp/doi/full/10.7566/JPSJ.88.061009)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://arxiv.org/pdf/quant-ph/9508027.pdf](https://arxiv.org/pdf/quant-ph/9508027.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://science.sciencemag.org/content/356/6343/1140](http://science.sciencemag.org/content/356/6343/1140)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://people.cs.umass.edu/~strubell/doc/quantum_tutorial.pdf](https://people.cs.umass.edu/~strubell/doc/quantum_tutorial.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/05.pdf](https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/05.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://grove-docs.readthedocs.io/en/latest/vqe.html](https://grove-docs.readthedocs.io/en/latest/vqe.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=beginners-guide&page=004-The_Weird_and_Wonderful_World_of_the_Qubit~2F001-The_Weird_and_Wonderful_World_of_the_Qubit](https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=beginners-guide&page=004-The_Weird_and_Wonderful_World_of_the_Qubit~2F001-The_Weird_and_Wonderful_World_of_the_Qubit)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://medium.com/@jonathan_hui/qc-cracking-rsa-with-shors-algorithm-bc22cb7b7767](mailto:https://medium.com/@jonathan_hui/qc-cracking-rsa-with-shors-algorithm-bc22cb7b7767)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/070-Grover''s_Algorithm.html](https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/070-Grover''s_Algorithm.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.cs.cmu.edu/~odonnell/quantum15/lecture04.pdf](https://www.cs.cmu.edu/~odonnell/quantum15/lecture04.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://medium.com/@quantum_wa/quantum-annealing-cdb129e96601](mailto:https://medium.com/@quantum_wa/quantum-annealing-cdb129e96601)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
