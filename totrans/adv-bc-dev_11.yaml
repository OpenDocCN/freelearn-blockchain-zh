- en: Development Tools and Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is an introduction to development tools, languages, and frameworks
    used for Ethereum smart contract development. We will examine different methods
    of developing smart contracts for the Ethereum blockchain. We will discuss various
    constructs of Solidity language in detail, which is currently the most popular
    development language for smart contract development on Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Development tools, IDEs, and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remix
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EthereumJS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TestRPC
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MetaMask
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Node Package Manager (NPM)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools and utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of tools available for Ethereum development. The following
    diagram shows the taxonomy of various development tools, clients, IDEs, and development
    frameworks for Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b00d90c-5e15-45a2-9d66-348e46e5aa28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taxonomy of Ethereum development ecosystem components
  prefs: []
  type: TYPE_NORMAL
- en: The preceding taxonomy does not include all frameworks and tools that are out
    there for development on Ethereum. It shows most commonly used tools and frameworks
    and also the ones that we will use in our examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are number of resources available related to development tools for Ethereum
    at the address [http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools](http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#developer-tools).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the main focus will be on Geth, Remix IDE, Solidity, Ganache,
    MetaMask, solc, and Truffle. The rest of the elements such as prerequisites (Node)
    will also be discussed briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smart contracts can be programmed in a variety of languages for Ethereum blockchain.
    There are five languages that can be used in order to write contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutan**: This is a Go-style language, which was deprecated in early 2015
    and is no longer used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLL**: This is a **Low-level Lisp-like Language**, hence the name LLL. This
    is also not used anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serpent**: This is a simple and clean Python-like language. It is not used
    for contract development anymore and not supported by the community anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solidity**: This language has now become almost a standard for contract writing
    for Ethereum. This language is the focus of this chapter and is discussed in detail
    in later sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vyper**: This language is a Python-like experimental language that is being
    developed to bring security, simplicity, and auditability to smart contract development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilers are used to convert high-level contract source code into the format
    that the Ethereum execution environment understands. The Solidity compiler is
    the most common one in use and is discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity compiler (solc)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: solc converts from a high-level solidity language into **Ethereum Virtual Machine**
    (**EVM**) bytecode so that it can be executed on the blockchain by EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'solc can be installed on a Linux Ubuntu operating system using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If PPAs are not already installed, those can be installed by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to verify the existing version of the solc and verify that it is installed,
    the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installation on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install solc on macOS, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'solc supports a variety of functions. A few examples are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display contract in a binary format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will produce an output similar to the following. This shows the
    binary translation of the
  prefs: []
  type: TYPE_NORMAL
- en: '`Addition.sol` contract code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/626c8c00-4fc7-4468-9733-8e8901efd663.png)'
  prefs: []
  type: TYPE_IMG
- en: Solidity compiler binary output
  prefs: []
  type: TYPE_NORMAL
- en: 'Estimate gas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0d9ee29-bdc2-4111-8d4c-b1a49d65a050.png)'
  prefs: []
  type: TYPE_IMG
- en: Gas estimation using solc
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate ABI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the contents of `Addition.abi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compilation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another useful command to compile and produce a binary compiled file along
    with an ABI is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce two files in the output directory `bin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Addition.abi`: This contains the Application Binary Interface of the smart
    contract in JSON format'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Addition.bin`: This contains the hex representation of binary of the smart
    contract code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of both files is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9f46d19-29ea-4048-8c2a-69f28fb91516.png)'
  prefs: []
  type: TYPE_IMG
- en: ABI and binary output of solidity compiler
  prefs: []
  type: TYPE_NORMAL
- en: '**ABI** is the abbreviation of **Application Binary Interface**. ABI encodes
    information about smart contract''s functions and events. It acts as an interface
    between EVM level bytecode and high level smart contract program code. To interact
    with a smart contract deployed on the Ethereum blockchain, external programs require
    ABI and address of the smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: solc is a very powerful command and further options can be explored using `--
    help` flag which will display detailed options. However, the preceding commands
    used for compilation, ABI generation and gas estimation should be sufficient for
    most development and deployment requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environments (IDEs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various IDEs available for Solidity development. Most of the IDEs
    are available online and are presented via web interfaces. Remix (formerly browser
    Solidity) is the most commonly used IDE for building and debugging smart contracts.
    It is discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix is the web-based environment for the development and testing of contracts
    using Solidity. It is a feature-rich IDE which does not run on live blockchain;
    in fact, it is a simulated environment in which contracts can be deployed, tested,
    and debugged.
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [https://remix.ethereum.org](https://remix.ethereum.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example interface is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af2b57aa-d1dc-452e-8647-4e63c648147e.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix IDE
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, there is a code editor with syntax highlighting and code
    formatting, and on the right-hand side, there are a number of tools available
    that can be used to deploy, debug, test, and interact with the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Various features, such as transaction interaction, options to connect to JavaScript
    VM, configuration of execution environment, debugger, formal verification, and
    static analysis, are available. They can be configured to connect to execution
    environments such as JavaScript VM, injected Web3—where Mist, MetaMask, or a similar
    environment has provided the execution environment—or Web3 provider, which allows
    connection to the locally running Ethereum client (for example, `geth`) via IPC
    or RPC over HTTP (Web3 provider endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix also has a debugger for EVM which is very powerful and can be used to
    perform detailed level tracing and analysis of the EVM bytecode. An example is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19dcf11-192c-4187-a770-816be44951e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix IDE, debugging
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows different elements of the Remix IDE. On the top
    left-hand side, the source code is shown. Below that is the output log which shows
    informational messages and data related to compilation and execution of the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shown shows the Remix debugger in more detail. It
    has the source code decoded into EVM instructions. The user can step through the
    instructions one by one and can examine what the source code does when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fb8ca55-767d-497a-b30d-3a3c7f61a4e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix Debugger
  prefs: []
  type: TYPE_NORMAL
- en: Tools and libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various tools and libraries available for Ethereum. The most common
    ones are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first install prerequisites that are required for developing
    applications for Ethereum. First requirement is Node, which will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Node version 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Node is required for most of the tools and libraries, it can be installed
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: EthereumJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, it is not possible to test on the testnet and mainnet is obviously
    not a place to test the contracts. Private net can be time-consuming to set up
    at times. EthereumJS' TestRPC comes in handy when quick testing is required and
    no proper testnet is available. It uses EthereumJS to simulate the Ethereum `geth`
    client behavior and allows for faster development testing. TestRPC is available
    via `npm` as a Node package.
  prefs: []
  type: TYPE_NORMAL
- en: Before installing TestRPC, Node should already have been installed and the `npm`
    package manager should also be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'TestRPC can be installed using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start `testrpc`, simply issue this command and keep it running
    in the background and open another Terminal to work on contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When TestRPC runs, it will display the output similar to the one shown in the
    following screenshot. It will automatically generate ten accounts and private
    keys, along with HD wallet. It will start to listen for incoming connection on
    TCP port `8545`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be20a349-f79f-4a24-981f-dcaa1860bafc.png)'
  prefs: []
  type: TYPE_IMG
- en: TestRPC
  prefs: []
  type: TYPE_NORMAL
- en: Ganache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ganache is the latest addition to the plethora of development tools and libraries
    developed for Ethereum. This is, in a way a replacement of TestRPC and uses a
    user-friendly graphical user interface to see transaction and blocks and relevant
    details. This is fully working Byzantium enabled personal blockchain which is
    used to provide a local testing environment for blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Ganache is based on a JavaScript implementation of the Ethereum blockchain,
    with built-in block explorer and mining, making testing locally on the system
    very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot you can view transaction, blocks, and
    addresses in detail on the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec0a456d-3a09-4120-b277-e10f15826df0.png)'
  prefs: []
  type: TYPE_IMG
- en: Ganache, A personal Ethereum blockchain
  prefs: []
  type: TYPE_NORMAL
- en: Ganache can be downloaded from [http://truffleframework.com/ganache/](http://truffleframework.com/ganache/).
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MetaMask allows interaction with Ethereum blockchain via Firefox and Chrome
    browsers. It injects a `web3` object within the running websites' JavaScript context
    which allows immediate interface capability for DApps. This *injection* allows
    DApps to interact directly with the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [https://metamask.io/](https://metamask.io/).
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask also allows account management. This acts as a verification method
    before any transaction is executed on the blockchain. The user is shown a secure
    interface to review the transaction for approval or rejection before it can reach
    the target blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [https://github.com/MetaMask/metamask-plugin](https://github.com/MetaMask/metamask-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c536ff7-2b23-4dbf-9474-f9aeb29f09d8.png)'
  prefs: []
  type: TYPE_IMG
- en: MetaMask
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows connectivity with various Ethereum networks as shown in the following
    screenshot. This is the screenshot of the MetaMask, where it allows users to select
    the network of their choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1581e34-a3cd-4571-a01c-ffaeb0bcf86b.png)'
  prefs: []
  type: TYPE_IMG
- en: MetaMask networks as shown in the MetaMask user interface
  prefs: []
  type: TYPE_NORMAL
- en: An interesting feature to note is that MetaMask can connect to any custom RPC
    too which allows you to run your own blockchain, such as private nets locally
    or even remotely and allows your browser to connect to it. It can also be used
    to connect to a locally running blockchain like Ganache and TestRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'MetaMask allows account management and also records all transactions for these
    accounts. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cda9989-6659-4674-988f-79575bb1e8c5.png)'
  prefs: []
  type: TYPE_IMG
- en: MetaMask accounts and transactions view
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Truffle (available at [http://truffleframework.com/](http://truffleframework.com/))
    is a development environment that makes it easier and simpler to test and deploy
    Ethereum contracts. Truffle provides contract compilation and linking along with
    an automated testing framework using Mocha and Chai. It also makes it easier to
    deploy the contracts to any private net, public, or testnet Ethereum blockchain.
    Also, asset pipeline is provided, which makes it easier for all JavaScript files
    to be processed, making them ready for use by a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before installation, it is assumed that `node` is available, which can be queried
    as shown here. If the `node` is not available, then the installation of `node`
    is required first in order to install `truffle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation of `truffle` is very simple and can be done using the following
    command via **Node Package Manager** (**npm**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take a few minutes; once it is installed, the `truffle` command can
    be used to display help information and verify that it is installed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `truffle` at Terminal to display usage help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea6b7207-c57b-498d-be6b-eb633cfb690f.png)'
  prefs: []
  type: TYPE_IMG
- en: Truffle help
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the repository is available at [https://github.com/ConsenSys/truffle](https://github.com/ConsenSys/truffle),
    which can be cloned locally to install `truffle`. **Git** can be used to clone
    the repository using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Contract development and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various steps that need to be taken in order to develop and deploy
    the contracts. Broadly, these can be divided into four steps: writing, testing,
    verification and deployment. After deployment, the next optional step is to create
    the user interface and present it to the end users via a web server. Web interface
    is sometimes not needed in the contracts where no human input or monitoring is
    required, but usually there is a requirement to create web interface to interact
    with the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The writing step is concerned with writing the contract source code in Solidity.
    This can be done in any text editor. There are various plugins and add-ons available
    for Vim in Linux, Atom, and other editors that provide syntax highlighting and
    formatting for Solidity source code.
  prefs: []
  type: TYPE_NORMAL
- en: Visual studio code has become quite popular and is used commonly for Solidity
    development. There is a Solidity plugin available that allows syntax highlighting,
    formatting, and intelligence. It can be installed via Extensions option in Visual
    Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01077efd-9e90-432a-ac8f-62087ad3c89e.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual studio code
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is usually performed by automated means. Earlier in the chapter, you
    were introduced to Truffle, which uses the Mocha framework to test contracts.
    However, manual functional testing can be performed as well by using Remix and
    running functions manually and validating results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be introduced to language Solidity. This is a
    brief introduction to Solidity, which should provide the base knowledge required
    in order to write the contracts. The syntax is very similar to C and JavaScript,
    and it is quite easy to program.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity is a domain-specific language of choice for programming contracts in
    Ethereum. There are, however, other languages that can be used, such as Serpent,
    Mutan, and LLL but Solidity is the most popular at the time of writing this. Its
    syntax is closer to both JavaScript and C.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity has evolved into a mature language over the last few years and is quite
    easy to use, but it still has a long way to go before it can become advanced,
    standardized, and feature-rich like other well-established languages such as Java,
    C or C Sharp. Nevertheless, this is the most widely used language available for
    programming contracts currently.
  prefs: []
  type: TYPE_NORMAL
- en: It is a statically typed language, which means that variable type checking in
    Solidity is carried out at compile time. Each variable, either state or local,
    must be specified with a type at compile time. This is beneficial in the sense
    that any validation and checking is completed at compile time and certain types
    of bugs, such as interpretation of data types, can be caught earlier in the development
    cycle instead of at runtime, which could be costly, especially in the case of
    the blockchain / smart contracts paradigm. Other features of the language include
    inheritance, libraries, and the ability to define composite data types.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is also called a contract-oriented language. In Solidity, contracts
    are equivalent to the concept of classes in other object-oriented programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity has two categories of data types: **value types** and **reference
    types**.'
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are explained in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This data type has two possible values, `true` or `false`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This statement assigns the value `true` to `v`.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This data type represents integers. The following table shows various keywords
    used to declare integer data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **Types** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Signed integer | `int8` to `int256`, which means that keywords are
    available from `int8` up to `int256` in increments of 8, for example, `int8`,
    `int16`, `int24`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | Unsigned integer | `uint8`, `uint16`, ... to `uint256`, unsigned
    integer from 8 bits to 256 bits. The usage is dependent on the requirements that
    how many bits are required to be stored in the variable. |'
  prefs: []
  type: TYPE_TB
- en: 'For example, in this code, note that `uint` is an alias for `uint256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These types can also be declared with the `constant` keyword, which means that
    no storage slot will be reserved by the compiler for these variables. In this
    case, each occurrence will be replaced with the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: State variables are declared outside the body of a function, and they remain
    available throughout the contract depending on the accessibility assigned to them
    and as long as the contract persists.
  prefs: []
  type: TYPE_NORMAL
- en: Address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This data type holds a 160-bit long (20 byte) value. This type has several
    members that can be used to interact with and query the contracts. These members
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balance**: The `balance` member returns the balance of the address in Wei.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Send**: This member is used to send an amount of ether to an address (Ethereum''s
    160-bit address) and returns `true` or `false` depending on the result of the
    transaction, for example, the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Call functions**: The `call`, `callcode`, and `delegatecall` calls are provided
    in order to interact with functions that do not have ABI. These functions should
    be used with caution as they are not safe to use due to the impact on type safety
    and security of the contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array value types (ﬁxed size and dynamically sized byte arrays)**: Solidity
    has fixed size and dynamically sized byte arrays. Fixed size keywords range from
    `bytes1` to `bytes32`, whereas dynamically sized keywords include `bytes` and
    `string`. The `bytes` keyword is used for raw byte data and `string` is used for
    strings encoded in UTF-8\. As these arrays are returned by the value, calling
    them will incur gas cost. `length` is a member of array value types and returns
    the length of the byte array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a static (fixed size) array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a dynamically sized array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Get length of trades by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These used to represent a fixed value. There are different types of literals
    that are described in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Integer literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integer literals are a sequence of decimal numbers in the range of 0-9\. An
    example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: String literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String literals specify a set of characters written with double or single quotes.
    An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Hexadecimal literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hexadecimal literals are prefixed with the keyword `hex` and specified within
    double or single quotation marks. An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This allows the creation of user-defined types. An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Explicit conversion to and from all integer types is allowed with enums.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two function types: internal and external functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These can be used only within the context of the current contract.
  prefs: []
  type: TYPE_NORMAL
- en: External functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External functions can be called via external function calls.
  prefs: []
  type: TYPE_NORMAL
- en: A **function** in solidity can be marked as a constant. Constant functions cannot
    change anything in the contract; they only return values when they are invoked
    and do not cost any gas. This is the practical implementation of the concept of
    *call.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to declare a function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, these types are passed by reference and are discussed
    in the following section. These are also called **complex types**.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays represent a contiguous set of elements of the same size and type laid
    out at a memory location. The concept is the same as any other programming language.
    Arrays have two members named `length` and `push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These constructs can be used to group a set of dissimilar data types under
    a logical group. These can be used to define new types, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Data location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data location specifies where a particular complex data type will be stored.
    Depending on the default or annotation specified, the location can be storage
    or memory. This is applicable to arrays and structs and can be specified using
    the `storage` or `memory` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: As copying between memory and storage can be quite expensive, specifying a location
    can be helpful to control the gas expenditure at times. **Calldata** is another
    memory location that is used to store function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters of external functions use **calldata** memory. By default, parameters
    of functions are stored in **memory**, whereas all other local variables make
    use of **storage**. State variables, on the other hand, are required to use storage.
  prefs: []
  type: TYPE_NORMAL
- en: Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mappings are used for a key to value mapping. This is a way to associate a
    value with a key. All values in this map are already initialized with all zeroes,
    for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows that offers is declared as a mapping. Another example makes
    this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is basically a dictionary or a hash table where string values are mapped
    to integer values. The mapping named `bids` has string `packt` mapped to value
    `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity provides a number of global variables that are always available in
    the global namespace. These variables provide information about blocks and transactions.
    Additionally, cryptographic functions and address-related variables are available
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subset of available functions and variables is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is used to compute the Keccak-256 hash of the argument provided
    to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the associated address of the public key from the elliptic
    curve signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This returns the current block number.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control structures available in solidity language are `if...else`, `do`, `while`,
    `for`, `break`, `continue`, and `return`. They work exactly the same as other
    languages such as C-language or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**: If `x` is equal to `0` then assign value `0` to `y` else assign `1`
    to `z`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**do**: Increment `x` while `z` is greater than `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**while**: Increment `z` while `x` is greater than `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**for, break, and continue**: Perform some work until `x` is less than or equal
    to `10`. This `for` loop will run `10` times, if `z` is `5` then break the `for`
    loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It will continue the work similarly, but when the condition is met, the loop
    will start again.
  prefs: []
  type: TYPE_NORMAL
- en: '**return**: Return is used to stop the execution of a function and returns
    an optional value. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It will stop the execution and return value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events in Solidity can be used to log certain events in EVM logs. These are
    quite useful when external interfaces are required to be notified of any change
    or event in the contract. These logs are stored on the blockchain in transaction
    logs. Logs cannot be accessed from the contracts but are used as a mechanism to
    notify change of state or the occurrence of an event (meeting a condition) in
    the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simple example here, the `valueEvent` event will return `true` if the
    `x` parameter passed to function `Matcher` is equal to or greater than `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is supported in Solidity. The `is` keyword is used to derive a
    contract from another contract. In the following example, `valueChecker2` is derived
    from the `valueChecker` contract. The derived contract has access to all non-private
    members of the parent contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if the `uint8 price = 20` is changed to `uint8 private
    price = 20`, then it will not be accessible by the `valueChecker2` contract. This
    is because now the member is declared as private, it is not allowed to be accessed
    by any other contract. The error message that you will see in Remix is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Libraries are deployed only once at a specific address and their code is called
    via `CALLCODE` or `DELEGATECALL` opcode of the EVM. The key idea behind libraries
    is code reusability. They are similar to contracts and act as base contracts to
    the calling contracts. A library can be declared as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This library can then be called in the contract, as shown here. First, it needs
    to be imported and then it can be used anywhere in the code. A simple example
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are a few limitations with libraries; for example, they cannot have state
    variables and cannot inherit or be inherited. Moreover, they cannot receive Ether
    either; this is in contrast to contracts that can receive Ether.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Solidity are modules of code that are associated with a contract.
    Functions are declared with a name, optional parameters, access modifier, optional
    `constant` keyword, and optional return type. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `function` is the keyword used to declare the function.
    `orderMatcher` is the function name, `uint x` is an optional parameter, `private`
    is the **access modifier** or **specifier** that controls access to the function
    from external contracts, `constant` is an optional keyword used to specify that
    this function does not change anything in the contract but is used only to retrieve
    values from the contract and `returns (bool return value)` is the optional return
    type of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to define a function**: The syntax of defining a function is shown as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Function signature**: Functions in Solidity are identified by its signature,
    which is the first four bytes of the Keccak-256 hash of its full signature string.
    This is also visible in Remix IDE, as shown in the following screenshot. `f9d55e21` is
    the first four bytes of 32-byte Keccak-256 hash of the function named `Matcher`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e48d5da8-756e-473a-a94c-ac2065bba59b.png)'
  prefs: []
  type: TYPE_IMG
- en: Function hash as shown in Remix IDE
  prefs: []
  type: TYPE_NORMAL
- en: In this example function, `Matcher` has the signature hash of `d99c89cb`. This
    information is useful in order to build interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input parameters of a function**: Input parameters of a function are declared
    in the form of `<data type> <parameter name>`. This example clarifies the concept
    where `uint x` and `uint y` are input parameters of the `checkValues` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Output parameters of a function**: Output parameters of a function are declared
    in the form of `<data type> <parameter name>`. This example shows a simple function
    returning a `uint` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: A function can return multiple values. In the preceding example function, `getValue`
    only returns one value, but a function can return up to 14 values of different
    data types. The names of the unused return parameters can be omitted optionally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal function calls**: Functions within the context of the current contract
    can be called internally in a direct manner. These calls are made to call the
    functions that exist within the same contract. These calls result in simple `JUMP`
    calls at the EVM bytecode level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External function calls**: External function calls are made via message calls
    from a contract to another contract. In this case, all function parameters are
    copied to the memory. If a call to an internal function is made using the `this`
    keyword, it is also considered an external call. The `this` variable is a pointer
    that refers to the current contract. It is explicitly convertible to an address
    and all members for a contract are inherited from the address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback functions**: This is an unnamed function in a contract with no arguments
    and return data. This function executes every time Ether is received. It is required
    to be implemented within a contract if the contract is intended to receive Ether;
    otherwise, an exception will be thrown and Ether will be returned. This function
    also executes if no other function signatures match in the contract. If the contract
    is expected to receive Ether, then the fallback function should be declared with
    the payable **modifier**. The payable is required; otherwise, this function will
    not be able to receive any Ether. This function can be called using the `address.call()`
    method as, for example, in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the fallback function is called according to the conditions
    described earlier; it will call `throw`, which will roll back the state to what
    it was before making the call. It can also be some other construct than `throw`;
    for example, it can log an event that can be used as an alert to feed back the
    outcome of the call to the calling application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifier functions**: These functions are used to change the behavior of
    a function and can be called before other functions. Usually, they are used to
    check some conditions or verification before executing the function. `_` (underscore)
    is used in the modifier functions that will be replaced with the actual body of
    the function when the modifier is called. Basically, it symbolizes the function
    that needs to be *guarded*. This concept is similar to guard functions in other
    languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor function**: This is an optional function that has the same name
    as the contract and is executed once a contract is created. Constructor functions
    cannot be called later on by users, and there is only one constructor allowed
    in a contract. This implies that no overloading functionality is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function visibility specifiers (access modifiers)**: Functions can be defined
    with four access specifiers as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External**: These functions are accessible from other contracts and transactions.
    They cannot be called internally unless the `this` keyword is used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: By default, functions are public. They can be called either internally
    or using messages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Internal functions are visible to other derived contracts from
    the parent contract.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: Private functions are only visible to the same contract they are
    declared in.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function Modifiers:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pure**: This modifier prohibits access or modification to state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**view**: This modifier disables any modification to state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**payable**: This modifier allows payment of ether with a call'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**constant**: This modifier disallows access or modification to state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other important keywords/functions throw**: `throw` is used to stop execution.
    As a result, all state changes are reverted. In this case, no gas is returned
    to the transaction originator because all the remaining gas is consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout of a Solidity source code ﬁle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following subsections we will look at the components of a Solidity source
    code file.
  prefs: []
  type: TYPE_NORMAL
- en: Version pragma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to address compatibility issues that may arise from future versions
    of the solc version, `pragma` can be used to specify the version of the compatible
    compiler as, for example, in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the source file does not compile with versions smaller
    than 0.5.0 and versions starting from 0.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import in Solidity allows the importing of symbols from the existing Solidity
    files into the current global scope. This is similar to `import` statements available
    in JavaScript, as for example, in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments can be added in the Solidity source code file in a manner similar to
    C-language. Multiple line comments are enclosed in `/*` and `*/`, whereas single
    line comments start with `//`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example Solidity program is as follows, showing the use of `pragma`, `import`,
    and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b80ab420-b712-4008-9cf9-7d0263d1de7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample Solidity program as shown in Remix IDE
  prefs: []
  type: TYPE_NORMAL
- en: This completes a brief introduction to the Solidity language. The language is
    very rich and under constant improvement. Detailed documentation and coding guidelines
    are available online at [http://solidity.readthedocs.io/en/latest/](http://solidity.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with the introduction of development tools for Ethereum
    such as Remix IDE. Then we discussed some frameworks such as Truffle along with
    local blockchain solutions for development and testing such as Ganache, EthereumJS
    and TestRPC. Other tools such as MetaMask were also explored. Installation of
    Node was also introduced, as most of the tools are JavaScript and Node based.
  prefs: []
  type: TYPE_NORMAL
