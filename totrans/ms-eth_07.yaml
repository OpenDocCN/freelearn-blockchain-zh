- en: Mastering dApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mastering dApps, you're going to learn how to create advanced decentralized
    applications that use the smart contract that we saw in previous chapters. We'll
    go through all the steps from scratch including planning, developing the code,
    and testing the applications. First, you'll start by taking a look at how dApps
    are structured so that you can efficiently create new dApps from scratch. You'll
    go through the installation of Ethereum and Truffle to use it for your products.
    Then, you'll learn how to create great user interfaces that show people the right
    content without clutter. Finally, you'll create the smart contracts required to
    interact with the dApp and you'll integrate those to allow users to interact easily
    with the contracts from the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing dApp architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ethereum and Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and configuring Ethereum and Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dApps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting smart contracts to web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing dApp architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecting a decentralized application means making high-level software decisions
    to direct the design of our ideas. We are laying out the steps so that we can
    fluently create a dApp without getting stuck in design decisions. It also implies
    planning how the smart contract will communicate with the dApp, how users will
    interact with the dApp, and what kind of features we want for the end product.
  prefs: []
  type: TYPE_NORMAL
- en: When designing an application, we want to focus heavily on the user experience
    so that they feel comfortable using the resulting dApp. That's why it's important
    to have a clear vision of how it will look before we start coding because if we
    want to have a modern dApp that feels responsive for tech users, we'll have to
    focus more on providing extensive information about each element of our application.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's suppose that you want to create a blog dApp where users
    can publish articles about specific topics. How would you design such a dApp?
    Where do you begin? Truthfully, there isn't a perfect system to design your ideal
    dApp from scratch; it's more of an interactive process where you go back and forth
    to the drawing board to clarify your ideas as you develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I like to start with a detailed description of what I have in mind
    with as much clarification as needed and with a list of features that must be
    there at all costs. For example, I want to create a decentralized blog for ICO
    enthusiasts who enjoy reading about new projects and are raising money with an
    ICO, TGE, or STO, since they are in the same ecosystem, surrounded by joint ventures,
    equity payments, blockchain innovations, and the like. This blog will reward users
    with tokens that they will be able to exchange for rewards in the system. Higher
    visibility, advanced metrics about each article, premium articles, and voting
    decisions will be accessible in exchange for tokens. The following are the features
    of this dApp:'
  prefs: []
  type: TYPE_NORMAL
- en: Search system to find articles by title and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment sections with responses in real-time like a chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tools for authors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promotion tools to increase visibility of an article
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A visibility score to indicate how visible each article is in the sea of content
    inside this dApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design tools to customize the appearance for each of your comments and publications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, it helps to draw a diagram with the relationship between the components
    that make the entire dApp—the different backend services, the frontend, and the
    blockchain interactions. The idea is that you see visually what''s important in
    your application. You can include whatever information you think will be relevant
    for the final dApp so that you are reminded of what''s important and what''s not.
    You''ll find out that you automatically discard the things that don''t matter.
    Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed242064-72f7-4823-b029-9652fad41f60.png)'
  prefs: []
  type: TYPE_IMG
- en: You can get way more technical than that but it's not that important in the
    stage of idea design where your goal is to fill in the blanks of what you plan
    to create. It will show you what's important before you realize it. Then, you
    can create a scheme of the types of data structures that you'll have in your smart
    contract, the building blocks of your user interface, and the performance features
    of the server for delivering snappy interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it''s important that you ask yourself several design questions, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to handle a sudden increase of users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What systems must be in place to keep the application running in case we face
    an attack such as DDoS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does a successful interaction from the user's point of view look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do we think that we'll face uncertainty, what things are not clear enough
    yet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a realistic date for completion of all the core features?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does a **Minimum Viable Product** (**MVP**) of this idea look like? What
    features are indispensable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When can we complete the MVP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What problems are we solving for the casual user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What solutions are we providing that they can't find elsewhere?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we discover or create demand for our idea before even starting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we get early users to help us deliver a product catered to that type of
    person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What does our ideal user look like: what do they do, what are their hobbies,
    where do they hang out online (so that we can bring them into the development
    process for creating a better product)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is our purpose, why are we doing it? Name three reasons behind the why.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can we be better, faster, more efficient?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From there, you can start creating your decentralized application from those
    ideas. Be sure to create a Google form, which is free and easy to use, to clarify
    all those questions and more that you consider relevant. Be explicit and detailed
    in your answers. Always remember to focus on solving a problem your users have.
    The key to successfully delivering a high-quality decentralized application is
    to have a solid base of why you are doing it so that you can stay motivated in
    tough times—that's why the questions are so important. It's a trick to get motivation
    from inside for facing difficult tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap what you've learned so far. You learned the steps that it takes
    to architect a decentralized application with several mind tools to expose weak
    points of your ideas so that you can create solid applications without getting
    stuck on poorly designed interactions. You understand that great questions are
    the core foundation of clear thinking. You want to ask yourself as many questions
    as possible, and write them down to remember your purpose, so that you can be
    fully motivated to continue and complete your goal. Continue reading the next
    section to learn more about setting up your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ethereum and Truffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create truly powerful decentralized applications, we need to have a local
    version of Ethereum and Truffle. You can't get Ethereum by itself; you need to
    use a client, which in this case will be Geth. Truffle is a framework for creating,
    deploying, and testing dApps on your machine without having to wait for external
    services, all in one place.
  prefs: []
  type: TYPE_NORMAL
- en: There are different Ethereum implementations, with the most well-known being
    Parity and Geth. When it comes to installing Ethereum, what you're actually doing
    is getting a client that implements its protocol, so you have a choice regarding
    your favorite development system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and install Ethereum and Truffle. First, to get Ethereum on
    Mac, you need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That will compile all the code you need for your Mac in a few minutes. To get
    Geth on Windows, you have to download the binaries from their official website:
    [https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/);
    you can also get the binaries for the other systems, but it''s just easier and
    more interesting to install Geth from the terminal when possible. Then, simply
    open the `geth.exe` file to run Ethereum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Ethereum on Linux, you must execute the following lines on your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to get Truffle, you''ll need to do some additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, install Node.js LTS from their official website at [http://nodejs.org](http://nodejs.org)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open it with your file explorer to run the installation process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that's done, run `node -v` or `nodejs -v`; if it doesn't work, verify that
    you have it installed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `truffle` by running `npm i -g truffle`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You are now able to use Truffle for your projects by simply running the following
    on an empty folder, which will generate the file structure required for any `truffle`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting up and configuring Ethereum and Truffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the required tools, we'll set up the basic file structure so
    that we have a clean environment to work with for all of our desired dApps. You'll
    be able to use it over and over as long as you need to, because it has all the
    dependencies set up.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a folder called `dapp`, which will contain all of our files.
    Then, with your Terminal or command line, execute `truffle init` to set up Truffle,
    making sure that you're inside the `dapp` folder.
  prefs: []
  type: TYPE_NORMAL
- en: After installing Truffle in that folder, run `npm init` to set up your `package.json`
    file of Node.js that will allow you to install npm plugins. It will ask you for
    some general information about your project; simply fill it in as you please or
    press *Enter* to leave them empty, which is what I usually do unless I'm planning
    on distributing that project for others to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see that you have the following folders created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contracts/`: Where your contracts will go. Right now, it has a migrations
    contract to update your contracts as you improve your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`migrations/`: Here is where you define how your smart contracts will be deployed,
    what parameters the constructor will have, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test/`: Your tests will go here for your smart contracts and dApps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: The main npm file, which is used to install packages from the
    node registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`truffle-config.js`: A configuration file to define how you''ll connect to
    the blockchain, what Ethereum account you''ll use, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have to do now is install the essential packages that we''ll need for
    using React and webpack. First, update your `npm` version to the latest one with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to your `dapp` project folder if you haven''t done so already and install
    `webpack` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Webpack is a utility that takes all of your JavaScript files and combines them
    into one single, gigantic, easy-to-manage JavaScript file so that you can optimize
    development times.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Webpack, install all the `babel` dependencies. Babel is a utility that
    works with webpack to take your JavaScript files and convert them into the latest
    version so that every browser is compatible with the new JavaScript functionalities,
    given that there are major differences across browsers that need to be normalized.
    Babel does just that, and you can install it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to install `react.js` since we''ll use it for our project, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setting up webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now generate the `webpack.config.js` file where we''ll specify how we
    want to have our JavaScript files handled, and where the combined version will
    be deployed. Create an empty `webpack.config.js` file at the root level of your
    `dapp/ folder` with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Module exports is the export object that''s used in `node.js` projects. It
    contains the `rules` array, where you indicate which files must be passed through
    which compilers, in this case, `babel-loader`. The entry and output properties
    define where our files will be generated after combining them. Amplify the webpack
    configuration file with some additional information for defining the HTML resulting
    file; this is required to generate a valid HTML page automatically with your JavaScript
    files bundled together. Install the following loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your webpack configuration like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the source folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to set up the source folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `src` folder where all your development code will go. Here''s what
    your project setup should look like by now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28fc131a-6b91-4745-b428-47d9d366227a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file inside `src/` called `index.html` with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<div id="root">` object will be where our React project will start. With
    HTML, `webpack`, and `babel` set up, we can start creating the main `react.js`
    file that will be used in our project. Inside the `src/ folder`, create a file
    called `index.jsx`, which will contain our initial `react.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are importing `React` and ReactDOM for connecting React with our HTML
    file. Then, we are creating a `Main` class that has a simple constructor and a
    `render()` function that returns a message confirming that the project has been
    set up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can compile those files with the following, where `-p` means production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to execute it inside your project folder. After compiling your files,
    you need to run a static server that will deliver the files to your browser so
    that you can use your dApp. For that, install `http-server` using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it for your distribution folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `localhost: 8080` on your browser to see your dApp project live:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3a3e963-b0d3-4023-88b0-3603b998e34f.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You now have a working startup project that you can replicate
    for other dApps that you want to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can publish the project on your GitHub to clone it for other situations
    where you may need it by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up [https://github.com](https://github.com) and create a new repository
    by clicking on New. Name it `dapp`, select gitignore Node, and an MIT License.
    Here''s the one I created: [https://github.com/merlox/dapp](https://github.com/merlox/dapp).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go back to your Terminal and type `git init` if you have `git` installed
    on your system. That will start a new GitHub project inside your folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you''ll need to tell GitHub which repository you want to update your
    changes when you are committing new files with your own credentials; you can do
    all that permanently with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Pull the initial license files from your repository with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add your files with `git add .`, and commit them with `git commit -m`. First,
    commit them and push them with `git push origin master`. Then, you'll see your
    files in your new repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember to not push any new changes, since you want this repository to be as
    it is right now for future projects that use the same file structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now ready to create dApps with Truffle, React, Webpack, and Solidity.
    To gain the required knowledge as fast as possible, we'll go through all the steps
    that it takes to create a fully working decentralized application. In this chapter,
    we are creating a music recommendation social media platform where people will
    be able to publish songs, they love at that moment to help their friends find
    interesting music to enjoy, all stored inside smart contracts without a centralized
    server.
  prefs: []
  type: TYPE_NORMAL
- en: We'll first create the smart contracts, then the user interface, and finally,
    we'll combine them all together with `web3.js`. We will test our decentralized
    application when the main interface is done to make sure it works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving straight into creating the smart contract, let''s define what
    we need it to do:'
  prefs: []
  type: TYPE_NORMAL
- en: We need an array that will store each users' music recommendations in a string
    or bytes32 format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct to define user information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping with each users' recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of followed users so that we can see new musical updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As usual, we start by creating the basic smart `contract` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the variables that we''ll use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each user struct will hold all the music recommendations made by that user.
    Now, we need to create functions to add new music recommendations. We won''t have
    functions to delete or modify past recommendations because we want it to be a
    permanent place for sharing past and present musical tastes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `addSong()` function takes the song name as a string and pushes that song
    to the array of music recommendations for that particular Ethereum address. The
    `_songName` must be between 1 and `100` characters long to avoid extremely large
    or empty recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need functions to create new users and to follow others. People will
    be able to publish music recommendations with just their address if they don''t
    want to set up their `name`, `age`, and `state`; they will be anonymous, so the
    `setup` function is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup` function must at least receive the `_name` of the user, the other
    parameters are optional, and the recommendations made before the setup will stay
    linked to that user. Here''s what the `follow` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simply pushing a new address to the array of following users. You can
    deploy your contract with remix to manually test that all the functions are working.
    To deploy it with Truffle, we first need to set up the `truffle-config.js` configuration
    file and make sure our `SocialMusic.sol` file is in the `contracts/ folder` of
    our project. As you learned in previous lessons, to set up `truffle-config.js`
    for `ropsten`, we need to uncomment the `ropsten` object at line 63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, uncomment the variables at the beginning of the file at line 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your `infuraKey` to your personal key, which you can find after creating
    a project in `infura.io`. If you don''t know how to get an `infuraKey`, go back
    to [Chapter 3](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml), *Ethereum Assets*,
    and execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create a `.secret` file with your MetaMask mnemonic, which will be used by Truffle
    to employ your first Ethereum account for deploying your `SocialMusic` smart contract.
    Be sure to add `.secret` to your `.gitignore` file if you're working on a git
    project, so that your account doesn't get leaked for people to see and steal your
    Ether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before deploying your contract, you need to install the wallet provider so
    that `truffle` has access to your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to tell Truffle which contracts you want to deploy. You can do
    so by opening the `migrations/1_initial_migrations.js` file and changing it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy your contract for `ropsten` after setting up your secret mnemonic with
    the following; remember to have enough `ropsten` Ether for deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--reset` flag will force Truffle to deploy a new version of your contract
    if you deployed an invalid one previously. The good thing about Truffle is that
    after setting up everything, you can quickly deploy new versions of your contract
    for testing very efficiently. You''ll see something like this if everything ran
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc32eea-afae-4b79-a084-7c67f8713dad.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You just deployed your `SocialMusic` smart contract. Continue
    reading to learn how to create the user interface that we'll use to interact with
    our smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we have a clean `react.js` project properly set up, we can start right
    away with creating our application's user interface. We'll use sample data to
    check the design before moving on and integrating the real smart contract code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `src/index.js` file to start coding your design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re writing our design inside the `render()` function since it''s where
    all the code will be shown to the user. I''ve created two main sections: an `h1`
    to welcome people to the dApp with a short message showing them three buttons
    to start using it, and an `h3` section showing people the latest 10 musical recommendations
    made by random people on the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b07582f-2cec-4d0b-bb21-871c22e87931.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To improve the appearance of the application, we''ll use some basic CSS so
    that it feels great to users. Create a new file inside `src/` called `index.css`.
    In order to be able to use CSS in our `react.js` application, we need to use a
    new loader that understands CSS. Open your `webpack.config.js` file to add the
    following section to the rules block, just like you did with the previous loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install `css-loader` and `style-loader`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write our CSS code inside `index.css`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e075653-0ea6-4b8e-adca-7d69ec875fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll now need to implement each of those features, but before that, let''s
    work on creating a new component called **Recommendation**, which will be an individual
    box that will contain an individual music recommendation by some user. Here''s
    how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added this new component that shows three divs containing the name,
    address, and song of each recommendation. I''ve also added a sample use inside
    the `Main` component so that you can see how it works. Props are just variables
    that you pass from component to component, and they are identified with their
    variable names. Let''s improve the appearance of this thing with some CSS code,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it will look like with the changes that we just made and with some
    more sample music recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3184070c-4877-4a41-9d77-9889348d90d8.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it—you just created the UI of your decentralized `SocialMusic` platform.
    Let's make it dynamic by integrating `web3.js` so that we can use our smart contracts
    to allow people to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting smart contracts to web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decentralized applications are made of smart contracts and user interfaces.
    Now that we have both elements, we can combine them by connecting the frontend
    with the backend using `web3`, the most powerful tool for interacting with the
    Ethereum blockchain from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by getting `web3.js`. You can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import it into your `index.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You don't really need to install `web3` since most, if not all of your users
    will have MetaMask installed, which automatically injects `web3.js` to your application.
    Nevertheless, it is good practice to have `web3` in your application's code because
    you can control which version is used across the application.
  prefs: []
  type: TYPE_NORMAL
- en: To fully connect our `react.js` application with our `SocialMusic` contract,
    we need to implement every function of the contract so that they can be executed
    from the user interface that we designed. We also want to retrieve specific information,
    such as the last five recommended songs. There are many ways you can start implementing
    your contracts, so, we'll start by making all three buttons in our web application
    work properly with the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the setup form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we have the Setup Account button. This one should show users a form
    with several inputs to set up their name, age, and state, where only the name
    is mandatory. There should be a Cancel button as well as a Submit button. Let''s
    create a new React component that we''ll call `Form`, which will include all these
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've added two inputs with a text area for the state and two buttons to cancel
    or submit. Notice how I've added a custom `className` attribute on the form element
    so that we can dynamically set up the class from the outer component, otherwise
    it wouldn't work. We only want to display this form when users click on Setup
    Account, so we'll add the form component below our three buttons as a hidden element,
    since that's the location that makes more sense to the user, given that it's closer
    to the mouse. How can we hide an element in a website? By using a custom class
    that sets display to none.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up the new state variable in the constructor to hide the form
    when it''s not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `Form` component right below the buttons with a dynamic class
    name that changes depending on when we want to display the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I've added a state element called `isFormHidden`, which indicates
    if the form is hidden or not. Then, I set up the `className` of our `Form` as
    a dynamic component that depends on state so that it stays hidden at the right
    moment. We need to use React's state because it's the main way React has to update
    information being displayed. React is reactive to state, so every time it changes,
    it updates the entire web application. If we simply selected the component and
    updated the class of it directly, React wouldn't know what's going on, and it
    would get messy since state is an essential element of every interactive web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a CSS class to hide it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the result on the live page. You shouldn''t be seeing anything
    because your form is hidden. To display it, you have to add an `onClick` event
    on your Setup Account button, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That will read the form''s state to hide it or display it when clicked. You''ll
    see that the design is a mess, so we''ve got to improve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6052099-4db4-44aa-b247-8b52eebc2bb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new general class to each of your inputs with separate ones to differentiate
    the text area, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create new CSS classes with your desired appearance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks after the changes in styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8da727f-fba6-462b-bfda-f1a2c3817eb9.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks way better.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the setup function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have to make it interact with our smart contract. To do that, we''ll
    have to create a new instance of our deployed contract on `ropsten`. We''ll need
    the address and the `ABI` interface, which you can quickly find inside the `build/contracts/`
    folder that Truffle created for you when you deployed your `SocialMusic` contract.
    Simply copy `SocialMusic.json` to your `src/ folder` for easier access. Bear in
    mind that you''ll need to replace that file with the newer ABI versions of your
    contract if you decide to extend the functionalities of it. Just repeat the same
    steps and you should be good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e759b48e-4164-4a99-a902-52ea097a6806.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need a way to import that JSON file in our React application. Fortunately,
    if you''re using webpack 2.0 or newer (I''m using 4.19 at the moment) you don''t
    need to do anything extra, since webpack supports JSON files by default. In previous
    versions, you had to add a new `json-loader` that would take care of those files.
    Just add the file at the beginning of your file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can import your JSON files with the name that you want; the purpose of
    the `ABI` variable is to be able to read the values of the JSON file. Then, create
    a variable with your smart contract''s address and your `abi` interface. Remember
    that you can deploy a new version whenever you want with Truffle using `deploy
    --network ropsten --reset` to get a new address if you lost it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want to deploy the contracts with our own version of web3 1.0 since
    the one injected by MetaMask is outdated and we cannot rely on an uncontrolled
    version. That''s why we''ll create a new instance of web3, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve renamed the `web3` variable to `myWeb3` to avoid confusing it with the
    one injected by MetaMask. Notice the `window` keyword in front of `myWeb3`; that''s
    used to set up that variable as global so that you can access `myWeb3` from anywhere
    in your dApp. It makes life much easier by just having access to our custom web3
    everywhere. We''ll use promises with async await later on. To be able to use async
    await for this version of webpack/babel, you''ll need to install `babel-polyfill`,
    which takes care of compiling your async code so that it works properly on all
    browsers. Install it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add it into your webpack configuration file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll create the contract's instance with some helper functions and the
    `setupAccount` function's integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the constructor to execute the function to set up the contract
    instance right when the dApp loads, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the required functions to properly set up the user account and
    contract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, update your `render()` function with the `Form` props to tell React
    what to do when the user clicks on the setup button, and when the user clicks
    on the Cancel button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update your `Form` component with the new functionality to trigger
    the setup functions when the user interacts with the inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There are quite some changes here, so let me explain what I did.
  prefs: []
  type: TYPE_NORMAL
- en: First, I created the `setContractInstance` function, which is used to set up
    the contract instance with our smart contract's address so that we can use it
    later for the other functions. The `getAccount` function is a helper to get the
    address of the current user quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I created the `setupAccount` function, which receives the three parameters
    we want to use for setting up the user's account with a helper function named
    `fillBytes32WithSpaces`, since we need to fill all the spaces in a bytes32 type
    of variable with this version of `web3.js`, otherwise it will reject the transaction.
    This function simply creates a transaction for the `setup()` function in our deployed
    smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I created some prop functions for the `Form` component that will be executed
    when the user clicks on Cancel or Submit. We want to hide the form when the user
    cancels, so I simply set the state of the form to hidden. When the user clicks
    on Submit, we extract the data from all the inputs and we send them to the `setupAccount`
    function. Notice how I've used `event.preventDefault()` inside each button's click
    event to avoid refreshing the page, since all HTML buttons are submit buttons
    that supposedly send information to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we used the `.send()` function when setting up users, data which
    generates a transaction and costs gas. Inside it, I''ve used my Ethereum address
    so that it knows who should make the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But you don''t want to use the same address since you can''t have access to
    it for your MetaMask. You can simply delete that parameter so that the function
    looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Telling React to find the user's address automatically doesn't work sometimes,
    so you can set your own address instead. Remember to have your MetaMask unlocked
    and using ropsten, then paste your current address there.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and interact with your dApp once the changes are done to verify that,
    indeed, it's submitting a transaction to the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do now is set up the Add Music button so that users can create
    musical recommendations. To start, create the design with a new component, just
    like we did previously, by updating the state object inside your constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new `addMusic()` function, which will push the indicated song
    to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `render()` function by adding the `onClick` event listener to the
    Add Music button, which will update the state to display the add music form. Then,
    add the new `AddMusic` component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define the new `AddMusic` component with the `class` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We've followed the same steps that we did when we created the `Form` component.
    Simply set up the render HTML, put the `AddMusic` element below your `Form` element
    while keeping it hidden, and set up all the prop functions. Then, create a function
    to add new songs to the smart contract. We've also created a new state variable
    for toggling the hidden class of those buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that if you click on Add Song and then Setup Account right
    after it without cancelling, the divs stay open—we don''t want that. We want to
    keep only one of those sections open at any given time. We can achieve that with
    a function that updates the state for hiding all the components before opening
    a new one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the function call to the buttons before opening the section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the final button function to be able to follow people. We''ll show
    a list of all the people that have registered so that the user can follow the
    ones they like to see updates from. To achieve that, we''ll have to modify our
    contract so that we can add an array with the latest newcomers that will get updated
    when users execute the `setup` function, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Redeploy the contract with Truffle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having to manually copy the new address and updating the json file,
    we''ll get all the information straight from the build folder, including the address,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you won''t have to worry about updating the information every single time,
    which is great because you can access different external folders freely, given
    that webpack takes all the required information and bundles it together, so it
    doesn''t matter that you''re accessing files outside of the `src/` folder. Now
    let''s create the desired functionality to get the latest people so that the user
    can follow them with a couple of new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `FollowPeopleContainer` is simply a component that holds all the users that
    you can follow with your account. It will receive data from the `Main` component
    inside the `this.props.followUsersData` prop, which sends an array containing
    up to 10 users to follow with up to two musical recommendations each, just so
    that you can see the type of person they are. It also removes already followed
    users from the array so that you don't see them as new users. Finally, it generates
    a `FollowPeopleUnit` component with all the required user properties, with a function
    that will transmit the information required to follow that specific user to the
    `Main` component.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `key={user.address}` attribute in each `FollowPeopleUnit`, since
    we need to be able to identify them individually, which is mandatory by React
    to avoid duplicate elements.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `FollowPeopleUnit` component is made of a set of divs
    that show all the required information to the user. Because we have two recommendations
    inside an array called `this.props.recommendations`, we'll have to loop through
    all of them to display each message individually. When you want to generate HTML
    elements dynamically with react, you must use the `.map()` function of your array
    with round brackets `()` instead of curly brackets `{}` since all HTML elements
    must be inside these types of brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our two new components, we have to define the functions to
    make them interactive in our `Main` component; you can check the complete code
    on GitHub just so you know where everything has to be placed in case you're facing
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we updated the address system to be dynamic so that you don''t have
    to manually type your Ethereum address in code. For instance, let''s say we had
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we would use the following code, which is essential to make our dApp
    interactive for many different users. You can see that we set up the `userAddress`
    state variable in the `setContractInstance()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Next, we created the complex `getFollowPeopleUsersData()` function, which gets
    the most recent user addresses; it takes up to 10 of them or less if there aren't
    that many users. Then, it creates a `userData` object with all the properties
    that we want and populates it with the smart contract state variable's information,
    by first getting the length of the array of musical recommendations with `getUsersMusicRecommendationLength()`,
    and then by getting each individual musical recommendation with `getUsersMusicRecommendation()`.
    At the bottom of the function, we get the array of users that that particular
    person is following, just in case we need to access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we used some new functions from our smart contract. That''s
    because we couldn''t make all of this possible without adding some complexity.
    Here''s how our updated smart contract looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There are a few functions to retrieve the following and recommendation data
    for each particular person from the respective arrays. This is done because we
    can't just get the entire array automatically with public arrays; as you know,
    public arrays only return one element of the entire array each time, so we need
    a function to get it entirely. The same thing happens with strings—we have to
    create a function to get each string individually because we can't just send an
    array of strings, given that they are low-level multidimensional `byte[][]` arrays.
    Solidity doesn't allow you to send a `byte[][][]`, which would be the equivalent
    to `string[]`, because it's too big and complex.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to redeploy your code after making changes with Truffle, `deploy --network
    ropsten --reset`. Now, you don't have to update the smart contract address, nor
    copy the ABI to your source folder, since it's set up to get the deployed contract
    data straight from the build folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our dApp doesn''t look as good as it should yet, so here''s the entire CSS
    code for your reference if you desire to achieve the same look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of the final result, which you can generate with `webpack
    -d` and `http-server dist/to` see it in `localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b87ca20-1f87-458e-80af-8528139c7eda.png)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and interact with your new awesome dApp by clicking the buttons shown
    in the preceding screenshot. The Follow People button will take a few seconds
    to load data from the smart contract since we are running several requests to
    generate our custom objects in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I could add functionality to display the latest music recommendations
    and unfollow systems, but I'll leave that to you as an exercise to practice your
    smart contract dApp implementation skills. The idea is to display dynamically
    generated recommendation components at the bottom of the page instead of the static
    ones we have already; you can do that by simply getting the data from our smart
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: This dApp is nowhere near perfect; you could fix some of its speed issues by
    optimizing the data structures so that you retrieve only the required information
    instead of the entire arrays. You can also fix some security issues by testing
    the code with truffle. The end result is up to you; you decide when the application
    can be considered finished since you can add and continue adding features that
    make it better—that's how all great dApps are born.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the final code on my GitHub here: [https://github.com/merlox/social-music](https://github.com/merlox/social-music).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw first-hand how to create a decentralized application
    with all the little nuances and changes required. You've gone through the entire
    process, starting from setting up your development environment with React, webpack,
    and Truffle. You've learned how to create React components that organize your
    code neatly so that you can manage all the complexity of your dApp with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add this application to your GitHub as proof that you finished it
    to improve your resume with valuable projects so that future clients can see with
    their own eyes what you can do for them and that you've mastered all the steps
    that it takes to build a fully decentralized application. In the next chapter,
    you'll learn more about improving your dApps with further advanced tips so that
    they feel responsive and behave like high-quality systems.
  prefs: []
  type: TYPE_NORMAL
