- en: Mastering dApps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 dApps
- en: In mastering dApps, you're going to learn how to create advanced decentralized
    applications that use the smart contract that we saw in previous chapters. We'll
    go through all the steps from scratch including planning, developing the code,
    and testing the applications. First, you'll start by taking a look at how dApps
    are structured so that you can efficiently create new dApps from scratch. You'll
    go through the installation of Ethereum and Truffle to use it for your products.
    Then, you'll learn how to create great user interfaces that show people the right
    content without clutter. Finally, you'll create the smart contracts required to
    interact with the dApp and you'll integrate those to allow users to interact easily
    with the contracts from the interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握 dApps 中，您将学习如何创建高级别的分散式应用程序，这些应用程序使用我们在前几章中看到的智能合约。我们将从头开始逐步完成所有步骤，包括规划、开发代码和测试应用程序。首先，您将了解
    dApp 的结构，以便能够有效地从头开始创建新的 dApp。您将通过安装以太坊和 Truffle 来为您的产品使用它。然后，您将学习如何创建出色的用户界面，展示正确的内容而不会混乱。最后，您将创建与
    dApp 交互所需的智能合约，并将这些合约集成到界面中，以便用户可以轻松地与合约交互。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing dApp architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 dApp 架构
- en: Installing Ethereum and Truffle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装以太坊和 Truffle
- en: Setting up and configuring Ethereum and Truffle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和配置以太坊和 Truffle
- en: Creating dApps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 dApp
- en: Creating user interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Connecting smart contracts to web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能合约连接到 Web 应用程序
- en: Introducing dApp architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 dApp 架构
- en: Architecting a decentralized application means making high-level software decisions
    to direct the design of our ideas. We are laying out the steps so that we can
    fluently create a dApp without getting stuck in design decisions. It also implies
    planning how the smart contract will communicate with the dApp, how users will
    interact with the dApp, and what kind of features we want for the end product.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 架构化分散式应用程序意味着做出高级别的软件决策，以指导我们的想法设计。我们正在规划步骤，以便能够流畅地创建一个 dApp，而不会陷入设计决策中。这也意味着计划智能合约将如何与
    dApp 通信，用户将如何与 dApp 交互，以及我们希望最终产品具有哪些功能。
- en: When designing an application, we want to focus heavily on the user experience
    so that they feel comfortable using the resulting dApp. That's why it's important
    to have a clear vision of how it will look before we start coding because if we
    want to have a modern dApp that feels responsive for tech users, we'll have to
    focus more on providing extensive information about each element of our application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序时，我们希望重点关注用户体验，以便他们在使用生成的 dApp 时感到舒适。这就是为什么在我们开始编码之前，拥有清晰的外观愿景非常重要，因为如果我们想要一个现代化的
    dApp，以满足技术用户的需求，我们将不得不更多地关注提供有关应用程序每个元素的详细信息。
- en: For instance, let's suppose that you want to create a blog dApp where users
    can publish articles about specific topics. How would you design such a dApp?
    Where do you begin? Truthfully, there isn't a perfect system to design your ideal
    dApp from scratch; it's more of an interactive process where you go back and forth
    to the drawing board to clarify your ideas as you develop.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想创建一个博客 dApp，用户可以在其中发布关于特定主题的文章。您将如何设计这样一个 dApp？您从何开始？事实上，没有一种完美的系统可以从头开始设计您理想的
    dApp；这更像是一个交互式过程，您需要反复回到草图板上澄清您的想法，随着开发的进行。
- en: 'Personally, I like to start with a detailed description of what I have in mind
    with as much clarification as needed and with a list of features that must be
    there at all costs. For example, I want to create a decentralized blog for ICO
    enthusiasts who enjoy reading about new projects and are raising money with an
    ICO, TGE, or STO, since they are in the same ecosystem, surrounded by joint ventures,
    equity payments, blockchain innovations, and the like. This blog will reward users
    with tokens that they will be able to exchange for rewards in the system. Higher
    visibility, advanced metrics about each article, premium articles, and voting
    decisions will be accessible in exchange for tokens. The following are the features
    of this dApp:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我喜欢从我脑海中对所想到的内容进行详细描述，尽可能多地澄清，并列出必须始终存在的功能列表。例如，我想为享受阅读有关新项目并通过 ICO、TGE
    或 STO 等筹款的 ICO 爱好者创建一个分散式博客，因为他们处于相同的生态系统中，周围有联合风险投资、股权支付、区块链创新等。这个博客将奖励用户的代币，他们将能够在系统中交换以获得奖励。可用于交换代币的高可见性、每篇文章的高级度量标准、高级文章和投票决策。以下是此
    dApp 的功能：
- en: Search system to find articles by title and tags
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按标题和标签查找文章的搜索系统
- en: Comment sections with responses in real-time like a chat
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有实时响应的评论区，就像聊天一样
- en: Writing tools for authors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者的写作工具
- en: Promotion tools to increase visibility of an article
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升文章可见性的推广工具
- en: A visibility score to indicate how visible each article is in the sea of content
    inside this dApp
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可见度评分，指示每篇文章在此 dApp 内容海洋中的可见性
- en: Design tools to customize the appearance for each of your comments and publications
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计工具来自定义每个评论和发布的外观
- en: 'Then, it helps to draw a diagram with the relationship between the components
    that make the entire dApp—the different backend services, the frontend, and the
    blockchain interactions. The idea is that you see visually what''s important in
    your application. You can include whatever information you think will be relevant
    for the final dApp so that you are reminded of what''s important and what''s not.
    You''ll find out that you automatically discard the things that don''t matter.
    Take a look at the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将有助于绘制一个关于构成整个 dApp 的组件之间关系的图表——不同的后端服务、前端和区块链交互。这个想法是让你以视觉方式看到你应用程序中的重要内容。你可以包含任何你认为将对最终
    dApp 有关的信息，以便提醒你什么是重要的，什么不重要。你会发现自己自动地丢弃那些不重要的东西。看看下面的图表：
- en: '![](img/ed242064-72f7-4823-b029-9652fad41f60.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed242064-72f7-4823-b029-9652fad41f60.png)'
- en: You can get way more technical than that but it's not that important in the
    stage of idea design where your goal is to fill in the blanks of what you plan
    to create. It will show you what's important before you realize it. Then, you
    can create a scheme of the types of data structures that you'll have in your smart
    contract, the building blocks of your user interface, and the performance features
    of the server for delivering snappy interactions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在技术方面做得更深入，但在创意设计阶段，这并不是那么重要，你的目标是填补你计划创建的内容空白。这会在你意识到之前显示出对你来说重要的东西。然后，你可以创建一个你的智能合约将拥有的数据结构类型的方案，你用户界面的构建模块，以及服务器性能特性，以提供迅捷的交互。
- en: 'Then, it''s important that you ask yourself several design questions, such
    as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重要的是你问自己几个设计问题，比如以下几个：
- en: How are we going to handle a sudden increase of users?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将如何处理用户数量的突然增加？
- en: What systems must be in place to keep the application running in case we face
    an attack such as DDoS?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们面对像 DDoS 这样的攻击，必须采取哪些措施来保持应用程序的运行？
- en: How does a successful interaction from the user's point of view look like?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户的角度看，成功的交互是什么样的？
- en: Where do we think that we'll face uncertainty, what things are not clear enough
    yet?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们认为我们将面临不确定性的地方在哪里，有哪些事情还不够清晰？
- en: What's a realistic date for completion of all the core features?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有核心功能完成的现实日期是什么？
- en: What does a **Minimum Viable Product** (**MVP**) of this idea look like? What
    features are indispensable?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个想法的**最小可行产品**（**MVP**）是什么样子？哪些功能是必不可少的？
- en: When can we complete the MVP?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们什么时候能完成 MVP？
- en: What problems are we solving for the casual user?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为普通用户解决了什么问题？
- en: What solutions are we providing that they can't find elsewhere?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供了哪些解决方案，他们在其他地方找不到？
- en: How can we discover or create demand for our idea before even starting?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在开始之前发现或创造对我们想法的需求？
- en: Can we get early users to help us deliver a product catered to that type of
    person?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否让早期用户帮助我们提供专门针对这类人的产品？
- en: 'What does our ideal user look like: what do they do, what are their hobbies,
    where do they hang out online (so that we can bring them into the development
    process for creating a better product)?'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的理想用户是什么样的：他们做什么，他们的爱好是什么，他们在网上待在哪里（以便我们可以将他们纳入到创建更好产品的开发过程中）？
- en: What is our purpose, why are we doing it? Name three reasons behind the why.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的目的是什么，为什么要做这件事？列出背后为什么的三个原因。
- en: Where can we be better, faster, more efficient?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在哪些方面可以做得更好、更快、更高效？
- en: From there, you can start creating your decentralized application from those
    ideas. Be sure to create a Google form, which is free and easy to use, to clarify
    all those questions and more that you consider relevant. Be explicit and detailed
    in your answers. Always remember to focus on solving a problem your users have.
    The key to successfully delivering a high-quality decentralized application is
    to have a solid base of why you are doing it so that you can stay motivated in
    tough times—that's why the questions are so important. It's a trick to get motivation
    from inside for facing difficult tasks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你可以根据这些想法开始创建你的去中心化应用。务必创建一个免费且易于使用的 Google 表单，以澄清你认为相关的所有问题及更多问题。在回答中要明确和详细。永远记住专注于解决用户存在的问题。成功交付高质量的去中心化应用的关键是有一个坚实的基础，明确你为何这样做，以便在困难时保持动力—这就是为什么问题如此重要。这是从内心获得动力以面对困难任务的诀窍。
- en: Let's recap what you've learned so far. You learned the steps that it takes
    to architect a decentralized application with several mind tools to expose weak
    points of your ideas so that you can create solid applications without getting
    stuck on poorly designed interactions. You understand that great questions are
    the core foundation of clear thinking. You want to ask yourself as many questions
    as possible, and write them down to remember your purpose, so that you can be
    fully motivated to continue and complete your goal. Continue reading the next
    section to learn more about setting up your development environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你到目前为止学到的东西。你学会了用几种心智工具来揭示你想法的薄弱点，以便你可以创建坚实的应用而不陷入设计不良交互中。你明白了优秀问题是清晰思考的核心基础。你希望自己能提出尽可能多的问题，并把它们写下来以记住你的目的，这样你就可以充分激励自己继续并完成你的目标。继续阅读下一节以了解更多有关设置开发环境的信息。
- en: Installing Ethereum and Truffle
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装以太坊和 Truffle
- en: To create truly powerful decentralized applications, we need to have a local
    version of Ethereum and Truffle. You can't get Ethereum by itself; you need to
    use a client, which in this case will be Geth. Truffle is a framework for creating,
    deploying, and testing dApps on your machine without having to wait for external
    services, all in one place.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建真正强大的去中心化应用，我们需要有本地版本的以太坊和 Truffle。你不能单独获取以太坊；你需要使用一个客户端，这在这种情况下将是 Geth。Truffle
    是一个在你的机器上创建、部署和测试 dApp 的框架，无需等待外部服务，一切都在一个地方。
- en: There are different Ethereum implementations, with the most well-known being
    Parity and Geth. When it comes to installing Ethereum, what you're actually doing
    is getting a client that implements its protocol, so you have a choice regarding
    your favorite development system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊有不同的实现方式，最著名的是 Parity 和 Geth。当涉及到安装以太坊时，实际上是获取一个实现其协议的客户端，所以你可以选择你喜欢的开发系统。
- en: 'Let''s go ahead and install Ethereum and Truffle. First, to get Ethereum on
    Mac, you need to run the following commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续安装以太坊和 Truffle。首先，在 Mac 上获取以太坊，你需要运行以下命令：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That will compile all the code you need for your Mac in a few minutes. To get
    Geth on Windows, you have to download the binaries from their official website:
    [https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/);
    you can also get the binaries for the other systems, but it''s just easier and
    more interesting to install Geth from the terminal when possible. Then, simply
    open the `geth.exe` file to run Ethereum.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在几分钟内为你的 Mac 编译所有需要的代码。要在 Windows 上获取 Geth，你需要从官方网站下载二进制文件：[https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/)；你也可以获取其他系统的二进制文件，但是尽可能在终端中安装
    Geth 会更容易和有趣。然后，只需打开 `geth.exe` 文件运行以太坊。
- en: 'To install Ethereum on Linux, you must execute the following lines on your
    Terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 上安装以太坊，你必须在终端上执行以下命令：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, to get Truffle, you''ll need to do some additional steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要获取 Truffle，你需要执行一些额外的步骤：
- en: First, install Node.js LTS from their official website at [http://nodejs.org](http://nodejs.org)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从官方网站[http://nodejs.org](http://nodejs.org)安装 Node.js LTS 版本。
- en: Then, open it with your file explorer to run the installation process
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用文件浏览器打开它以运行安装过程
- en: When that's done, run `node -v` or `nodejs -v`; if it doesn't work, verify that
    you have it installed
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，运行 `node -v` 或 `nodejs -v`；如果不起作用，请验证是否已安装
- en: Install `truffle` by running `npm i -g truffle`
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm i -g truffle` 安装 `truffle`
- en: 'You are now able to use Truffle for your projects by simply running the following
    on an empty folder, which will generate the file structure required for any `truffle`
    project:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过在空文件夹上运行以下命令来为您的项目使用 Truffle，该命令将为任何`truffle`项目生成所需的文件结构：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting up and configuring Ethereum and Truffle
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和配置以太坊和 Truffle
- en: Now that we have the required tools, we'll set up the basic file structure so
    that we have a clean environment to work with for all of our desired dApps. You'll
    be able to use it over and over as long as you need to, because it has all the
    dependencies set up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的工具，我们将设置基本的文件结构，以便我们有一个干净的环境来处理我们所需的所有 dApps。只要您需要，您就可以一次又一次地使用它，因为它已经设置了所有的依赖项。
- en: First, let's create a folder called `dapp`, which will contain all of our files.
    Then, with your Terminal or command line, execute `truffle init` to set up Truffle,
    making sure that you're inside the `dapp` folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`dapp`的文件夹，其中将包含我们的所有文件。然后，使用您的终端或命令行，在`dapp`文件夹内执行`truffle init`以设置
    Truffle，确保您在`dapp`文件夹内。
- en: After installing Truffle in that folder, run `npm init` to set up your `package.json`
    file of Node.js that will allow you to install npm plugins. It will ask you for
    some general information about your project; simply fill it in as you please or
    press *Enter* to leave them empty, which is what I usually do unless I'm planning
    on distributing that project for others to use.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件夹中安装 Truffle 后，运行`npm init`来设置 Node.js 的`package.json`文件，这将允许您安装 npm 插件。它会要求您提供有关您的项目的一些常规信息；只需按照您的意愿填写或按*Enter*键留空，这是我通常所做的，除非我打算将该项目分发给其他人使用。
- en: 'You''ll see that you have the following folders created:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到您已创建以下文件夹：
- en: '`contracts/`: Where your contracts will go. Right now, it has a migrations
    contract to update your contracts as you improve your code.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/`：您的合同将放在这里。现在，它有一个迁移合同，以更新您的合同，因为您改进了您的代码。'
- en: '`migrations/`: Here is where you define how your smart contracts will be deployed,
    what parameters the constructor will have, and so on.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrations/`：这里是您定义智能合约将如何部署、构造函数将有哪些参数等的地方。'
- en: '`test/`: Your tests will go here for your smart contracts and dApps.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test/`：您的智能合约和 dApps 的测试将放在这里。'
- en: '`package.json`: The main npm file, which is used to install packages from the
    node registry.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：主要的 npm 文件，用于从节点注册表中安装包。'
- en: '`truffle-config.js`: A configuration file to define how you''ll connect to
    the blockchain, what Ethereum account you''ll use, and so on.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truffle-config.js`：一个配置文件，用于定义如何连接到区块链，您将使用哪个以太坊帐户等。'
- en: Installing the required packages
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的软件包
- en: 'What we have to do now is install the essential packages that we''ll need for
    using React and webpack. First, update your `npm` version to the latest one with
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是安装我们将用于使用 React 和 webpack 的基本包。首先，使用以下命令将您的`npm`版本更新为最新版本：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go to your `dapp` project folder if you haven''t done so already and install
    `webpack` with the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请进入您的`dapp`项目文件夹，并使用以下命令安装`webpack`：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Webpack is a utility that takes all of your JavaScript files and combines them
    into one single, gigantic, easy-to-manage JavaScript file so that you can optimize
    development times.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个实用工具，它会将所有 JavaScript 文件合并为一个单一的、庞大的、易于管理的 JavaScript 文件，以便您可以优化开发时间。
- en: 'After Webpack, install all the `babel` dependencies. Babel is a utility that
    works with webpack to take your JavaScript files and convert them into the latest
    version so that every browser is compatible with the new JavaScript functionalities,
    given that there are major differences across browsers that need to be normalized.
    Babel does just that, and you can install it like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Webpack 后，安装所有`babel`依赖项。Babel 是一个实用工具，它与 webpack 一起工作，将您的 JavaScript 文件转换为最新版本，以便每个浏览器都与新的
    JavaScript 功能兼容，鉴于各种浏览器之间存在重大差异需要进行标准化。Babel 就是这样做的，您可以这样安装它：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we need to install `react.js` since we''ll use it for our project, as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要安装`react.js`，因为我们将在我们的项目中使用它，如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Setting up webpack
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 webpack
- en: 'We can now generate the `webpack.config.js` file where we''ll specify how we
    want to have our JavaScript files handled, and where the combined version will
    be deployed. Create an empty `webpack.config.js` file at the root level of your
    `dapp/ folder` with the following configuration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成`webpack.config.js`文件，其中我们将指定如何处理我们的 JavaScript 文件，以及组合版本将部署到何处。在您的`dapp/文件夹`的根级别创建一个空的`webpack.config.js`文件，并使用以下配置：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Module exports is the export object that''s used in `node.js` projects. It
    contains the `rules` array, where you indicate which files must be passed through
    which compilers, in this case, `babel-loader`. The entry and output properties
    define where our files will be generated after combining them. Amplify the webpack
    configuration file with some additional information for defining the HTML resulting
    file; this is required to generate a valid HTML page automatically with your JavaScript
    files bundled together. Install the following loaders:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模块导出是在`node.js`项目中使用的导出对象。它包含`rules`数组，其中你指示哪些文件必须通过哪些编译器，这里是`babel-loader`。入口和输出属性定义了在合并文件后生成文件的位置。增加
    webpack 配置文件中的一些额外信息以定义 HTML 结果文件；这是为了自动生成一个包含你的 JavaScript 文件的有效 HTML 页面。安装以下加载器：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update your webpack configuration like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的 webpack 配置如下：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting up the source folder
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置源文件夹
- en: 'Let''s take a look at the following steps to set up the source folder:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看设置源文件夹的以下步骤：
- en: 'Create a `src` folder where all your development code will go. Here''s what
    your project setup should look like by now:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`src`文件夹，所有你的开发代码都会在这里。现在你的项目设置应该是这样的：
- en: '![](img/28fc131a-6b91-4745-b428-47d9d366227a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28fc131a-6b91-4745-b428-47d9d366227a.png)'
- en: 'Create a new file inside `src/` called `index.html` with this code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/`中创建一个名为`index.html`的新文件，使用以下代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `<div id="root">` object will be where our React project will start. With
    HTML, `webpack`, and `babel` set up, we can start creating the main `react.js`
    file that will be used in our project. Inside the `src/ folder`, create a file
    called `index.jsx`, which will contain our initial `react.js` file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<div id="root">`对象将是我们 React 项目的起点。有了 HTML、`webpack` 和 `babel` 设置，我们可以开始创建主`react.js`文件。在`src/`文件夹中创建一个名为`index.jsx`的文件，里面包含我们的初始`react.js`文件：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are importing `React` and ReactDOM for connecting React with our HTML
    file. Then, we are creating a `Main` class that has a simple constructor and a
    `render()` function that returns a message confirming that the project has been
    set up properly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`React`和 ReactDOM，将 React 与我们的 HTML 文件连接起来。然后，我们创建一个`Main`类，它有一个简单的构造函数和一个`render()`函数，该函数返回一个确认项目已正确设置的消息。
- en: 'Finally, you can compile those files with the following, where `-p` means production:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令编译这些文件，其中`-p`表示生产环境：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remember to execute it inside your project folder. After compiling your files,
    you need to run a static server that will deliver the files to your browser so
    that you can use your dApp. For that, install `http-server` using the following
    command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在你的项目文件夹中执行。编译文件后，你需要运行一个静态服务器，将文件传送到你的浏览器，以便你可以使用你的 dApp。为此，使用以下命令安装`http-server`：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run it for your distribution folder:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为你的分发文件运行它：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `localhost: 8080` on your browser to see your dApp project live:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在浏览器中打开`localhost: 8080`，即可查看你的 dApp 项目实时展示：'
- en: '![](img/a3a3e963-b0d3-4023-88b0-3603b998e34f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3a3e963-b0d3-4023-88b0-3603b998e34f.png)'
- en: Congratulations! You now have a working startup project that you can replicate
    for other dApps that you want to create.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在拥有一个可以复制到其他想要创建的 dApp 的工作启动项目。
- en: 'You can publish the project on your GitHub to clone it for other situations
    where you may need it by performing the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将项目发布到你的 GitHub 上，以便在其他情况下需要时克隆它，执行以下步骤：
- en: 'Open up [https://github.com](https://github.com) and create a new repository
    by clicking on New. Name it `dapp`, select gitignore Node, and an MIT License.
    Here''s the one I created: [https://github.com/merlox/dapp](https://github.com/merlox/dapp).'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[https://github.com](https://github.com)，点击 New 创建一个新的仓库。命名为`dapp`，选择 gitignore
    Node 和 MIT 许可证。这是我创建的一个示例：[https://github.com/merlox/dapp](https://github.com/merlox/dapp)。
- en: Now, go back to your Terminal and type `git init` if you have `git` installed
    on your system. That will start a new GitHub project inside your folder.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到你的终端并键入`git init`，如果你的系统上已安装了`git`。\那将在你的文件夹中启动一个新的 GitHub 项目。
- en: 'Then, you''ll need to tell GitHub which repository you want to update your
    changes when you are committing new files with your own credentials; you can do
    all that permanently with the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当你在使用自己的凭证提交新文件时，你需要告诉 GitHub 你想要更新哪个仓库的更改；你可以使用以下命令来永久执行所有这些操作：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pull the initial license files from your repository with the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下命令从你的仓库中拉取初始许可文件：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add your files with `git add .`, and commit them with `git commit -m`. First,
    commit them and push them with `git push origin master`. Then, you'll see your
    files in your new repository.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git add .`添加你的文件，用`git commit -m`进行提交。首先，提交它们，然后用`git push origin master`推送它们。接下来，你将在你的新存储库中看到你的文件。
- en: Remember to not push any new changes, since you want this repository to be as
    it is right now for future projects that use the same file structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得不要推送任何新的更改，因为你希望这个存储库在未来使用相同文件结构的项目中保持不变。
- en: Creating dApps
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建dApps
- en: You are now ready to create dApps with Truffle, React, Webpack, and Solidity.
    To gain the required knowledge as fast as possible, we'll go through all the steps
    that it takes to create a fully working decentralized application. In this chapter,
    we are creating a music recommendation social media platform where people will
    be able to publish songs, they love at that moment to help their friends find
    interesting music to enjoy, all stored inside smart contracts without a centralized
    server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经准备好用Truffle, React, Webpack和Solidity创建dApps。为了尽快获得必要的知识，我们将经历创建一个完全可行的分散式应用程序所需的所有步骤。在本章中，我们正在创建一个音乐推荐社交媒体平台，在这里人们将能够发布他们当时喜欢的歌曲，以帮助他们的朋友找到有趣的音乐来享受，所有这些都存储在智能合约内，而不需要一个集中的服务器。
- en: We'll first create the smart contracts, then the user interface, and finally,
    we'll combine them all together with `web3.js`. We will test our decentralized
    application when the main interface is done to make sure it works properly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建智能合约，然后是用户界面，最后，我们将用`web3.js`将它们全部结合在一起。在主界面完成后，我们将测试我们的分散式应用程序，以确保它正常运作。
- en: Creating the smart contract
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建智能合约
- en: 'Before diving straight into creating the smart contract, let''s define what
    we need it to do:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接创建智能合约之前，让我们定义我们需要它做什么：
- en: We need an array that will store each users' music recommendations in a string
    or bytes32 format
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个数组，它将以字符串或bytes32格式存储每个用户的音乐推荐
- en: A struct to define user information
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于定义用户信息的结构体
- en: A mapping with each users' recommendations
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含每个用户推荐的映射
- en: An array of followed users so that we can see new musical updates
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关注用户的数组，这样我们可以看到新的音乐更新
- en: 'As usual, we start by creating the basic smart `contract` structure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 跟往常一样，我们从创建基本的智能`contract`结构开始：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we define the variables that we''ll use, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们将使用的变量，如下所示：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each user struct will hold all the music recommendations made by that user.
    Now, we need to create functions to add new music recommendations. We won''t have
    functions to delete or modify past recommendations because we want it to be a
    permanent place for sharing past and present musical tastes, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户结构体将保存该用户做出的所有音乐推荐。现在，我们需要创建函数来添加新的音乐推荐。我们不会有函数来删除或修改过去的推荐，因为我们希望它成为分享过去和现在的音乐品味的永久场所，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `addSong()` function takes the song name as a string and pushes that song
    to the array of music recommendations for that particular Ethereum address. The
    `_songName` must be between 1 and `100` characters long to avoid extremely large
    or empty recommendations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSong()`函数接受歌曲名作为字符串，并将该歌曲推荐到特定以太坊地址的音乐推荐数组中。_songName_必须在1和`100`个字符长之间，以避免极大或空的推荐。'
- en: 'Then, we need functions to create new users and to follow others. People will
    be able to publish music recommendations with just their address if they don''t
    want to set up their `name`, `age`, and `state`; they will be anonymous, so the
    `setup` function is optional:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建用于创建新用户和关注其他用户的函数。人们可以只用他们的地址发布音乐推荐，如果他们不想设置他们的`姓名`、`年龄`和`州`，他们将是匿名的，因此`setup`函数是可选的：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `setup` function must at least receive the `_name` of the user, the other
    parameters are optional, and the recommendations made before the setup will stay
    linked to that user. Here''s what the `follow` function looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`函数必须至少接收用户的`_name`，其他参数是可选的，而在设置之前做出的推荐将与该用户保持链接。以下是`follow`函数的样子：'
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are simply pushing a new address to the array of following users. You can
    deploy your contract with remix to manually test that all the functions are working.
    To deploy it with Truffle, we first need to set up the `truffle-config.js` configuration
    file and make sure our `SocialMusic.sol` file is in the `contracts/ folder` of
    our project. As you learned in previous lessons, to set up `truffle-config.js`
    for `ropsten`, we need to uncomment the `ropsten` object at line 63:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将一个新地址推送到以下用户的数组中。你可以使用 Remix 手动测试所有功能来部署你的合约。要使用 Truffle 部署它，我们首先需要设置`truffle-config.js`配置文件，并确保我们的`SocialMusic.sol`文件位于项目的`contracts/文件夹`中。正如你在之前的课程中学到的那样，要为`ropsten`设置`truffle-config.js`，我们需要取消注释第
    63 行的`ropsten`对象：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, uncomment the variables at the beginning of the file at line 21:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文件开头的第 21 行取消注释变量：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change your `infuraKey` to your personal key, which you can find after creating
    a project in `infura.io`. If you don''t know how to get an `infuraKey`, go back
    to [Chapter 3](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml), *Ethereum Assets*,
    and execute the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`infuraKey`更改为你的个人密钥，你可以在`infura.io`创建项目后找到。如果你不知道如何获取`infuraKey`，请返回到[第
    3 章](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml)，*以太坊资产*，并执行以下代码：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a `.secret` file with your MetaMask mnemonic, which will be used by Truffle
    to employ your first Ethereum account for deploying your `SocialMusic` smart contract.
    Be sure to add `.secret` to your `.gitignore` file if you're working on a git
    project, so that your account doesn't get leaked for people to see and steal your
    Ether.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含你的 MetaMask 助记词的`.secret`文件，Truffle 将使用它来使用你的第一个以太坊帐户部署你的`SocialMusic`智能合约。如果你正在进行
    git 项目的开发，请确保将`.secret`添加到你的`.gitignore`文件中，这样你的帐户就不会泄露给别人看到并窃取你的以太币。
- en: 'Before deploying your contract, you need to install the wallet provider so
    that `truffle` has access to your account:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署你的合约之前，你需要安装钱包提供程序，以便`truffle`可以访问你的帐户：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you need to tell Truffle which contracts you want to deploy. You can do
    so by opening the `migrations/1_initial_migrations.js` file and changing it accordingly:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要告诉 Truffle 你想要部署哪些合约。你可以通过打开`migrations/1_initial_migrations.js`文件并相应更改来实现：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Deploy your contract for `ropsten` after setting up your secret mnemonic with
    the following; remember to have enough `ropsten` Ether for deployment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好秘密助记词之后，为`ropsten`部署你的合约；记得要有足够的`ropsten`以太币用于部署：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `--reset` flag will force Truffle to deploy a new version of your contract
    if you deployed an invalid one previously. The good thing about Truffle is that
    after setting up everything, you can quickly deploy new versions of your contract
    for testing very efficiently. You''ll see something like this if everything ran
    successfully:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reset`标志将强制 Truffle 部署新版本的合约，如果你之前部署的是无效的。Truffle 的好处在于设置好一切之后，你可以非常高效地快速部署新版本的合约进行测试。如果一切都运行成功，你将看到类似于下面的内容：'
- en: '![](img/7fc32eea-afae-4b79-a084-7c67f8713dad.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc32eea-afae-4b79-a084-7c67f8713dad.png)'
- en: Congratulations! You just deployed your `SocialMusic` smart contract. Continue
    reading to learn how to create the user interface that we'll use to interact with
    our smart contract.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚部署了你的`SocialMusic`智能合约。继续阅读，了解如何创建我们将用于与智能合约交互的用户界面。
- en: Creating user interfaces
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Because we have a clean `react.js` project properly set up, we can start right
    away with creating our application's user interface. We'll use sample data to
    check the design before moving on and integrating the real smart contract code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有一个干净的`react.js`项目正确设置，所以我们可以立即开始创建我们应用程序的用户界面。我们将使用示例数据来检查设计，然后再移动并集成真实的智能合约代码。
- en: 'Open up the `src/index.js` file to start coding your design:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/index.js`文件开始编写你的设计：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''re writing our design inside the `render()` function since it''s where
    all the code will be shown to the user. I''ve created two main sections: an `h1`
    to welcome people to the dApp with a short message showing them three buttons
    to start using it, and an `h3` section showing people the latest 10 musical recommendations
    made by random people on the network:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计写在`render()`函数内部，因为这是所有代码将显示给用户的地方。我创建了两个主要部分：一个`h1`欢迎用户来到 dApp，并显示给他们三个按钮开始使用它的简短消息，以及一个`h3`部分向用户展示网络上随机人员最新的
    10 条音乐推荐：
- en: '![](img/1b07582f-2cec-4d0b-bb21-871c22e87931.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b07582f-2cec-4d0b-bb21-871c22e87931.png)'
- en: 'To improve the appearance of the application, we''ll use some basic CSS so
    that it feels great to users. Create a new file inside `src/` called `index.css`.
    In order to be able to use CSS in our `react.js` application, we need to use a
    new loader that understands CSS. Open your `webpack.config.js` file to add the
    following section to the rules block, just like you did with the previous loaders:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善应用程序的外观，我们将使用一些基本的CSS，让用户感觉很棒。在`src/`目录下创建一个名为`index.css`的新文件。为了能够在我们的`react.js`应用程序中使用CSS，我们需要使用一个新的加载程序来理解CSS。打开你的`webpack.config.js`文件，在rules块中添加以下部分，就像之前使用其他加载程序一样：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, install `css-loader` and `style-loader`, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装`css-loader`和`style-loader`，如下所示：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can write our CSS code inside `index.css`, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`index.css`中编写我们的CSS代码，如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should get something that looks like the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似以下截图的东西：
- en: '![](img/3e075653-0ea6-4b8e-adca-7d69ec875fdc.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e075653-0ea6-4b8e-adca-7d69ec875fdc.png)'
- en: 'We''ll now need to implement each of those features, but before that, let''s
    work on creating a new component called **Recommendation**, which will be an individual
    box that will contain an individual music recommendation by some user. Here''s
    how it will look:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现每一个这些功能，但在此之前，让我们先创建一个名为**推荐**的新组件，它将是一个包含某个用户推荐的个人音乐推荐的个体盒子。它将是这个样子：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ve added this new component that shows three divs containing the name,
    address, and song of each recommendation. I''ve also added a sample use inside
    the `Main` component so that you can see how it works. Props are just variables
    that you pass from component to component, and they are identified with their
    variable names. Let''s improve the appearance of this thing with some CSS code,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新增了一个显示三个包含推荐歌曲的名称、地址和歌曲的div的新组件。我还在`Main`组件中添加了一个示例用法，这样你就可以看到它是如何工作的。Props只是你从一个组件传递到另一个组件的变量，并且它们是通过它们的变量名识别的。让我们用一些CSS代码改善一下外观，如下所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s how it will look like with the changes that we just made and with some
    more sample music recommendations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们刚刚做的改变和一些更多音乐推荐样本的样子：
- en: '![](img/3184070c-4877-4a41-9d77-9889348d90d8.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3184070c-4877-4a41-9d77-9889348d90d8.png)'
- en: That's it—you just created the UI of your decentralized `SocialMusic` platform.
    Let's make it dynamic by integrating `web3.js` so that we can use our smart contracts
    to allow people to interact with it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——你刚刚创建了你的去中心化`SocialMusic`平台的UI。让我们通过集成`web3.js`使它动态起来，以便我们可以使用我们的智能合同让人们与它互动。
- en: Connecting smart contracts to web applications
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将智能合同连接到web应用程序
- en: Decentralized applications are made of smart contracts and user interfaces.
    Now that we have both elements, we can combine them by connecting the frontend
    with the backend using `web3`, the most powerful tool for interacting with the
    Ethereum blockchain from the browser.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序由智能合同和用户界面组成。我们现在有了这两个元素，我们可以通过使用`web3`连接前端和后端来将它们结合起来，`web3`是从浏览器与以太坊区块链交互的最强大工具。
- en: 'Let''s start by getting `web3.js`. You can install it with the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取`web3.js`开始。你可以用以下命令来安装它：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, import it into your `index.js` file, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将它导入到你的`index.js`文件中，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You don't really need to install `web3` since most, if not all of your users
    will have MetaMask installed, which automatically injects `web3.js` to your application.
    Nevertheless, it is good practice to have `web3` in your application's code because
    you can control which version is used across the application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要安装`web3`，因为大多数用户（如果不是所有用户）都会安装MetaMask，它会自动将`web3.js`注入到你的应用程序中。尽管如此，在应用程序的代码中有`web3`是一个好习惯，因为你可以控制应用程序中使用的版本。
- en: To fully connect our `react.js` application with our `SocialMusic` contract,
    we need to implement every function of the contract so that they can be executed
    from the user interface that we designed. We also want to retrieve specific information,
    such as the last five recommended songs. There are many ways you can start implementing
    your contracts, so, we'll start by making all three buttons in our web application
    work properly with the smart contract.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`react.js`应用程序完全连接到我们的`SocialMusic`合同，我们需要实现合同的每个函数，以便它们可以从我们设计的用户界面执行。我们还想要检索特定信息，比如最后推荐的五首歌曲。你可以用许多方法开始实现你的合同，所以，我们将首先让我们web应用程序中的所有三个按钮与智能合同正常工作。
- en: Designing the setup form
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计设置表单
- en: 'First, we have the Setup Account button. This one should show users a form
    with several inputs to set up their name, age, and state, where only the name
    is mandatory. There should be a Cancel button as well as a Submit button. Let''s
    create a new React component that we''ll call `Form`, which will include all these
    requirements:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有“设置账户”按钮。这个按钮应该向用户显示一个表单，其中包含几个输入来设置他们的姓名、年龄和状态，其中只有姓名是必填的。还应该有一个取消按钮和一个提交按钮。让我们创建一个新的React组件，我们将其称为`Form`，它将包括所有这些要求：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've added two inputs with a text area for the state and two buttons to cancel
    or submit. Notice how I've added a custom `className` attribute on the form element
    so that we can dynamically set up the class from the outer component, otherwise
    it wouldn't work. We only want to display this form when users click on Setup
    Account, so we'll add the form component below our three buttons as a hidden element,
    since that's the location that makes more sense to the user, given that it's closer
    to the mouse. How can we hide an element in a website? By using a custom class
    that sets display to none.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个带有文本区域的输入，用于状态和两个按钮以取消或提交。注意我在表单元素上添加了自定义`className`属性，以便我们可以从外部组件动态设置类，否则它将不起作用。我们只想在用户点击“设置账户”时显示这个表单，所以我们将表单组件添加到我们的三个按钮下面作为一个隐藏元素，因为这个位置对用户来说更有意义，因为它更靠近鼠标。我们如何在网站中隐藏一个元素？通过使用一个自定义类，将显示设置为none。
- en: 'First, we set up the new state variable in the constructor to hide the form
    when it''s not necessary:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在构造函数中设置新的状态变量，以在不必要时隐藏表单：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we add the `Form` component right below the buttons with a dynamic class
    name that changes depending on when we want to display the form:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在按钮下面添加`Form`组件，并使用一个动态类名来根据需要显示表单：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, I've added a state element called `isFormHidden`, which indicates
    if the form is hidden or not. Then, I set up the `className` of our `Form` as
    a dynamic component that depends on state so that it stays hidden at the right
    moment. We need to use React's state because it's the main way React has to update
    information being displayed. React is reactive to state, so every time it changes,
    it updates the entire web application. If we simply selected the component and
    updated the class of it directly, React wouldn't know what's going on, and it
    would get messy since state is an essential element of every interactive web application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我添加了一个叫做`isFormHidden`的状态元素，它指示表单是否隐藏。然后，我设置了我们的`Form`的`className`作为一个依赖于状态的动态组件，以便在适当的时候保持隐藏。我们需要使用React的状态，因为这是React更新正在显示的信息的主要方式。React对状态是响应式的，所以每当它改变时，它就会更新整个Web应用程序。如果我们简单地选择组件并直接更新它的类，React就不会知道发生了什么，并且会变得混乱，因为状态是每个交互式Web应用程序的重要组成部分。
- en: 'Then, create a CSS class to hide it, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个CSS类来隐藏它，如下所示：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Take a look at the result on the live page. You shouldn''t be seeing anything
    because your form is hidden. To display it, you have to add an `onClick` event
    on your Setup Account button, like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时页面上查看结果。你不应该看到任何东西，因为你的表单是隐藏的。要显示它，你必须在“设置账户”按钮上添加一个`onClick`事件，如下所示：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That will read the form''s state to hide it or display it when clicked. You''ll
    see that the design is a mess, so we''ve got to improve that:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将读取表单的状态以在点击时隐藏或显示它。你会发现设计是一团糟，所以我们必须改进它：
- en: '![](img/e6052099-4db4-44aa-b247-8b52eebc2bb1.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6052099-4db4-44aa-b247-8b52eebc2bb1.png)'
- en: 'Add a new general class to each of your inputs with separate ones to differentiate
    the text area, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个输入添加一个新的通用类，用不同的类来区分文本区域，如下所示：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create new CSS classes with your desired appearance, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建具有所需外观的新CSS类，如下所示：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s how it looks after the changes in styling:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在样式更改后的外观：
- en: '![](img/b8da727f-fba6-462b-bfda-f1a2c3817eb9.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8da727f-fba6-462b-bfda-f1a2c3817eb9.png)'
- en: It looks way better.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了。
- en: Implementing the setup function
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设置功能
- en: 'Now, we have to make it interact with our smart contract. To do that, we''ll
    have to create a new instance of our deployed contract on `ropsten`. We''ll need
    the address and the `ABI` interface, which you can quickly find inside the `build/contracts/`
    folder that Truffle created for you when you deployed your `SocialMusic` contract.
    Simply copy `SocialMusic.json` to your `src/ folder` for easier access. Bear in
    mind that you''ll need to replace that file with the newer ABI versions of your
    contract if you decide to extend the functionalities of it. Just repeat the same
    steps and you should be good:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须让它与我们的智能合约交互。为此，我们将不得不在`ropsten`上创建我们部署的合约的新实例。我们需要地址和`ABI`接口，你可以在 Truffle
    为你部署`SocialMusic`合约时创建的`build/contracts/`文件夹中快速找到它们。只需将`SocialMusic.json`复制到你的`src/文件夹`以便更容易访问。请记住，如果决定扩展其功能，则需要用新的
    ABI 版本替换该文件。只需重复相同的步骤即可：
- en: '![](img/e759b48e-4164-4a99-a902-52ea097a6806.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e759b48e-4164-4a99-a902-52ea097a6806.png)'
- en: 'Next, we need a way to import that JSON file in our React application. Fortunately,
    if you''re using webpack 2.0 or newer (I''m using 4.19 at the moment) you don''t
    need to do anything extra, since webpack supports JSON files by default. In previous
    versions, you had to add a new `json-loader` that would take care of those files.
    Just add the file at the beginning of your file, like so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来在我们的 React 应用程序中导入该 JSON 文件。幸运的是，如果你使用的是 webpack 2.0 或更新版本（我目前使用的是
    4.19），则无需执行任何额外操作，因为 webpack 默认支持 JSON 文件。在之前的版本中，你必须添加一个新的`json-loader`来处理这些文件。只需在文件开头添加文件，如下所示：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can import your JSON files with the name that you want; the purpose of
    the `ABI` variable is to be able to read the values of the JSON file. Then, create
    a variable with your smart contract''s address and your `abi` interface. Remember
    that you can deploy a new version whenever you want with Truffle using `deploy
    --network ropsten --reset` to get a new address if you lost it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你想要的名称导入你的 JSON 文件；`ABI`变量的目的是为了能够读取 JSON 文件的值。然后，创建一个变量，其中包含你的智能合约的地址和你的`abi`接口。请记住，你可以随时使用
    Truffle 使用`deploy --network ropsten --reset`部署新版本以获取新地址（如果你丢失了它）：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll want to deploy the contracts with our own version of web3 1.0 since
    the one injected by MetaMask is outdated and we cannot rely on an uncontrolled
    version. That''s why we''ll create a new instance of web3, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用我们自己版本的 web3 1.0 部署合约，因为 MetaMask 注入的版本已过时，我们无法依赖于不受控制的版本。这就是为什么我们会创建一个新的
    web3 实例，如下所示：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I''ve renamed the `web3` variable to `myWeb3` to avoid confusing it with the
    one injected by MetaMask. Notice the `window` keyword in front of `myWeb3`; that''s
    used to set up that variable as global so that you can access `myWeb3` from anywhere
    in your dApp. It makes life much easier by just having access to our custom web3
    everywhere. We''ll use promises with async await later on. To be able to use async
    await for this version of webpack/babel, you''ll need to install `babel-polyfill`,
    which takes care of compiling your async code so that it works properly on all
    browsers. Install it with the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`web3`变量重命名为`myWeb3`，以避免与 MetaMask 注入的变量混淆。请注意`myWeb3`前面的`window`关键字；这用于将该变量设置为全局，以便你可以从你的
    dApp 中的任何位置访问`myWeb3`。通过在任何地方都可以访问我们的自定义 web3，生活会变得更加轻松。稍后我们将使用带有 async await
    的 promises。为了能够在这个版本的 webpack/babel 中使用 async await，你需要安装`babel-polyfill`，它负责编译你的
    async 代码，以便在所有浏览器上正常工作。使用以下命令安装：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, add it into your webpack configuration file, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其添加到你的 webpack 配置文件中，如下所示：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, we'll create the contract's instance with some helper functions and the
    `setupAccount` function's integration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用一些辅助函数和`setupAccount`函数的集成来创建合约的实例。
- en: 'First, update the constructor to execute the function to set up the contract
    instance right when the dApp loads, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新构造函数以在 dApp 加载时执行设置合约实例的函数，如下所示：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, create the required functions to properly set up the user account and
    contract, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建所需的函数来正确设置用户帐户和合约，如下所示：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, update your `render()` function with the `Form` props to tell React
    what to do when the user clicks on the setup button, and when the user clicks
    on the Cancel button:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的`render()`函数中使用`Form` props来告诉 React 用户单击设置按钮时要执行什么操作，以及用户单击取消按钮时要执行什么操作：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, update your `Form` component with the new functionality to trigger
    the setup functions when the user interacts with the inputs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新你的`Form`组件，添加新功能以在用户与输入交互时触发设置功能：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There are quite some changes here, so let me explain what I did.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些变化，让我解释一下我做了什么。
- en: First, I created the `setContractInstance` function, which is used to set up
    the contract instance with our smart contract's address so that we can use it
    later for the other functions. The `getAccount` function is a helper to get the
    address of the current user quickly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建了`setContractInstance`函数，用于使用我们智能合约的地址设置合约实例，以便以后可以使用它执行其他功能。`getAccount`函数是一个快速获取当前用户地址的辅助函数。
- en: Then, I created the `setupAccount` function, which receives the three parameters
    we want to use for setting up the user's account with a helper function named
    `fillBytes32WithSpaces`, since we need to fill all the spaces in a bytes32 type
    of variable with this version of `web3.js`, otherwise it will reject the transaction.
    This function simply creates a transaction for the `setup()` function in our deployed
    smart contract.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我创建了`setupAccount`函数，它接收我们想要用于设置用户帐户的三个参数，并使用一个名为`fillBytes32WithSpaces`的辅助函数，因为我们需要用这个版本的`web3.js`填充一个bytes32类型变量的所有空格，否则它会拒绝交易。此函数简单地创建了我们部署的智能合约中的`setup()`函数的事务。
- en: Next, I created some prop functions for the `Form` component that will be executed
    when the user clicks on Cancel or Submit. We want to hide the form when the user
    cancels, so I simply set the state of the form to hidden. When the user clicks
    on Submit, we extract the data from all the inputs and we send them to the `setupAccount`
    function. Notice how I've used `event.preventDefault()` inside each button's click
    event to avoid refreshing the page, since all HTML buttons are submit buttons
    that supposedly send information to the server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我为`Form`组件创建了一些属性函数，当用户点击取消或提交时将执行这些函数。我们希望当用户取消时隐藏表单，所以我简单地将表单的状态设置为隐藏。当用户点击提交时，我们提取所有输入的数据，并将它们发送到`setupAccount`函数。请注意，我在每个按钮的点击事件内部都使用了`event.preventDefault()`，以避免刷新页面，因为所有的HTML按钮都是提交按钮，它们应该向服务器发送信息。
- en: 'Notice that we used the `.send()` function when setting up users, data which
    generates a transaction and costs gas. Inside it, I''ve used my Ethereum address
    so that it knows who should make the transaction:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设置用户数据时我们使用了`.send()`函数，这会生成一个交易并花费gas。在其中，我使用了我的以太坊地址，以便它知道谁应该进行交易：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But you don''t want to use the same address since you can''t have access to
    it for your MetaMask. You can simply delete that parameter so that the function
    looks like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你不想使用相同的地址，因为你无法访问它来使用你的MetaMask。你可以简单地删除那个参数，让函数看起来像这样：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Telling React to find the user's address automatically doesn't work sometimes,
    so you can set your own address instead. Remember to have your MetaMask unlocked
    and using ropsten, then paste your current address there.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时告诉React自动查找用户的地址不起作用，所以你可以设置自己的地址。记得解锁你的MetaMask并使用ropsten，然后把你当前的地址粘贴到那里。
- en: Go ahead and interact with your dApp once the changes are done to verify that,
    indeed, it's submitting a transaction to the smart contract.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完变化后，与您的dApp进行交互，以验证它确实正在向智能合约提交交易。
- en: 'What we''ll do now is set up the Add Music button so that users can create
    musical recommendations. To start, create the design with a new component, just
    like we did previously, by updating the state object inside your constructor:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是设置“添加音乐”按钮，使用户可以创建音乐推荐。首先，通过更新构造函数内的状态对象，创建一个新的组件设计，就像我们之前做的那样：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, create a new `addMusic()` function, which will push the indicated song
    to the array:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的`addMusic()`函数，它将把指定的歌曲推送到数组中：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Update the `render()` function by adding the `onClick` event listener to the
    Add Music button, which will update the state to display the add music form. Then,
    add the new `AddMusic` component, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向“添加音乐”按钮添加`onClick`事件监听器来更新`state`以显示添加音乐表单。然后，添加新的`AddMusic`组件，就像这样：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, define the new `AddMusic` component with the `class` function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`class`函数定义新的`AddMusic`组件：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We've followed the same steps that we did when we created the `Form` component.
    Simply set up the render HTML, put the `AddMusic` element below your `Form` element
    while keeping it hidden, and set up all the prop functions. Then, create a function
    to add new songs to the smart contract. We've also created a new state variable
    for toggling the hidden class of those buttons.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了创建`Form`组件时所做的相同步骤。只需设置渲染HTML，将`AddMusic`元素放在`Form`元素下方，同时保持隐藏，并设置所有prop函数。然后，创建一个将新歌曲添加到智能合约的函数。我们还为切换这些按钮的隐藏类创建了一个新的状态变量。
- en: 'You may have noticed that if you click on Add Song and then Setup Account right
    after it without cancelling, the divs stay open—we don''t want that. We want to
    keep only one of those sections open at any given time. We can achieve that with
    a function that updates the state for hiding all the components before opening
    a new one, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，如果您先单击“添加歌曲”，然后立即单击“设置帐户”而不取消，那些div会保持打开状态——这不是我们想要的。我们希望在任何给定时间内仅保持一个部分处于打开状态。我们可以通过一个函数来更新隐藏所有组件的状态来实现这一点，然后再打开新的组件，如下所示：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, add the function call to the buttons before opening the section:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在打开部分之前添加函数调用到按钮：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s add the final button function to be able to follow people. We''ll show
    a list of all the people that have registered so that the user can follow the
    ones they like to see updates from. To achieve that, we''ll have to modify our
    contract so that we can add an array with the latest newcomers that will get updated
    when users execute the `setup` function, as shown in the following code block:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加最终的按钮功能，以便关注其他用户。我们将显示所有已注册用户的列表，以便用户可以关注自己喜欢的用户以获取更新。为了实现这一点，我们将不得不修改我们的合同，以便我们可以添加一个包含最新新人的数组，当用户执行`setup`函数时会更新该数组，如下所示：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Redeploy the contract with Truffle, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Truffle重新部署合同，如下所示：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Instead of having to manually copy the new address and updating the json file,
    we''ll get all the information straight from the build folder, including the address,
    like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从构建文件夹中获取所有信息，包括地址，而不是手动复制新地址并更新json文件，如下所示：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, you won''t have to worry about updating the information every single time,
    which is great because you can access different external folders freely, given
    that webpack takes all the required information and bundles it together, so it
    doesn''t matter that you''re accessing files outside of the `src/` folder. Now
    let''s create the desired functionality to get the latest people so that the user
    can follow them with a couple of new components:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不必每次都担心更新信息，这很棒，因为您可以自由访问不同的外部文件夹，webpack会获取并捆绑所有所需信息，因此访问`src/`文件夹之外的文件并不重要。现在让我们创建所需的功能，以获取最新的用户，以便用户可以关注他们，并添加一些新组件：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `FollowPeopleContainer` is simply a component that holds all the users that
    you can follow with your account. It will receive data from the `Main` component
    inside the `this.props.followUsersData` prop, which sends an array containing
    up to 10 users to follow with up to two musical recommendations each, just so
    that you can see the type of person they are. It also removes already followed
    users from the array so that you don't see them as new users. Finally, it generates
    a `FollowPeopleUnit` component with all the required user properties, with a function
    that will transmit the information required to follow that specific user to the
    `Main` component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`FollowPeopleContainer`只是一个组件，它保存了您可以用您的账户关注的所有用户。它将从`Main`组件中的`this.props.followUsersData`
    prop接收数据，该数据发送一个包含最多 10 位用户和每位用户最多两个音乐推荐的数组，以便您可以了解他们的类型。它还从数组中删除已经关注的用户，以便您不将其视为新用户。最后，它使用一个包含所有所需用户属性的`FollowPeopleUnit`组件，并具有一个将传输所需关注特定用户信息到`Main`组件的函数。'
- en: Notice the `key={user.address}` attribute in each `FollowPeopleUnit`, since
    we need to be able to identify them individually, which is mandatory by React
    to avoid duplicate elements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在每个`FollowPeopleUnit`中的`key={user.address}`属性，因为我们需要能够单独识别它们，这是 React 强制性需要的，以避免重复元素。
- en: On the other hand, the `FollowPeopleUnit` component is made of a set of divs
    that show all the required information to the user. Because we have two recommendations
    inside an array called `this.props.recommendations`, we'll have to loop through
    all of them to display each message individually. When you want to generate HTML
    elements dynamically with react, you must use the `.map()` function of your array
    with round brackets `()` instead of curly brackets `{}` since all HTML elements
    must be inside these types of brackets.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`FollowPeopleUnit`组件由一组显示所有必要信息给用户的 div 组成。因为我们在一个名为`this.props.recommendations`的数组中有两个推荐，所以我们必须循环遍历它们以逐个显示每个消息。当你想要使用
    react 动态生成 HTML 元素时，你必须使用你的数组的`.map()`函数，并用圆括号`()`而不是花括号`{}`，因为所有 HTML 元素必须在这些类型的括号内。
- en: Now that we have our two new components, we have to define the functions to
    make them interactive in our `Main` component; you can check the complete code
    on GitHub just so you know where everything has to be placed in case you're facing
    errors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个新组件，我们必须在我们的`Main`组件中定义函数以使它们交互式；你可以在 GitHub 上查看完整的代码，这样你就知道所有东西应该放在哪里，以防你遇到错误。
- en: 'First, we updated the address system to be dynamic so that you don''t have
    to manually type your Ethereum address in code. For instance, let''s say we had
    the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新了地址系统，使其动态化，这样你就不必在代码中手动输入你的以太坊地址。例如，假设我们有以下代码：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Instead, we would use the following code, which is essential to make our dApp
    interactive for many different users. You can see that we set up the `userAddress`
    state variable in the `setContractInstance()` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用以下代码，这对于使我们的 dApp 与许多不同的用户交互是必不可少的。您可以看到我们在`setContractInstance()`函数中设置了`userAddress`状态变量：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, we created the complex `getFollowPeopleUsersData()` function, which gets
    the most recent user addresses; it takes up to 10 of them or less if there aren't
    that many users. Then, it creates a `userData` object with all the properties
    that we want and populates it with the smart contract state variable's information,
    by first getting the length of the array of musical recommendations with `getUsersMusicRecommendationLength()`,
    and then by getting each individual musical recommendation with `getUsersMusicRecommendation()`.
    At the bottom of the function, we get the array of users that that particular
    person is following, just in case we need to access them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了复杂的`getFollowPeopleUsersData()`函数，该函数获取最近的用户地址；它最多获取10个用户地址，如果用户数量不够，则获取尽可能多的用户。然后，它创建一个包含我们想要的所有属性的`userData`对象，并使用智能合约状态变量的信息填充它，首先通过使用`getUsersMusicRecommendationLength()`获取音乐推荐数组的长度，然后通过使用`getUsersMusicRecommendation()`获取每个单独的音乐推荐。在函数的底部，我们获取了那个特定人正在关注的用户数组，以防我们需要访问它们。
- en: 'As you can see, we used some new functions from our smart contract. That''s
    because we couldn''t make all of this possible without adding some complexity.
    Here''s how our updated smart contract looks:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用了智能合约中的一些新函数。这是因为如果不添加一些复杂性，我们无法使所有这些成为可能。这是我们更新后的智能合约的样子：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are a few functions to retrieve the following and recommendation data
    for each particular person from the respective arrays. This is done because we
    can't just get the entire array automatically with public arrays; as you know,
    public arrays only return one element of the entire array each time, so we need
    a function to get it entirely. The same thing happens with strings—we have to
    create a function to get each string individually because we can't just send an
    array of strings, given that they are low-level multidimensional `byte[][]` arrays.
    Solidity doesn't allow you to send a `byte[][][]`, which would be the equivalent
    to `string[]`, because it's too big and complex.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些函数用于从各自的数组中检索每个特定人的以下和推荐数据。这是因为我们不能只使用公共数组自动获取整个数组；正如你所知，公共数组每次只返回整个数组的一个元素，所以我们需要一个函数来完整获取它。字符串也是同样的情况——我们必须创建一个函数来逐个获取每个字符串，因为我们不能只发送一个字符串数组，考虑到它们是低级多维度的`byte[][]`数组。Solidity
    不允许你发送`byte[][][]`，它将是等同于`string[]`的等价物，因为它太大且太复杂了。
- en: Remember to redeploy your code after making changes with Truffle, `deploy --network
    ropsten --reset`. Now, you don't have to update the smart contract address, nor
    copy the ABI to your source folder, since it's set up to get the deployed contract
    data straight from the build folder.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在用 Truffle 进行更改后重新部署你的代码，`deploy --network ropsten --reset`。现在，你不需要更新智能合约地址，也不需要将
    ABI 复制到源文件夹中，因为它被设置为直接从构建文件夹中获取部署的合约数据。
- en: 'Our dApp doesn''t look as good as it should yet, so here''s the entire CSS
    code for your reference if you desire to achieve the same look:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 dApp 看起来还不够好，所以这里是你参考的整个 CSS 代码，如果你想要达到相同的外观：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here''s a screenshot of the final result, which you can generate with `webpack
    -d` and `http-server dist/to` see it in `localhost:8080`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终结果的截图，你可以通过`webpack -d`和`http-server dist/to`在`localhost:8080`上看到它：
- en: '![](img/2b87ca20-1f87-458e-80af-8528139c7eda.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b87ca20-1f87-458e-80af-8528139c7eda.png)'
- en: Go ahead and interact with your new awesome dApp by clicking the buttons shown
    in the preceding screenshot. The Follow People button will take a few seconds
    to load data from the smart contract since we are running several requests to
    generate our custom objects in JavaScript.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 继续点击前面截图中显示的按钮与你的新的很棒的 dApp 进行交互吧。关注人们按钮将需要几秒钟的时间从智能合约中加载数据，因为我们正在运行几个请求来生成我们在
    JavaScript 中的自定义对象。
- en: Finally, I could add functionality to display the latest music recommendations
    and unfollow systems, but I'll leave that to you as an exercise to practice your
    smart contract dApp implementation skills. The idea is to display dynamically
    generated recommendation components at the bottom of the page instead of the static
    ones we have already; you can do that by simply getting the data from our smart
    contract.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以添加功能来显示最新的音乐推荐和取消关注系统，但我将把这留给你作为一个练习，来提高你的智能合约 dApp 实现技能。这个想法是在页面底部动态显示生成的推荐组件，而不是我们已经有的静态组件；你可以通过简单地从我们的智能合约中获取数据来实现这一点。
- en: This dApp is nowhere near perfect; you could fix some of its speed issues by
    optimizing the data structures so that you retrieve only the required information
    instead of the entire arrays. You can also fix some security issues by testing
    the code with truffle. The end result is up to you; you decide when the application
    can be considered finished since you can add and continue adding features that
    make it better—that's how all great dApps are born.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 dApp 远非完美；你可以通过优化数据结构来解决一些速度问题，这样你就只检索所需的信息而不是整个数组。你也可以通过用 truffle 测试代码来解决一些安全问题。最终结果取决于你；你决定何时可以认为应用程序已经完成，因为你可以添加并继续添加使其更好的功能——这就是所有伟大的
    dApp 的诞生方式。
- en: 'You can check the final code on my GitHub here: [https://github.com/merlox/social-music](https://github.com/merlox/social-music).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的 GitHub 上查看最终代码：[https://github.com/merlox/social-music](https://github.com/merlox/social-music)。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw first-hand how to create a decentralized application
    with all the little nuances and changes required. You've gone through the entire
    process, starting from setting up your development environment with React, webpack,
    and Truffle. You've learned how to create React components that organize your
    code neatly so that you can manage all the complexity of your dApp with ease.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你亲自看到了如何创建一个去中心化应用程序，以及所需的所有细微差别和更改。你已经经历了整个过程，从使用 React、webpack 和 Truffle
    设置开发环境开始。你学会了如何创建整洁地组织代码的 React 组件，以便你可以轻松地管理你的 dApp 的所有复杂性。
- en: Remember to add this application to your GitHub as proof that you finished it
    to improve your resume with valuable projects so that future clients can see with
    their own eyes what you can do for them and that you've mastered all the steps
    that it takes to build a fully decentralized application. In the next chapter,
    you'll learn more about improving your dApps with further advanced tips so that
    they feel responsive and behave like high-quality systems.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记得把这个应用程序加到你的 GitHub 上作为证明你已经完成了它，以提高你的简历上有价值的项目，这样未来的客户就可以亲眼看到你为他们做了什么，以及你已经掌握了构建完全去中心化应用程序所需的所有步骤。在下一章中，你将学到更多关于如何通过进一步的高级技巧来改进你的
    dApps，使它们感觉灵敏，并表现得像高质量的系统一样。
