- en: Hyperledger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperledger is not a blockchain, but it is a project that was initiated by the
    Linux Foundation in December 2015 to advance blockchain technology. This project
    is a collaborative effort by its members to build an open source distributed ledger
    framework that can be used to develop and implement cross-industry blockchain
    applications and systems. The principal focus is to develop and run platforms
    that support global business transactions. The project also focuses on improving
    the reliability and performance of blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: Projects under Hyperledger undergo various stages of development, starting from
    proposal to incubation and graduating to an active state. Projects can also be
    deprecated or in end-of-life state where they are no longer actively developed.
    For a project to be able to move into the incubation stage, it must have a fully
    working code base along with an active community of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Projects under Hyperledger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two categories of projects under Hyperledger. The first is **blockchain
    projects** and the second category is **relevant tools or modules that support
    these blockchains**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are five blockchain framework projects under the Hyperledger
    umbrella: **Fabric**, **Sawtooth Lake**, **Iroha**, **Burrow**, and **Indy**.
    Under modules, there are the **Hyperledger Cello**, **Hyperledger Composer**,
    **Hyperledger Explorer**, and **Hyperledger Quilt**. The Hyperledger project currently
    has more than 200-member organizations and is very active with many contributors,
    with regular meet-ups and talks organized around the globe.'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction of all these projects follows, after which we will see
    more details around the design, architecture, and implementation of Fabric and
    Sawtooth Lake.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fabric is a blockchain project that was proposed by **IBM** and **DAH**
    (**Digital Asset Holdings**). This blockchain framework implementation is intended
    to provide a foundation for the development of blockchain solutions with a modular
    architecture. It is based on a pluggable architecture where various components,
    such as consensus engine and membership services, can be plugged into the system
    as required. It also makes use of container technology which is used to run smart
    contracts in an isolated contained environment. Currently, its status is *active*
    and it's the first project to graduate from incubation to active state.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is available at [https://github.com/hyperledger/fabric](https://github.com/hyperledger/fabric).
  prefs: []
  type: TYPE_NORMAL
- en: Sawtooth Lake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sawtooth Lake is a blockchain project proposed by Intel in April 2016 with
    some key innovations focusing on the decoupling of ledgers from transactions,
    flexible usage across multiple business areas using transaction families, and
    pluggable consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling can be explained more precisely by saying that the transactions are
    decoupled from the consensus layer by making use of a new concept called **transaction
    families**. Instead of transactions being individually coupled with the ledger,
    transaction families are used, which allows for more flexibility, rich semantics,
    and open design of business logic. Transactions follow the patterns and structures
    defined in the transaction families.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the innovative elements Intel has introduced include a novel consensus
    algorithm abbreviated as **PoET**, **Proof of Elapsed Time**, which makes use
    of **Trusted Execution Environment** (**TEE**) provided by **Intel Software Guard
    Extensions** (**Intel's SGX**) to provide a safe and random leader election process.
    It also supports permissioned and permission-less setups.
  prefs: []
  type: TYPE_NORMAL
- en: This project is available at [https://github.com/hyperledger/sawtooth-core](https://github.com/hyperledger/sawtooth-core).
  prefs: []
  type: TYPE_NORMAL
- en: Iroha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iroha was contributed by Soramitsu, Hitachi, NTT Data, and Colu in September
    2016\. Iroha is aiming to build a library of reusable components that users can
    choose to run on their own Hyperledger-based distributed ledgers.
  prefs: []
  type: TYPE_NORMAL
- en: Iroha's primary goal is to complement other Hyperledger projects by providing
    reusable components written in C++ with an emphasis on mobile development. This
    project has also proposed a novel consensus algorithm called **Sumeragi**, which
    is a chain-based Byzantine fault tolerant consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Iroha is available at [https://github.com/hyperledger/iroha](https://github.com/hyperledger/iroha).
  prefs: []
  type: TYPE_NORMAL
- en: Various libraries have been proposed and are being worked on by Iroha, including
    but not limited to a digital signature library (ed25519), a SHA-3 hashing library,
    a transaction serialization library, a P2P library, an API server library, an
    iOS library, an Android library, and a JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: Burrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is currently in the incubation state. Hyperledger Burrow was contributed
    by Monax, who develop blockchain development and deployment platforms for business.
    Hyperledger Burrow introduces a modular blockchain platform and an **Ethereum
    Virtual Machine** (**EVM**) based smart contract execution environment. Burrow
    uses proof of stake, Byzantine fault tolerant Tendermint consensus mechanism.
    As a result, Burrow provides high throughput and transaction finality.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is available at [https://github.com/hyperledger/burrow](https://github.com/hyperledger/burrow).
  prefs: []
  type: TYPE_NORMAL
- en: Indy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is under incubation under Hyperledger. Indy is a distributed ledger
    developed for building a decentralized identity. It provides tools, utility libraries,
    and modules which can be used to build blockchain-based digital identities. These
    identities can be used across multiple blockchains, domains, and applications.
    Indy has its own distributed ledger and uses **Redundant Byzantine Fault Tolerance**
    (**RBFT**) for consensus.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is available at [https://github.com/hyperledger/indy-node](https://github.com/hyperledger/indy-node).
  prefs: []
  type: TYPE_NORMAL
- en: Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project aims to build a blockchain explorer for Hyperledger Fabric that
    can be used to view and query the transactions, blocks, and associated data from
    the blockchain. It also provides network information and the ability to interact
    with chain code.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are few other projects that are in incubation under Hyperledger.
    These projects are aimed to provide tools and utilities to support blockchain
    networks. These projects are introduced in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is available at [https://github.com/hyperledger/blockchain-explorer](https://github.com/hyperledger/blockchain-explorer).
  prefs: []
  type: TYPE_NORMAL
- en: Cello
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim behind Cello is to allow easy deployment of blockchains. This will provide
    an ability to allow "as a service" deployments of blockchain service. Currently,
    this project is in the incubation stage.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of Cello is available at [https://github.com/hyperledger/cello](https://github.com/hyperledger/cello).
  prefs: []
  type: TYPE_NORMAL
- en: Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This utility makes the development of blockchain solutions easier by allowing
    business processes to be described in a business language, while abstracting away
    the low-level smart contract development details.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger composer is available at [https://hyperledger.github.io/composer/](https://hyperledger.github.io/composer/).
  prefs: []
  type: TYPE_NORMAL
- en: Quilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This utility implements the Interledger protocol, which facilitates interoperability
    across different distributed and non-distributed ledger networks.
  prefs: []
  type: TYPE_NORMAL
- en: Quilt is available at [https://github.com/hyperledger/quilt](https://github.com/hyperledger/quilt).
  prefs: []
  type: TYPE_NORMAL
- en: Currently, all the mentioned projects are in various stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: This list is expected to grow as more and more members are joining Hyperledger
    project and contributing to the development of blockchain technology. Now in the
    next section, we will see the reference architecture of Hyperledger, which provides
    general principles and design philosophy which can be followed to build new Hyperledger
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger as a protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperledger is aiming to build new blockchain platforms that are driven by industry
    use cases. As there have been many contributions made to the Hyperledger project
    by the community, Hyperledger blockchain platform is evolving into a protocol
    for business transactions. Hyperledger is also evolving into a specification that
    can be used as a reference to build blockchain platforms as compared to earlier
    blockchain solutions that address only a specific type of industry or requirement.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, a reference architecture is presented that has been
    published by the Hyperledger project. As this work is under continuous and rigorous
    development, some changes are expected in this, but core services are expected
    to remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The reference architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperledger has published a white paper which is available at [https://docs.google.com/document/d/1Z4M_qwILLRehPbVRUsJ3OF8Iir-gqS-ZYe7W-LE9gnE/edit#heading=h.m6iml6hqrnm2](https://docs.google.com/document/d/1Z4M_qwILLRehPbVRUsJ3OF8Iir-gqS-ZYe7W-LE9gnE/edit#heading=h.m6iml6hqrnm2).
  prefs: []
  type: TYPE_NORMAL
- en: 'This document presents a reference architecture that can serve as a guideline
    to build permissioned distributed ledgers. The reference architecture consists
    of various components that form a business blockchain. These high-level components
    are shown in the reference architecture diagram shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e33420fd-cbc4-438a-b342-4eec50f34eea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reference architecture - source: Hyperledger whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the left we see that we have five top-level components which provide
    various services. We will explore all these components in detail.
  prefs: []
  type: TYPE_NORMAL
- en: First is identity, that provides authorization, identification, and authentication
    services under membership services.
  prefs: []
  type: TYPE_NORMAL
- en: Then is the policy component, which provides policy services.
  prefs: []
  type: TYPE_NORMAL
- en: After this, ledger and transactions come, which consists of the distributed
    ledger, ordering service, network protocols, and endorsement and validation services.
    This ledger is updateable only via consensus among the participants of the blockchain
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the smart contracts layer, which provides chaincode services
    in Hyperledger and makes use of secure container technology to host smart contracts.
    We will see all these in more detail in the *Hyperledger Fabric* section shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, from a components point of view Hyperledger contains various elements
    described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus layer**: These services are responsible for facilitating the agreement
    process between the participants on the blockchain network. The consensus is required
    to make sure that the order and state of transactions is validated and agreed
    upon in the blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart contract layer**: These services are responsible for implementing business
    logic as per the requirements of the users. Transaction are processed based on
    the logic defined in the smart contracts that reside on the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication layer**: This layer is responsible for message transmission
    and exchange between the nodes on the blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and crypto layer**: These services are responsible for providing
    a capability to allow various cryptographic algorithms or modules to provide privacy,
    confidentiality and non-repudiations services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data stores**: This layer provides an ability to use different data stores
    for storing state of the ledger. This means that data stores are also pluggable
    and allows usage of any database backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy services**: This set of services provide the ability to manage different
    policies required for the blockchain network. This includes endorsement policy
    and consensus policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIs and SDKs**: This layer allows clients and applications to interact with
    the blockchain. An SDK is used to provide mechanisms to deploy and execute chaincode,
    query blocks and monitor events on the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are certain requirements of a blockchain service. In the next section,
    we are going to discuss the design goals of Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and design goals of Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are certain requirements of a blockchain service. The reference architecture
    is driven by the needs and requirements raised by the participants of the Hyperledger
    project and after studying the industry use cases. There are several categories
    of requirements that have been deduced from the study of industrial use cases
    and are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The modular approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main requirement of Hyperledger is a modular structure. It is expected that
    as a cross-industry fabric (blockchain), it will be used in many business scenarios.
    As such, functions related to storage, policy, chaincode, access control, consensus,
    and many other blockchain services should be modular and pluggable. The specification
    suggests that the modules should be plug and play and users should be able to
    easily remove and add a different module that meets the requirements of the business.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy and confidentiality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This requirement is one of the most critical factors. As traditional blockchains
    are permissionless, in the permissioned model like Hyperledger Fabric, it is of
    utmost importance that transactions on the network are visible to only those who
    are allowed to view it.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy and confidentiality of transactions and contracts are of absolute importance
    in a business blockchain. As such, Hyperledger's vision is to provide support
    for a full range of cryptographic protocols and algorithms. We discussed cryptography
    in [Chapter 5](5e44a805-fb66-4135-b59e-4e03367aaed5.xhtml), *Symmetric Cryptography*
    and [Chapter 6](c49f1747-2096-4ab6-a1e1-334e092ef2be.xhtml), *Public Key Cryptography*.
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that users will be able to choose appropriate modules according
    to their business requirements. For example, if a business blockchain needs to
    be run only between already trusted parties and performs very basic business operations,
    then perhaps there is no need to have advanced cryptographic support for confidentiality
    and privacy. Therefore, users should be able to remove that functionality (module)
    or replace that with a more appropriate module that suits their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if users need to run a cross-industry blockchain, then confidentiality
    and privacy can be of paramount importance. In this case, users should be able
    to plug an advanced cryptographic and access control mechanism (module) into the
    blockchain (fabric), which can even allow usage of **hardware of security modules**
    (**HSMs**).
  prefs: []
  type: TYPE_NORMAL
- en: Also, the blockchain should be able to handle sophisticated cryptographic algorithms
    without compromising performance. In addition to the previously mentioned scenarios,
    due to regulatory requirements in business, there should also be a provision to
    allow implementation of privacy and confidentiality policies in conformance with
    regulatory and compliance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another major requirement which once met will allow reasonable transaction
    throughput, which will be sufficient for all business requirements and also a
    large number of users.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a core requirement in any blockchain because if transactions do not
    produce the same result every time they are executed regardless of who and where
    the transaction is executed, then achieving consensus is impossible. Therefore,
    deterministic transactions become a key requirement in any blockchain network.
    We discussed these concepts in [Chapter 4](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml),
    *Smart Contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide privacy and confidentiality services, a flexible PKI model
    that can be used to handle the access control functionality is also required.
    The strength and type of cryptographic mechanisms is also expected to vary according
    to the needs and requirements of the users. In certain scenarios, it might be
    required for a user to hide their identity, and as such, the Hyperledger is expected
    to provide this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Auditability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auditability is another requirement of Hyperledger Fabric. It is expected that
    an immutable audit trail of all identities, related operations, and any changes
    is kept.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there are many blockchain platforms available, but they cannot communicate
    with each other and this can be a limiting factor in the growth of a blockchain-based
    global business ecosystem. It is envisaged that many blockchain networks will
    operate in the business world for specific needs, but it is important that they
    are able to communicate with each other. There should be a common set of standards
    that all blockchains can follow in order to allow communication between different
    ledgers. It is expected that a protocol will be developed that will allow the
    exchange of information between many fabrics.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The portability requirement is concerned with the ability to run across multiple
    platforms and environments without the need to change anything at code level.
    Hyperledger Fabric is envisaged to be portable, not only at infrastructure level
    but also at code, libraries, and API levels, so that it can support uniform development
    across various implementations of Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: Rich data queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blockchain network should allow rich queries to be run on the network. This
    can be used to query the current state of the ledger using traditional query languages,
    which will allow for wider adoption and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: All aforementioned points describe the requirements, which need to be met to
    develop blockchain solutions that are in line with the Hyperledger design philosophy.
    In the next section, we will have a look at Hyperledger Fabric, which is the first
    project to graduate to active status under Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand various projects that are under development in the Hyperledger
    project, it is essential to understand the foundations of Hyperledger first. A
    few terminologies that are specific to Hyperledger need some clarification before
    readers are introduced to the more in-depth material.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the concept of fabric. Fabric can be defined as a collection
    of components providing a foundation layer that can be used to deliver a blockchain
    network. There are various types and capabilities of a fabric network, but all
    fabrics share common attributes such as immutability and are consensus-driven.
    Some fabrics can provide a modular approach towards building blockchain networks.
    In this case, the blockchain network can have multiple pluggable modules to perform
    a various function on the network.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consensus algorithms can be a pluggable module in a blockchain
    network where, depending on the requirements of the network, an appropriate consensus
    algorithm can be chosen and plugged into the network. The modules can be based
    on some particular specification of the fabric and can include APIs, access control,
    and various other components.
  prefs: []
  type: TYPE_NORMAL
- en: Fabrics can also be designed either to be private or public and can allow the
    creation of multiple business networks. As an example, Bitcoin is an application
    that runs on top of its fabric (blockchain network). As discussed earlier in [Chapter
    1](76e4e401-30ba-44f9-832f-333ba6c12cbc.xhtml), *Blockchain 101*, blockchain can
    either be permissioned or permission-less. However, the aim of Hyperledger Fabric
    is to develop a permissioned distributed ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric is also the name given to the code contribution made by IBM to the Hyperledger
    foundation and is formally called Hyperledger Fabric. IBM also offers blockchain
    as a service (IBM Blockchain) via its *IBM Cloud service*.
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [https://www.ibm.com/cloud/](https://www.ibm.com/cloud/).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's have a detailed look at Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fabric is the contribution made initially by IBM and Digital Assets to the
    Hyperledger project. This contribution aims to enable a modular, open, and flexible
    approach towards building blockchain networks.
  prefs: []
  type: TYPE_NORMAL
- en: Various functions in the fabric are pluggable, and it also allows the use of
    any language to develop smart contracts. This functionality is possible because
    it is based on container technology (Docker), which can host any language.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is sandboxed in a secure container, which includes a secure operating
    system, chaincode language, runtime environment, and SDKs for Go, Java, and Node.js.
    Other languages can be supported too in future, if required, but needs some development
    work. Smart contracts are called chaincode in the fabric. This ability is a compelling
    feature compared to domain-specific languages in Ethereum, or the limited scripted
    language in Bitcoin. It is a permissioned network that aims to address issues
    such as scalability, privacy, and confidentiality. The fundamental idea behind
    this is modularization, which would allow for flexibility in design and implementation
    of the business blockchain. This can then result in achieving scalability, privacy,
    and other desired attributes and fine tune them according to the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in the fabric are private, confidential, and anonymous for general
    users, but they can still be traced and linked to the users by authorized auditors.
    As a permissioned network, all participants are required to be registered with
    the membership services to access the blockchain network. This ledger also provided
    auditability functionality to meet the regulatory and compliance needs required
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Membership services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These services are used to provide access control capability for the users
    of the fabric network. The following list shows the functions that membership
    services perform:'
  prefs: []
  type: TYPE_NORMAL
- en: User identity verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign appropriate permissions to the users depending on their roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Membership services make use of **a certificate authority** in order to support
    identity management and authorization operations. This CA can be internal (Fabric
    CA), which is a default interface in Hyperledger Fabric or organization can opt
    to use an external certificate authority. Fabric CA issues **enrollment certificates**
    (**E-Certs**), which are produced by **enrollment certificate authority** (**E-CA**).
    Once peers are issued with an identity, they are allowed to join the blockchain
    network. There are also temporary certificates issued called T-Certs, which are
    used for one-time transactions.
  prefs: []
  type: TYPE_NORMAL
- en: All peers and applications are identified using certificate authority. Authentication
    service is provided by the certificate authority. MSPs can also interface with
    existing identity services like LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain services are at the core of the Hyperledger Fabric. Components within
    this category are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A consensus service is responsible for providing the interface to the consensus
    mechanism. This serves as a module that is pluggable and receives the transaction
    from other Hyperledger entities and executes them under criteria according to
    the type of mechanism chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consensus in Hyperledger V1 is implemented as a peer called **orderer**, which
    is responsible for ordering the transactions in sequence into a block. Orderer
    does not hold smart contracts or ledgers. Consensus is pluggable and currently,
    there are two types of ordering services available in Hyperledger Fabric:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOLO**: This is a basic ordering service intended to be used for development
    and testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kafka**: This is an implementation of Apache Kafka, which provides ordering
    service. It should be noted that currently Kafka only provides crash fault tolerance
    but does not provide byzantine fault tolerance. This is acceptable in a permissioned
    network where chances of malicious actors are almost none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these mechanisms, the **Simple Byzantine Fault Tolerance** (**SBFT**)
    based mechanism is also under development, which will become available in the
    later releases of Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed ledger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain and world state are two main elements of the distributed ledger.
    Blockchain is simply a cryptographically linked list of blocks (as introduced
    in [Chapter 1](76e4e401-30ba-44f9-832f-333ba6c12cbc.xhtml), *Blockchain 101*)
    and world state is a key-value database. This database is used by smart contracts
    to store relevant states during execution by the transactions. The blockchain
    consists of blocks that contain transactions. These transactions contain chaincode,
    which runs transactions that can result in updating the world state. Each node
    saves the world state on disk in LevelDB or CouchDB depending on the implementation.
    As Fabric allows pluggable data store, you can choose any data store for storage.
  prefs: []
  type: TYPE_NORMAL
- en: A block consists of three main components called Block header, Transactions
    (Data) and block metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical block in the Hyperledger Fabric 1.0 with
    the relevant fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ed05257-7915-4eeb-a12f-b59d391c7754.png)'
  prefs: []
  type: TYPE_IMG
- en: Block structure
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Header** consists of three fields, namely Number, Previous hash, and
    Data hash.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction** is made up of multiple fields such as transaction type, version,
    timestamp, channel ID, transaction ID, epoch, payload visibility, chaincode path,
    chaincode name, chaincode version, creator identity, signature, chaincode type,
    input, timeout, endorser identities and signatures, proposal hash, chaincode events,
    response status, namespace, read set, write set, start key, end key, list of read,
    and Merkle tree query summary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Metadata** consists of creator identity, relevant signatures, last
    configuration block number, flag for each transaction included in the block, and
    last offset persisted (kafka).'
  prefs: []
  type: TYPE_NORMAL
- en: The peer to peer protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The P2P protocol in the Hyperledger Fabric is built using **google RPC** (**gRPC**).
    It uses protocol buffers to define the structure of the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages are passed between nodes in order to perform various functions. There
    are four main types of messages in Hyperledger Fabric: **discovery**, **transaction**,
    **synchronization**, and **consensus**. Discovery messages are exchanged between
    nodes when starting up in order to discover other peers on the network. Transaction
    messages are used to deploy, invoke, and query transactions, and consensus messages
    are exchanged during consensus. Synchronization messages are passed between nodes
    to synchronize and keep the blockchain updated on all nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Ledger storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to save the state of the ledger, by default, LevelDB is used which
    is available at each peer. An alternative is to use CouchDB which provides the
    ability to run rich queries.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These services allow the creation of secure containers that are used to execute
    the chaincode. Components in this category are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c79da003-2239-46db-bf53-6a9084d272b2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Secure container**: Chaincode is deployed in Docker containers that provide
    a locked down sandboxed environment for smart contract execution. Currently, Golang
    is supported as the main smart contract language, but any other mainstream languages
    can be added and enabled if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure registry:** This provides a record of all images containing smart
    contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**'
  prefs: []
  type: TYPE_NORMAL
- en: Events on the blockchain can be triggered by endorsers and smart contracts.
    External applications can listen to these events and react to them if required
    via event adapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**APIs and CLIs**'
  prefs: []
  type: TYPE_NORMAL
- en: An application programming interface provides an interface into the fabric by
    exposing various REST APIs. Additionally, command-line interfaces that provide
    a subset of REST APIs and allow for quick testing and limited interaction with
    the blockchain are also available.
  prefs: []
  type: TYPE_NORMAL
- en: Components of the fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various components that can be part of the Hyperledger Fabric blockchain.
    These components include but are not limited to the ledger, chaincode, consensus
    mechanism, access control, events, system monitoring and management, wallets,
    and system integration components.
  prefs: []
  type: TYPE_NORMAL
- en: Peers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Peers participate in maintaining the state of the distributed ledger. They
    also hold a local copy of the distributed ledger. Peers communicate via gossip
    protocol. There are three types of peers in the Hyperledger Fabric network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endorsing peers** or endorsers which simulate the transaction execution and
    generate a read-write set. Read is a simulation of transaction''s reading of data
    from the ledger and write is the set of updates that would be made to the ledger
    if and when the transaction is executed and committed to the ledger. Endorses
    execute and endorse transactions. It should be noted that an endorser is also
    a committer too. Endorsement policies are implemented with chaincode and specify
    the rules for transaction endorsement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Committing peers** or committers which receives transaction endorsed by endorsers,
    verify them and then update the ledger with the read-write set. A committer verifies
    the read-write set generated by the endorsers along with transaction validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Submitters** is the third type of peers which has not been implemented yet.
    It is on the development roadmap and will be implemented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orderer nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordering nodes receive transactions from endorsers along with read-write sets,
    arrange them in a sequence, and send those to committing peers. Committing peers
    then perform validation and committing to the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: All peers make use of certificates issued by membership services.
  prefs: []
  type: TYPE_NORMAL
- en: Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clients are software that makes use of APIs to interact with the Hyperledger
    Fabric and propose transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channels allow the flow of confidential transactions between different parties
    on the network. They allow using the same blockchain network but with separate
    blockchains. Channels allow only members of the channel to view the transaction
    related to them, all other members of the network will not be able to view the
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: World state database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: World state reflects all committed transaction on the blockchain. This is basically
    a key-value store which is updated as a result of transactions and chaincode execution.
    For this purpose, either LevelDB or CouchDB is used. LevelDB is a key-value store
    whereas CouchDB stores data as JSON objects which allows rich queries to run against
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transaction messages can be divided into two types: **deployment transactions**
    and **invocation transactions**. The former is used to deploy new chaincode to
    the ledger, and the latter is used to call functions from the smart contract.
    Transactions can be either public or confidential. Public transactions are open
    and available to all participants whilst confidential transactions are visible
    only in a channel open to its participants.'
  prefs: []
  type: TYPE_NORMAL
- en: Membership Service Provider (MSP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSP is a modular component that is used to manage identities on the blockchain
    network. This provider is used to authenticate clients who want to join the blockchain
    network. We have discussed certificate authority is some detail earlier in this
    chapter. CA is used in MSP to provide identity verification and binding service.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed smart contracts in good detail in [Chapter 4](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml),
    *Smart Contracts*. In Hyperledger Fabric same concept of smart contracts is implemented
    but they are called chain code instead of smart contracts. They contain conditions
    and parameters to execute transactions and update the ledger. Chaincode is usually
    written in Golang and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto service provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests this is a service that provides cryptographic algorithms
    and standards for usage in the blockchain network. This service provides key management,
    signature and verification operations, and encryption-decryption mechanisms. This
    service is used with the membership service to provide support for cryptographic
    operations for elements of blockchain such as endorsers, clients, and other nodes
    and peers.
  prefs: []
  type: TYPE_NORMAL
- en: After this introduction to this component of Hyperledger Fabric, in the next
    section, we will see what an application looks like when on a Hyperledger network.
  prefs: []
  type: TYPE_NORMAL
- en: Applications on blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical application on Fabric is simply composed of a user interface, usually
    written in JavaScript/HTML, that interacts with the backend chaincode (smart contract)
    stored on the ledger via an API layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ff6419-cbdc-45f7-b5bc-2afcbbd63f75.png)'
  prefs: []
  type: TYPE_IMG
- en: A typical Fabric application
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger provides various APIs and command-line interfaces to enable interaction
    with the ledger. These APIs include interfaces for identity, transactions, chaincode,
    ledger, network, storage, and events.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chaincode is usually written in Golang or Java. Chaincode can be public (visible
    to all on the network), confidential, or access controlled. These code files serve
    as a smart contract that users can interact with via APIs. Users can call functions
    in the chaincode that result in a state change, and consequently updates the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: There are also functions that are only used to query the ledger and do not result
    in any state change. Chaincode implementation is performed by first creating the
    chaincode shim interface in the code. Shim provides APIs for accessing state variables
    and transaction context of chain code. It can either be in Java or Golang code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four functions are required in order to implement the chaincode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Init()`: This function is invoked when chaincode is deployed onto the ledger.
    This initializes the chaincode and results in making a state change, which accordingly
    updates the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke()`: This function is used when contracts are executed. It takes a function
    name as parameters along with an array of arguments. This function results in
    a state change and writes to the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query()`: This function is used to query the current state of a deployed chaincode.
    This function does not make any changes to the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4()`**:** This function is executed when a peer deploys its own copy of the
    chaincode. The chaincode is registered with the peer using this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following diagram illustrates the general overview of Hyperledger Fabric,
    note that peers cluster at the top includes all types of nodes such as endorsers,
    committers, Orderers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/502f40d5-83b4-4493-a8e9-6ce824b44ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: A high-level overview of Hyperledger Fabric
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows that peers shown at the top middle communicate with
    each and each node has a copy of blockchain. On the top-right corner, the membership
    services are shown which validate and authenticate peers on the network by using
    a **certificate authority** (**CA**). At the bottom of the image, a magnified
    view of blockchain is shown where by existing systems can produce events for the
    blockchain and also can listen for the blockchain events, which then can optionally
    trigger an action. At the bottom right-hand side, a user's interaction is shown
    with the application which talks to the smart contract via the `invoice()` method,
    and smart contracts can query or update the state of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The application model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any blockchain application for Hyperledger Fabric follows the MVC-B architecture.
    This is based on the popular MVC design pattern. Components in this model are
    Model, View, Control, and Blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View logic**: This is concerned with the user interface. It can be a desktop,
    web application, or mobile frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control logic**: This is the orchestrator between the user interface, data
    model, and APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data model**: This model is used to manage the off-chain data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blockchain logic**: This is used to manage the blockchain via the controller
    and the data model via transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IBM cloud service offers sample applications for blockchain under its blockchain
    as a service offering. It is available at [https://www.ibm.com/blockchain/platform/](https://www.ibm.com/blockchain/platform/). [This
    service allows users to create their own blockchain networks in an easy-to-use
    environment.](https://www.ibm.com/blockchain/platform/)
  prefs: []
  type: TYPE_NORMAL
- en: Consensus in Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The consensus mechanism in Hyperledger Fabric consists of three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction endorsement**: This process endorses the transactions by simulating
    the transaction execution process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ordering**: This is a service provided by the cluster of orderers which takes
    endorsed transactions and decide on a sequence in which the transactions will
    be written to the ledger.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Validation and commitment**: This process is executed by committing peers
    which first validates the transactions received from the orderers and then commit
    that transaction to the ledger.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are shown in the following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfa08f66-dc5e-49c1-9b55-dc7baa2bfded.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The consensus flow
  prefs: []
  type: TYPE_NORMAL
- en: The transaction life cycle in Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several steps that are involved in a transaction flow in Hyperledger
    Fabric. These steps are shown in the following diagram below
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick summary of the process can be visualized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7a1a70d-b05d-4c42-be94-bf099a30baa9.png)'
  prefs: []
  type: TYPE_IMG
- en: The transaction life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are described below in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction proposal by clients. This is the first step where a transaction
    is proposed by the clients and sent to endorsing peers on the distributed ledger
    network. All clients need to be enrolled via membership services before they can
    propose transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction is simulated by endorsers which generates a read-write (RW)
    set. This is achieved by executing the chaincode but instead of updating the ledger,
    only a read-write set depicting any reads or updates to the ledger is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The endorsed transaction is sent back to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submission of endorsed transactions and read-write (RW) sets to the ordering
    service by the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ordering service assembles all endorsed transactions and read-write sets
    in order into a block, and sorts them by channel ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ordering service broadcasts the assembled block to all committing peers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Committing peers validate the transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Committing peers update the ledger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, notification of success or failure of the transaction by committing
    peers is sent back to the clients/applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram represents the above-mentioned steps and Fabric architecture
    from transaction flow point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f80ff2d9-b1b3-4b43-b7f6-343fff8ef019.png)'
  prefs: []
  type: TYPE_IMG
- en: The transaction flow architecture
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding diagram, the first step is to propose transactions
    which a client does via an SDK. Before this, it is assumed that all clients and
    peers are registered with the Membership service provider.
  prefs: []
  type: TYPE_NORMAL
- en: With this topic, our introduction to Hyperledger Fabric is complete. In the
    next section, we will see another Hyperledger project named Sawtooth Lake.
  prefs: []
  type: TYPE_NORMAL
- en: Sawtooth Lake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sawtooth Lake can run in both permissioned and non-permissioned modes. It is
    a distributed ledger that proposes two novel concepts: the first is the introduction
    of a new consensus algorithm called **Proof of Elapsed Time** (**PoET**); and
    the second is the idea of **transaction families**.'
  prefs: []
  type: TYPE_NORMAL
- en: A description of these novel proposals is given in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: PoET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PoET is a novel consensus algorithm that allows a node to be selected randomly
    based on the time that the node has waited before proposing a block. This concept
    is in contrast to other leader election and lottery-based proof of work algorithms,
    such as the PoW used in Bitcoin where an enormous amount of electricity and computer
    resources are used in order be elected as a block proposer; for example in the
    case of Bitcoin. PoET is a type of Proof of Work algorithm but, instead of spending
    computer resources, it uses a trusted computing model to provide a mechanism to
    fulfill the Proof of Work requirements. PoET makes use of Intel's SGX architecture
    (Software Guard Extensions) to provide a trusted execution environment (TEE) to
    ensure randomness and cryptographic security of the process.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the current implementation of Sawtooth Lake does not
    require real hardware SGX-based TEE, as it is simulated for experimental purposes
    only and as such should not be used in production environments. The fundamental
    idea in PoET is to provide a mechanism of leader election by waiting randomly
    to be elected as a leader for proposing new transactions.
  prefs: []
  type: TYPE_NORMAL
- en: PoET, however, has a limitation which has been highlighted by Ittay Eyal. This
    limitation is called the *stale chips* problem.
  prefs: []
  type: TYPE_NORMAL
- en: The research paper is available at [https://eprint.iacr.org/2017/179.pdf](https://eprint.iacr.org/2017/179.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: This limitation results in hardware wastage, which can result in the waste of
    resources. There is also a possibility of hacking the chip's hardware, which could
    result in system compromise and undue incentivizing to miners.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction families
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A traditional smart contract paradigm provides a solution that is based on a
    general-purpose instruction set for all domains. For example, in the case of Ethereum,
    a set of opcodes has been developed for the EVM that can be used to build smart
    contracts to address any type of requirements for any industry.
  prefs: []
  type: TYPE_NORMAL
- en: While this model has its merits, it is becoming clear that this approach is
    not very secure as it provides a single interface into the ledger with a powerful
    and expressive language, which potentially offers a larger attack surface for
    malicious code. This complexity and generic virtual machine paradigm have resulted
    in several vulnerabilities that were found and exploited recently by hackers.
    A recent example is the **DAO hack** and further **Denial of Services** (**DoS**)
    attacks that exploited limitations in some EVM opcodes. The DAO hack was discussed
    in [Chapter 4](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml), *Smart Contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model shown in the following figure describes the traditional smart contract
    model, where a generic virtual machine has been used to provide the interface
    into the blockchain for all domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c614fdef-8123-4aaa-b00f-f8ca2254016d.png)'
  prefs: []
  type: TYPE_IMG
- en: The traditional smart contract paradigm
  prefs: []
  type: TYPE_NORMAL
- en: In order to address this issue, Sawtooth Lake has proposed the idea of transaction
    families. A transaction family is created by decomposing the logic layer into
    a set of rules and a composition layer for a specific domain. The key idea is
    that business logic is composed within transaction families, which provides a
    more secure and powerful way to build smart contracts. Transaction families contain
    the domain-specific rules and another layer that allows for creating transactions
    for that domain. Another way of looking at it is that transaction families are
    a combination of a data model and a transaction language that implements a logic
    layer for a specific domain. The data model represents the current state of the
    blockchain (ledger) whereas the transaction language modifies the state of the
    ledger. It is expected that users will build their own transaction families according
    to their business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents this model, where each specific domain, like
    financial services, **digital rights management** (**DRM**), supply chain, and
    the health industry, has its own logic layer comprised of operations and services
    specific to that domain. This makes the logic layer both restrictive and powerful
    at the same time. Transaction families ensure that operations related to only
    the required domain are present in the control logic, thus removing the possibility
    of executing needless, arbitrary and potentially harmful operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb76e9a8-6986-409e-bab8-130c6b81292e.png)'
  prefs: []
  type: TYPE_IMG
- en: The Sawtooth (transaction families) smart contract paradigm
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel has provided three transaction families with Sawtooth: Endpoint registry,
    Integerkey, and MarketPlace.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endpoint registry** is used for registering ledger services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integerkey** is used for testing deployed ledgers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MarketPlace** is used for selling, buying, and trading operations and services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sawtooth_bond** has been developed as a proof of concept to demonstrate a
    bond trading platform.'
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [https://github.com/hyperledger/sawtooth-core/tree/master/extensions/bond](https://github.com/hyperledger/sawtooth-core/tree/master/extensions/bond).
  prefs: []
  type: TYPE_NORMAL
- en: Consensus in Sawtooth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sawtooth has two types of consensus mechanisms based on the choice of network.
    PoET, as discussed previously, is a trusted executed environment-based lottery
    function that elects a leader randomly based on the time a node has waited for
    block proposal.
  prefs: []
  type: TYPE_NORMAL
- en: There is another consensus type called **quorum voting**, which is an adaptation
    of consensus protocols built by Ripple and Stellar. This consensus algorithm allows
    instant transaction finality, which is usually desirable in permissioned networks.
  prefs: []
  type: TYPE_NORMAL
- en: The development environment – Sawtooth Lake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, a quick introduction is given on how to set up a development
    environment for Sawtooth Lake. There are a few prerequisites that are required
    in order to set up the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples in this section assume a running Ubuntu system and the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant, at least version 1.9.0, available at [h](https://www.vagrantup.com/downloads.html)[t](https://www.vagrantup.com/downloads.html)[t](https://www.vagrantup.com/downloads.html)[p](https://www.vagrantup.com/downloads.html)[s](https://www.vagrantup.com/downloads.html)[://w](https://www.vagrantup.com/downloads.html)[w](https://www.vagrantup.com/downloads.html)[w](https://www.vagrantup.com/downloads.html)[.](https://www.vagrantup.com/downloads.html)[v](https://www.vagrantup.com/downloads.html)[a](https://www.vagrantup.com/downloads.html)[g](https://www.vagrantup.com/downloads.html)[r](https://www.vagrantup.com/downloads.html)[a](https://www.vagrantup.com/downloads.html)[n](https://www.vagrantup.com/downloads.html)[t](https://www.vagrantup.com/downloads.html)[u](https://www.vagrantup.com/downloads.html)[p](https://www.vagrantup.com/downloads.html)[.](https://www.vagrantup.com/downloads.html)[c](https://www.vagrantup.com/downloads.html)[o](https://www.vagrantup.com/downloads.html)[m](https://www.vagrantup.com/downloads.html)[/d](https://www.vagrantup.com/downloads.html)[o](https://www.vagrantup.com/downloads.html)[w](https://www.vagrantup.com/downloads.html)[n](https://www.vagrantup.com/downloads.html)[l](https://www.vagrantup.com/downloads.html)[o](https://www.vagrantup.com/downloads.html)[a](https://www.vagrantup.com/downloads.html)[d](https://www.vagrantup.com/downloads.html)[s](https://www.vagrantup.com/downloads.html)[.](https://www.vagrantup.com/downloads.html)[h](https://www.vagrantup.com/downloads.html)[t](https://www.vagrantup.com/downloads.html)[m](https://www.vagrantup.com/downloads.html)[l](https://www.vagrantup.com/downloads.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox, at least 5.0.10 r104061, available at [h](https://www.virtualbox.org/wiki/Downloads)[t](https://www.virtualbox.org/wiki/Downloads)[t](https://www.virtualbox.org/wiki/Downloads)[p](https://www.virtualbox.org/wiki/Downloads)[s](https://www.virtualbox.org/wiki/Downloads)[://w](https://www.virtualbox.org/wiki/Downloads)[w](https://www.virtualbox.org/wiki/Downloads)[w](https://www.virtualbox.org/wiki/Downloads)[.](https://www.virtualbox.org/wiki/Downloads)[v](https://www.virtualbox.org/wiki/Downloads)[i](https://www.virtualbox.org/wiki/Downloads)[r](https://www.virtualbox.org/wiki/Downloads)[t](https://www.virtualbox.org/wiki/Downloads)[u](https://www.virtualbox.org/wiki/Downloads)[a](https://www.virtualbox.org/wiki/Downloads)[l](https://www.virtualbox.org/wiki/Downloads)[b](https://www.virtualbox.org/wiki/Downloads)[o](https://www.virtualbox.org/wiki/Downloads)[x](https://www.virtualbox.org/wiki/Downloads)[.](https://www.virtualbox.org/wiki/Downloads)[o](https://www.virtualbox.org/wiki/Downloads)[r](https://www.virtualbox.org/wiki/Downloads)[g](https://www.virtualbox.org/wiki/Downloads)[/w](https://www.virtualbox.org/wiki/Downloads)[i](https://www.virtualbox.org/wiki/Downloads)[k](https://www.virtualbox.org/wiki/Downloads)[i](https://www.virtualbox.org/wiki/Downloads)[/D](https://www.virtualbox.org/wiki/Downloads)[o](https://www.virtualbox.org/wiki/Downloads)[w](https://www.virtualbox.org/wiki/Downloads)[n](https://www.virtualbox.org/wiki/Downloads)[l](https://www.virtualbox.org/wiki/Downloads)[o](https://www.virtualbox.org/wiki/Downloads)[a](https://www.virtualbox.org/wiki/Downloads)[d](https://www.virtualbox.org/wiki/Downloads)[s](https://www.virtualbox.org/wiki/Downloads).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once both of the prerequisites are downloaded and installed successfully, the
    next step is to clone the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb1a4de1-d855-4de1-b39b-728903ad3b85.png)'
  prefs: []
  type: TYPE_IMG
- en: The GitHub Sawtooth clone
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Sawtooth is cloned correctly, the next step is to start up the environment.
    First, run the following command to change the directory to the correct location
    and then start the vagrant box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fb96efa-699f-440f-9055-33c1bdf94f13.png)'
  prefs: []
  type: TYPE_IMG
- en: The vagrant up command
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any point vagrant needs to be stopped, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`halt` will stop the vagrant machine, whereas `destroy` will stop and delete
    vagrant machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the transaction validator can be started by using the following commands.
    First `ssh` into the vagrant Sawtooth box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the vagrant prompt is available, run the following commands. First build
    the Sawtooth Lake core using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the build has completed successfully, in order to run the transaction
    validator, issue the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the genesis block and clear any existing data files and keys.
    This command should show an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f31597d8-25d6-4cb1-b05b-059068c01e53.png)'
  prefs: []
  type: TYPE_IMG
- en: Genesis block and keys generation
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run the transaction validator, and change the directory
    as shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the transaction validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b106baee-8113-49d6-ad85-e93067ebfb16.png)'
  prefs: []
  type: TYPE_IMG
- en: Running transaction validator
  prefs: []
  type: TYPE_NORMAL
- en: The validator node can be stopped by pressing *Ctrl* + *C*. Once the validator
    is up and running, various clients can be started up in another terminal window
    to communicate with the transaction validator and submit transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following screenshot, the market client is started up to
    communicate with the transaction validator. Note that keys under `/keys/mkt.wif` are
    created by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b597d1bc-3ec0-44f0-b0ff-faaef110b370.png)'
  prefs: []
  type: TYPE_IMG
- en: mktclient for marketplace transaction family
  prefs: []
  type: TYPE_NORMAL
- en: This completes our basic introduction to Sawtooth. The example shown above is
    also quite basic but demonstrates that how Sawtooth Lake works.
  prefs: []
  type: TYPE_NORMAL
- en: Sawtooth Lake is also under continuous development and therefore, it is recommended
    that readers keep an eye on documentation available at [http://intelledger.github.io/](http://intelledger.github.io/)
    to keep up with the latest developments.
  prefs: []
  type: TYPE_NORMAL
- en: There is an excellent online page where official Sawtooth lake examples are
    provided. The page is available at [https://sawtooth.hyperledger.org/examples/](https://sawtooth.hyperledger.org/examples/). Readers
    are encouraged to visit this page and explore these sample projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now in the next section we will see an introduction to Corda. It should be noted
    that Corda is not yet an official project under Hyperledger; however, it may become
    a member very soon. Therefore, for now, this is being discussed under Hyperledger,
    but in the future, it may not become part of Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: Corda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Corda is not a blockchain by definition because it does not contain blocks of
    bundled transactions, but it falls under the category of distributed ledgers.
    It provides all benefits that a blockchain can. Traditional blockchain solutions,
    as discussed before, have the concept of transactions that are bundled together
    in a block and each block is linked back cryptographically to its parent block,
    which provides an immutable record of transactions. This is not the case with
    Corda.
  prefs: []
  type: TYPE_NORMAL
- en: Corda has been designed entirely from scratch with a new model for providing
    all blockchain benefits, but without a traditional blockchain. It has been developed
    purely for the financial industry to solve issues arising from the fact that each
    organization manages their own ledgers and thus have their own view of *truth*,
    which leads to contradictions and operational risk. Moreover, data is also duplicated
    at each organization, which results in an increased cost of managing individual
    infrastructures and complexity. These are the types of problems within the financial
    industry that Corda aims to resolve by building a decentralized database platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Corda source code is available at [https://github.com/corda/corda](https://github.com/corda/corda).
    It is written in a language called Kotlin, which is a statically typed language
    targeting the **Java Virtual Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main components of the Corda platform include state objects, contract code,
    legal prose, transactions, consensus, and flows. We will now explore them in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: State objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State objects represent the smallest unit of data that represent a financial
    agreement. They are created or deleted as a result of a transaction execution.
    They refer to **contract code** and **legal prose.** Legal prose is optional and
    provides legal binding to the contract. However, contract code is mandatory in
    order to manage the state of the object. It is required in order to provide a
    state transition mechanism for the node according to the business logic defined
    in the contract code. State objects contain a data structure that represents the
    current state of the object. A state object can be either current (live) or historic
    (no longer valid).
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following diagram, a state object represents the current
    state of the object. In this case, it is a simple mock agreement between **Party
    A** and **Party B** where **Party ABC** has paid **Party XYZ 1,000 GBP**. This
    represents the current state of the object; however, the referred contract code
    can change the state via transactions. State objects can be thought of as a state
    machine, which are consumed by transactions in order to create updated state objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaa1bff2-31ef-4612-ab6c-e58cab09a902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example state object
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transactions are used to perform transitions between different states. For example,
    the state object shown in the preceding diagram is created as a result of a transaction.
    Corda uses a Bitcoin-style UTXO-based model for its transaction processing. The
    concept of state transition by transactions is same as in Bitcoin. Similar to
    Bitcoin, transactions can have none, single, or multiple inputs, and single or
    multiple outputs. All transactions are digitally signed.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Corda has no concept of mining because it does not use blocks to arrange
    transactions in a blockchain. Instead, notary services are used in order to provide
    temporal ordering of transactions. In Corda, new transaction types can be developed
    using JVM bytecode, which makes it very flexible and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The consensus model in Corda is quite simple and is based on notary services
    that are discussed in a later section of this chapter. The general idea is that
    the transactions are evaluated for their uniqueness by the notary service and,
    if they are unique (that is, unique transaction inputs), they are signed by consensus
    services as valid. There can be single or multiple clustered notary services running
    on a Corda network. Various consensus algorithms like PBFT or Raft can be used
    by notaries to reach consensus.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts regarding consensus in Corda: **consensus over
    state validity** and **consensus over state uniqueness**. The first concept is
    concerned with the validation of the transaction, ensuring that all required signatures
    are available and states are appropriate. The second concept is a means to detect
    double-spend attacks and ensures that a transaction has not already been spent
    and is unique.'
  prefs: []
  type: TYPE_NORMAL
- en: Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flows in Corda are a novel idea that allows the development of decentralized
    workflows. All communication on the Corda network is handled by these flows. These
    are transaction-building protocols that can be used to define any financial flow
    of any complexity using code. Flows run as an asynchronous state machine and they
    interact with other nodes and users. During the execution, they can be suspended
    or resumed as required.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Corda network has multiple components. All these components are described
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nodes in a Corda network operated under a trust-less model and run by different
    organizations. Nodes run as part of an authenticated peer-to-peer network. Nodes
    communicate directly with each other using the **Advanced Message Queuing Protocol**
    (**AMQP**), which is an approved international standard (ISO/IEC 19464) and ensures
    that messages across different nodes are transferred safely and securely. AMQP
    works over **Transport Layer Security** (**TLS**) in Corda, thus ensuring privacy
    and integrity of data communicated between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nodes also make use of a local relational database for storage. Messages on
    the network are encoded in a compact binary format. They are delivered and managed
    by using the **Apache Artemis message broker** (**Active MQ**). A node can serve
    as a network map service, notary, Oracle, or a regular node. The following diagram
    shows a high-level view of two nodes communicating with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6804328-cfc4-4a35-9786-39cb4d49847b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two nodes communicating in a Corda network
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, **Node 1** is communicating with **Node 2** over a
    TLS communication channel using the AMQP protocol, and the nodes have a local
    relational database for storage.
  prefs: []
  type: TYPE_NORMAL
- en: The permissioning service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A permissioning service is used to provision TLS certificates for security.
    In order to participate in the network, participants are required to have a signed
    identity issued by a root certificate authority. Identities are required to be
    unique on the network and the permissioning service is used to sign these identities.
    The naming convention used to recognize participants is based on the X.500 standard.
    This ensures the uniqueness of the name.
  prefs: []
  type: TYPE_NORMAL
- en: Network map service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This service is used to provide a network map in the form of a document of all
    nodes on the network. This service publishes IP addresses, identity certificates,
    and a list of services offered by nodes. All nodes announce their presence by
    registering to this service when they first startup, and when a connection request
    is received by a node, the presence of the requesting node is checked on the network
    map first. Put another way, this service resolves the identities of the participants
    to physical nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Notary service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional blockchain, mining is used to ascertain the order of blocks
    that contain transactions. In Corda, notary services are used to provide transaction
    ordering and timestamping services. There can be multiple notaries in a network
    and they are identified by composite public keys. Notaries can use different consensus
    algorithms like BFT or Raft depending on the requirements of the applications.
    Notary services sign the transactions to indicate validity and finality of the
    transaction which is then persisted to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Notaries can be run in a load-balanced configuration in order to spread the
    load across the nodes for performance reasons; and, in order to reduce latency,
    the nodes are recommended to be run physically closer to the transaction participants.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle services either sign a transaction containing a fact, if it is true,
    or can themselves provide factual data. They allow real-world feed into the distributed
    ledgers. Oracles were discussed in [Chapter 4](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml),
    *Smart Contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transactions in a Corda network are never transmitted globally but in a semi-private
    network. They are shared only between a subset of participants who are related
    to the transaction. This is in contrast to traditional blockchain solutions like
    Ethereum and Bitcoin, where all transactions are broadcasted to the entire network
    globally. Transactions are digitally signed and either consume state(s) or create
    new state(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Transactions on a Corda network are composed of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input references**: This is a reference to the states the transaction is
    going to consume and use as an input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output states**: These are new states created by the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attachments**: This is a list of hashes of attached ZIP files. ZIP files
    can contain code and other relevant documentation related to the transaction.
    Files themselves are not made part of the transaction, instead, they are transferred
    and stored separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commands**: A command represents the information about the intended operation
    of the transaction as a parameter to the contract. Each command has a list of
    public keys, which represents all parties that are required to sign a transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signatures**: This represents the signature required by the transaction.
    The total number of signatures required is directly proportional to the number
    of public keys for commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: There are two types of transactions namely, normal or notary changing.
    Notary changing transactions are used for reassigning a notary for a state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: This field represents a bracket of time during which the transaction
    has taken place. These are verified and enforced by notary services. Also, it
    is expected that if strict timings are required, which is desirable in many financial
    services scenarios, notaries should be synced with an atomic clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summaries:** This is a text description that describes the operations of
    the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vaults run on a node and are akin to the concept of wallets in bitcoin. As the
    transactions are not globally broadcasted, each node will have only that part
    of data in their vaults that is considered relevant to them. Vaults store their
    data in a standard relational database and as such can be queried by using standard
    SQL. Vaults can contain both on ledger and off ledger data, meaning that it can
    also have some part of data that is not on ledger.
  prefs: []
  type: TYPE_NORMAL
- en: CorDapp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core model of Corda consists of state objects, transactions, and transaction
    protocols, which when combined with contract code, APIs, wallet plugins, and user
    interface components results in constructing a **Corda distributed application**
    (**CorDapp**).
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts in Corda are written using Kotlin or Java. The code is targeted
    for JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'JVM has been modified slightly in order to achieve deterministic results of
    execution of JVM bytecode. There are three main components in a Corda smart contract
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Executable code that defines the validation logic to validate changes to the
    state objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State objects represent the current state of a contract and either can be consumed
    by a transaction or produced (created) by a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands are used to describe the operational and verification data that defines
    how a transaction can be verified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development environment – Corda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development environment for Corda can be set up easily using the following
    steps. Required software includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 8 (8u131), which is available at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA Community edition, which is free and available at [https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download)[.](https://www.jetbrains.com/idea/download)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H2 database platform independent ZIP, and is available at [http://www.h2database.com/html/download.html](http://www.h2database.com/html/download.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git, which is available at [https://git-scm.com/downloads](https://git-scm.com/downloads).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin language, which is available for IntelliJ, and more information can be
    found at [https://kotlinlang.org/](https://kotlinlang.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle is another component that is used to build Corda. It is available at
    [https://gradle.org](https://gradle.org).
  prefs: []
  type: TYPE_NORMAL
- en: Once all these tools are installed, smart contract development can be started.
    CorDapps can be developed by utilizing an example template available at [https://github.com/corda/cordapp-template](https://github.com/corda/cordapp-template).
  prefs: []
  type: TYPE_NORMAL
- en: Detailed documentation on how to develop contract code is available at [https://docs.corda.net/](https://docs.corda.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Corda can be cloned locally from GitHub using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the cloning is successful, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the repository is cloned, it can be opened in IntelliJ for further development.
    There are multiple samples available in the repository, such as a bank of Corda,
    interest rate swaps, demo, and traders demo. Readers can find them under the `/samples`
    directory under `corda` and they can be explored using IntelliJ IDEA IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through an introduction to the Hyperledger project.
    Firstly, the core ideas behind the Hyperledger project were discussed, and a brief
    introduction to all projects under Hyperledger was provided. Three main Hyperledger
    projects were discussed in detail, namely Hyperledger Fabric, Sawtooth lake, and
    Corda. All these projects are continuously improving and changes are expected
    in the next releases. However, the core concepts of all the projects mentioned
    above are expected to remain unchanged or change only slightly. Readers are encouraged
    to visit the relevant links provided within the chapter to see the latest updates.
  prefs: []
  type: TYPE_NORMAL
- en: It is evident that a lot is going on in this space and projects like Hyperledger
    from the Linux Foundation are playing a pivotal role in the advancement of blockchain
    technology. Each of the projects discussed in this chapter has novel approaches
    towards solving the issues faced in various industries, and any current limitations
    within the blockchain technology are also being addressed, such as scalability
    and privacy. It is expected that more projects will soon be proposed to the Hyperledger
    project, and it is envisaged that with this collaborative and open effort blockchain
    technology will advance tremendously and will benefit the community as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, alternative blockchain solutions and platforms will be
    introduced. As blockchain technology is growing very fast and has attracted lot
    of research interest there are many new projects that have emerged recently. We
    will discuss those projects in the next chapter.
  prefs: []
  type: TYPE_NORMAL
