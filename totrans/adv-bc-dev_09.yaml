- en: Building a Wallet Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wallet service is used to send and receive funds. Major challenges for building
    a wallet service are security and trust. Users must feel that their funds are
    secure and the administrator of the wallet service doesn't steal their funds.
    The wallet service we will build in this chapter will tackle both these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Difference between online and offline wallets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using hooked-web3-provider and ethereumjs-tx to make it easier to create and
    sign transactions using accounts not managed by an Ethereum node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what a HD wallet is and also its uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HD wallet and a transaction signer using `lightwallet.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a wallet service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference between online and offline wallets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wallet is a collection of accounts, and an account is a combination of an
    address and its associated private key.
  prefs: []
  type: TYPE_NORMAL
- en: A wallet is said to be an online wallet when it is connected to the Internet.
    For example, wallets stored in geth, any website/database, and so on are called
    online wallets. Online wallets are also called hot wallets, web wallets, hosted
    wallets, and so on. Online wallets are not recommended at least when storing large
    amounts of ether or storing ether for a long time because they are risky. Also,
    depending on where the wallet is stored, it may require trusting a third party.
  prefs: []
  type: TYPE_NORMAL
- en: For example, most of the popular wallet services store the private keys of the
    wallets with themselves and allow you to access the wallet via an e-mail and password,
    so basically, you don't have actual access to the wallet, and if they want, they
    can steal the funds in the wallets.
  prefs: []
  type: TYPE_NORMAL
- en: A wallet is said to be an offline wallet when it is not connected to the Internet.
    For example, wallets stored in pen drives, papers, text files, and so on. Offline
    wallets are also called cold wallets. Offline wallets are more secure than online
    wallets because to steal funds, someone will need physical access to the storage.
    The challenges with offline storage is that you need to find a location that you
    won't delete accidentally or forget, or nobody else can have access to. Many people
    store the wallet in paper and keep the paper in a safe locker if they want to
    hold some funds safely for a very long time. If you want to frequently send funds
    from your account, then you can store it in a password-protected pen drive and
    also in a safe locker. It is a little risker to store wallets in a digital device
    only because digital devices can corrupt anytime and you may lose access to your
    wallet; that's why along with storing in a pen drive, you should also put it in
    a safe locker. You can also find a better solution depending on your needs, but
    just make sure it's safe and that you accidentally don't lose access to it.
  prefs: []
  type: TYPE_NORMAL
- en: hooked-web3-provider and ethereumjs-tx libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all the examples of Web3.js library's `sendTransaction()` method
    we saw were using the `from` address that's present in the Ethereum node; therefore,
    the Ethereum node was able to sign the transactions before broadcasting. But if
    you have the private key of a wallet stored somewhere else, then geth cannot find
    it. Therefore, in this case, you will need to use the `web3.eth.sendRawTransaction()`
    method to broadcast transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '`web3.eth.sendRawTransaction()` is used to broadcast raw transactions, that
    is, you will have to write code to create and sign raw transactions. The Ethereum
    node will directly broadcast it without doing anything else to the transaction.
    But writing code to broadcast transactions using `web3.eth.sendRawTransaction()`
    is difficult because it requires generating the data part, creating raw transactions,
    and also signing the transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: The Hooked-Web3-Provider library provides us with a custom provider, which communicates
    with geth using HTTP; but the uniqueness of this provider is that it lets us sign
    the `sendTransaction()` calls of contract instances using our keys. Therefore,
    we don't need to create data part of the transactions anymore. The custom provider
    actually overrides the implementation of the `web3.eth.sendTransaction()` method.
    So basically, it lets us sign both the `sendTransaction()` calls of contract instances
    and also the `web3.eth.sendTransaction()` calls. The `sendTransaction()` method
    of contract instances internally generate data of the transaction and calls `web3.eth.sendTransaction()`
    to broadcast the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: EthereumJS is a collection of those libraries related to Ethereum. ethereumjs-tx
    is one of those that provide various APIs related to transactions. For example,
    it lets us create raw transactions, sign the raw transactions, check whether transactions
    are signed using proper keys or not, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these libraries are available for Node.js and client-side JavaScript.
    Download the Hooked-Web3-Provider from [https://www.npmjs.com/package/hooked-web3-provider](https://www.npmjs.com/package/hooked-web3-provider),
    and download ethereumjs-tx from [https://www.npmjs.com/package/ethereumjs-tx](https://www.npmjs.com/package/ethereumjs-tx).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the latest version of Hooked-Web3-Provider
    is 1.0.0 and the latest version of ethereumjs-tx is 1.1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use these libraries together to send a transaction from an
    account that's not managed by geth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we created a `HookedWeb3Provider` instance. This is provided by the
    Hooked-Web3-Provider library. This constructor takes an object that has two properties,
    which must be provided. `host` is the HTTP URL of the node and `transaction_signer`
    is an object that the custom provider communicates with to get the transaction
    signed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `transaction_signer` object has two properties: `hasAddress` and `signTransaction`.
    `hasAddress` is invoked to check whether the transaction can be signed, that is,
    to check whether the transaction signer has the private key of the `from` address
    account. This method receives the address and a callback. The callback should
    be called with the first argument as an error message and the second argument
    as `false` if the private key of the address is not found. And if the private
    key is found, the first argument should be `null`, and the second argument should
    be `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the private key for the address is found, then the custom provider invokes
    the `signTransaction` method to get the transaction signed. This method has two
    parameters, that is, the transactions parameters and a callback. Inside the method,
    at first, we convert the transaction parameters to raw transaction parameters,
    that is, the raw transaction parameters values are encoded as hexadecimal strings.
    Then we create a buffer to hold the private key. The buffer is created using the
    `EthJS.Util.toBuffer()` method, which is part of the `ethereumjs-util` library.
    The `ethereumjs-util` library is imported by the `ethereumjs-tx` library. We then
    create a raw transaction and sign it, after which we serialize and convert it
    to hexadecimal strings. Finally, we need to provide the hexadecimal string of
    the signed raw transaction to the custom provider using the callback. In case
    there is an error inside the method, then the first argument of the callback should
    be an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the custom provider takes the raw transactions and broadcasts it using `web3.eth.sendRawTransaction()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `web3.eth.sendTransaction` function to send some ether
    to another account. Here, we need to provide all the transaction parameters except
    `nonce` because the custom provider can calculate nonce. Earlier, many of these
    were optional because we were leaving it to the Ethereum node to calculate them,
    but now as we are signing it ourselves, we need to provide all of them. The `gas`
    is always 21,000 when the transaction doesn't have any data associated with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What about the public key?**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, nowhere did we mention anything about the public key
    of the signing address. You must be wondering how a miner will verify the authenticity
    of a transaction without the public key. Miners use a unique property of ECDSA,
    which allows you to calculate the public key from the message and signature. In
    a transaction, the message indicates the intention of the transaction, and the
    signature is used to find whether the message is signed using the correct private
    key. This is what makes ECDSA so special. ethereumjs-tx provides an API to verify
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: What is a hierarchical deterministic wallet?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hierarchical deterministic wallet is a system of deriving addresses and keys
    from a single starting point called a seed. Deterministic indicates that for the
    same seed, the same addresses and keys will be generated, and hierarchical indicates
    that the addresses and keys will be generated in the same order. This makes it
    easier to back up and store multiple accounts, as you just have to store the seed,
    not the individual keys and addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why will users need multiple accounts?**'
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering why users will need multiple accounts. The reason is to
    hide their wealth. The balance of accounts is available publicly in the blockchain.
    So, if user A shares an address with user B to receive some ether, then user B
    can check how much ether is present in that address. Therefore, users usually
    distribute their wealth across various accounts.
  prefs: []
  type: TYPE_NORMAL
- en: There are various types of HD wallets, which differ in terms of seed format
    and the algorithm to generate addresses and keys, for instance, BIP32, Armory,
    Coinkite, Coinb.in, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are BIP32, BIP44, and BIP39?**'
  prefs: []
  type: TYPE_NORMAL
- en: A **Bitcoin Improvement Proposal** (**BIP**) is a design document providing
    information to the Bitcoin community, or describing a new feature for Bitcoin
    or its processes or environment. The BIP should provide a concise technical specification
    of the feature and a rationale for the feature. At the time of writing this book,
    there are 152 BIPS (Bitcoin Improvement Proposals). BIP32 and BIP39 provide information
    about an algorithm to implement an HD wallet and mnemonic seed specification respectively.
    You can learn more about these at [https://github.com/bitcoin/bips](https://github.com/bitcoin/bips).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to key derivation functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymmetric cryptography algorithms define the nature of their keys and how the
    keys should be generated because the keys need to be related. For example, the
    RSA key generation algorithm is deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptography algorithms only define key sizes. It's up to us to generate
    the keys. There are various algorithms to generate these keys. One such algorithm
    is KDF.
  prefs: []
  type: TYPE_NORMAL
- en: A **key derivation function** (**KDF**) is a deterministic algorithm to derive
    a symmetric key from some secret value (such as master key, password, or passphrase).
    There are various types of KDFs, such as bcrypt, crypt, PBKDF2, scrypt, HKDF,
    and so on. You can learn more about KDFs at [https://en.wikipedia.org/wiki/Key_derivation_function](https://en.wikipedia.org/wiki/Key_derivation_function).
  prefs: []
  type: TYPE_NORMAL
- en: To generate multiple keys from a single secret value, you can concatenate a
    number and increment it.
  prefs: []
  type: TYPE_NORMAL
- en: A password-based key derivation function takes a password and generates a symmetric
    key. Due to the fact that users usually use weak passwords, password-based key
    derivation functions are designed to be slower and take a lot of memory to make
    it difficult to launch brute force attacks and other kinds of attacks. Password-based
    key derivation functions are used widely because it's difficult to remember secret
    keys, and storing them somewhere is risky as it can be stolen. PBKDF2 is an example
    of a password-based key derivation function.
  prefs: []
  type: TYPE_NORMAL
- en: A master key or passphrase is difficult to be cracked using a brute force attack;
    therefore, in case you want to generate a symmetric key from a master key or passphrase,
    you can use a non-password-based key derivation function, such as HKDF. HKDF is
    much faster compared to PBKDF2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why not just use a hash function instead of KDFs?**'
  prefs: []
  type: TYPE_NORMAL
- en: The output of hash functions can be used as symmetric keys. So you must be wondering
    what is the need for KDFs. Well, if you are using a master key, passphrase, or
    a strong password, you can simply use a hash function. For example, HKDF simply
    uses a hash function to generate the key. But if you cannot guarantee that users
    will use a strong password, it's better to use a password derived hash function.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to LightWallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LightWallet is an HD wallet that implements BIP32, BIP39, and BIP44\. LightWallet
    provides APIs to create and sign transactions or encrypt and decrypt data using
    the addresses and keys generated using it.
  prefs: []
  type: TYPE_NORMAL
- en: LightWallet API is divided into four namespaces, that is, `keystore`, `signing`,
    `encryption`, and `txutils`. `signing`, `encrpytion,` and `txutils` provide APIs
    to sign transactions, asymmetric cryptography, and create transactions respectively,
    whereas a `keystore` namespace is used to create a `keystore`, generated seed,
    and so on. `keystore` is an object that holds the seed and keys encrypted. The
    `keystore` namespace implements transaction signer methods that requires signing
    the `we3.eth.sendTransaction()` calls if we are using Hooked-Web3-Provider. Therefore
    the `keystore` namespace can automatically create and sign transactions for the
    addresses that it can find in it. Actually, LightWallet is primarily intended
    to be a signing provider for the Hooked-Web3-Provider.
  prefs: []
  type: TYPE_NORMAL
- en: A `keystore` instance can be configured to either create and sign transactions
    or encrypt and decrypt data. For signing transactions, it uses the `secp256k1`
    parameter, and for encryption and decryption, it uses the `curve25519` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The seed of LightWallet is a 12-word mnemonic, which is easy to remember yet
    difficult to hack. It cannot be any 12 words; instead, it should be a seed generated
    by LightWallet. A seed generated by LightWallet has certain properties in terms
    of selection of words and other things.
  prefs: []
  type: TYPE_NORMAL
- en: HD derivation path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HD derivation path is a string that makes it easy to handle multiple crypto
    currencies (assuming they all use the same signature algorithms), multiple blockchains,
    multiple accounts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: HD derivation path can have as many parameters as needed, and using different
    values for the parameters, we can produce different group of addresses and their
    associated keys.
  prefs: []
  type: TYPE_NORMAL
- en: By default, LightWallet uses the `m/0'/0'/0'` derivation path. Here, `/n'` is
    a parameter, and `n` is the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: Every HD derivation path has a `curve`, and `purpose`. `purpose` can be either
    `sign` or `asymEncrypt`. `sign` indicates that the path is used for signing transactions,
    and `asymEncrypt` indicates that the path is used for encryption and decryption.
    `curve` indicates the parameters of ECC. For signing, the parameter must be `secp256k1`,
    and for asymmetric encryption, the curve must be `curve25591` because LightWallet
    forces us to use these paramters due to their benefits in those purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a wallet service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have learned enough theory about LightWallet, it's time to build a wallet
    service using LightWallet and hooked-web3-provider. Our wallet service will let
    users generate a unique seed, display addresses and their associated balance,
    and finally, the service will let users send ether to other accounts. All the
    operations will be done on the client side so that users can trust us easily.
    Users will either have to remember the seed or store it somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start building the wallet service, make sure that you are running
    the geth development instance, which is mining, has the HTTP-RPC server enabled,
    allows client-side requests from any domain, and finally has account 0 unlocked.
    You can do all these by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `--rpccorsdomain` is used to allow certain domains to communicate with
    geth. We need to provide a list of domains space separated, such as `"http://localhost:8080
    https://mySite.com *"`. It also supports the `*` wildcard character. `--rpcaddr`
    indicates to which IP address the geth server is reachable. The default for this
    is `127.0.0.1`, so if it's a hosted server, you won't be able to reach it using
    the public IP address of the server. Therefore, we changed it's value to `0.0.0.0`,
    which indicates that the server can be reached using any IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the exercise files of this chapter, you will find two directories, that is,
    `Final` and `Initial. Final` contains the final source code of the project, whereas
    `Initial` contains the empty source code files and libraries to get started with
    building the application quickly.
  prefs: []
  type: TYPE_NORMAL
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and then run the app using the `node app.js` command inside the `Final` directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. `package.json` contains the backend dependencies.
    Our app, `app.js`, is where you will place the backend source code.
  prefs: []
  type: TYPE_NORMAL
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the bootstrap library. Inside `public/html`,
    you will find `index.html`, where you will place the HTML code of our app, and
    finally, in the `public/js` directory, you will find `.js` files for Hooked-Web3-Provider,
    web3js, and LightWallet. Inside `public/js`, you will also find a `main.js` file
    where you will place the frontend JS code of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first build the backend of the app. First of all, run `npm install` inside
    the initial directory to install the required dependencies for our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete backend code to run an express service and serve the `index.html`
    file and static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Building the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's build the frontend of the app. The frontend will consists of the major
    functionalities, that is, generating seed, displaying addresses of a seed, and
    sending ether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the HTML code of the app. Place this code in the `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we enqueue a Bootstrap 4 stylesheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we display an information box, where we will display various messages to
    the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And then we have a form with an input box and two buttons. The input box is
    used to enter the seed, or while generating new seed, the seed is displayed there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Generate Details button is used to display addresses and Generate New Seed
    is used to generate a new unique seed. When Generate Details is clicked, we call
    the `generate_addresses()` method, and when the Generate New Seed button is clicked,
    we call the `generate_seed()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, we have an empty ordered list. Here, we will dynamically display the
    addresses, their balances, and associated private keys of a seed when a user clicks
    on the Generate Details button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have another form that takes a from address and a to address and
    the amount of ether to transfer. The from address must be one of the addresses
    that's currently displayed in the unordered list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s write the implementation of each of the functions that the HTML
    code calls. At first, let''s write the code to generate a new seed. Place this
    code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `generateRandomSeed()` method of the `keystore` namespace is used to generate
    a random seed. It takes an optional parameter, which is a string that indicates
    the extra entropy.
  prefs: []
  type: TYPE_NORMAL
- en: Entropy is the randomness collected by an application for use in some algorithm
    or somewhere else that requires random data. Usually, entropy is collected from
    hardware sources, either pre-existing ones such as mouse movements or specially
    provided randomness generators.
  prefs: []
  type: TYPE_NORMAL
- en: To produce a unique seed, we need really high entropy. LightWallet is already
    built with methods to produce unique seeds. The algorithm LightWallet uses to
    produce entropy depends on the environment. But if you feel you can generate better
    entropy, you can pass the generated entropy to the `generateRandomSeed()` method,
    and it will get concatenated with the entropy generated by `generateRandomSeed()`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: After generating a random seed, we call the `generate_addresses` method. This
    method takes a seed and displays addresses in it. Before generating addresses,
    it prompts the user to ask how many addresses they want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `generate_addresses()` method. Place this
    code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we have a variable named `totalAddresses`, which holds a number indicating
    the total number of addresses the user wants to generate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we check whether the `seed` parameter is defined or not. If it's undefined,
    we fetch the seed from the input field. We are doing this so that the `generate_addressess()`
    method can be used to display the information seed while generating a new seed
    and also if the user clicks on the Generate Details button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we validate the seed using the `isSeedValid()` method of the `keystore`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then ask for the user's input regarding how many addresses they want to generate
    and display. And then we validate the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The private keys in the `keystore` namespace are always stored encrypted. While
    generating keys, we need to encrypt them, and while signing transactions, we need
    to decrypt the keys. The password for deriving a symmetric encryption key can
    be taken as input from the user or by supplying a random string as a password.
    For better user experience, we generate a random string and use it as the password.
    The symmetric key is not stored inside the `keystore` namespace; therefore, we
    need to generate the key from the password whenever we do operations related to
    the private key, such as generating keys, accessing keys, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we use the `createVault` method to create a `keystore` instance. `createVault`
    takes an object and a callback. The object can have four properties: `password`,
    `seedPharse`, `salt`, and `hdPathString`. `password` is compulsory, and everything
    else is optional. If we don''t provide a `seedPharse`, it will generate and use
    a random seed. `salt` is concatenated to the password to increase the security
    of the symmetric key as the attacker has to also find the salt along with the
    password. If the salt is not provided, it''s randomly generated. The `keystore`
    namespace holds the salt unencrypted. `hdPathString` is used to provide the default
    derivation path for the `keystore` namespace, that is, while generating addresses,
    signing transactions, and so on. If we don''t provide a derivation path, then
    this derivation path is used. If we don''t provide `hdPathString`, then the default
    value is `m/0''/0''/0''`. The default purpose of this derivation path is `sign`.
    You can create new derivation paths or overwrite the purpose of derivation paths
    present using the `addHdDerivationPath()` method of a `keystore` instance. You
    can also change the default derivation path using the `setDefaultHdDerivationPath()`
    method of a `keystore` instance. Finally, once the `keystore` namespace is created,
    the instance is returned via the callback. So here, we created a `keystore` using
    a password and seed only.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to generate the number of addresses and their associated keys the
    user needs. As we can generate millions of addresses from a seed, `keystore` doesn't
    generate any address until we want it to because it doesn't know how many addresses
    we want to generate. After creating the `keystore`, we generate the symmetric
    key from the password using the `keyFromPassword` method. And then we call the
    `generateNewAddress()` method to generate addresses and their associated keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`generateNewAddress()` takes three arguments: password derived key, number
    of addresses to generate, and derivation path. As we haven''t provided a derivation
    path, it uses the default derivation path of the keystore. If you call `generateNewAddress()`
    multiple times, it resumes from the address it created in the last call. For example,
    if you call this method twice, each time generating two addresses, you will have
    the first four addresses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we use `getAddresses()` to get all the addresses stored in the `keystore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We decrypt and retrieve private keys of the addresses using the `exportPrivateKey`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `web3.eth.getBalance()` to get balances of the address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we display all the information inside the unordered list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we know how to generate the address and their private keys from a seed.
    Now let's write the implementation of the `send_ether()` method, which is used
    to send ether from one of the addresses generated from the seed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this. Place this code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code up and until generating addresses from the seed is self explanatory.
    After that, we assign a callback to the `passwordProvider` property of `ks`. This
    callback is invoked during transaction signing to get the password to decrypt
    the private key. If we don't provide this, LightWallet prompts the user to enter
    the password. And then, we create a `HookedWeb3Provider` instance by passing the
    `keystore` as the transaction signer. Now when the custom provider wants a transaction
    to be signed, it calls the `hasAddress` and `signTransactions` methods of `ks`.
    If the address to be signed is not among the generated addresses, `ks` will give
    an error to the custom provider. And finally, we send some ether using the `web3.eth.sendTransaction`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have finished building our wallet service, let''s test it to make
    sure it works as expected. First, run `node app.js` inside the initial directory,
    and then visit `http://localhost:8080` in your favorite browser. You will see
    this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbe83a3a-20d0-4452-b520-3563938f0469.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Generate New Seed button to generate a new seed. You will
    be prompted to enter a number indicating the number of addresses to generate.
    You can provide any number, but for testing purposes, provide a number greater
    than 1\. Now the screen will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a45c767-bf9c-44ef-99ba-0ecc2b32ffa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now to test sending ether, you need to send some ether to one of the generated
    addresses from the coinbase account. Once you have sent some ether to one of the
    generated addresses, click on the Generate Details button to refresh the UI, although
    it''s not necessary to test sending ether using the wallet service. Make sure
    the same address is generated again. Now the screen will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb3e5fc0-247f-4fe3-bef1-4b322347fa8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now in the from address field, enter the account address from the list that
    has the balance in the `from` address field. Then enter another address in the
    to address field. For testing purposes, you can enter any of the other addresses
    displayed. Then enter some ether amount that is less than or equal to the ether
    balance of the from address account. Now your screen will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/901b84cc-07a1-4344-9970-f69722910b56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Send Ether button, and you will see the transaction hash in
    the information box. Wait for sometime for it to get mined. Meanwhile, you can
    check whether the transactions got mined or not by clicking on the Generate Details
    button in a very short span of time. Once the transaction is mined, your screen
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5bce142-96b6-4d3d-ac31-d0141ccc1fd0.png)'
  prefs: []
  type: TYPE_IMG
- en: If everything goes the same way as explained, your wallet service is ready.
    You can actually deploy this service to a custom domain and make it available
    for use publicly. It's completely secure, and users will trust it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about three important Ethereum libraries: Hooked-Web3-Provider,
    ethereumjs-tx, and LightWallet. These libraries can be used to manage accounts
    and sign transactions outside of the Ethereum node. While developing clients for
    most kinds of DApps, you will find these libraries useful.'
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we created a wallet service that lets users manage their accounts
    that share private keys or any other information related to their wallet with
    the backend of the service..
  prefs: []
  type: TYPE_NORMAL
