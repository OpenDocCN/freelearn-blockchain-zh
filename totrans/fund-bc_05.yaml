- en: Cryptocurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the original and best implementation of blockchain
    technologyâ€”cryptocurrency. Cryptocurrency is much more than just a blockchain
    application; it makes use of cryptographic primitives such as digital signatures
    to achieve asset management by using atomic events called transactions. Throughout
    this chapter, we will be familiarized with all the concepts required to understand
    how cryptocurrency is different from any of the traditional digital currencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Bitcoin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys and addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining and consensus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation of a simple cryptocurrency application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin was the first successful cryptocurrency to be deployed in a decentralized
    network. It is the best-known cryptocurrency to date due to its resilient software
    and infrastructure, widespread adoption in various fields, and high market capitalization.
    By the end of 2017, Bitcoin had achieved a market cap of 300 billion USD, which
    is the highest by any cryptocurrency to date. Most of the cryptocurrencies in
    the market are inspired by and use similar designs to Bitcoin. We will be using
    Bitcoin to learn about most of the relevant concepts in cryptocurrency, and later
    on in this chapter, we will also implement a cryptocurrency similar to Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: A cryptocurrency is a digital asset that uses cryptography to secure, spend,
    and verify its value in the transactions. The cryptocurrency could be transferred
    from the owner to any recipient without the need for an intermediary to settle
    the transactions. Although the early adoption of cryptocurrency provided a number
    of features, such as pseudo anonymity, lower transaction fees, and removing the
    need for an intermediary, it never achieved true decentralization. There were
    known issues, such as double-spending. This was when a single asset was transferred
    to multiple recipients because there was no centralized source to verify these
    transactions. All of these issues were addressed when a completely decentralized
    cryptocurrency called Bitcoin was created in 2009\. This solved the double-spend
    issue for the first time in a decentralized network by using immutable blockchain
    to achieve consensus among the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin is a collection of cryptography and decentralized consensus algorithms
    that enabled the creation of a complete decentralized digital currency ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin can be used just like conventional currencies. It can be used to buy
    and sell goods and services or to just transfer money to people. Bitcoin has several
    advantages over conventional currencies, such as lower transaction costs and the
    ability to transfer currency to any part of the world, because it is not controlled
    by any national authorities. Bitcoin is also entirely virtual, meaning there is
    no physical form of the currency. The value of Bitcoin is generated by transactions
    in Bitcoin. Anyone can transfer Bitcoin to a particular Bitcoin address using
    a transaction. The address of the legitimate recipient of the Bitcoin will be
    identified by a secret key corresponding to the address. The user can then transfer
    the Bitcoin to others by constructing a new transaction using the secret key.
    Generally, a Bitcoin address is created using the public key, and the secret key
    is the private key counterpart of the public key. The keys are generally stored
    in a software application called a wallet, but they can also be backed up and
    stored anywhere if we need better security.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, Bitcoin is the system that paved the way for the invention of blockchain.
    It utilizes all the concepts we have discussed so far to build a cryptocurrency
    that functions in a completely decentralized **peer-to-peer** (**P2P**) system.
    Because of Bitcoin's completely decentralized network, there is no need for a
    central trusted authority, such as a bank, to act as a moderator and validate
    the transactions. Instead, everyone in the Bitcoin ecosystem participates in ensuring
    that valid transactions take place.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin software is open source, and anyone can join the Bitcoin network by
    running this software on a device such as a smartphone or a computer. A lighter
    version of the Bitcoin software can be used on devices where the computing and
    storage capacity is limited. There is a special type of node called a miner, which
    uses processing power to verify transactions and contributes to the creation of
    blocks by solving a hard-cryptographic puzzle. This is a hash puzzle, more specifically
    called the Proof of Work consensus algorithm, which was discussed in [Chapter
    3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml), *Cryptography in Blockchain*.
    Every 10 minutes, a miner can publish a valid block, which is then propagated
    and validated by everyone on the Bitcoin network. The miner is rewarded in bitcoin
    for the computing power spent creating the block. Due to an increase in competition
    in mining, the difficulty of the puzzle has been adjusted so that the average
    block creation time remains around 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: So, every time the miner creates a new block, new bitcoins are minted, which
    circulate in the Bitcoin network. There is a limit set on the total number of
    bitcoins that can circulate in the network, and it is hard-capped to 21 million
    coins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, the following innovations helped Bitcoin to survive in a completely
    trustless network:'
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized P2P network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blockchain (public ledger)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized consensus algorithm (Proof of Work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction validation rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will try to explain how Bitcoin uses these concepts,
    which made its creation possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Bitcoin Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin is an experimental digital currency that is maintained by an open source
    community. Bitcoin Core is the name of open source software that enables the use
    of this currency. It's the original implementation of the Bitcoin system and whose
    initial release was created by Satoshi Nakamoto.
  prefs: []
  type: TYPE_NORMAL
- en: Open source software is software whose source code is made available to the
    public with the right to read, modify, and redistribute it. Although open source
    code can be covered by different licenses, most of it is free to use for any purpose.
    Bitcoin is licensed under the MIT license.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Bitcoin full node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Bitcoin full node can be set up for development purposes, or just to enable
    a user to be a part of the Bitcoin network in order to validate or explore the
    transactions. The user has to set up all the tools, libraries, and dependent applications
    they may need if they want to set up a complete development environment, whereas
    a Bitcoin node can be set up without much effort just by installing the software.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Bitcoin full node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, installing a Bitcoin full node is much simpler than setting up
    a development environment. Bitcoin full nodes are ideal for users who want to
    be a part of the Bitcoin network but don't want to worry about any of its implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Bitcoin full node has certain hardware requirements. It needs dedicated
    storage because it has to store all the blocks of the public ledger. At the time
    of writing, Bitcoin blockchain blocks occupy around 180 GB of storage. A Bitcoin
    full node also needs a decent amount of memory and processing power in order to
    validate the transactions of every block. Bitcoin can be installed on Linux, macOS,
    and Windows platforms quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be providing details about the installation here because it varies
    from platform to platform. You can find installation details for different platforms
    in the GitHub repository of the book ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain)).
    Moreover, you can find the installation instructions for all the platforms at
    [https://bitcoin.org/en/full-node](https://bitcoin.org/en/full-node).
  prefs: []
  type: TYPE_NORMAL
- en: Compiling from source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Bitcoin development environment is set up by compiling the source code obtained
    from the Bitcoin repository. The source code of Bitcoin Core is hosted in a GitHub
    repository under the MIT license. You can either clone and fetch all the branches
    or download the ZIP file of a specific release.
  prefs: []
  type: TYPE_NORMAL
- en: You can clone the Bitcoin Core project from the [https://github.com/bitcoin/bitcoin.git](https://github.com/bitcoin/bitcoin.git)
    repository using the Git tool. Once the project has been cloned, you can either
    use the latest master code or checkout to any of the release using the Git tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process might take up to an hour depending on the system''s hardware
    configuration. Compiling the source code involves only a few steps, but they are
    time-consuming:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, Bitcoin Core needs you to run a script called `autogen.sh`,
    which creates a set of automatic configuration scripts that examine the system
    and ensure that your system has all the libraries to compile the code. The shell
    script is executed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to use the configure script to customize the build process
    by enabling or disabling certain features. We can build Bitcoin Core with the
    default features because most of Bitcoin Core''s features are required to set
    up a node. The configuration script is executed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the source code is compiled to create executables and install the
    created executables. This is achieved using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The installation of will create a binary called `bitcoind`, which creates the
    Bitcoin daemon process, and a command-line tool called `bitcoin-cli`, which is
    used to invoke Bitcoin APIs to communicate with the local Bitcoin node.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Bitcoin node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Bitcoin daemon process is created when `bitcoind` is executed by creating
    a configuration file. The basic configuration file consists of a username and
    password for the JSON-RPC interface. There are several options that can be specified
    while running to Bitcoin node to alter its behavior. These options can also be
    specified in the configuration file. Execute `bitcoind --help` to list out the
    available options.Â `bitcoind` can be executed after the configuration file is
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will start Bitcoin Core as a background process. It may take several minutes
    to load the block index and verify the blocks. The `bitcoin-cli` tool can then
    be used to check the status once the `bitcoind` process has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows some basic information about Bitcoin Core as well
    as some local blockchain information. The API was invoked on a `mainnet` chain
    that had mined 519,993 blocks at the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Bitcoin has several blockchain networks formed by the bitcoin nodes. Each of
    these networks maintains different blockchain. Bitcoin's main network is called
    `mainnet` and it has a test network called `testnet`. More information on this
    topic is covered in the *Blockchain and networks* section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Bitcoin node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin Core provides an API through the JSON-RPC interface to facilitate communication
    with the Bitcoin node. Most of the consensus, wallet, and P2P Bitcoin operations
    can be performed on the node using this interface. Bitcoin uses `8332` as the
    default JSON-RPC server port for mainnet. Users should make sure not to allow
    arbitrary machines to access the JSON-RPC port. Exposing this interface would
    allow external machines to access private information, which could lead to theft.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin has a command-line interface tool,Â `bitcoin-cli`, that can be used to
    access all the JSON-RPC APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any transaction details can be fetched using the `getrawtransaction` RPC command
    by specifying the transaction ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a serialized transaction in hexadecimal format. This data can
    then be decoded using the `decoderawtransaction` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This generates a decoded transaction in a human-readable JSON format. We will
    discuss the decoded transactions in the *Transactions* section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating using scripting language through the JSON-RPC implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any programming language''s JSON-RPC implementation can be used to communicate
    with a Bitcoin node. Let''s execute an API using the Python JSON-RPC implementation,
    which will automatically generate all the Python methods for RPC calls. Python
    has several libraries with support for JSON-RPC, but we will be using `python-bitcoinlib`,
    which not only provides a JSON-RPC implementation but can also interface with
    Bitcoin data structures and protocols. The following Python script accepts a transaction
    ID in hexadecimal format and converts it into raw bytes using the `lx()` function.
    An RPC object, `proxy_connection`, which can be used to invoke any API, is created.
    The `gettransaction` API will fetch the decoded transaction of the transaction
    ID that was provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Keys and addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered all the concepts of cryptography that will be required in order
    to understand the keys, addresses, and wallets used in cryptocurrency. In this
    section, we will get a thorough grounding of how keys and addresses are used to
    control the ownership of funds through cryptographic primitives.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how asymmetric cryptography is used to create public/private
    keys, which identify the user accounts in the blockchain network. Bitcoin generates
    public/private key pairs that identify users and help them to claim ownership
    of funds through digital signatures. The private key is also called the secret
    key in cryptocurrency because it is kept secret from the public. Digital signatures
    are a prevalent concept in cryptography that allows the owner of the secret key
    to create a signature for a transaction and allow anyone to verify a transaction.
    Secret key owners manage all their keys using lightweight software called a wallet.
    Keys are independent of the blockchain protocol and are created and managed by
    the wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitcoin uses addresses to identify the Bitcoin user. These addresses are the
    encoded version of the public key derived from the user''s secret key.Â Let''s
    consider a banking example: Alice transfers the money to Bob by signing a check
    addressed to Bob. Bitcoin uses a similar approach by signing a transaction using
    the secret key and providing the recipient''s account number, which is the Bitcoin
    public address. The only public information is the account number, which is similar
    in concept to making the Bitcoin address public.'
  prefs: []
  type: TYPE_NORMAL
- en: Public and private keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public and private keys are generated using asymmetric cryptography. Private
    keys are kept secret in the users' wallets, whereas public keys are made public
    in the form of a Bitcoin address. Bitcoin uses elliptic curve cryptography to
    generate the public/private key pair. The private key is selected at random, and
    elliptic curve multiplication is performed to generate the public key. Elliptic
    curve multiplication is a one-way cryptographic function that makes it impossible
    to derive the private key from the exposed public key. You can explore the mathematical
    explanation and analysis of elliptical curve cryptography in [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin's private key is a randomly selected 256-bit character string or 64-character
    hexadecimal string. This means that the private key can be any number between
    1 and 2^(256). So, it is impossible to find the corresponding private key of the
    public key just by brute-forcing 2^(256) combinations. The randomly generated
    private key is isolated from the Bitcoin network and maintained secretly in the
    Bitcoin wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitcoin''s command-line interface can be used to generate secret keys. Bitcoin
    has a set of APIs that deal with keys and addresses. The following commands are
    performed on the local wallet. `dumprivkey` fetches the already existing private
    key, which was generated from the public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Bitcoin public addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public addresses in Bitcoin are produced from public keys, which consist of
    digits beginning with 1, or 3 for mainnet. Most Bitcoin addresses are 33 or 34
    characters long and use Base58-encoding. Bitcoin public key addresses always represent
    the owner of the secret key and are used in the recipient field of transactions.
    However, addresses can also have different uses, such as representing the payment
    script used in **Pay-to-Script-Hash** (**P2SH**) transactions, which will be covered
    in the *Transaction* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitcoin addresses are derived from the public key by constructing an encoded
    string called Base58Check. Base58Check is a Base58 encoded string along with fixed
    characters that acts as error-checking code. The Base58Check encoded string that
    represents Bitcoin address has three parts â€“ a prefixed version byte, a payload
    derived from the public key, and the checksum. The version byte represents the
    type of Bitcoin address. *Table 5.1* shows a variety of prefixes found in the
    Bitcoin addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prefix (Base58)** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Bitcoin pubkey hash (P2PKH address) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Bitcoin script hash (P2SH address) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Private key (WIF) |'
  prefs: []
  type: TYPE_TB
- en: '| m or n | Bitcoin testnet pubkey hash |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Bitcoin testnet script hash |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Prefixes used as version bytes (Source: https://en.bitcoin.it)'
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the Bitcoin public address is derived from the public key
    by hashing it using the `SHA256` and `RIPEMD160` hashing algorithms. As we already
    know, hashing functions are one-way functions, which makes it infeasible to derive
    the public key from the computed Bitcoin address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following function, `K` is the public key derived from the private key,
    and `H` is the Bitcoin public key hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After constructing the hash value `H` using the hash functions, the third part
    of the address, a checksum, is computed from the resultant value. Finally, all
    the three parts are concatenated and encoded using Base58 encoding, which uses
    58 characters (please refer to [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, for more details regarding Base58 encoding) to create
    the Bitcoin public address in the Base58Check format as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7fd2ac7-7d86-41a2-b3fd-865be49b4c0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Generation of a Bitcoin public address from the public key'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.1* shows how a 64-byte public key along with the 1-byte version is
    hashed initially to produce a 20-byte digest. This is the payload, which is then
    encoded to generate the Bitcoin address. But the final address also consists of
    checksum bits, which are used to protect against errors. This 4-byte checksum
    is calculated by hashing the payload twice using the SHA256 hash function and
    extracting the initial 4 bytes from the resulting 32-byte digest.'
  prefs: []
  type: TYPE_NORMAL
- en: This checksum is concatenated with the payload and version byte. Finally, the
    resulting string is encoded using the Base58 encoding system to generate the Bitcoin
    address, which will identify the user who is holding the corresponding secret
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, it is impossible for anyone to generate the private key from the
    publicly available Bitcoin address. This is due to the functions used to derive
    the public key. A public key is created using elliptical curve multiplication,
    which is a one-way function. Similarly, a Bitcoin address is derived from the
    public key by applying hash functions, which are one-way functions by nature.
    This prevents anyone from generating the public key from the Bitcoin public address
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/333b075f-3293-45fb-af32-acb80bab0a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The one-way functionality of Bitcoin address generation'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.2* depicts the one-way functions used in the generation of the Bitcoin
    address. Although the Bitcoin address, which represents the identity of the entity
    holding the private key, is known to the public, the private key cannot be retrieved
    due to the one-way nature of these functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already covered many of the concepts used in Bitcoin that aid in the
    creation of a cryptocurrency in a decentralized network. Although every concept
    has a significant role in Bitcoin, transactions play a central role. Everything
    else in Bitcoin is designed to ensure that valid transactions are safely included
    in the blockchain and are propagated to the entire network of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional bookkeeping, in which an account-based ledger is used, Bitcoin
    maintains a transaction-based ledger. Every transaction entered into Bitcoin has
    to be validated before it is included in the blockchain. Bitcoin nodes refer to
    the transactions
  prefs: []
  type: TYPE_NORMAL
- en: included in the other blocks or transaction mempool to validate every transaction.
    In this section, we will dig deep into concepts such as transaction creation,
    verification, and the components of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction mempool is a collection of unconfirmed transactions maintained
    by each Bitcoin node. The transactions in the mempool will be eventually included
    in the blockchain. A real-time view of the Bitcoin mempool can be observed at
    [https://www.blockchain.com/btc/unconfirmed-transactions](https://www.blockchain.com/btc/unconfirmed-transactions).
  prefs: []
  type: TYPE_NORMAL
- en: Transactions at a high level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the low-level details of transactions and their components,
    let''s look at an example that illustrates a simple Bitcoin transaction from the
    user''s point of view. Let''s say Alice sends 0.1 bitcoin from her Bitcoin wallet
    to Bob''s wallet. Since she already has more than 0.1 bitcoin in her wallet, a
    valid transaction will be created and propagated to the network. *Figure 5.3*
    shows the transaction details in a block explorer application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb013ee2-902f-41c5-a4dd-5831c4567fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Bitcoin transaction from Alice to Bob'
  prefs: []
  type: TYPE_NORMAL
- en: All the transaction details shown in this section are created using Bitcoin's
    `testnet` blockchain. You can check the transaction details by switching the Bitcoin
    node to the testnet blockchain. The block explorer application also runs in the
    testnet blockchain. You can verify the transactions at [https://testnet.blockexplorer.com](https://testnet.blockexplorer.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Transactions are visible to everyone who has access to the blockchain. A hex
    editor must be used to read transactions because they are not stored in a human-readable
    form. Bitcoin Core''s command-line interface can read raw transactions and decode
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `getrawtransaction` API is used to retrieve the encoded transaction. It
    can be decoded using `decoderawtransaction`. These commands can be invoked using
    Bitcoin's command-line interface or using any RPC client.
  prefs: []
  type: TYPE_NORMAL
- en: The readable version of the raw transaction has many fields and can be overwhelming
    at first glance. We will cover some of the components of the transaction in the
    following section, in order to make sense of the raw transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transactions are primarily constructed with input and output. Each transaction
    can have multiple inputs and outputs. Unlike account-based bookkeeping, Bitcoin
    needs to keep track of the output of every transaction. A node needs to have all
    the transaction output information in order to know the spendable balance of an
    account. The output can later be referenced in a transaction's input whenever
    a user wants to spend their cryptocurrency. This output consists of indivisible
    chunks of currency and can only be broken down after they are consumed in a transaction.
    The output that is not referenced in any of the transaction's input is referred
    to as **unspent transaction output** or **UTXO**.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user wants to spend the UTXO, it has to be spent entirely. After
    spending a UTXO, any excess is returned as one more UTXO to the user. This is
    similar to real-world currency, where coins cannot be broken down into lower values,
    and change is received for the excess amount paid. Let's consider our previous
    example, where Alice sends 0.1 bitcoin to Bob. As we can see in *Figure 5.3*,
    Alice doesn't have a UTXO of value 0.1\. So, Alice spends a transaction output
    of 0.325, which is greater than 0.1\. After sending 0.1 bitcoin to Bob, the rest
    of the amount is sent back to Alice, creating a new UTXO. As we can see from the
    transaction, Alice gets back slightly less than 0.225 bitcoin to her account.
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the transaction fees levied when inserting the transaction into
    the blockchain. This fee will be given to the miner for performing Proof of Work.
    This transaction created two output values, 0.1 and ~0.225\. These two output
    values have to be consumed in their entirety by other input.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous section, every transaction creates output that
    can be consumed later by a transaction input. Each full node client keeps track
    of all the UTXO so that each transaction input can be easily verified by checking
    the UTXO pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s investigate the output of the earlier transaction between Alice and
    Bob. Transaction outputs are referenced with the `vout` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `vout` is one of the outputs of the transaction. Each output has
    two major components, **value** and **cryptographic condition**, which explain
    who owns the transaction. In the preceding transaction, the output value indicates
    the bitcoin amount transferred to Bob, and `scriptPubKey` is the cryptographic
    condition (or the locking script), which ensures that the output amount can only
    be spent by Bob. `scriptPubKey` has several fields containing a locking script
    in serialized (`hex`) and deserialized (`asm`) format. It also provides some additional
    information, such as required signatures (`reqSigs`), type, and the public addresses
    of the recipient. Although the transaction output has several fields, only the
    locking script is of interest for a transaction, and other fields can be derived
    from it. Most of the locking script is a simple representation of the user's public
    address. We will look into locking scripts later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transaction input references UTXOs whenever a user wishes to make a Bitcoin
    transaction. The transaction input uses an unlocking script to claim the UTXO.
    A valid transaction input proves the ownership of the UTXO with the help of this
    unlocking script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A transaction input can have multiple inputs pointing to multiple UTXOs. The
    transaction input makes sure that there are enough UTXOs to enable the transaction
    to take place. In the earlier example, the transaction input had a single input
    pointing to a UTXO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A single UTXO was sufficient to fulfill the transaction. *Figure 5.3* shows
    that this single UTXO had a value of 0.325, which was enough to send a value of
    0.1 to Bob. The transaction input points to the UTXO by using the transaction
    ID (`txid`) and the sequence number of the transaction that created this UTXO.
    Like a transaction output, a transaction input contains an unlocking script that
    proves the user's claim on the UTXO and ensures that the transaction is valid.
    The spender initially retrieves the UTXO and references it using the transaction
    ID. An unlocking script is created with the secret information required to unlock
    the funds. A simple unlocking script will have a digital signature signed with
    a private key and the corresponding public key. However, the representation could
    be complex, but it's something we will cover in much more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, Alice uses `txid` to point to the spendable UTXO in the transaction.
    Alice then creates an unlocking script and places it in the `scriptSig` field
    of the transaction. Everyone who gets this transaction will validate it by checking
    the locking script in the UTXO.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, there is a transaction fee that Alice has to pay on top
    of the 0.1 bitcoin she intends to transfer to Bob. However, there is no transaction
    fee field in the raw transaction structure. It is calculated by checking the value
    of all referenced UTXOs and then subtracting this from the transaction input values
    in the transaction. This additional value, which is not tracked in the transaction
    output, forms the transaction fee. Each miner will calculate the fee for every
    transaction and rewards the combined value to themselves in a special coinbase
    transaction. We will cover more about the coinbase transaction in the *Mining
    and consensus* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verification of the transaction is performed using an unlocking script and a
    locking script. Bitcoin uses a simple custom scripting language called Script,
    which is similar to the stack-based execution language Forth. To validate the
    transaction, the unlocking script in the input is executed alongside its corresponding
    locking script. The stack-based execution should return a true value and successfully
    execute the unlocking script.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the input's `scriptSig` and the referenced output's `scriptPubKey`
    are evaluated (in that order), with `scriptPubKey` using the values left on the
    stack by `scriptSig`. The input is authorized if `scriptPubKey` returns true.
  prefs: []
  type: TYPE_NORMAL
- en: Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to understand the basic execution of the Script language before trying
    to make sense of the locking and unlocking scripts. Script is simple, a stack-based
    language that is processed from left to right. It is intentionally not Turing-complete.
    It doesn't have a complex control flow, such as loops, other than conditions.
    This makes sure that the program is executed in a predictable time. This was done
    intentionally to avoid denial-of-service attacks, which create infinite execution
    loops. The simplicity of the Script language ensures that Bitcoin is not vulnerable
    to any attacks of this nature.
  prefs: []
  type: TYPE_NORMAL
- en: Script is also stateless, meaning that there is no information stored prior
    to or after execution. This ensures that execution is not affected by any other
    aspects of the system and that scripts could be executed on any system.
  prefs: []
  type: TYPE_NORMAL
- en: Script is a stack-based language because it uses a stack data structure during
    execution. A stack data structure performs push and pop operations on the data
    items. Push operations add an item to the top of the stack, and pop operations
    remove the last inserted item. Script executes the program by processing items
    from left to right. Data items are pushed to the stack whenever they are encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Operators pop an item from the stack and perform operations on them, and then
    push the results back to the stack. Script has a huge set of operators, which
    are represented by opcodes that can be used on the items. Arithmetic opcodes such
    as `OP_ADD` perform addition on the top two items, whereas the conditional `OP_EQUAL`
    opcode evaluates a condition, producing a Boolean result. Bitcoin transaction
    scripts mostly consist of a conditional operator whose final result must evaluate
    to a true value if the transaction is to be considered valid.
  prefs: []
  type: TYPE_NORMAL
- en: Script example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a simple example to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execution of the script starts from the left-hand side. The data constants `2`
    and `4` are inserted into the stack as soon as the execution begins. Next, the
    script performs an addition operation, represented by the `OP_ADD` operator. The
    addition operation is performed on the top two items of the stack after popping
    them, so *2 + 4 = 6*. The result is pushed back to the stack. The data constant
    `6` is pushed to the stack when it is encountered. Finally, the conditional `OP_EQUAL`
    operator is performed on the stack items. The last two items are popped from the
    stack and compared to see if they are equal. Since the last two data items in
    our stack are `6`, the equality condition will return a `TRUE` value.
  prefs: []
  type: TYPE_NORMAL
- en: Locking and unlocking scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin uses a similar method of script execution but has a different set of
    opcodes. Bitcoin transactions use locking and unlocking scripts, which are executed
    together to verify a transaction. As mentioned earlier, a locking script is a
    spending condition specified in the transaction output, and an unlocking script
    satisfies this condition when the two scripts are executed together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a simple locking and unlocking script by breaking down the previous
    script example. Part of the script could form a locking script, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This could only be satisfied by an unlocking script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Any node will validate these scripts by combining and executing the locking
    and unlocking scripts sequentially, as shown in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But these are basic scripts, and anyone with basic arithmetical skill can create
    an unlocking script in order to spend the transaction output. This is why Bitcoin
    uses a complex condition with a cryptographic puzzle as a locking script. Only
    a legitimate owner who has the private key will be able to spend the funds by
    creating proof with an unlocking script.
  prefs: []
  type: TYPE_NORMAL
- en: The locking script in Bitcoin is referred to as `scriptPubKey`, as seen in the
    earlier transaction example in the *Transactions* section. This is due to the
    use of a public key hash (the Bitcoin address) in the locking script to transfer
    a fund to the owner of the corresponding private key. Similarly, an unlocking
    script can be found in the `scriptSig` field in the transaction input. The unlocking
    script generally proves the ownership of the private key corresponding to the
    public key by creating a digital signature. This is why the unlocking script is
    generally referred to as `scriptSig`.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way to the example, Bitcoin transaction validators validate transactions
    by executing the combined locking and unlocking scripts. Validators retrieve the
    UTXO referenced by the transaction input and place the locking and unlocking script
    side by side for sequential execution.
  prefs: []
  type: TYPE_NORMAL
- en: Types of transaction script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin currently creates two different basic `scriptSig`/`scriptPubKey` pairs.
    There are complex transaction scripts that are used rarely in Bitcoin transactions.
    **Pay-to-PubKeyHash** (**P2PKH**)Â and Â **Pay-to-Script-Hash** (**P2SH**) are the
    most popular scripts. The majority of the scripts executed in the Bitcoin network
    use P2PKH as their transaction script.
  prefs: []
  type: TYPE_NORMAL
- en: '**P2PKH**'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin transactions create an output transaction with a public key hash called
    P2PKH. The public key hash denotes the Bitcoin public address of the corresponding
    private key that a user holds. The user creates a locking script with the recipient's
    public address. No-one other than the holder of the corresponding private key
    will be able to claim the transaction output.
  prefs: []
  type: TYPE_NORMAL
- en: In our earlier example, Alice creates a transaction input that contains `scriptSig`
    and transaction output with `scriptPubKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows the syntax of `scriptPubKey` and `scriptSig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The validator will combine the scripts and execute them sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature (`sig`) and public key (`pubKey`) recorded by the spender are
    pushed into the stack. The `OP_DUP` operator duplicates the `pubKey` in the stack.
    The next operator, `OP_HASH160`, calculates a 160-bit hash value of the public
    key using the `SHA256` and `RIPEMD160` algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `pubKeyHash` value in the locking script is pushed into the stack. The `OP_EQUALVERIFY`
    operator verifies that the public key hash created from the unlocking script and
    `pubKeyHash` value previously pushed to the stack are equal. It returns a `TRUE`
    value if the public key hashes of both the locking and unlocking scripts match.
    Finally, `OP_CHECKSIG` pops `sig` and `pubKey` from the stack, performs digital
    signature verification, and verifies that the signature is valid. Once the verification
    is successful, the script returns a `TRUE` value, indicating that unlocking script
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '**P2SH**'
  prefs: []
  type: TYPE_NORMAL
- en: 'P2SH was introduced by one of the early Bitcoin developers, Gavin Andresen.
    According to Gavin Andresen, P2SH was created with a purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '"To move the responsibility for supplying the conditions to redeem a transaction
    from the sender of the funds to the redeemer."'
  prefs: []
  type: TYPE_NORMAL
- en: â€“Â Andresen
  prefs: []
  type: TYPE_NORMAL
- en: In P2SH, funds are addressed to the hash of the script instead of the public
    address. The script is called a redeem script, which houses all the conditions
    needed to spend the funds. As Gavin Andresen mentioned, the creator of the transaction
    doesn't have to worry about the conditions to spend the funds, and needs only
    mention the hash of the script containing the conditions. When the funds need
    to be spent, the redeemer should provide the script that matches the mentioned
    script hash and also make sure that the script evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: P2SH provides a means for complicated transactions to take place, unlike P2PKH,
    which has a specific definition for `scriptPubKey` and `scriptSig`. The specification
    places no limitations on the script, and therefore absolutely any script can be
    funded using these addresses. The concept of the script is similar to that of
    the smart contract, which will be covered in [Chapter 7](6bcd989e-2411-4096-91e1-943698f1702e.xhtml),
    *Diving into Blockchain â€“ Proof of Ownership*.
  prefs: []
  type: TYPE_NORMAL
- en: Mining and consensus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mining in Bitcoin is a crucial concept to achieve a consensus on the state of
    the blockchain in the decentralized Bitcoin network. Any node in the Bitcoin network
    can perform mining operations, and these nodes are rewarded with incentives for
    their contribution to mining. This has led to confusion between mining and incentivizing.
    Although incentives are part of mining, that is not the only intention of mining.
    Mining is a mechanism that underpins the decentralization of the Bitcoin network.
    It helps to achieve a consensus among the nodes in a trustless network by constructing
    a blockchain that is accepted by everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other Bitcoin node, a miner also validates new transactions and stores
    them locally in a memory pool. In addition to performing validation, a miner creates
    a block of transactions and solves a hash puzzle to include the created block
    in the global Bitcoin ledger. The miner will be rewarded with two types of incentive
    once the created block is included in the blockchain: the transaction fees of
    each transaction and the newly created bitcoins in each block. Transaction fees
    are the fees charged for the processing of each transaction, and the fee is attached
    by the creator of the transaction. Each block has a special transaction that creates
    new bitcoins and awards them to the miner responsible for the creation of the
    block. This special transaction, called a coinbase transaction, is responsible
    for the creation of new bitcoins.'
  prefs: []
  type: TYPE_NORMAL
- en: Since there is a hard cap on the total number of bitcoins that can be created
    (21 million), at some point in time in the future, miners will be only rewarded
    with incentives from the transaction fees. The maximum number of newly created
    bitcoins that the miner is rewarded halves for every 210,000 blocks created. Since
    each block's creation time is kept at around 10 minutes, 210,000 blocks are created
    every four years. The incentive started at 50 bitcoins per block in 2009 when
    Bitcoin was launched and was later halved in 2012, and again in 2016.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, miners are rewarded with 12.5 newly minted bitcoins for every block
    they create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d1d0e5b-9b79-4cb8-98de-89d247d47803.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The supply of Bitcoin currency over the years till 2018 (Source:
    www.blockchain.info)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.4* shows the supply of Bitcoin over time. The curve is geometrically
    decreasing due to the halving of the Bitcoin rewards for each block. The Bitcoin
    network is likely to supply 21 million coins by 2140\. The line in the graph will
    be almost parallel to the x-axis when it nears the year 2040.'
  prefs: []
  type: TYPE_NORMAL
- en: Mining a block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any node in the Bitcoin network can create a block and call itself a miner.
    A miner has to run a Bitcoin node maintaining the full blockchain. Although mining
    operations can be performed with minimal hardware requirements, due to high competition
    among Bitcoin nodes, mining on standalone computing hardware with a minimal hardware
    configuration is no longer profitable. This is why Bitcoin miners often run specialized
    computer hardware with higher processing power, such as GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the increased competition among miners, the mining difficulty of Bitcoin
    increased. Miners started building specialized integrated circuits designed specifically
    for mining purposes. These specialized integrated circuits are known as **Application-Specific
    Integrated Circuits** (**ASICs**), and they cannot be used for general-purpose
    computing. There are several Bitcoin ASIC manufacturers producing ASICs of different
    capacities. Bitmain's Antminer devices are the most widely used ASICs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each miner node will also listen to the Bitcoin network for new transactions
    and blocks. They perform several tasks before they conclude that they have successfully
    mined a new block:'
  prefs: []
  type: TYPE_NORMAL
- en: Verification of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating transactions into blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining the block using the Proof of Work algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verification of transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, each valid transaction is created by collecting the UTXOs and
    unlocking them with appropriate scripts, before using the locking scripts, which
    will lock the funds for the next owner. The transaction is broadcast to the Bitcoin
    network so that everyone knows about the updated state of the blockchain. Broadcasting
    the transaction also makes sure that the transaction reaches a miner node and
    is included in any blocks that are created.
  prefs: []
  type: TYPE_NORMAL
- en: Although transactions are verified before they are broadcast to the network,
    a miner node always verifies each and every transaction before including it in
    the block. A single invalid transaction could result in the entire block being
    rejected by the Bitcoin network. To prevent unnecessary losses, a miner always
    ensures that only the valid transactions are included in the block.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating transactions into a block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like any full node in the Bitcoin network, a miner accumulates all the
    transactions it receives and adds them to the local memory pool. A miner will
    start constructing a candidate block that could be inserted into the blockchain
    by including a set of transactions in the block. The node will make sure that
    any time a new block arrives during the block construction process, all the transactions
    in the newly-arrived block should be omitted from the candidate block because
    this would create duplicate transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the metadata of the block and transactions are created for the block,
    the miner solves the hash puzzle by performing Proof of Work. The block is broadcasted
    to the Bitcoin network as soon as it successfully creates a Proof of Work for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every block created in the Bitcoin blockchain has a special type of transaction,
    which is the first transaction of the block. This transaction is created by the
    miner, which rewards itself with incentives earned from transaction fees and newly
    created bitcoins, as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the coinbase transaction of Bitcoin mainnet block 520,956\. Decoding
    the first transaction of the block will give these details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Coinbase transactions don't have any references to a UTXO in the transaction
    input because the amount is created from new coins and transaction fees. The address
    mentioned in the transaction output is the miner's own Bitcoin address, so the
    entire fund of the coinbase transaction is transferred solely to the miner.
  prefs: []
  type: TYPE_NORMAL
- en: Mining a block using the Proof of Work algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Proof of Work algorithm is used in Bitcoin to achieve consensus in the Bitcoin
    network about the blocks that belong to the blockchain. It helps to achieve consistency
    of data in the ledger among the nodes in the network. The Proof of Work algorithm
    creates proof that a certain amount of work has been done to create the block.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin's Proof of Work is a hash puzzle that uses the SHA256 hash function
    to find the required hash value and thus solve the puzzle. The Proof of Work algorithm
    used in Bitcoin is similar to the one explained in [Chapter 3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml),
    *Cryptography in Blockchain*. You can refer to [Chapter 3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml),Â *Cryptography
    in Blockchain*,Â for more details regarding the implementation and analysis of
    the Proof of Work algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Mining pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are aware that mining difficulty in Bitcoin is adjusted to maintain an average
    block creation time of 10 minutes. But due to high competition among miners, the
    difficulty of solving the hash puzzle has increased over time.
  prefs: []
  type: TYPE_NORMAL
- en: This has forced the miners to upgrade their hardware to achieve higher hash
    rates. Miners who had limited resources couldn't compete with miners who owned
    huge computing resources. This was when the mining pool was introduced to pool
    the resources of individual miners with limited resources.
  prefs: []
  type: TYPE_NORMAL
- en: A mining pool is a pooling of computing resources of miners to share the computing
    power and attain a higher hash rate to solve the hash puzzle. If the combined
    hash power of the mining pool solves the hash puzzle for a block, each miner who
    is part of the mining pool is rewarded based on the amount of hash power contributed.
    There are a number of mining pools implemented in different languages. A miner
    can join any of the mining pool servers and start contributing the hash power.
    Slush Pool is the oldest mining pool and was formerly known as **Bitcoin.cz Mining**.
  prefs: []
  type: TYPE_NORMAL
- en: Mining pools use different protocols to communicate between the miner and the
    mining pool server. The getblocktemplate, getwork, and stratum protocols are some
    of the mining protocols used in the mining pools. The stratum mining protocol
    is a widely used protocol that was designed as a replacement for the getwork protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each miner connected to the mining pool server has to follow a few stepsÂ to
    successfully contribute to the pool mining:'
  prefs: []
  type: TYPE_NORMAL
- en: A miner has to authorize themselves with the right credentials before working
    on a job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They then need to fetch the set of transactions for a job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the miner needs to submit the work to the server along with username
    and job details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several ways in which a miner's share can be distributed. Most of
    the mining pool rewards the miner based on the miner's share for the block that
    was created by the pool.
  prefs: []
  type: TYPE_NORMAL
- en: The hash rate is the unit used in blockchain mining to determine the computing
    power or the hashing power of the miner. It is nothing but the number of hashes
    produced per second.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blockchain in Bitcoin is a collection of an ordered lists of blocks that
    connects the previous block with the hash pointer. Bitcoin uses Google's `LevelDB`
    database to store the blockchain metadata. The identity of each block is created
    by using the SHA256 hash value of the block header, and this block hash is stored
    in the block header of the next block in the blockchain in order to form a link.
  prefs: []
  type: TYPE_NORMAL
- en: Block structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data structure of a Bitcoin block holds a collection of transactions and
    metadata information about the block. A block is made up of a header and body,
    which consists of all the transactions. A block holds more than 500 transactions,
    on average.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 5.2* shows all the fields that are included in a block. The dominant
    part of the block is the header and transactions, which would occupy variable
    size. Each field shows the size or the transactions occupied in the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Description** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| Magic no | The value is always 0xD9B4BEF9 | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Block Size | Number of bytes up to the end of the block | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Block Header | Consists of six items | 80 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Transaction Counter | Integer count | 1 - 9 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Transactions | List of transactions | Variable |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: The block structure'
  prefs: []
  type: TYPE_NORMAL
- en: Block header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The block header stores the metadata of the block, and its size is 80 bytes,
    as shown in the previous table. It stores version information with which you can
    identify the block. `hashPrevBlock` stores a 256-bit hash value of the previous
    block, which links the blocks and ensures the integrity of the blockchain. `hashMerkleRoot`
    is the hash digest of the transactions and ensures the integrity of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time, difficulty bits, and nonce fields are related to the Proof of Work
    consensus algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Purpose** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| `Version` | Block version | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `hashPrevBlock` | 256-bit hash of the previous block header | 32 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `hashMerkleRoot` | 256-bit hash based on all of the transactions in the block
    | 32 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `Time` | Current timestamp in seconds since 1970-01-01T00:00 UTC | 4 bytes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Difficulty Bits` | Current target in a compact format ([https://en.bitcoin.it/wiki/Target](https://en.bitcoin.it/wiki/Target))
    | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `Nonce` | 32-bit number (starts at 0) | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.3: The block header'
  prefs: []
  type: TYPE_NORMAL
- en: The genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The genesis block, which is the first block in a blockchain, in Bitcoin was
    created by Satoshi Nakamoto. It is statically coded so that everyone who runs
    a Bitcoin core node will only believe one blockchain state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The genesis block hash can be fetched by fetching the block hash of the 0^(th)
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the block details of the Bitcoin genesis block. This block
    has a coinbase transaction and no other transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The coinbase transaction of the block has the following text, along with the
    normal data in its transaction input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This proves that the first block was mined on or after January 3, 2009\. The
    coinbase transaction also has an output transaction of 50 bitcoins, just like
    any other coinbase transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Merkle trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Bitcoin header has metadata that summarizes all the transactions present in
    the block. This is achieved by creating a digest using a special type of tree
    called a Merkle hash tree. As mentioned in [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, a Merkle hash tree is a binary hash tree that is used
    to summarize large sets of data. Merkle trees are used to summarize all the transactions
    in Bitcoin and thus ensure the integrity of the transactions. They provide an
    efficient way to verify whether a transaction is included in the block.
  prefs: []
  type: TYPE_NORMAL
- en: Merkle trees recursively hash the nodes, starting from the leaves, which are
    hashes of transactions, until there is only one hash. This hash value summarizes
    all the transactions in the block and is called the Merkle root. Bitcoin applies
    the SHA256 hash function twice to create the hash of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: When there are *N* transactions in a block, the Merkle tree ensures that it
    doesn't need more than *2*log2(N)* calculations to check whether the transaction
    is included in the block. This makes the Merkle tree implementation a very efficient
    way to verify whether a transaction is included, as well as to check integrity.
    Merkle trees are efficient in cases with large numbers of transactions. Even though
    the number of transactions in a block increases exponentially, the path required
    to verify a transaction will always be logarithmic due to the binary tree nature
    of the Merkle tree.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bitcoin blockchain network is formed of decentralized nodes, and each node
    communicates with the others using the P2P networking protocol. Each node running
    the Bitcoin client contributes to the growth of the blockchain and the network.
    Surprisingly, the Bitcoin network consists of nodes that deal with multiple public
    blockchains. The main blockchain, which is used to hold transactions with actual
    value, is called **mainnet**. This is the longest blockchain, with the highest
    number of participating nodes. Besides mainnet, Bitcoin has several other blockchains
    for testing purposes. Currently, Bitcoin has theÂ **testnet**, **segnet**, and
    **regtest** blockchain networks.
  prefs: []
  type: TYPE_NORMAL
- en: Testnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testnet is the Bitcoin blockchain version that was created solely for testing
    purposes. The testnet blockchain works on the same network as mainnet, with features
    such as wallets, transactions, and mining. The only difference is that the coins
    circulated in testnet don't have any monetary value. Testnet was created as a
    test network that can be used by developers to check features and fixes before
    they are deployed in mainnet. Testing on testnet is crucial because it is impossible
    to revert the mainnet blockchain due to the decentralization. Testnet is supposed
    to work with a lightweight configuration by keeping the mining difficulty to a
    minimum so that even simple hardware can be used for testing. But people tend
    to use high-configuration hardware in the testing network, which increases the
    mining difficulty. Every now and then, testnet is recreated by propagating a new
    genesis block and resetting the difficulty. The current iteration of testnet is
    called testnet 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'A testnet blockchain can be created using Bitcoin Core by creating a separate
    daemon process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new process, which creates a new testnet blockchain copy. The
    testnet blockchain is considerably smaller than mainnet. The testnet blockchain
    syncs all the blocks much more quickly than the mainnet blockchain. Bitcoin''s
    command-line interface is invoked with a similar argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In 2016, a special-purpose testnet called segnet was created to test the Bitcoin
    Segregated Witness feature. It is no longer required to run a separate network,
    however, because the segnet feature has been added to testnet 3.
  prefs: []
  type: TYPE_NORMAL
- en: Regtest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regtest is a testing blockchain for regression purposes. Unlike testnet, regtest
    is not a public blockchain. Regtest is a blockchain that can be created by a user
    for local testing purposes. This is ideal for testing features that don''t need
    to interact very much with the network. You can create your version of the blockchain
    with a local genesis block. Similar to testnet, a regtest flag is added to the
    command to launch the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the blockchain is a local copy, the user can mine the blocks without
    worrying about the consensus. The following command mines 500 blocks within a
    few seconds, and the user will be rewarded with coins in each coinbase transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Bitcoin hard forks and altcoins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hard fork in Bitcoin is an update to the protocol that will not entertain
    the older protocol, thus requiring everyone to upgrade. Hard fork upgrades often
    include major changes such as changing the blockchain structure, transaction,
    or consensus rules. The major difference between a soft fork and hard fork is
    that the latter is not backward compatible, meaning that the older system will
    not function in the updated protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There will be two different versions of blockchain after the blockchain hard
    fork. The multiple versions of blockchain are a result of disagreement among the
    blockchain nodes to follow a single protocol. Blockchain hard forks often result
    in protocol upgrades. Bitcoin has had several hard forks, which has resulted in
    the creation of Bitcoin forked cryptocurrencies. Bitcoin Cash was the first successfully
    hard-forked cryptocurrency, which was forked at the 478,558^(th) block of Bitcoin
    on 1st August, 2017\. Bitcoin Cash was mainly created to increase the block size
    to 8 MB. Bitcoin Gold and Bitcoin Private were the other two successful hard forks
    that followed Bitcoin Cash.
  prefs: []
  type: TYPE_NORMAL
- en: Altcoins, or alternative coins are the cryptocurrencies launched after the success
    of Bitcoin. Altcoins are created on a separate blockchain, unlike Bitcoin's hard
    forked cryptocurrencies. Most altcoins use the basic framework provided by Bitcoin
    and try to solve its existing limitations. Few of the coins have tried to increase
    the transaction speed by using alternative algorithms to Proof of Work, and few
    others have tried to enhance security by increasing the anonymity of the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Namecoin was one of the initial well-known altcoins that were based on Bitcoin.
    Litecoin, Zcash, Dogecoin, and Ethereum are a few of the coins that followed Namecoin.
    Litecoin is the closest implementation of Bitcoin and has a reputation of being
    the silver to Bitcoin's gold. Litecoin has a total supply of 84 million coins,
    which is four times that of Bitcoin. It also increases the transaction speed by
    reducing the block creation time. Litecoin uses a memory-intensive Proof of Work
    algorithm called Scrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Thousands of altcoins have been created since the invention of Bitcoin, and
    the number keeps growing every day. However, Bitcoin is the most widely used cryptocurrency
    to date.
  prefs: []
  type: TYPE_NORMAL
- en: A simple cryptocurrency application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a cryptocurrency application will allow us to implement all the blockchain
    concepts we''ve looked at so far, along with the transaction structure used in
    Bitcoin, and we can then deploy it in a fully P2P network. We created a blockchain
    application in a decentralized P2P network in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml),
    *Networking in Blockchain*. We will be using the same application to create and
    propagate the blocks in the network, but also extend the application with the
    concepts of transactions and wallets to create a completely decentralized cryptocurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2de03c82-a0d7-4fd0-9847-9b6e02dc2b7e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: A flow diagram connecting all the components of the application'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.5* shows how the cryptocurrency application can be extended by adding
    wallet and transaction functionality. We will walk through the implementation
    of each component in order to understand its functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created an application in which blocks were created with data without verifying
    the contents of the data. We will extend this functionality by restricting the
    block to only accepting transaction data. The transaction data is similar to what
    we have covered in this chapter. It consists of input and output components. The
    output specifies the recipient of the transaction, and the input makes sure that
    the user has enough funds for the transaction to take place successfully. The
    input references an existing unspent output.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transaction output has a structure that only accepts the recipient''s address
    and the transaction amount. The address is the public key counterpart of the **Elliptic-curve
    cryptography**Â (**ECC**) key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Transaction input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transaction input provides information about the funds that will be spent by
    referencing the spendable transaction output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`tx_out_id` and `tx_out_index` are used to reference the transaction output,
    and the signature provides proof that the spender is the legitimate owner of the
    fund. Unlike Bitcoin, we have not used a Script-like language to lock and unlock
    the transactions. Transaction validation will be performed simply by verifying
    the signature with the help of an **elliptical curve digital signature algorithm**
    (**ECDSA**).'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A transaction is a collection of valid transaction inputs and outputs, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A transaction ID is derived from the digest of the entire transaction. The
    `SHA256` hash function is used to calculate the digest of the concatenated transaction
    input and output contents, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: UTXO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A transaction input will always refer to a UTXO. A list of UTXOs is maintained
    locally. This list is updated whenever a transaction is processed, and is referred
    to during transaction validation. Although this list could be generated at any
    time by traversing the entire blockchain, it is maintained in memory to facilitate
    speedy transaction validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The list of UTXOs is a simple list that is initially created by processing the
    genesis transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the node creates or receives a transaction, it updates the unspent
    transaction outputs while processing it. A set of new UTXOs is calculated from
    the newly added transactions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All the UTXOs that are referenced in the transaction input are collected as
    consumed UTXOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated UTXO list is created by adding the newly created UTXOs and removing
    all the consumed UTXOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Transaction validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a node receives a transaction pool or a new block, all the transactions
    are validated before they store the transaction data in the local blockchain.
    The structure of each transaction is tested by checking the data structure of
    each field. Transaction inputs and outputs are also verified so that no invalid
    input or output is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The transaction is rejected if the transaction structure is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The transaction ID in this application is calculated using the SHA256 hash
    function, and this demonstrates the integrity of the transaction. The transaction
    is considered invalid if the ID is tampered with and doesn''t pass the integrity
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Transaction inputs are validated by checking whether they have a reference
    to a valid UTXO, along with a valid signature signed with the private key of the
    public key mentioned in the UTXO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The total transaction output amount is compared with the total transaction input
    amount by summing the output and input amounts. The transaction is considered
    invalid if the input amount doesn't match the output amount. In Bitcoin, the transaction
    output is always lower than the transaction input due to the transaction fee.
    This amount is included in the coinbase transaction. Since we don't have transaction
    fees in this application, the input and output amount should always match.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transaction signing is a crucial process to unlock the funds so that they can
    be transferred to a new owner. Every transaction input includes a signature field
    that contains a signature signed by the owner of the referenced transaction output
    fund. Each transaction input signs the transaction ID, and this makes sure that
    none of the transaction inputs can be tampered with because the transaction ID
    is the digest of the entire transaction. Modifying any of the input will render
    all the signatures invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use packages to perform serialization, signing, and verification of
    the transaction information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Although we have used `pycryptodome` as the core library for cryptography throughout
    the book, we will make use of the `ecdsa` package for digital signatures in this
    application due to its exclusive support for digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The referenced UTXO is fetched in order to find the public key to validate
    whether the signer is the owner of the funds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The signer''s public key is compared with the referenced UTXO public key to
    check whether the signer is authorized to sign the transaction input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the transaction ID is signed using the user''s private key. The signature
    is created using ECDSA with a `secp256k1` curve. Refer to [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, for more details on ECDSA signing and verification with
    a secp256k1 curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Wallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, a wallet secures the ownership of funds by storing the private keys
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of a wallet gives us only abstract operations, such as viewing
    the balance of the user's account and sending funds to another user.Â The wallet
    is often considered an end user application for those who don't want or need to
    understand the internal implementation of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Key management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the generation of a key pair and store the keys in plaintext,
    that is, without applying any encryption. Although wallets can store multiple
    keys, which can also be generated by a seed phrase, we will use a single key per
    wallet in this application to keep the wallet implementation as simple as possible.
    The following method will read the private key and convert the hexadecimal to
    byte representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Wallet is initialized by creating a private key using the ecdsa package. The
    SigningKey class has a generate method which is used to create a signing key in
    ecdsa. This key is then converted to hexadecimal format and then stored in a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The public key can be generated by using the private key at any time. The following
    method creates a `SigningKey` object by reading the raw private key. This object
    can generate a verifying key, which is the public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Wallet balance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Owning funds in cryptocurrency boils down to claiming the transaction outputs
    that are addressed to the user. The wallet's balance is calculated by collecting
    all the UTXOs whose addresses match the public key counterpart of the user's private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our application maintains a single private key per wallet, all the UTXOs
    of the user will be referenced to a single public address, which isn''t the case
    in implementations where user-owned UTXOs will be addressed to multiple addresses.Â The
    following method finds the sum of all the funds amounts specified in the UTXOs
    whose addresses match the user''s public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The public address in our application is a public key. This isn't the case in
    other cryptocurrency applications, which may use locking and unlocking scripts,
    and the public address is generated from the public key by using a hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating a transaction is simply the construction of a transaction
    object that has a valid set of transaction inputs and outputs that satisfy the
    transaction request of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming UTXOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a transaction to transfer funds, you need to combine one or more
    UTXOs, just like gathering coins or cash to pay someone. *Figure 5.6* shows how
    two UTXOs that have the values 40 and 10 are combined to create a transaction
    output of 45 to pay to the other user. The remaining output value of 5 is called
    the change amount, and this will be addressed back to the creator of the transaction
    in a similar way to receiving change when we pay for something in a shop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab16b3e5-4c1a-40ca-be94-5fe759e66c3b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The creation of new output transaction outputs from the available
    UTXOs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user wallet selects a set of UTXOs that could be used to spend a particular
    amount. The total value of the selected UTXOs will always be either equal to or
    greater than the required amount. The following method traverses serially and
    selects all the transaction outputs that are enough to satisfy the requested amount.
    The excess amount, which is required to create a new transaction output, is calculated,
    and this is sent to the transaction creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Constructing a transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transactions are created by constructing valid transaction inputs and outputs.
    Consumable UTXOs are fetched by the `find_tx_outs_for_amount` method, as described
    in the previous section. Transaction inputs will be created for these UTXOs. The
    leftover amount is used to create a change transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'User''s unspent transactions are filtered and will be referenced in the transaction
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Transaction inputs are created using the `TxIn` class by initially keeping
    the signature field empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The transaction is created with the unsigned transaction input and output values
    created with the `create_tx_outs` method. This method creates the recipient and
    change transaction output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the unsigned transaction inputs are signed by the wallet owner using
    the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the transactions are created, they should be included in the blockchain
    in order to update the global transaction state. Transactions that haven't yet
    been included in the blockchain are called **unconfirmed transactions**. Unconfirmed
    transactions are always locally stored in a pool called a transaction pool. This
    is the same as Bitcoin's mempool.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the unconfirmed transactions created by the user and other nodes are included
    in the transaction pool. The transaction pool could be a local file or an in-memory
    pool. We will maintain all the transactions in a list stored in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a transaction is created by a node, it is added to the local transaction
    pool before broadcasting. The following `send_transaction` method adds the transaction
    to the pool after creating the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'These transactions remain in the pool until they are included in the blockchain.
    The pool of transactions needs to be updated once the transaction is included
    in a block. The node updates its pool whenever it receives a new block. The following
    method removes the transaction from the pool when it fails to find the UTXO referenced
    by the transaction input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The missing UTXO signifies that the transaction has been included in the blockchain,
    and so the transaction can be removed from the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user node can mine a block for transactions itself or propagate transactions
    to the blockchain network so that some other node can mine the transactions. Our
    blockchain application has only communicated block information so far. Since not
    all transaction creators want to mine blocks themselves, transactions need to
    communicate to the nodes. We will add two more message types to the application.
    Refer to the message types described in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml),
    *Networking in Blockchain*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the formats of query and response messages that will be exchanged
    between the nodes. Similar to the broadcasting of blocks, transactions are broadcast
    when a new transaction is created by a node and when it receives an unconfirmed
    transaction from other nodes. The node will broadcast a transaction pool query
    message when it first connects to another node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the blockchain part of the application is pretty similar to the application
    created in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml), *Networking
    in Blockchain*, we have added some functionality due to the introduction of the
    transaction data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mining a blockchain without transactions is straightforward; it just entails
    the construction of a block with a header and data. But when the arbitrary data
    is replaced with transaction data, the node needs to fetch the transactions from
    the local transaction pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This method constructs and mines a block's data, which contains a coinbase transaction
    and transactions from the pool. The block will be added to the blockchain once
    the block header and transactions are validated.
  prefs: []
  type: TYPE_NORMAL
- en: Application endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the application has an HTTP interface that it uses to
    manage the nodes and a WebSocket interface for P2P communication between the nodes.
    Here are some of the endpoints that are required to manage the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/blocks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/block/<hash>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mineBlock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/transaction/<id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sendTransaction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sendTransaction` endpoint will basically create the transaction and add
    it to the pool, as explained in the *Transaction Management* section. Unconfirmed
    transactions are included in the blockchain by using the `/mineBlock` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the state of the blockchain before any other transactions
    are performed because it contains a genesis block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a transaction is confirmed by inserting it to the blockchain, it can be
    viewed by sending an HTTP GET request to the `blocks` or `transaction` endpoint.
    Here is the transaction result thrown out when hitting the transaction endpoint
    with the transaction ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This transaction consumed the transaction output of the genesis block, which
    had a value of 50\. Since a transaction totaling 20 coins was created, the remaining
    30 coins were sent back to the owner.
  prefs: []
  type: TYPE_NORMAL
- en: The entire application's code can be found in the GitHub repository. Since not
    all the components of the application are described here, refer to the code in
    the repository in order to understand and execute the implementation. You will
    also find a block explorer and wallet UI for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the concept of blockchain originated from a cryptocurrency, the best way
    to understand the true implementation of the blockchain technology is through
    a cryptocurrency application. In this chapter, we have covered all the concepts
    of cryptocurrency with the help of Bitcoin in order to understand how cryptocurrency
    functions in a decentralized network.
  prefs: []
  type: TYPE_NORMAL
- en: We started with the basics of Bitcoin and how they are set up to form a decentralized
    network. Then we dived into several concepts, such as keys, addresses, and wallets,
    used in Bitcoin. Bitcoin transactions were explored in depth since those are the
    events that bring value to the Bitcoin network. We also dived into the essence
    of blockchain, including mining and consensus of Bitcoin. Finally, we concluded
    the chapter by creating a simple cryptocurrency application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a reference because it elaborates on most of the concepts
    used to deploy a basic cryptocurrency. Now that we are familiar with the key concepts
    of a decentralized application, we will dive into blockchain by creating an application
    using the existing platform in the next chapter.
  prefs: []
  type: TYPE_NORMAL
