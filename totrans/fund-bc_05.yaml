- en: Cryptocurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币
- en: In this chapter, we will explore the original and best implementation of blockchain
    technology—cryptocurrency. Cryptocurrency is much more than just a blockchain
    application; it makes use of cryptographic primitives such as digital signatures
    to achieve asset management by using atomic events called transactions. Throughout
    this chapter, we will be familiarized with all the concepts required to understand
    how cryptocurrency is different from any of the traditional digital currencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索区块链技术的原始和最佳实现——加密货币。加密货币不仅仅是一个区块链应用程序；它利用了诸如数字签名之类的加密基元来实现通过称为交易的原子事件来管理资产。在整个本章中，我们将熟悉理解加密货币与传统数字货币有何不同所需的所有概念。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of Bitcoin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币的基础知识
- en: Keys and addresses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥和地址
- en: Transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易
- en: Mining and consensus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖矿和共识
- en: Blockchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链
- en: Blockchain networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链网络
- en: The creation of a simple cryptocurrency application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的加密货币应用程序
- en: Bitcoin was the first successful cryptocurrency to be deployed in a decentralized
    network. It is the best-known cryptocurrency to date due to its resilient software
    and infrastructure, widespread adoption in various fields, and high market capitalization.
    By the end of 2017, Bitcoin had achieved a market cap of 300 billion USD, which
    is the highest by any cryptocurrency to date. Most of the cryptocurrencies in
    the market are inspired by and use similar designs to Bitcoin. We will be using
    Bitcoin to learn about most of the relevant concepts in cryptocurrency, and later
    on in this chapter, we will also implement a cryptocurrency similar to Bitcoin.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是第一个成功部署在去中心化网络中的加密货币。由于其具有韧性的软件和基础设施、在各个领域的广泛采用以及高市值，比特币是迄今为止最知名的加密货币。截至2017年底，比特币的市值达到了3000亿美元，这是迄今为止所有加密货币中最高的。市场上的大多数加密货币都受到比特币的启发，并采用类似的设计。我们将使用比特币来了解加密货币中大多数相关概念，并在本章的后面部分，我们还将实现一个类似比特币的加密货币。
- en: A cryptocurrency is a digital asset that uses cryptography to secure, spend,
    and verify its value in the transactions. The cryptocurrency could be transferred
    from the owner to any recipient without the need for an intermediary to settle
    the transactions. Although the early adoption of cryptocurrency provided a number
    of features, such as pseudo anonymity, lower transaction fees, and removing the
    need for an intermediary, it never achieved true decentralization. There were
    known issues, such as double-spending. This was when a single asset was transferred
    to multiple recipients because there was no centralized source to verify these
    transactions. All of these issues were addressed when a completely decentralized
    cryptocurrency called Bitcoin was created in 2009\. This solved the double-spend
    issue for the first time in a decentralized network by using immutable blockchain
    to achieve consensus among the nodes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币是一种使用密码学来确保、花费和验证交易价值的数字资产。加密货币可以从所有者转移到任何接收者，而无需中介来完成交易。尽管早期采用的加密货币提供了许多功能，如伪匿名性、更低的交易费用和消除中介的需求，但它从未实现真正的去中心化。已知存在问题，例如双花。这是因为单一资产转移到多个接收者，因为没有集中的来源来验证这些交易。当一个完全去中心化的加密货币——比特币在2009年创建时，所有这些问题都得到了解决。这是通过使用不可变的区块链在节点之间实现共识来首次解决了在去中心化网络中的双花问题。
- en: Bitcoin basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币基础
- en: Bitcoin is a collection of cryptography and decentralized consensus algorithms
    that enabled the creation of a complete decentralized digital currency ecosystem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是加密学和去中心化共识算法的集合，它使得创造一个完全去中心化的数字货币生态系统成为可能。
- en: Bitcoin can be used just like conventional currencies. It can be used to buy
    and sell goods and services or to just transfer money to people. Bitcoin has several
    advantages over conventional currencies, such as lower transaction costs and the
    ability to transfer currency to any part of the world, because it is not controlled
    by any national authorities. Bitcoin is also entirely virtual, meaning there is
    no physical form of the currency. The value of Bitcoin is generated by transactions
    in Bitcoin. Anyone can transfer Bitcoin to a particular Bitcoin address using
    a transaction. The address of the legitimate recipient of the Bitcoin will be
    identified by a secret key corresponding to the address. The user can then transfer
    the Bitcoin to others by constructing a new transaction using the secret key.
    Generally, a Bitcoin address is created using the public key, and the secret key
    is the private key counterpart of the public key. The keys are generally stored
    in a software application called a wallet, but they can also be backed up and
    stored anywhere if we need better security.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币可以像传统货币一样使用。可以用来购买和出售商品和服务，或者只是向他人转账。比特币相对于传统货币有一些优势，比如较低的交易成本以及能够将货币转账到世界上的任何地方，因为它不受任何国家当局控制。比特币也是完全虚拟的，意味着没有实体形式的货币。比特币的价值是通过比特币的交易产生的。任何人都可以通过交易将比特币转账到特定的比特币地址。合法接收比特币的地址将通过与地址对应的秘钥进行标识。然后用户可以使用秘钥构建一个新的交易将比特币转账给其他人。一般来说，比特币地址是使用公钥创建的，而秘钥是私钥的对应。这些秘钥通常存储在一个称为钱包的软件应用程序中，但如果我们需要更好的安全性，它们也可以被备份和存储在任何地方。
- en: As we know, Bitcoin is the system that paved the way for the invention of blockchain.
    It utilizes all the concepts we have discussed so far to build a cryptocurrency
    that functions in a completely decentralized **peer-to-peer** (**P2P**) system.
    Because of Bitcoin's completely decentralized network, there is no need for a
    central trusted authority, such as a bank, to act as a moderator and validate
    the transactions. Instead, everyone in the Bitcoin ecosystem participates in ensuring
    that valid transactions take place.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，比特币是铺就了区块链发明之路的系统。它利用了我们迄今为止讨论过的所有概念，构建了一个在完全去中心化的**点对点**（**P2P**）系统中运作的加密货币。由于比特币的完全去中心化网络，没有必要有一个像银行这样的中心信任机构充当调解者和验证交易。相反，比特币生态系统中的每个人都参与确保有效交易的进行。
- en: Bitcoin software is open source, and anyone can join the Bitcoin network by
    running this software on a device such as a smartphone or a computer. A lighter
    version of the Bitcoin software can be used on devices where the computing and
    storage capacity is limited. There is a special type of node called a miner, which
    uses processing power to verify transactions and contributes to the creation of
    blocks by solving a hard-cryptographic puzzle. This is a hash puzzle, more specifically
    called the Proof of Work consensus algorithm, which was discussed in [Chapter
    3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml), *Cryptography in Blockchain*.
    Every 10 minutes, a miner can publish a valid block, which is then propagated
    and validated by everyone on the Bitcoin network. The miner is rewarded in bitcoin
    for the computing power spent creating the block. Due to an increase in competition
    in mining, the difficulty of the puzzle has been adjusted so that the average
    block creation time remains around 10 minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币软件是开源的，任何人都可以通过在智能手机或计算机等设备上运行该软件来加入比特币网络。在计算和存储能力有限的设备上可以使用比特币软件的轻量级版本。有一种特殊类型的节点称为矿工，它使用处理能力来验证交易并通过解决一个难解的加密难题为区块的创建做出贡献。这是一个哈希难题，更具体地称为工作证明共识算法，在[第三章](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml)中讨论过，*区块链中的加密技术*。每
    10 分钟，一个矿工可以发布一个有效的区块，然后比特币网络中的每个人都会验证它。矿工以比特币作为奖励来补偿用于创建该区块的计算能力。由于挖矿竞争的加剧，难题的难度已经调整，以使平均区块创建时间保持在
    10 分钟左右。
- en: So, every time the miner creates a new block, new bitcoins are minted, which
    circulate in the Bitcoin network. There is a limit set on the total number of
    bitcoins that can circulate in the network, and it is hard-capped to 21 million
    coins.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当矿工创建一个新区块时，新的比特币就会产生，并在比特币网络中流通。对比特币网络的流通总量设置了一个上限，它被硬性限制在 2100 万枚硬币。
- en: 'To sum up, the following innovations helped Bitcoin to survive in a completely
    trustless network:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，以下创新帮助比特币在完全无需信任的网络中生存下来：
- en: A decentralized P2P network
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个去中心化的点对点（**P2P**）网络
- en: A blockchain (public ledger)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链（公共分类账）
- en: Decentralized consensus algorithm (Proof of Work)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散式共识算法（工作量证明）
- en: Transaction validation rules
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易验证规则
- en: Throughout this chapter, we will try to explain how Bitcoin uses these concepts,
    which made its creation possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将试图解释比特币如何利用这些概念，从而实现了它的创造。
- en: Getting started with Bitcoin Core
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用比特币核心
- en: Bitcoin is an experimental digital currency that is maintained by an open source
    community. Bitcoin Core is the name of open source software that enables the use
    of this currency. It's the original implementation of the Bitcoin system and whose
    initial release was created by Satoshi Nakamoto.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是由一个开源社区维护的实验性数字货币。比特币核心是一种开源软件，可实现该货币的使用。它是比特币系统的原始实现，最初由中本聪创建。
- en: Open source software is software whose source code is made available to the
    public with the right to read, modify, and redistribute it. Although open source
    code can be covered by different licenses, most of it is free to use for any purpose.
    Bitcoin is licensed under the MIT license.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件是指其源代码向公众开放，具有阅读、修改和重新分发的权利。虽然开源代码可以由不同的许可证覆盖，但大部分都可以免费用于任何目的。比特币是在MIT许可下发布的。
- en: Setting up a Bitcoin full node
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置比特币全节点
- en: A Bitcoin full node can be set up for development purposes, or just to enable
    a user to be a part of the Bitcoin network in order to validate or explore the
    transactions. The user has to set up all the tools, libraries, and dependent applications
    they may need if they want to set up a complete development environment, whereas
    a Bitcoin node can be set up without much effort just by installing the software.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币全节点可以用于开发目的，或者只是为了使用户成为比特币网络的一部分，以验证或探索交易。如果用户想要建立完整的开发环境，他们必须设置可能需要的所有工具、库和依赖应用程序，而安装软件只需不费吹灰之力。
- en: Installing a Bitcoin full node
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装比特币全节点
- en: As mentioned, installing a Bitcoin full node is much simpler than setting up
    a development environment. Bitcoin full nodes are ideal for users who want to
    be a part of the Bitcoin network but don't want to worry about any of its implementations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，安装比特币全节点比设置开发环境简单得多。比特币全节点非常适合想要成为比特币网络一部分但不想担心任何实现细节的用户。
- en: Running a Bitcoin full node has certain hardware requirements. It needs dedicated
    storage because it has to store all the blocks of the public ledger. At the time
    of writing, Bitcoin blockchain blocks occupy around 180 GB of storage. A Bitcoin
    full node also needs a decent amount of memory and processing power in order to
    validate the transactions of every block. Bitcoin can be installed on Linux, macOS,
    and Windows platforms quite easily.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行比特币全节点有一定的硬件要求。它需要专用存储空间，因为它必须存储公共分类账的所有区块。在撰写本文时，比特币区块链区块占用约180 GB的存储空间。比特币全节点还需要相当数量的内存和处理能力，以验证每个区块的交易。比特币可以相当轻松地安装在
    Linux、macOS 和 Windows 平台上。
- en: We will not be providing details about the installation here because it varies
    from platform to platform. You can find installation details for different platforms
    in the GitHub repository of the book ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain)).
    Moreover, you can find the installation instructions for all the platforms at
    [https://bitcoin.org/en/full-node](https://bitcoin.org/en/full-node).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里提供安装细节，因为它因平台而异。您可以在该书的 GitHub 存储库 ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain))
    中找到不同平台的安装详情。此外，您可以在[https://bitcoin.org/en/full-node](https://bitcoin.org/en/full-node)上找到所有平台的安装说明。
- en: Compiling from source code
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码编译
- en: A Bitcoin development environment is set up by compiling the source code obtained
    from the Bitcoin repository. The source code of Bitcoin Core is hosted in a GitHub
    repository under the MIT license. You can either clone and fetch all the branches
    or download the ZIP file of a specific release.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币开发环境是通过编译从比特币存储库获得的源代码来设置的。比特币核心的源代码托管在 GitHub 存储库中，使用 MIT 许可证。您可以克隆并获取所有分支，也可以下载特定版本的
    ZIP 文件。
- en: You can clone the Bitcoin Core project from the [https://github.com/bitcoin/bitcoin.git](https://github.com/bitcoin/bitcoin.git)
    repository using the Git tool. Once the project has been cloned, you can either
    use the latest master code or checkout to any of the release using the Git tag.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Git 工具从 [https://github.com/bitcoin/bitcoin.git](https://github.com/bitcoin/bitcoin.git)
    仓库克隆比特币核心项目。项目克隆后，您可以使用最新的主代码或使用 Git 标签检出任何发布版本。
- en: 'The build process might take up to an hour depending on the system''s hardware
    configuration. Compiling the source code involves only a few steps, but they are
    time-consuming:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程可能需要长达一个小时，具体时间取决于系统的硬件配置。编译源代码只涉及几个步骤，但它们耗时：
- en: 'As the first step, Bitcoin Core needs you to run a script called `autogen.sh`,
    which creates a set of automatic configuration scripts that examine the system
    and ensure that your system has all the libraries to compile the code. The shell
    script is executed as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，比特币核心需要您运行一个名为`autogen.sh`的脚本，该脚本创建一组自动配置脚本，检查系统并确保系统具有编译代码所需的所有库。脚本的执行如下：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to use the configure script to customize the build process
    by enabling or disabling certain features. We can build Bitcoin Core with the
    default features because most of Bitcoin Core''s features are required to set
    up a node. The configuration script is executed as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用配置脚本通过启用或禁用某些功能来自定义构建过程。因为大多数比特币核心功能都需要设置节点，所以我们可以使用默认功能构建比特币核心。配置脚本的执行如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the source code is compiled to create executables and install the
    created executables. This is achieved using the following commands:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，源代码将被编译以创建可执行文件，并安装创建的可执行文件。使用以下命令实现：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The installation of will create a binary called `bitcoind`, which creates the
    Bitcoin daemon process, and a command-line tool called `bitcoin-cli`, which is
    used to invoke Bitcoin APIs to communicate with the local Bitcoin node.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将创建一个名为`bitcoind`的二进制文件，它创建比特币守护进程，并创建一个名为`bitcoin-cli`的命令行工具，用于调用比特币 API
    与本地比特币节点进行通信。
- en: Running the Bitcoin node
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行比特币节点
- en: 'The Bitcoin daemon process is created when `bitcoind` is executed by creating
    a configuration file. The basic configuration file consists of a username and
    password for the JSON-RPC interface. There are several options that can be specified
    while running to Bitcoin node to alter its behavior. These options can also be
    specified in the configuration file. Execute `bitcoind --help` to list out the
    available options. `bitcoind` can be executed after the configuration file is
    created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`bitcoind`时，通过创建配置文件创建比特币守护进程。基本配置文件包括 JSON-RPC 接口的用户名和密码。在运行比特币节点时，可以指定几个选项来修改其行为。这些选项也可以在配置文件中指定。执行`bitcoind
    --help`以列出可用选项。创建配置文件后，可以执行`bitcoind`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will start Bitcoin Core as a background process. It may take several minutes
    to load the block index and verify the blocks. The `bitcoin-cli` tool can then
    be used to check the status once the `bitcoind` process has been created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为后台进程启动比特币核心。加载区块索引并验证区块可能需要几分钟时间。一旦创建了`bitcoind`进程，就可以使用`bitcoin-cli`工具检查状态。
- en: 'The following command shows some basic information about Bitcoin Core as well
    as some local blockchain information. The API was invoked on a `mainnet` chain
    that had mined 519,993 blocks at the time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示有关比特币核心的一些基本信息以及一些本地区块链信息。在调用 API 时，`mainnet`链在那时已经挖掘了 519,993 个区块：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Bitcoin has several blockchain networks formed by the bitcoin nodes. Each of
    these networks maintains different blockchain. Bitcoin's main network is called
    `mainnet` and it has a test network called `testnet`. More information on this
    topic is covered in the *Blockchain and networks* section of the chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币由比特币节点形成了几个区块链网络。每个网络维护不同的区块链。比特币的主网络称为`mainnet`，并且有一个称为`testnet`的测试网络。关于这个主题的更多信息在本章的*区块链和网络*部分有涉及。
- en: Communicating with the Bitcoin node
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与比特币节点通信
- en: Bitcoin Core provides an API through the JSON-RPC interface to facilitate communication
    with the Bitcoin node. Most of the consensus, wallet, and P2P Bitcoin operations
    can be performed on the node using this interface. Bitcoin uses `8332` as the
    default JSON-RPC server port for mainnet. Users should make sure not to allow
    arbitrary machines to access the JSON-RPC port. Exposing this interface would
    allow external machines to access private information, which could lead to theft.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币核心通过 JSON-RPC 接口提供 API，以便与比特币节点进行通信。可以使用此接口在节点上执行大多数共识、钱包和 P2P 比特币操作。比特币使用
    `8332` 作为主网的默认 JSON-RPC 服务器端口。用户应确保不允许任意机器访问 JSON-RPC 端口。暴露此接口将允许外部机器访问私人信息，这可能导致盗窃。
- en: Bitcoin has a command-line interface tool, `bitcoin-cli`, that can be used to
    access all the JSON-RPC APIs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币有一个命令行界面工具，名为 `bitcoin-cli`，可用于访问所有 JSON-RPC API。
- en: 'Any transaction details can be fetched using the `getrawtransaction` RPC command
    by specifying the transaction ID:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定交易 ID，可以使用 `getrawtransaction` RPC 命令获取任何交易的详细信息：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is a serialized transaction in hexadecimal format. This data can
    then be decoded using the `decoderawtransaction` API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是十六进制格式的序列化交易。然后可以使用 `decoderawtransaction` API 对此数据进行解码：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This generates a decoded transaction in a human-readable JSON format. We will
    discuss the decoded transactions in the *Transactions* section of the chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个以人类可读的 JSON 格式解码的交易。我们将在本章的 *交易* 部分讨论解码后的交易。
- en: Communicating using scripting language through the JSON-RPC implementation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 JSON-RPC 实现使用脚本语言进行通信
- en: 'Any programming language''s JSON-RPC implementation can be used to communicate
    with a Bitcoin node. Let''s execute an API using the Python JSON-RPC implementation,
    which will automatically generate all the Python methods for RPC calls. Python
    has several libraries with support for JSON-RPC, but we will be using `python-bitcoinlib`,
    which not only provides a JSON-RPC implementation but can also interface with
    Bitcoin data structures and protocols. The following Python script accepts a transaction
    ID in hexadecimal format and converts it into raw bytes using the `lx()` function.
    An RPC object, `proxy_connection`, which can be used to invoke any API, is created.
    The `gettransaction` API will fetch the decoded transaction of the transaction
    ID that was provided:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的 JSON-RPC 实现都可以用于与比特币节点进行通信。让我们使用 Python 的 JSON-RPC 实现执行一个 API，它将自动生成所有用于
    RPC 调用的 Python 方法。Python 有几个支持 JSON-RPC 的库，但我们将使用 `python-bitcoinlib`，它不仅提供了 JSON-RPC
    实现，还可以与比特币数据结构和协议进行接口交互。以下 Python 脚本接受十六进制格式的交易 ID，并使用 `lx()` 函数将其转换为原始字节。创建了一个
    RPC 对象 `proxy_connection`，它可以用来调用任何 API。`gettransaction` API 将获取所提供交易 ID 的解码交易：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Keys and addresses
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥和地址
- en: We have covered all the concepts of cryptography that will be required in order
    to understand the keys, addresses, and wallets used in cryptocurrency. In this
    section, we will get a thorough grounding of how keys and addresses are used to
    control the ownership of funds through cryptographic primitives.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在理解加密货币中使用的密钥、地址和钱包所需的所有加密学概念。在本节中，我们将深入了解密钥和地址如何通过密码原语来控制资金所有权。
- en: We have covered how asymmetric cryptography is used to create public/private
    keys, which identify the user accounts in the blockchain network. Bitcoin generates
    public/private key pairs that identify users and help them to claim ownership
    of funds through digital signatures. The private key is also called the secret
    key in cryptocurrency because it is kept secret from the public. Digital signatures
    are a prevalent concept in cryptography that allows the owner of the secret key
    to create a signature for a transaction and allow anyone to verify a transaction.
    Secret key owners manage all their keys using lightweight software called a wallet.
    Keys are independent of the blockchain protocol and are created and managed by
    the wallet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了非对称加密是如何用于创建区块链网络中的公钥/私钥，这些密钥标识用户帐户。比特币生成用于标识用户并帮助他们通过数字签名声称资金所有权的公钥/私钥对。私钥在加密货币中也称为密钥，因为它对公众保密。数字签名是密码学中常见的概念，它允许密钥所有者为交易创建签名，并允许任何人验证交易。密钥所有者使用称为钱包的轻量级软件管理其所有密钥。密钥独立于区块链协议，由钱包创建和管理。
- en: 'Bitcoin uses addresses to identify the Bitcoin user. These addresses are the
    encoded version of the public key derived from the user''s secret key. Let''s
    consider a banking example: Alice transfers the money to Bob by signing a check
    addressed to Bob. Bitcoin uses a similar approach by signing a transaction using
    the secret key and providing the recipient''s account number, which is the Bitcoin
    public address. The only public information is the account number, which is similar
    in concept to making the Bitcoin address public.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用地址来识别比特币用户。这些地址是从用户的秘密密钥派生的公共密钥的编码版本。让我们考虑一个银行业务的例子：爱丽丝通过签署一张支票并寄给鲍勃来向鲍勃转账。比特币使用类似的方法，通过使用秘密密钥签署交易并提供接收方的账户号码（比特币公共地址）来完成交易。唯一的公共信息是账户号码，这与将比特币地址公开的概念类似。
- en: Public and private keys
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共和私有密钥
- en: Public and private keys are generated using asymmetric cryptography. Private
    keys are kept secret in the users' wallets, whereas public keys are made public
    in the form of a Bitcoin address. Bitcoin uses elliptic curve cryptography to
    generate the public/private key pair. The private key is selected at random, and
    elliptic curve multiplication is performed to generate the public key. Elliptic
    curve multiplication is a one-way cryptographic function that makes it impossible
    to derive the private key from the exposed public key. You can explore the mathematical
    explanation and analysis of elliptical curve cryptography in [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称加密生成公共和私有密钥。私有密钥保密存放在用户的钱包中，而公共密钥以比特币地址的形式公开。比特币使用椭圆曲线加密生成公共/私有密钥对。私有密钥是随机选择的，并执行椭圆曲线乘法以生成公共密钥。椭圆曲线乘法是一种单向加密函数，使得从公开的公共密钥推导出私有密钥变得不可能。你可以在[第
    2 章](bbe822af-c535-4a33-9783-168d174c48c1.xhtml)，*一点点密码学*中探索椭圆曲线加密的数学解释和分析。
- en: Bitcoin's private key is a randomly selected 256-bit character string or 64-character
    hexadecimal string. This means that the private key can be any number between
    1 and 2^(256). So, it is impossible to find the corresponding private key of the
    public key just by brute-forcing 2^(256) combinations. The randomly generated
    private key is isolated from the Bitcoin network and maintained secretly in the
    Bitcoin wallet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的私有密钥是随机选择的 256 位字符串或 64 位十六进制字符串。这意味着私有密钥可以是介于 1 和 2^(256) 之间的任意数字。因此，通过暴力破解
    2^(256) 组合来找到公共密钥的对应私有密钥是不可能的。随机生成的私有密钥与比特币网络隔离，并在比特币钱包中保密存放。
- en: 'Bitcoin''s command-line interface can be used to generate secret keys. Bitcoin
    has a set of APIs that deal with keys and addresses. The following commands are
    performed on the local wallet. `dumprivkey` fetches the already existing private
    key, which was generated from the public key:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的命令行界面可用于生成秘密密钥。比特币有一套处理密钥和地址的 API。以下命令在本地钱包上执行。`dumprivkey` 获取已存在的从公共密钥生成的私有密钥：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Bitcoin public addresses
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币公共地址
- en: Public addresses in Bitcoin are produced from public keys, which consist of
    digits beginning with 1, or 3 for mainnet. Most Bitcoin addresses are 33 or 34
    characters long and use Base58-encoding. Bitcoin public key addresses always represent
    the owner of the secret key and are used in the recipient field of transactions.
    However, addresses can also have different uses, such as representing the payment
    script used in **Pay-to-Script-Hash** (**P2SH**) transactions, which will be covered
    in the *Transaction* section of this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的公共地址由以数字 1 或 3 开头的公共密钥生成。大多数比特币地址有 33 或 34 个字符长，并使用 Base58 编码。比特币公共密钥地址始终代表秘密密钥的所有者，并用于交易的接收者字段。然而，地址也可以有不同的用途，例如表示在本章的*交易*部分中将要介绍的**支付到脚本哈希**（**P2SH**）交易中使用的付款脚本。
- en: 'Bitcoin addresses are derived from the public key by constructing an encoded
    string called Base58Check. Base58Check is a Base58 encoded string along with fixed
    characters that acts as error-checking code. The Base58Check encoded string that
    represents Bitcoin address has three parts – a prefixed version byte, a payload
    derived from the public key, and the checksum. The version byte represents the
    type of Bitcoin address. *Table 5.1* shows a variety of prefixes found in the
    Bitcoin addresses:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币地址是通过构建一个名为Base58Check的编码字符串从公钥派生出来的。Base58Check是一个Base58编码的字符串，附带固定字符作为错误检查码。代表比特币地址的Base58Check编码字符串有三部分——一个前缀版本字节，一个从公钥派生出来的有效载荷，和一个校验和。版本字节代表比特币地址的类型。*表5.1*展示了在比特币地址中找到的各种前缀：
- en: '| **Prefix (Base58)** | **Use** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **前缀（Base58）** | **用途** |'
- en: '| 1 | Bitcoin pubkey hash (P2PKH address) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 比特币公钥哈希（P2PKH地址） |'
- en: '| 3 | Bitcoin script hash (P2SH address) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 比特币脚本哈希（P2SH地址） |'
- en: '| 5 | Private key (WIF) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 私钥（WIF） |'
- en: '| m or n | Bitcoin testnet pubkey hash |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| m 或 n | 比特币测试网公钥哈希 |'
- en: '| 2 | Bitcoin testnet script hash |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 比特币测试网脚本哈希 |'
- en: 'Table 5.1: Prefixes used as version bytes (Source: https://en.bitcoin.it)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：用作版本字节的前缀（来源：https://en.bitcoin.it）
- en: The second part of the Bitcoin public address is derived from the public key
    by hashing it using the `SHA256` and `RIPEMD160` hashing algorithms. As we already
    know, hashing functions are one-way functions, which makes it infeasible to derive
    the public key from the computed Bitcoin address.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币公共地址的第二部分是通过使用`SHA256`和`RIPEMD160`哈希算法对公钥进行哈希计算得到的。正如我们已经知道的，哈希函数是单向函数，这使得无法从计算出的比特币地址派生出公钥。
- en: 'In the following function, `K` is the public key derived from the private key,
    and `H` is the Bitcoin public key hash:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的函数中，`K`是从私钥派生出的公钥，`H`是比特币公钥哈希：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After constructing the hash value `H` using the hash functions, the third part
    of the address, a checksum, is computed from the resultant value. Finally, all
    the three parts are concatenated and encoded using Base58 encoding, which uses
    58 characters (please refer to [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, for more details regarding Base58 encoding) to create
    the Bitcoin public address in the Base58Check format as mentioned earlier:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希函数构建哈希值`H`后，地址的第三部分——校验和，是从结果值计算出来的。最后，三个部分被连接并使用Base58编码进行编码，Base58编码使用58个字符（请参阅[第2章](bbe822af-c535-4a33-9783-168d174c48c1.xhtml)，
    *密码学知识点*，了解Base58编码的更多详情）来创建比特币公钥地址，如前面提到的Base58Check格式：
- en: '![](img/f7fd2ac7-7d86-41a2-b3fd-865be49b4c0f.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7fd2ac7-7d86-41a2-b3fd-865be49b4c0f.png)'
- en: 'Figure 5.1: Generation of a Bitcoin public address from the public key'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：从公钥生成比特币公共地址
- en: '*Figure 5.1* shows how a 64-byte public key along with the 1-byte version is
    hashed initially to produce a 20-byte digest. This is the payload, which is then
    encoded to generate the Bitcoin address. But the final address also consists of
    checksum bits, which are used to protect against errors. This 4-byte checksum
    is calculated by hashing the payload twice using the SHA256 hash function and
    extracting the initial 4 bytes from the resulting 32-byte digest.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*显示了如何从64字节的公钥以及1字节的版本开始进行哈希计算，最初产生20字节的摘要。这就是有效载荷，然后对其进行编码以生成比特币地址。但最终地址还包括校验和位，用于防止错误。这4字节的校验和是通过使用SHA256哈希函数反复对有效载荷进行两次哈希计算并从结果的32字节摘要中提取初始4字节来计算出来的。'
- en: This checksum is concatenated with the payload and version byte. Finally, the
    resulting string is encoded using the Base58 encoding system to generate the Bitcoin
    address, which will identify the user who is holding the corresponding secret
    key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个校验和与有效载荷和版本字节连接起来。最后，得到的字符串使用Base58编码系统进行编码以生成比特币地址，这将标识持有相应密钥的用户。
- en: 'As we know, it is impossible for anyone to generate the private key from the
    publicly available Bitcoin address. This is due to the functions used to derive
    the public key. A public key is created using elliptical curve multiplication,
    which is a one-way function. Similarly, a Bitcoin address is derived from the
    public key by applying hash functions, which are one-way functions by nature.
    This prevents anyone from generating the public key from the Bitcoin public address
    as well:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，从公开的比特币地址中生成私钥是不可能的。这是由于用于派生公钥的函数。公钥是使用椭圆曲线乘法来创建的，这是一个单向函数。同样，比特币地址是通过应用哈希函数来自公钥派生出来的，这些函数本质上也是单向函数。这也防止了任何人从比特币公共地址中生成公钥：
- en: '![](img/333b075f-3293-45fb-af32-acb80bab0a2c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/333b075f-3293-45fb-af32-acb80bab0a2c.png)'
- en: 'Figure 5.2: The one-way functionality of Bitcoin address generation'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '图5.2: 比特币地址生成的单向功能'
- en: '*Figure 5.2* depicts the one-way functions used in the generation of the Bitcoin
    address. Although the Bitcoin address, which represents the identity of the entity
    holding the private key, is known to the public, the private key cannot be retrieved
    due to the one-way nature of these functions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.2*描述了比特币地址生成中使用的单向功能。虽然代表持有私钥实体的身份的比特币地址为公众所知，但由于这些功能的单向性质，无法检索私钥。'
- en: Transactions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易
- en: We have already covered many of the concepts used in Bitcoin that aid in the
    creation of a cryptocurrency in a decentralized network. Although every concept
    has a significant role in Bitcoin, transactions play a central role. Everything
    else in Bitcoin is designed to ensure that valid transactions are safely included
    in the blockchain and are propagated to the entire network of nodes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了比特币中用于在分布式网络中创建加密货币的许多概念。尽管比特币中的每个概念都在其中发挥着重要作用，但交易扮演着中心角色。比特币中的其他一切都旨在确保有效的交易安全地包含在区块链中并传播到整个节点网络中。
- en: Unlike traditional bookkeeping, in which an account-based ledger is used, Bitcoin
    maintains a transaction-based ledger. Every transaction entered into Bitcoin has
    to be validated before it is included in the blockchain. Bitcoin nodes refer to
    the transactions
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用基于账户的分类账的传统簿记不同，比特币维护基于交易的分类账。在将每笔交易输入比特币之前，必须对其进行验证。比特币节点引用这些交易。
- en: included in the other blocks or transaction mempool to validate every transaction.
    In this section, we will dig deep into concepts such as transaction creation,
    verification, and the components of transactions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在其他块或交易内存池中，以验证每个交易。在本节中，我们将深入探讨交易创建、验证和交易各部分的概念。
- en: A transaction mempool is a collection of unconfirmed transactions maintained
    by each Bitcoin node. The transactions in the mempool will be eventually included
    in the blockchain. A real-time view of the Bitcoin mempool can be observed at
    [https://www.blockchain.com/btc/unconfirmed-transactions](https://www.blockchain.com/btc/unconfirmed-transactions).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 交易内存池是每个比特币节点维护的未确认交易的集合。内存池中的交易最终将被包含在区块链中。可以在[https://www.blockchain.com/btc/unconfirmed-transactions](https://www.blockchain.com/btc/unconfirmed-transactions)上实时查看比特币内存池。
- en: Transactions at a high level
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易的高级概览
- en: 'Before diving into the low-level details of transactions and their components,
    let''s look at an example that illustrates a simple Bitcoin transaction from the
    user''s point of view. Let''s say Alice sends 0.1 bitcoin from her Bitcoin wallet
    to Bob''s wallet. Since she already has more than 0.1 bitcoin in her wallet, a
    valid transaction will be created and propagated to the network. *Figure 5.3*
    shows the transaction details in a block explorer application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解交易及其各部分的低级细节之前，让我们看一个例子，从用户角度说明了一个简单的比特币交易。假设Alice从她的比特币钱包向Bob的钱包发送了0.1比特币。由于她的钱包中已经拥有超过0.1比特币，将会创建一个有效的交易并传播到网络中。*图5.3*显示了在区块浏览器应用程序中的交易详情：
- en: '![](img/fb013ee2-902f-41c5-a4dd-5831c4567fe7.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb013ee2-902f-41c5-a4dd-5831c4567fe7.png)'
- en: 'Figure 5.3: Bitcoin transaction from Alice to Bob'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '图5.3: 从Alice到Bob的比特币交易'
- en: All the transaction details shown in this section are created using Bitcoin's
    `testnet` blockchain. You can check the transaction details by switching the Bitcoin
    node to the testnet blockchain. The block explorer application also runs in the
    testnet blockchain. You can verify the transactions at [https://testnet.blockexplorer.com](https://testnet.blockexplorer.com).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的交易详细信息均使用比特币的`testnet`区块链创建。您可以通过将比特币节点切换到testnet区块链来检查交易细节。区块浏览器应用程序也在testnet区块链中运行。您可以在[https://testnet.blockexplorer.com](https://testnet.blockexplorer.com)上验证这些交易。
- en: 'Transactions are visible to everyone who has access to the blockchain. A hex
    editor must be used to read transactions because they are not stored in a human-readable
    form. Bitcoin Core''s command-line interface can read raw transactions and decode
    them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 交易对所有访问区块链的人都是可见的。需要使用十六进制编辑器读取交易，因为它们不是以人类可读的形式存储的。比特币核心的命令行界面可以读取原始交易并对其进行解码：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getrawtransaction` API is used to retrieve the encoded transaction. It
    can be decoded using `decoderawtransaction`. These commands can be invoked using
    Bitcoin's command-line interface or using any RPC client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`getrawtransaction` API 用于检索编码的交易。可以使用`decoderawtransaction`对其进行解码。可以使用比特币的命令行界面或任何RPC客户端调用这些命令。'
- en: The readable version of the raw transaction has many fields and can be overwhelming
    at first glance. We will cover some of the components of the transaction in the
    following section, in order to make sense of the raw transaction.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 原始交易的可读版本具有许多字段，在第一眼看起来可能会很压倒性。我们将在接下来的部分中介绍交易的一些组成部分，以便理解原始交易。
- en: Transaction input and output
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易输入和输出
- en: Transactions are primarily constructed with input and output. Each transaction
    can have multiple inputs and outputs. Unlike account-based bookkeeping, Bitcoin
    needs to keep track of the output of every transaction. A node needs to have all
    the transaction output information in order to know the spendable balance of an
    account. The output can later be referenced in a transaction's input whenever
    a user wants to spend their cryptocurrency. This output consists of indivisible
    chunks of currency and can only be broken down after they are consumed in a transaction.
    The output that is not referenced in any of the transaction's input is referred
    to as **unspent transaction output** or **UTXO**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 交易主要由输入和输出构成。每个交易可以有多个输入和输出。与基于账户的簿记不同，比特币需要跟踪每笔交易的输出。节点需要拥有所有交易输出信息才能知道账户的可消费余额。当用户想要花费他们的加密货币时，输出可以在交易的输入中被引用。这个输出由不可分割的货币块组成，在交易中消耗后才能分割。在任何交易输入中都没有被引用的输出被称为**未消费交易输出**或**UTXO**。
- en: Whenever a user wants to spend the UTXO, it has to be spent entirely. After
    spending a UTXO, any excess is returned as one more UTXO to the user. This is
    similar to real-world currency, where coins cannot be broken down into lower values,
    and change is received for the excess amount paid. Let's consider our previous
    example, where Alice sends 0.1 bitcoin to Bob. As we can see in *Figure 5.3*,
    Alice doesn't have a UTXO of value 0.1\. So, Alice spends a transaction output
    of 0.325, which is greater than 0.1\. After sending 0.1 bitcoin to Bob, the rest
    of the amount is sent back to Alice, creating a new UTXO. As we can see from the
    transaction, Alice gets back slightly less than 0.225 bitcoin to her account.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户想要花费UTXO时，它必须完全花费。在花费UTXO后，任何多余的金额都将作为另一个UTXO返回给用户。这类似于现实世界中的货币，其中硬币无法分解为更小的值，并且会因支付超额金额而收到找零。让我们考虑之前的例子，阿丽斯向鲍勃发送了0.1比特币。正如我们在*图5.3*中所看到的，阿丽斯没有价值为0.1的UTXO。因此，阿丽斯消耗了价值为0.325的交易输出，这大于0.1。在向鲍勃发送0.1比特币后，剩余的金额将退回给阿丽斯，创建一个新的UTXO。从交易中我们可以看到，阿丽斯的账户得到了略少于0.225比特币的退款。
- en: This is due to the transaction fees levied when inserting the transaction into
    the blockchain. This fee will be given to the miner for performing Proof of Work.
    This transaction created two output values, 0.1 and ~0.225\. These two output
    values have to be consumed in their entirety by other input.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于在将交易插入区块链时收取的交易费。此费用将被支付给执行工作量证明的矿工。此交易创建了两个输出值，0.1 和 ~0.225。这两个输出值必须完全被其他输入消耗。
- en: Transaction output
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易输出
- en: As mentioned in the previous section, every transaction creates output that
    can be consumed later by a transaction input. Each full node client keeps track
    of all the UTXO so that each transaction input can be easily verified by checking
    the UTXO pool.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，每笔交易都会创建输出，后续交易输入可以消耗。每个完整节点客户端都会跟踪所有UTXO，以便通过检查UTXO池轻松验证每个交易输入。
- en: 'Let''s investigate the output of the earlier transaction between Alice and
    Bob. Transaction outputs are referenced with the `vout` key:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下之前阿丽斯和鲍勃之间交易的输出。交易输出使用`vout`键来引用：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `vout` is one of the outputs of the transaction. Each output has
    two major components, **value** and **cryptographic condition**, which explain
    who owns the transaction. In the preceding transaction, the output value indicates
    the bitcoin amount transferred to Bob, and `scriptPubKey` is the cryptographic
    condition (or the locking script), which ensures that the output amount can only
    be spent by Bob. `scriptPubKey` has several fields containing a locking script
    in serialized (`hex`) and deserialized (`asm`) format. It also provides some additional
    information, such as required signatures (`reqSigs`), type, and the public addresses
    of the recipient. Although the transaction output has several fields, only the
    locking script is of interest for a transaction, and other fields can be derived
    from it. Most of the locking script is a simple representation of the user's public
    address. We will look into locking scripts later in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的`vout`是交易的输出之一。每个输出都有两个主要组成部分，**价值**和**密码条件**，它们解释了谁拥有这笔交易。在前述交易中，输出值表示转账给鲍勃的比特币数量，`scriptPubKey`是密码条件（或锁定脚本），它确保输出金额只能被鲍勃花费。
    `scriptPubKey`具有几个包含序列化（`hex`）和反序列化（`asm`）格式的锁定脚本的字段。它还提供了一些额外信息，例如所需签名（`reqSigs`）、类型以及接收方的公共地址。虽然交易输出有几个字段，但对于一笔交易来说，只有锁定脚本是感兴趣的，其他字段可以由它派生。大部分锁定脚本是用户公共地址的简单表示。我们将在本章的后面更深入地研究锁定脚本。
- en: Transaction input
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易输入
- en: A transaction input references UTXOs whenever a user wishes to make a Bitcoin
    transaction. The transaction input uses an unlocking script to claim the UTXO.
    A valid transaction input proves the ownership of the UTXO with the help of this
    unlocking script.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望进行比特币交易时，交易输入会引用UTXO。交易输入使用解锁脚本来声明UTXO。有效的交易输入通过这个解锁脚本证明对UTXO的所有权。
- en: 'A transaction input can have multiple inputs pointing to multiple UTXOs. The
    transaction input makes sure that there are enough UTXOs to enable the transaction
    to take place. In the earlier example, the transaction input had a single input
    pointing to a UTXO:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交易输入可以有多个输入指向多个UTXO。交易输入确保有足够的UTXO使交易得以进行。在前面的示例中，交易输入有一个指向UTXO的单个输入：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A single UTXO was sufficient to fulfill the transaction. *Figure 5.3* shows
    that this single UTXO had a value of 0.325, which was enough to send a value of
    0.1 to Bob. The transaction input points to the UTXO by using the transaction
    ID (`txid`) and the sequence number of the transaction that created this UTXO.
    Like a transaction output, a transaction input contains an unlocking script that
    proves the user's claim on the UTXO and ensures that the transaction is valid.
    The spender initially retrieves the UTXO and references it using the transaction
    ID. An unlocking script is created with the secret information required to unlock
    the funds. A simple unlocking script will have a digital signature signed with
    a private key and the corresponding public key. However, the representation could
    be complex, but it's something we will cover in much more detail in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单个UTXO足以完成交易。*图5.3*显示，这个单个UTXO的价值为0.325，足以向鲍勃发送0.1的价值。交易输入通过使用交易ID（`txid`）和创建此UTXO的交易的序列号来指向UTXO。与交易输出一样，交易输入包含一个解锁脚本，用于证明用户对UTXO的索赔并确保交易有效。花费者最初检索UTXO并使用交易ID引用它。解锁脚本使用解锁资金所需的秘密信息。一个简单的解锁脚本将带有使用私钥签名的数字签名和相应的公钥。但是，表示可能是复杂的，但这是我们将在下一节更详细地介绍的内容。
- en: In the example, Alice uses `txid` to point to the spendable UTXO in the transaction.
    Alice then creates an unlocking script and places it in the `scriptSig` field
    of the transaction. Everyone who gets this transaction will validate it by checking
    the locking script in the UTXO.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，爱丽丝使用`txid`指向交易中可花费的UTXO。然后爱丽丝创建一个解锁脚本并将其放置在交易的`scriptSig`字段中。每个得到交易的人都将通过检查UTXO中的锁定脚本来验证它。
- en: As mentioned earlier, there is a transaction fee that Alice has to pay on top
    of the 0.1 bitcoin she intends to transfer to Bob. However, there is no transaction
    fee field in the raw transaction structure. It is calculated by checking the value
    of all referenced UTXOs and then subtracting this from the transaction input values
    in the transaction. This additional value, which is not tracked in the transaction
    output, forms the transaction fee. Each miner will calculate the fee for every
    transaction and rewards the combined value to themselves in a special coinbase
    transaction. We will cover more about the coinbase transaction in the *Mining
    and consensus* section of this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了 Alice 打算转账给 Bob 的 0.1 比特币之外，她还需要支付交易费用。但是，在原始交易结构中没有交易费用字段。通过检查所有引用的
    UTXO 的值然后从交易输入值中减去此值来计算。这不被跟踪在交易输出中的附加值形成交易费用。每个矿工将为每个交易计算费用，并将合并的值作为特殊的 coinbase
    交易奖励给自己。我们将在本章的*挖矿和共识*部分更多地涵盖 coinbase 交易。
- en: Transaction verification
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易验证
- en: Verification of the transaction is performed using an unlocking script and a
    locking script. Bitcoin uses a simple custom scripting language called Script,
    which is similar to the stack-based execution language Forth. To validate the
    transaction, the unlocking script in the input is executed alongside its corresponding
    locking script. The stack-based execution should return a true value and successfully
    execute the unlocking script.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 交易验证是通过解锁脚本和锁定脚本来执行的。比特币使用一种简单的自定义脚本语言称为 Script，它类似于基于堆栈的执行语言 Forth。为了验证交易，执行输入中的解锁脚本与其相应的锁定脚本。基于堆栈的执行应返回一个真值并成功执行解锁脚本。
- en: In the example, the input's `scriptSig` and the referenced output's `scriptPubKey`
    are evaluated (in that order), with `scriptPubKey` using the values left on the
    stack by `scriptSig`. The input is authorized if `scriptPubKey` returns true.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，按顺序评估了输入的 `scriptSig` 和引用的输出的 `scriptPubKey`，其中 `scriptPubKey` 使用 `scriptSig`
    留在堆栈上的值。如果 `scriptPubKey` 返回真，则授权输入。
- en: Script
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Script
- en: We need to understand the basic execution of the Script language before trying
    to make sense of the locking and unlocking scripts. Script is simple, a stack-based
    language that is processed from left to right. It is intentionally not Turing-complete.
    It doesn't have a complex control flow, such as loops, other than conditions.
    This makes sure that the program is executed in a predictable time. This was done
    intentionally to avoid denial-of-service attacks, which create infinite execution
    loops. The simplicity of the Script language ensures that Bitcoin is not vulnerable
    to any attacks of this nature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试理解锁定和解锁脚本之前，我们需要了解 Script 语言的基本执行方式。Script 是一个简单的基于堆栈的语言，从左到右进行处理。它有意地不是图灵完备的。它没有复杂的控制流程，如循环，除了条件。这确保了程序在可预测的时间内执行。这是有意为之，以避免拒绝服务攻击，这些攻击会创建无限执行循环。Script
    语言的简单性确保了比特币不会受到这种攻击的任何影响。
- en: Script is also stateless, meaning that there is no information stored prior
    to or after execution. This ensures that execution is not affected by any other
    aspects of the system and that scripts could be executed on any system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Script 也是无状态的，这意味着在执行之前或之后没有存储任何信息。这确保了执行不受系统的任何其他方面的影响，并且脚本可以在任何系统上执行。
- en: Script is a stack-based language because it uses a stack data structure during
    execution. A stack data structure performs push and pop operations on the data
    items. Push operations add an item to the top of the stack, and pop operations
    remove the last inserted item. Script executes the program by processing items
    from left to right. Data items are pushed to the stack whenever they are encountered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Script 是一种基于堆栈的语言，因为它在执行过程中使用堆栈数据结构。堆栈数据结构对数据项执行推送和弹出操作。推送操作将项添加到堆栈顶部，弹出操作删除最后插入的项。Script
    通过从左到右处理项来执行程序。每当遇到数据项时，就将其推送到堆栈上。
- en: Operators pop an item from the stack and perform operations on them, and then
    push the results back to the stack. Script has a huge set of operators, which
    are represented by opcodes that can be used on the items. Arithmetic opcodes such
    as `OP_ADD` perform addition on the top two items, whereas the conditional `OP_EQUAL`
    opcode evaluates a condition, producing a Boolean result. Bitcoin transaction
    scripts mostly consist of a conditional operator whose final result must evaluate
    to a true value if the transaction is to be considered valid.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员从堆栈中弹出一个项目并对它们执行操作，然后将结果推回到堆栈中。脚本具有一个庞大的操作员集合，这些操作员由操作码表示，可以用于项目上。诸如`OP_ADD`之类的算术操作码对堆栈顶部的两个项目执行加法，而条件`OP_EQUAL`操作码评估条件，产生布尔结果。比特币交易脚本主要由一个条件运算符组成，其最终结果必须在交易被视为有效时评估为真值。
- en: Script example
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: 'Let''s take a simple example to execute the script:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来执行该脚本：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Execution of the script starts from the left-hand side. The data constants `2`
    and `4` are inserted into the stack as soon as the execution begins. Next, the
    script performs an addition operation, represented by the `OP_ADD` operator. The
    addition operation is performed on the top two items of the stack after popping
    them, so *2 + 4 = 6*. The result is pushed back to the stack. The data constant
    `6` is pushed to the stack when it is encountered. Finally, the conditional `OP_EQUAL`
    operator is performed on the stack items. The last two items are popped from the
    stack and compared to see if they are equal. Since the last two data items in
    our stack are `6`, the equality condition will return a `TRUE` value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的执行从左边开始。当执行开始时，数据常量`2`和`4`被插入到堆栈中。接下来，脚本执行一个加法操作，由`OP_ADD`操作员表示。加法操作在弹出堆栈顶部的两个项目后执行，因此
    *2 + 4 = 6*。结果被推回到堆栈中。当遇到它时，数据常量`6`被推到堆栈中。最后，在堆栈项目上执行条件`OP_EQUAL`操作员。最后两个项目从堆栈中弹出并进行比较，以查看它们是否相等。由于我们堆栈中的最后两个数据项是`6`，所以相等条件将返回一个`TRUE`值。
- en: Locking and unlocking scripts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定和解锁脚本
- en: Bitcoin uses a similar method of script execution but has a different set of
    opcodes. Bitcoin transactions use locking and unlocking scripts, which are executed
    together to verify a transaction. As mentioned earlier, a locking script is a
    spending condition specified in the transaction output, and an unlocking script
    satisfies this condition when the two scripts are executed together.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用类似的脚本执行方法，但具有不同的操作码集。比特币交易使用锁定和解锁脚本，这些脚本一起执行以验证交易。如前所述，锁定脚本是在交易输出中指定的支出条件，而解锁脚本在执行两个脚本时满足这个条件。
- en: 'We can create a simple locking and unlocking script by breaking down the previous
    script example. Part of the script could form a locking script, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分解前面的脚本示例来创建一个简单的锁定和解锁脚本。脚本的一部分可以形成一个锁定脚本，如下所示：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This could only be satisfied by an unlocking script:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这只能通过解锁脚本来满足：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any node will validate these scripts by combining and executing the locking
    and unlocking scripts sequentially, as shown in the previous example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何节点都将通过按顺序组合和执行锁定和解锁脚本来验证这些脚本，就像前面的示例中所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But these are basic scripts, and anyone with basic arithmetical skill can create
    an unlocking script in order to spend the transaction output. This is why Bitcoin
    uses a complex condition with a cryptographic puzzle as a locking script. Only
    a legitimate owner who has the private key will be able to spend the funds by
    creating proof with an unlocking script.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些只是基本脚本，任何具有基本算术技能的人都可以创建一个解锁脚本以花费交易输出。这就是为什么比特币使用一个具有密码难题的复杂条件作为锁定脚本。只有具有私钥的合法所有者才能通过创建具有解锁脚本的证明来花费资金。
- en: The locking script in Bitcoin is referred to as `scriptPubKey`, as seen in the
    earlier transaction example in the *Transactions* section. This is due to the
    use of a public key hash (the Bitcoin address) in the locking script to transfer
    a fund to the owner of the corresponding private key. Similarly, an unlocking
    script can be found in the `scriptSig` field in the transaction input. The unlocking
    script generally proves the ownership of the private key corresponding to the
    public key by creating a digital signature. This is why the unlocking script is
    generally referred to as `scriptSig`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币中，锁定脚本被称为`scriptPubKey`，就像在*交易*部分的早期交易示例中看到的那样。这是因为在锁定脚本中使用了公钥哈希（比特币地址）来将资金转移到相应私钥的所有者。类似地，解锁脚本可以在交易输入的`scriptSig`字段中找到。解锁脚本通常通过创建数字签名来证明与公钥对应的私钥的所有权。这就是为什么解锁脚本通常被称为`scriptSig`的原因。
- en: In a similar way to the example, Bitcoin transaction validators validate transactions
    by executing the combined locking and unlocking scripts. Validators retrieve the
    UTXO referenced by the transaction input and place the locking and unlocking script
    side by side for sequential execution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于示例，比特币交易验证者通过执行合并的锁定和解锁脚本来验证交易。验证者检索交易输入引用的UTXO，并将锁定和解锁脚本并排放置以进行顺序执行。
- en: Types of transaction script
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易脚本类型
- en: Bitcoin currently creates two different basic `scriptSig`/`scriptPubKey` pairs.
    There are complex transaction scripts that are used rarely in Bitcoin transactions.
    **Pay-to-PubKeyHash** (**P2PKH**) and  **Pay-to-Script-Hash** (**P2SH**) are the
    most popular scripts. The majority of the scripts executed in the Bitcoin network
    use P2PKH as their transaction script.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币目前创建两种不同的基本`scriptSig`/`scriptPubKey`对。在比特币交易中很少使用复杂的交易脚本。**付款至公钥哈希**（**P2PKH**）和**付款至脚本哈希**（**P2SH**）是最受欢迎的脚本。比特币网络中执行的大多数脚本使用P2PKH作为它们的交易脚本。
- en: '**P2PKH**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**P2PKH**'
- en: Bitcoin transactions create an output transaction with a public key hash called
    P2PKH. The public key hash denotes the Bitcoin public address of the corresponding
    private key that a user holds. The user creates a locking script with the recipient's
    public address. No-one other than the holder of the corresponding private key
    will be able to claim the transaction output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易创建一个带有名为P2PKH的公钥哈希的输出交易。公钥哈希表示用户持有的相应私钥的比特币公共地址。用户使用接收者的公共地址创建一个锁定脚本。除了相应私钥的持有者外，没有人能够索取交易输出。
- en: In our earlier example, Alice creates a transaction input that contains `scriptSig`
    and transaction output with `scriptPubKey`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，Alice创建了一个包含`scriptSig`的交易输入，并使用`scriptPubKey`创建了交易输出。
- en: 'The following script shows the syntax of `scriptPubKey` and `scriptSig`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了`scriptPubKey`和`scriptSig`的语法：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The validator will combine the scripts and execute them sequentially:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者将合并脚本并按顺序执行它们：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The signature (`sig`) and public key (`pubKey`) recorded by the spender are
    pushed into the stack. The `OP_DUP` operator duplicates the `pubKey` in the stack.
    The next operator, `OP_HASH160`, calculates a 160-bit hash value of the public
    key using the `SHA256` and `RIPEMD160` algorithms:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 花费者记录的签名（`sig`）和公钥（`pubKey`）被推送到堆栈中。`OP_DUP`运算符在堆栈中复制`pubKey`。下一个运算符，`OP_HASH160`，使用`SHA256`和`RIPEMD160`算法计算公钥的160位哈希值：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `pubKeyHash` value in the locking script is pushed into the stack. The `OP_EQUALVERIFY`
    operator verifies that the public key hash created from the unlocking script and
    `pubKeyHash` value previously pushed to the stack are equal. It returns a `TRUE`
    value if the public key hashes of both the locking and unlocking scripts match.
    Finally, `OP_CHECKSIG` pops `sig` and `pubKey` from the stack, performs digital
    signature verification, and verifies that the signature is valid. Once the verification
    is successful, the script returns a `TRUE` value, indicating that unlocking script
    is valid.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定脚本中的`pubKeyHash`值被推入堆栈。`OP_EQUALVERIFY`运算符验证解锁脚本中创建的公钥哈希与之前推送到堆栈的`pubKeyHash`值是否相等。如果锁定和解锁脚本的公钥哈希匹配，则返回`TRUE`值。最后，`OP_CHECKSIG`从堆栈中弹出`sig`和`pubKey`，执行数字签名验证，并验证签名是否有效。一旦验证成功，脚本返回`TRUE`值，表示解锁脚本有效。
- en: '**P2SH**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**P2SH**'
- en: 'P2SH was introduced by one of the early Bitcoin developers, Gavin Andresen.
    According to Gavin Andresen, P2SH was created with a purpose:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: P2SH是早期比特币开发者之一**加文·安德森**引入的。根据加文·安德森的说法，P2SH是有目的地创建的：
- en: '"To move the responsibility for supplying the conditions to redeem a transaction
    from the sender of the funds to the redeemer."'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"将供应赎回交易的条件的责任从资金发送方移交给赎回方。"'
- en: – Andresen
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: – 安德森
- en: In P2SH, funds are addressed to the hash of the script instead of the public
    address. The script is called a redeem script, which houses all the conditions
    needed to spend the funds. As Gavin Andresen mentioned, the creator of the transaction
    doesn't have to worry about the conditions to spend the funds, and needs only
    mention the hash of the script containing the conditions. When the funds need
    to be spent, the redeemer should provide the script that matches the mentioned
    script hash and also make sure that the script evaluates to true.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在P2SH中，资金寻址到脚本的哈希而不是公共地址。这个脚本被称为赎回脚本，其中包含了花费资金所需的所有条件。正如Gavin Andresen所说，交易的创建者无需担心花费资金的条件，只需提及包含条件的脚本的哈希。当需要花费资金时，赎回者应提供与提及的脚本哈希匹配的脚本，并确保脚本求值为true。
- en: P2SH provides a means for complicated transactions to take place, unlike P2PKH,
    which has a specific definition for `scriptPubKey` and `scriptSig`. The specification
    places no limitations on the script, and therefore absolutely any script can be
    funded using these addresses. The concept of the script is similar to that of
    the smart contract, which will be covered in [Chapter 7](6bcd989e-2411-4096-91e1-943698f1702e.xhtml),
    *Diving into Blockchain – Proof of Ownership*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: P2SH提供了一种进行复杂交易的方式，不像P2PKH对`scriptPubKey`和`scriptSig`有特定的定义。该规范对脚本没有任何限制，因此任何脚本都可以使用这些地址进行资金支付。脚本的概念类似于智能合约的概念，这将在[第7章](6bcd989e-2411-4096-91e1-943698f1702e.xhtml)，*深入区块链-所有权的证明*中进行讨论。
- en: Mining and consensus
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖矿和共识
- en: Mining in Bitcoin is a crucial concept to achieve a consensus on the state of
    the blockchain in the decentralized Bitcoin network. Any node in the Bitcoin network
    can perform mining operations, and these nodes are rewarded with incentives for
    their contribution to mining. This has led to confusion between mining and incentivizing.
    Although incentives are part of mining, that is not the only intention of mining.
    Mining is a mechanism that underpins the decentralization of the Bitcoin network.
    It helps to achieve a consensus among the nodes in a trustless network by constructing
    a blockchain that is accepted by everyone.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的挖矿是在去中心化的比特币网络中实现区块链状态共识的一个至关重要的概念。比特币网络中的任何节点都可以执行挖矿操作，并且这些节点会因为它们对挖矿的贡献而获得激励。这导致了对挖矿和奖励之间的混淆。尽管奖励是挖矿的一部分，但挖矿并不只是为了奖励。挖矿是比特币网络去中心化的机制，通过构建一个被所有人接受的区块链，在不可信任的网络中实现节点之间的共识。
- en: 'Like any other Bitcoin node, a miner also validates new transactions and stores
    them locally in a memory pool. In addition to performing validation, a miner creates
    a block of transactions and solves a hash puzzle to include the created block
    in the global Bitcoin ledger. The miner will be rewarded with two types of incentive
    once the created block is included in the blockchain: the transaction fees of
    each transaction and the newly created bitcoins in each block. Transaction fees
    are the fees charged for the processing of each transaction, and the fee is attached
    by the creator of the transaction. Each block has a special transaction that creates
    new bitcoins and awards them to the miner responsible for the creation of the
    block. This special transaction, called a coinbase transaction, is responsible
    for the creation of new bitcoins.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他比特币节点一样，矿工也会验证新的交易并将它们存储在本地内存池中。除了执行验证，矿工还会创建一个交易块并解决哈希难题，以将创建的区块包括在全球比特币总账中。一旦创建的区块被纳入区块链，矿工将获得两种激励：每笔交易的交易费和每个区块中新创建的比特币。交易费是每笔交易处理所收取的费用，并且由交易的创建者附加。每个区块都有一个特殊的交易，创建新的比特币并将其授予负责创建区块的矿工。这种特殊的交易被称为coinbase交易，负责创建新的比特币。
- en: Since there is a hard cap on the total number of bitcoins that can be created
    (21 million), at some point in time in the future, miners will be only rewarded
    with incentives from the transaction fees. The maximum number of newly created
    bitcoins that the miner is rewarded halves for every 210,000 blocks created. Since
    each block's creation time is kept at around 10 minutes, 210,000 blocks are created
    every four years. The incentive started at 50 bitcoins per block in 2009 when
    Bitcoin was launched and was later halved in 2012, and again in 2016.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于比特币总量存在硬性上限（2100万枚），在未来的某个时间点，矿工只会从交易费用中获得激励。每挖掘出210,000个区块，矿工获得的新铸比特币最大数量就减半一次。由于每个区块的创建时间保持在约10分钟左右，每四年就会创建出210,000个区块。激励从2009年比特币启动时的每个区块50个比特币开始，之后在2012年和2016年分别减半。
- en: 'Currently, miners are rewarded with 12.5 newly minted bitcoins for every block
    they create:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每个区块的矿工奖励为12.5个新铸币的比特币：
- en: '![](img/2d1d0e5b-9b79-4cb8-98de-89d247d47803.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d1d0e5b-9b79-4cb8-98de-89d247d47803.jpg)'
- en: 'Figure 5.4: The supply of Bitcoin currency over the years till 2018 (Source:
    www.blockchain.info)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：截至2018年的比特币货币供应量（来源：www.blockchain.info）
- en: '*Figure 5.4* shows the supply of Bitcoin over time. The curve is geometrically
    decreasing due to the halving of the Bitcoin rewards for each block. The Bitcoin
    network is likely to supply 21 million coins by 2140\. The line in the graph will
    be almost parallel to the x-axis when it nears the year 2040.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.4*显示了比特币随时间的供应量。由于每个区块的比特币奖励减半，曲线呈几何减少趋势。比特币网络可能在2140年之前供应2100万枚硬币。当年份接近2040年时，图中的线将几乎平行于x轴。'
- en: Mining a block
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖掘一个区块
- en: Any node in the Bitcoin network can create a block and call itself a miner.
    A miner has to run a Bitcoin node maintaining the full blockchain. Although mining
    operations can be performed with minimal hardware requirements, due to high competition
    among Bitcoin nodes, mining on standalone computing hardware with a minimal hardware
    configuration is no longer profitable. This is why Bitcoin miners often run specialized
    computer hardware with higher processing power, such as GPUs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络中的任何节点都可以创建一个区块并自称为矿工。矿工必须运行维护完整区块链的比特币节点。虽然挖矿操作可以使用最小的硬件要求执行，但由于比特币节点之间的激烈竞争，使用最小硬件配置的独立计算硬件进行挖矿已经不再具有盈利性。这就是为什么比特币矿工经常运行具有更高处理能力的专用计算机硬件，如GPU。
- en: Due to the increased competition among miners, the mining difficulty of Bitcoin
    increased. Miners started building specialized integrated circuits designed specifically
    for mining purposes. These specialized integrated circuits are known as **Application-Specific
    Integrated Circuits** (**ASICs**), and they cannot be used for general-purpose
    computing. There are several Bitcoin ASIC manufacturers producing ASICs of different
    capacities. Bitmain's Antminer devices are the most widely used ASICs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于矿工之间的竞争加剧，比特币的挖矿难度增加了。矿工开始构建专门用于挖矿的专用集成电路。这些专用集成电路被称为**专用集成电路**（**ASICs**），它们不能用于通用计算。有几家比特币ASIC制造商生产不同规格的ASIC。Bitmain的Antminer设备是最广泛使用的ASIC。
- en: 'Each miner node will also listen to the Bitcoin network for new transactions
    and blocks. They perform several tasks before they conclude that they have successfully
    mined a new block:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矿工节点还将监听比特币网络以获取新的交易和区块。在得出他们已成功挖掘新区块之前，他们会执行几项任务：
- en: Verification of transactions
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易验证
- en: Aggregating transactions into blocks
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将交易汇总到区块中
- en: Mining the block using the Proof of Work algorithm
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作量证明算法挖掘区块
- en: Verification of transactions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易验证
- en: As we have seen, each valid transaction is created by collecting the UTXOs and
    unlocking them with appropriate scripts, before using the locking scripts, which
    will lock the funds for the next owner. The transaction is broadcast to the Bitcoin
    network so that everyone knows about the updated state of the blockchain. Broadcasting
    the transaction also makes sure that the transaction reaches a miner node and
    is included in any blocks that are created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个有效的交易是通过收集UTXO并使用适当的脚本来解锁它们，然后使用锁定脚本创建的，该脚本将资金锁定给下一个所有者。交易被广播到比特币网络，以便每个人都知道区块链的更新状态。广播交易还确保交易到达矿工节点并包含在任何创建的区块中。
- en: Although transactions are verified before they are broadcast to the network,
    a miner node always verifies each and every transaction before including it in
    the block. A single invalid transaction could result in the entire block being
    rejected by the Bitcoin network. To prevent unnecessary losses, a miner always
    ensures that only the valid transactions are included in the block.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管交易在广播到网络之前会被验证，但矿工节点在将其包含在区块之前总是验证每一笔交易。一个无效的交易可能会导致整个区块被比特币网络拒绝。为防止不必要的损失，矿工总是确保只有有效的交易被包含在区块中。
- en: Aggregating transactions into a block
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将交易聚合到一个区块中
- en: Just like any full node in the Bitcoin network, a miner accumulates all the
    transactions it receives and adds them to the local memory pool. A miner will
    start constructing a candidate block that could be inserted into the blockchain
    by including a set of transactions in the block. The node will make sure that
    any time a new block arrives during the block construction process, all the transactions
    in the newly-arrived block should be omitted from the candidate block because
    this would create duplicate transactions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像比特币网络中的任何完整节点一样，矿工会累积它收到的所有交易，并将它们添加到本地内存池中。矿工将开始构建一个候选区块，该区块可以通过包含区块中的一组交易来插入区块链。节点会确保在区块构建过程中每次有新区块到来时，候选区块中的所有交易都应该被忽略，因为这将创建重复的交易。
- en: Once all the metadata of the block and transactions are created for the block,
    the miner solves the hash puzzle by performing Proof of Work. The block is broadcasted
    to the Bitcoin network as soon as it successfully creates a Proof of Work for
    it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为区块和交易创建了所有的元数据，矿工通过执行工作证明（Proof of Work）来解决哈希难题。一旦成功为区块创建了工作证明，该区块就会立即被广播到比特币网络中。
- en: Coinbase transactions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coinbase 交易
- en: Every block created in the Bitcoin blockchain has a special type of transaction,
    which is the first transaction of the block. This transaction is created by the
    miner, which rewards itself with incentives earned from transaction fees and newly
    created bitcoins, as mentioned earlier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链中创建的每个区块都有一种特殊类型的交易，即区块的第一笔交易。这笔交易是由矿工创建的，用于奖励自己通过交易费和新创建的比特币，就像前面提到的那样。
- en: 'Here is the coinbase transaction of Bitcoin mainnet block 520,956\. Decoding
    the first transaction of the block will give these details:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比特币主网区块 520,956 的 coinbase 交易。解码该区块的第一笔交易将给出以下细节：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Coinbase transactions don't have any references to a UTXO in the transaction
    input because the amount is created from new coins and transaction fees. The address
    mentioned in the transaction output is the miner's own Bitcoin address, so the
    entire fund of the coinbase transaction is transferred solely to the miner.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Coinbase 交易在交易输入中没有任何指向未使用交易输出 (UTXO) 的引用，因为该金额是来自新币和交易费。交易输出中提到的地址是矿工自己的比特币地址，因此
    coinbase 交易的所有资金都被完全转移到了矿工名下。
- en: Mining a block using the Proof of Work algorithm
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作证明算法挖掘区块
- en: The Proof of Work algorithm is used in Bitcoin to achieve consensus in the Bitcoin
    network about the blocks that belong to the blockchain. It helps to achieve consistency
    of data in the ledger among the nodes in the network. The Proof of Work algorithm
    creates proof that a certain amount of work has been done to create the block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 工作证明算法在比特币中用于在比特币网络中达成关于属于区块链的区块的共识。它有助于在网络中的节点之间实现分类帐数据的一致性。工作证明算法可以创建证明一定量的工作已经被完成以创建区块。
- en: Bitcoin's Proof of Work is a hash puzzle that uses the SHA256 hash function
    to find the required hash value and thus solve the puzzle. The Proof of Work algorithm
    used in Bitcoin is similar to the one explained in [Chapter 3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml),
    *Cryptography in Blockchain*. You can refer to [Chapter 3](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml), *Cryptography
    in Blockchain*, for more details regarding the implementation and analysis of
    the Proof of Work algorithm.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的工作证明是一个使用 SHA256 哈希函数寻找所需哈希值并解决难题的哈希难题。比特币中使用的工作证明算法类似于 [第 3 章](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml)《区块链中的密码学》
    中解释的算法。您可以参考 [第 3 章](6d775eaf-4ee6-4463-b5e9-623f49c80aca.xhtml)《区块链中的密码学》来获取有关工作证明算法的实现和分析的更多细节。
- en: Mining pool
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖矿池
- en: We are aware that mining difficulty in Bitcoin is adjusted to maintain an average
    block creation time of 10 minutes. But due to high competition among miners, the
    difficulty of solving the hash puzzle has increased over time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，比特币中的挖矿难度会调整以保持平均区块创建时间为10分钟。但由于矿工之间的激烈竞争，解决哈希难题的难度随着时间的推移而增加。
- en: This has forced the miners to upgrade their hardware to achieve higher hash
    rates. Miners who had limited resources couldn't compete with miners who owned
    huge computing resources. This was when the mining pool was introduced to pool
    the resources of individual miners with limited resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使矿工升级其硬件以实现更高的哈希率。拥有有限资源的矿工无法与拥有大量计算资源的矿工竞争。这就是引入矿池的时候，用于汇集个人有限资源矿工资源的时候。
- en: A mining pool is a pooling of computing resources of miners to share the computing
    power and attain a higher hash rate to solve the hash puzzle. If the combined
    hash power of the mining pool solves the hash puzzle for a block, each miner who
    is part of the mining pool is rewarded based on the amount of hash power contributed.
    There are a number of mining pools implemented in different languages. A miner
    can join any of the mining pool servers and start contributing the hash power.
    Slush Pool is the oldest mining pool and was formerly known as **Bitcoin.cz Mining**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个矿池是矿工计算资源的集合，用于共享计算能力并获得更高的哈希率以解决哈希难题。如果矿池的组合哈希能力解决了一个区块的哈希难题，那么每个加入矿池的矿工都将根据其贡献的哈希能力获得奖励。在不同语言中实现了许多矿池。矿工可以加入任何一个矿池服务器并开始贡献哈希能力。Slush
    Pool是最古老的矿池，曾被称为**Bitcoin.cz Mining**。
- en: Mining pools use different protocols to communicate between the miner and the
    mining pool server. The getblocktemplate, getwork, and stratum protocols are some
    of the mining protocols used in the mining pools. The stratum mining protocol
    is a widely used protocol that was designed as a replacement for the getwork protocol.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 矿池使用不同的协议在矿工和矿池服务器之间进行通信。getblocktemplate、getwork和stratum协议是矿池中使用的一些挖矿协议。stratum挖矿协议是一种广泛使用的协议，旨在取代getwork协议。
- en: 'Each miner connected to the mining pool server has to follow a few steps to
    successfully contribute to the pool mining:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到矿池服务器的每个矿工都必须遵循一些步骤才能成功贡献到矿池挖矿中：
- en: A miner has to authorize themselves with the right credentials before working
    on a job
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矿工必须在开始工作之前使用正确的凭据进行授权。
- en: They then need to fetch the set of transactions for a job
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后他们需要获取一个工作的交易集。
- en: Finally, the miner needs to submit the work to the server along with username
    and job details
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，矿工需要将工作提交给服务器，并附上用户名和工作细节。
- en: There are several ways in which a miner's share can be distributed. Most of
    the mining pool rewards the miner based on the miner's share for the block that
    was created by the pool.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以分配矿工的份额。大多数矿池根据矿池创建的区块的矿工份额对矿工进行奖励。
- en: The hash rate is the unit used in blockchain mining to determine the computing
    power or the hashing power of the miner. It is nothing but the number of hashes
    produced per second.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希率是区块链挖矿中用于确定矿工的计算能力或哈希能力的单位。它只是每秒钟产生的哈希数量。
- en: Blockchain
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链
- en: The blockchain in Bitcoin is a collection of an ordered lists of blocks that
    connects the previous block with the hash pointer. Bitcoin uses Google's `LevelDB`
    database to store the blockchain metadata. The identity of each block is created
    by using the SHA256 hash value of the block header, and this block hash is stored
    in the block header of the next block in the blockchain in order to form a link.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中的区块链是一系列有序的区块列表，将上一个区块与哈希指针连接起来。比特币使用Google的`LevelDB`数据库存储区块链元数据。每个区块的身份是通过使用区块头的SHA256哈希值创建的，并且该区块哈希值存储在区块链中下一个区块的区块头中，以形成链接。
- en: Block structure
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块结构
- en: The data structure of a Bitcoin block holds a collection of transactions and
    metadata information about the block. A block is made up of a header and body,
    which consists of all the transactions. A block holds more than 500 transactions,
    on average.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块的数据结构包含一系列交易和关于该区块的元数据信息。一个区块由头部和体部组成，其中包含所有交易。一个区块平均包含500多个交易。
- en: '*Table 5.2* shows all the fields that are included in a block. The dominant
    part of the block is the header and transactions, which would occupy variable
    size. Each field shows the size or the transactions occupied in the block:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*表5.2* 展示了区块中包括的所有字段。区块的主要部分是头和交易，占用的大小会有所不同。每个字段展示了区块中的大小或者交易所占用的大小：'
- en: '| **Field** | **Description** | **Size** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **描述** | **大小** |'
- en: '| Magic no | The value is always 0xD9B4BEF9 | 4 bytes |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 魔数 | 值始终为0xD9B4BEF9 | 4字节 |'
- en: '| Block Size | Number of bytes up to the end of the block | 4 bytes |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 区块大小 | 截至区块末尾的字节数 | 4字节 |'
- en: '| Block Header | Consists of six items | 80 bytes |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 区块头 | 包括六个项目 | 80字节 |'
- en: '| Transaction Counter | Integer count | 1 - 9 bytes |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 交易计数器 | 整数计数 | 1 - 9字节 |'
- en: '| Transactions | List of transactions | Variable |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 交易 | 交易列表 | 可变 |'
- en: 'Table 5.2: The block structure'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：区块结构
- en: Block header
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块头
- en: The block header stores the metadata of the block, and its size is 80 bytes,
    as shown in the previous table. It stores version information with which you can
    identify the block. `hashPrevBlock` stores a 256-bit hash value of the previous
    block, which links the blocks and ensures the integrity of the blockchain. `hashMerkleRoot`
    is the hash digest of the transactions and ensures the integrity of transactions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 区块头存储了区块的元数据，其大小为80字节，如前表所示。它存储了版本信息，可以用来识别区块。`hashPrevBlock`存储了前一个区块的256位哈希值，将区块链接起来，并确保区块链的完整性。`hashMerkleRoot`是交易的哈希摘要，并确保了交易的完整性。
- en: 'The time, difficulty bits, and nonce fields are related to the Proof of Work
    consensus algorithm:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 时间、难度位和随机数字段与工作量证明共识算法有关：
- en: '| **Field** | **Purpose** | **Size** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **用途** | **大小** |'
- en: '| `Version` | Block version | 4 bytes |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `Version` | 区块版本 | 4字节 |'
- en: '| `hashPrevBlock` | 256-bit hash of the previous block header | 32 bytes |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `hashPrevBlock` | 上一个区块头的256位哈希 | 32字节 |'
- en: '| `hashMerkleRoot` | 256-bit hash based on all of the transactions in the block
    | 32 bytes |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `hashMerkleRoot` | 基于区块中所有交易的256位哈希 | 32字节 |'
- en: '| `Time` | Current timestamp in seconds since 1970-01-01T00:00 UTC | 4 bytes
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `时间` | 从1970-01-01T00:00 UTC以来的当前时间戳（秒） | 4字节 |'
- en: '| `Difficulty Bits` | Current target in a compact format ([https://en.bitcoin.it/wiki/Target](https://en.bitcoin.it/wiki/Target))
    | 4 bytes |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `Difficulty Bits` | 以紧凑格式表示的当前目标（[https://en.bitcoin.it/wiki/Target](https://en.bitcoin.it/wiki/Target)）
    | 4字节 |'
- en: '| `Nonce` | 32-bit number (starts at 0) | 4 bytes |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Nonce` | 32位数字（从0开始） | 4字节 |'
- en: 'Table 5.3: The block header'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3：区块头
- en: The genesis block
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创世区块
- en: The genesis block, which is the first block in a blockchain, in Bitcoin was
    created by Satoshi Nakamoto. It is statically coded so that everyone who runs
    a Bitcoin core node will only believe one blockchain state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创世区块是比特币区块链中的第一个区块，由中本聪创建。它是静态编码的，以便每个运行比特币核心节点的人只会相信一个区块链状态。
- en: 'The genesis block hash can be fetched by fetching the block hash of the 0^(th)
    index:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过获取第0个索引的区块哈希来获取创世区块的哈希：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following are the block details of the Bitcoin genesis block. This block
    has a coinbase transaction and no other transactions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比特币创世区块的详细信息。该区块中有一个coinbase交易，没有其他交易：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The coinbase transaction of the block has the following text, along with the
    normal data in its transaction input:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 区块的coinbase交易除了有其交易输入中的正常数据外，还有以下文本：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This proves that the first block was mined on or after January 3, 2009\. The
    coinbase transaction also has an output transaction of 50 bitcoins, just like
    any other coinbase transaction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明第一个区块是在2009年1月3日或之后挖掘出来的。coinbase交易也有一个输出交易，价值50比特币，就像任何其他coinbase交易一样。
- en: Merkle trees
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默克尔树
- en: A Bitcoin header has metadata that summarizes all the transactions present in
    the block. This is achieved by creating a digest using a special type of tree
    called a Merkle hash tree. As mentioned in [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, a Merkle hash tree is a binary hash tree that is used
    to summarize large sets of data. Merkle trees are used to summarize all the transactions
    in Bitcoin and thus ensure the integrity of the transactions. They provide an
    efficient way to verify whether a transaction is included in the block.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的区块头包含了总结区块中所有交易的元数据。这是通过使用一种称为默克尔哈希树的特殊类型树来创建摘要而实现的。正如在[第2章](bbe822af-c535-4a33-9783-168d174c48c1.xhtml)
    *密码学概要* 中所提到的，默克尔哈希树是一种用于总结大型数据集的二进制哈希树。默克尔树用于总结比特币中的所有交易，并确保交易的完整性。它们提供了一种高效的方法来验证交易是否包含在区块中。
- en: Merkle trees recursively hash the nodes, starting from the leaves, which are
    hashes of transactions, until there is only one hash. This hash value summarizes
    all the transactions in the block and is called the Merkle root. Bitcoin applies
    the SHA256 hash function twice to create the hash of a transaction.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 默克尔树从叶子开始递归地对节点进行哈希，叶子是交易的哈希，直到只剩下一个哈希。这个哈希值总结了区块中的所有交易，称为默克尔根。比特币对交易的哈希应用了两次SHA256哈希函数。
- en: When there are *N* transactions in a block, the Merkle tree ensures that it
    doesn't need more than *2*log2(N)* calculations to check whether the transaction
    is included in the block. This makes the Merkle tree implementation a very efficient
    way to verify whether a transaction is included, as well as to check integrity.
    Merkle trees are efficient in cases with large numbers of transactions. Even though
    the number of transactions in a block increases exponentially, the path required
    to verify a transaction will always be logarithmic due to the binary tree nature
    of the Merkle tree.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个区块中有*N*个交易时，默克尔树确保只需*2*log2(N)*次计算就可以检查交易是否包含在区块中。这使得默克尔树实现成为一种非常高效的验证交易是否包含以及检查完整性的方式。在交易数量大的情况下，默克尔树非常高效。即使区块中的交易数量呈指数增长，由于默克尔树的二叉树性质，验证交易所需的路径始终是对数的。
- en: Blockchain networks
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链网络
- en: The Bitcoin blockchain network is formed of decentralized nodes, and each node
    communicates with the others using the P2P networking protocol. Each node running
    the Bitcoin client contributes to the growth of the blockchain and the network.
    Surprisingly, the Bitcoin network consists of nodes that deal with multiple public
    blockchains. The main blockchain, which is used to hold transactions with actual
    value, is called **mainnet**. This is the longest blockchain, with the highest
    number of participating nodes. Besides mainnet, Bitcoin has several other blockchains
    for testing purposes. Currently, Bitcoin has the **testnet**, **segnet**, and
    **regtest** blockchain networks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链网络由分散的节点组成，每个节点使用P2P网络协议与其他节点通信。每个运行比特币客户端的节点都有助于区块链和网络的增长。令人惊讶的是，比特币网络由处理多个公共区块链的节点组成。用于保存具有实际价值交易的主要区块链被称为**主网**。这是最长的区块链，参与节点数量最多。除了主网之外，比特币还有几个用于测试的其他区块链。目前，比特币有**测试网**、**segnet**和**regtest**区块链网络。
- en: Testnet
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网
- en: Testnet is the Bitcoin blockchain version that was created solely for testing
    purposes. The testnet blockchain works on the same network as mainnet, with features
    such as wallets, transactions, and mining. The only difference is that the coins
    circulated in testnet don't have any monetary value. Testnet was created as a
    test network that can be used by developers to check features and fixes before
    they are deployed in mainnet. Testing on testnet is crucial because it is impossible
    to revert the mainnet blockchain due to the decentralization. Testnet is supposed
    to work with a lightweight configuration by keeping the mining difficulty to a
    minimum so that even simple hardware can be used for testing. But people tend
    to use high-configuration hardware in the testing network, which increases the
    mining difficulty. Every now and then, testnet is recreated by propagating a new
    genesis block and resetting the difficulty. The current iteration of testnet is
    called testnet 3.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网是专为测试目的而创建的比特币区块链版本。测试网区块链与主网相同的网络上运行，具有钱包、交易和挖矿等功能。唯一的区别是，在测试网中流通的硬币没有任何货币价值。测试网被创建为一个测试网络，开发人员可以在将功能和修复部署到主网之前检查它们。在测试网上进行测试是至关重要的，因为由于分散化，不可能回滚主网区块链。测试网应该通过保持挖矿难度最低来使用轻量级配置，以便甚至可以使用简单的硬件进行测试。但人们倾向于在测试网络中使用高配置的硬件，这会增加挖矿难度。不时地，通过传播一个新的创世区块并重置难度来重新创建测试网。当前版本的测试网被称为测试网3。
- en: 'A testnet blockchain can be created using Bitcoin Core by creating a separate
    daemon process:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建单独的守护进程使用比特币核心来创建一个测试网区块链：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates a new process, which creates a new testnet blockchain copy. The
    testnet blockchain is considerably smaller than mainnet. The testnet blockchain
    syncs all the blocks much more quickly than the mainnet blockchain. Bitcoin''s
    command-line interface is invoked with a similar argument:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的进程，它创建一个新的测试网区块链副本。测试网区块链比主网小得多。测试网区块链比主网区块链更快地同步所有区块。比特币的命令行界面通过类似的参数调用：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In 2016, a special-purpose testnet called segnet was created to test the Bitcoin
    Segregated Witness feature. It is no longer required to run a separate network,
    however, because the segnet feature has been added to testnet 3.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，一个名为segnet的专用测试网络被创建，用于测试比特币的隔离见证功能。然而，由于segnet功能已经添加到测试网络3中，不再需要运行一个单独的网络。
- en: Regtest
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归测试
- en: 'Regtest is a testing blockchain for regression purposes. Unlike testnet, regtest
    is not a public blockchain. Regtest is a blockchain that can be created by a user
    for local testing purposes. This is ideal for testing features that don''t need
    to interact very much with the network. You can create your version of the blockchain
    with a local genesis block. Similar to testnet, a regtest flag is added to the
    command to launch the process:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是用于回归目的的测试区块链。与测试网络不同，回归测试不是一个公共区块链。回归测试是一个可以由用户为本地测试目的创建的区块链。这对于测试不需要与网络进行大量交互的功能非常理想。您可以使用本地创世区块创建您自己的区块链版本。与测试网络类似，命令中添加了一个回归测试标志来启动进程：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since the blockchain is a local copy, the user can mine the blocks without
    worrying about the consensus. The following command mines 500 blocks within a
    few seconds, and the user will be rewarded with coins in each coinbase transaction:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链是一个本地副本，用户可以在不担心共识的情况下挖掘区块。以下命令在几秒钟内挖掘了500个区块，并且用户将在每个coinbase交易中获得硬币作为奖励：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Bitcoin hard forks and altcoins
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币硬分叉和另类币
- en: A hard fork in Bitcoin is an update to the protocol that will not entertain
    the older protocol, thus requiring everyone to upgrade. Hard fork upgrades often
    include major changes such as changing the blockchain structure, transaction,
    or consensus rules. The major difference between a soft fork and hard fork is
    that the latter is not backward compatible, meaning that the older system will
    not function in the updated protocol.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的硬分叉是协议的更新，不会支持旧协议，因此需要所有人升级。硬分叉升级通常包括重大更改，如改变区块链结构、交易或共识规则。软分叉和硬分叉之间的主要区别在于后者不向后兼容，这意味着旧系统在更新的协议中将无法运行。
- en: There will be two different versions of blockchain after the blockchain hard
    fork. The multiple versions of blockchain are a result of disagreement among the
    blockchain nodes to follow a single protocol. Blockchain hard forks often result
    in protocol upgrades. Bitcoin has had several hard forks, which has resulted in
    the creation of Bitcoin forked cryptocurrencies. Bitcoin Cash was the first successfully
    hard-forked cryptocurrency, which was forked at the 478,558^(th) block of Bitcoin
    on 1st August, 2017\. Bitcoin Cash was mainly created to increase the block size
    to 8 MB. Bitcoin Gold and Bitcoin Private were the other two successful hard forks
    that followed Bitcoin Cash.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链硬分叉后将会有两个不同版本的区块链。区块链节点之间对遵循单一协议的分歧导致了多个版本的区块链。区块链硬分叉通常会导致协议升级。比特币曾经有过几次硬分叉，这导致了比特币分叉加密货币的诞生。比特币现金是第一个成功的硬分叉加密货币，于2017年8月1日在比特币的第478,558^(th)个区块上分叉。比特币现金主要是为了增加区块大小到8
    MB而创建的。比特币黄金和比特币私人是随后跟随比特币现金的另外两个成功的硬分叉。
- en: Altcoins, or alternative coins are the cryptocurrencies launched after the success
    of Bitcoin. Altcoins are created on a separate blockchain, unlike Bitcoin's hard
    forked cryptocurrencies. Most altcoins use the basic framework provided by Bitcoin
    and try to solve its existing limitations. Few of the coins have tried to increase
    the transaction speed by using alternative algorithms to Proof of Work, and few
    others have tried to enhance security by increasing the anonymity of the transactions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 替代币，或者另类币是在比特币成功之后推出的加密货币。另类币是在单独的区块链上创建的，不像比特币的硬分叉加密货币。大多数另类币使用比特币提供的基本框架，并尝试解决其现有的限制。其中一些币尝试通过使用替代的工作证明算法来增加交易速度，而另一些币尝试通过增加交易的匿名性来增强安全性。
- en: Namecoin was one of the initial well-known altcoins that were based on Bitcoin.
    Litecoin, Zcash, Dogecoin, and Ethereum are a few of the coins that followed Namecoin.
    Litecoin is the closest implementation of Bitcoin and has a reputation of being
    the silver to Bitcoin's gold. Litecoin has a total supply of 84 million coins,
    which is four times that of Bitcoin. It also increases the transaction speed by
    reducing the block creation time. Litecoin uses a memory-intensive Proof of Work
    algorithm called Scrypt.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Namecoin是最初基于比特币的知名替代币之一。莱特币、Zcash、狗狗币和以太坊是跟随Namecoin的一些货币。莱特币是对比特币最接近的实现，并且被认为是比特币的银子。莱特币的总供应量为8400万枚，是比特币的四倍。它还通过减少块创建时间来提高交易速度。莱特币使用一种内存密集型的工作证明算法，称为Scrypt。
- en: Thousands of altcoins have been created since the invention of Bitcoin, and
    the number keeps growing every day. However, Bitcoin is the most widely used cryptocurrency
    to date.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 自比特币发明以来已经创建了数千种替代币，并且这个数量每天都在增长。然而，到目前为止，比特币是最广泛使用的加密货币。
- en: A simple cryptocurrency application
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的加密货币应用程序
- en: 'Creating a cryptocurrency application will allow us to implement all the blockchain
    concepts we''ve looked at so far, along with the transaction structure used in
    Bitcoin, and we can then deploy it in a fully P2P network. We created a blockchain
    application in a decentralized P2P network in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml),
    *Networking in Blockchain*. We will be using the same application to create and
    propagate the blocks in the network, but also extend the application with the
    concepts of transactions and wallets to create a completely decentralized cryptocurrency:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个加密货币应用程序将使我们能够实现我们到目前为止所学的所有区块链概念，以及比特币中使用的交易结构，然后我们可以将其部署在完全的P2P网络中。我们在[第4章](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml)，*区块链中的网络*中创建了一个在去中心化的P2P网络中的区块链应用程序。我们将使用相同的应用程序来创建和传播网络中的区块，但还将通过交易和钱包的概念扩展该应用程序，以创建一个完全去中心化的加密货币：
- en: '![](img/2de03c82-a0d7-4fd0-9847-9b6e02dc2b7e.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2de03c82-a0d7-4fd0-9847-9b6e02dc2b7e.jpg)'
- en: 'Figure 5.5: A flow diagram connecting all the components of the application'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：连接应用程序所有组件的流程图
- en: '*Figure 5.5* shows how the cryptocurrency application can be extended by adding
    wallet and transaction functionality. We will walk through the implementation
    of each component in order to understand its functionality.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.5*显示了如何通过添加钱包和交易功能来扩展加密货币应用程序。我们将逐步了解每个组件的实现以理解其功能。'
- en: Transactions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易
- en: We created an application in which blocks were created with data without verifying
    the contents of the data. We will extend this functionality by restricting the
    block to only accepting transaction data. The transaction data is similar to what
    we have covered in this chapter. It consists of input and output components. The
    output specifies the recipient of the transaction, and the input makes sure that
    the user has enough funds for the transaction to take place successfully. The
    input references an existing unspent output.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个应用程序，在该应用程序中，块是用数据创建的，而没有验证数据的内容。我们将通过限制块仅接受交易数据来扩展此功能。交易数据类似于本章中所涵盖的内容。它由输入和输出组件组成。输出指定了交易的接收方，而输入确保用户拥有足够的资金以便交易成功进行。输入引用了现有的未花费输出。
- en: Transaction output
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易输出
- en: 'Transaction output has a structure that only accepts the recipient''s address
    and the transaction amount. The address is the public key counterpart of the **Elliptic-curve
    cryptography** (**ECC**) key pair:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 交易输出具有只接受接收方地址和交易金额的结构。该地址是**椭圆曲线密码学**（**ECC**）密钥对的公钥对应物：
- en: '[PRE28]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Transaction input
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易输入
- en: 'Transaction input provides information about the funds that will be spent by
    referencing the spendable transaction output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 交易输入提供有关将通过引用可消费交易输出而花费的资金的信息：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`tx_out_id` and `tx_out_index` are used to reference the transaction output,
    and the signature provides proof that the spender is the legitimate owner of the
    fund. Unlike Bitcoin, we have not used a Script-like language to lock and unlock
    the transactions. Transaction validation will be performed simply by verifying
    the signature with the help of an **elliptical curve digital signature algorithm**
    (**ECDSA**).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx_out_id`和`tx_out_index`用于引用交易输出，而签名提供了支出者是资金的合法所有者的证明。与比特币不同，我们没有使用类似于脚本的语言来锁定和解锁交易。交易验证将通过使用**椭圆曲线数字签名算法**（**ECDSA**）简单地验证签名来执行。'
- en: Transaction structure
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易结构
- en: 'A transaction is a collection of valid transaction inputs and outputs, as shown
    here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是有效交易输入和输出的集合，如下所示：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A transaction ID is derived from the digest of the entire transaction. The
    `SHA256` hash function is used to calculate the digest of the concatenated transaction
    input and output contents, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 交易ID是从整个交易的摘要派生的。使用`SHA256`哈希函数来计算连接的交易输入和输出内容的摘要，如下所示：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: UTXO
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UTXO
- en: 'A transaction input will always refer to a UTXO. A list of UTXOs is maintained
    locally. This list is updated whenever a transaction is processed, and is referred
    to during transaction validation. Although this list could be generated at any
    time by traversing the entire blockchain, it is maintained in memory to facilitate
    speedy transaction validation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 交易输入将始终引用UTXO。本地维护着一个UTXO列表。在处理交易时更新此列表，并在交易验证期间引用该列表。尽管可以通过遍历整个区块链随时生成此列表，但为了方便快速交易验证，它被维护在内存中：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The list of UTXOs is a simple list that is initially created by processing the
    genesis transaction.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: UTXO列表是一个简单的列表，最初是通过处理创世交易来创建的。
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Whenever the node creates or receives a transaction, it updates the unspent
    transaction outputs while processing it. A set of new UTXOs is calculated from
    the newly added transactions as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每当节点创建或接收交易时，它会在处理过程中更新未花费的交易输出。从新添加的交易中计算一组新的UTXO如下：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All the UTXOs that are referenced in the transaction input are collected as
    consumed UTXOs:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在交易输入中引用的UTXO都被收集为已消耗的UTXO：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The updated UTXO list is created by adding the newly created UTXOs and removing
    all the consumed UTXOs:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的UTXO列表是通过添加新创建的UTXO并删除所有已消耗的UTXO来创建的：
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Transaction validation
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易验证
- en: 'Whenever a node receives a transaction pool or a new block, all the transactions
    are validated before they store the transaction data in the local blockchain.
    The structure of each transaction is tested by checking the data structure of
    each field. Transaction inputs and outputs are also verified so that no invalid
    input or output is included:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每当节点接收到交易池或新的区块时，在将交易数据存储到本地区块链之前，所有交易都会经过验证。通过检查每个字段的数据结构来测试每个交易的结构。还会验证交易的输入和输出，以确保不包含任何无效的输入或输出：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The transaction is rejected if the transaction structure is invalid:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交易结构无效，则交易被拒绝：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The transaction ID in this application is calculated using the SHA256 hash
    function, and this demonstrates the integrity of the transaction. The transaction
    is considered invalid if the ID is tampered with and doesn''t pass the integrity
    check:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用中的交易ID是使用SHA256哈希函数计算的，这证明了交易的完整性。如果ID被篡改且未通过完整性检查，则交易被视为无效：
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Transaction inputs are validated by checking whether they have a reference
    to a valid UTXO, along with a valid signature signed with the private key of the
    public key mentioned in the UTXO:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查交易是否引用了有效的UTXO以及是否具有用UTXO中提到的公钥的有效签名来验证交易输入：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The total transaction output amount is compared with the total transaction input
    amount by summing the output and input amounts. The transaction is considered
    invalid if the input amount doesn't match the output amount. In Bitcoin, the transaction
    output is always lower than the transaction input due to the transaction fee.
    This amount is included in the coinbase transaction. Since we don't have transaction
    fees in this application, the input and output amount should always match.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对输出和输入金额求和来将总交易输出金额与总交易输入金额进行比较。如果输入金额与输出金额不匹配，则交易被视为无效。在比特币中，由于交易费用，交易输出始终低于交易输入。此金额包含在coinbase交易中。由于本应用中没有交易费用，输入和输出金额应始终匹配。
- en: Transaction signing
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易签名
- en: Transaction signing is a crucial process to unlock the funds so that they can
    be transferred to a new owner. Every transaction input includes a signature field
    that contains a signature signed by the owner of the referenced transaction output
    fund. Each transaction input signs the transaction ID, and this makes sure that
    none of the transaction inputs can be tampered with because the transaction ID
    is the digest of the entire transaction. Modifying any of the input will render
    all the signatures invalid.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 交易签名是一个至关重要的过程，用于解锁资金，使其可以转移到新的所有者手中。每个交易输入都包括一个签名字段，其中包含由引用交易输出资金的所有者签名的签名。每个交易输入都对交易ID进行签名，这确保了不能篡改任何交易输入的交易ID，因为交易ID是整个交易的摘要。修改任何输入都将使所有签名无效。
- en: 'We will use packages to perform serialization, signing, and verification of
    the transaction information:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用软件包来执行事务信息的序列化、签名和验证：
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Although we have used `pycryptodome` as the core library for cryptography throughout
    the book, we will make use of the `ecdsa` package for digital signatures in this
    application due to its exclusive support for digital signatures.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在整本书中我们一直将`pycryptodome`作为密码学的核心库，但由于其对数字签名的独家支持，我们将在本应用程序中使用`ecdsa`软件包进行数字签名。
- en: 'The referenced UTXO is fetched in order to find the public key to validate
    whether the signer is the owner of the funds:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找公钥以验证签名者是否是资金的所有者，必须获取引用的UTXO：
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The signer''s public key is compared with the referenced UTXO public key to
    check whether the signer is authorized to sign the transaction input:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 签名者的公钥将与引用的UTXO公钥进行比较，以检查签名者是否被授权对交易输入进行签名：
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, the transaction ID is signed using the user''s private key. The signature
    is created using ECDSA with a `secp256k1` curve. Refer to [Chapter 2](bbe822af-c535-4a33-9783-168d174c48c1.xhtml),
    *A Bit of Cryptography*, for more details on ECDSA signing and verification with
    a secp256k1 curve:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用用户的私钥对交易ID进行签名。签名使用`secp256k1`曲线的ECDSA创建。有关使用secp256k1曲线进行ECDSA签名和验证的更多细节，请参阅[第2章](bbe822af-c535-4a33-9783-168d174c48c1.xhtml)《密码学的一点知识》：
- en: '[PRE44]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wallet
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钱包
- en: As we know, a wallet secures the ownership of funds by storing the private keys
    of the user.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所知，钱包通过存储用户的私钥来保管资金的所有权。
- en: The implementation of a wallet gives us only abstract operations, such as viewing
    the balance of the user's account and sending funds to another user. The wallet
    is often considered an end user application for those who don't want or need to
    understand the internal implementation of transactions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包的实现只能为我们提供抽象操作，例如查看用户账户余额并向其他用户发送资金。钱包通常被认为是终端用户应用程序，适用于那些不愿或不需要了解交易内部实现的人。
- en: Key management
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥管理
- en: 'We will implement the generation of a key pair and store the keys in plaintext,
    that is, without applying any encryption. Although wallets can store multiple
    keys, which can also be generated by a seed phrase, we will use a single key per
    wallet in this application to keep the wallet implementation as simple as possible.
    The following method will read the private key and convert the hexadecimal to
    byte representation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现密钥对的生成，并将密钥以明文形式存储，即不应用任何加密。虽然钱包可以存储多个密钥，也可以由种子短语生成，但在本应用中，我们将每个钱包使用单个密钥，以使钱包的实现尽可能简单。以下方法将读取私钥并将十六进制转换为字节表示：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Wallet is initialized by creating a private key using the ecdsa package. The
    SigningKey class has a generate method which is used to create a signing key in
    ecdsa. This key is then converted to hexadecimal format and then stored in a file.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用ecdsa软件包创建私钥来初始化钱包。SigningKey类具有generate方法，用于在ecdsa中创建签名密钥。然后将此密钥转换为十六进制格式，然后存储在文件中。
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The public key can be generated by using the private key at any time. The following
    method creates a `SigningKey` object by reading the raw private key. This object
    can generate a verifying key, which is the public key:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥可以随时通过私钥生成。以下方法通过读取原始私钥创建一个`SigningKey`对象。该对象可以生成一个验证密钥，即公钥：
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Wallet balance
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钱包余额
- en: Owning funds in cryptocurrency boils down to claiming the transaction outputs
    that are addressed to the user. The wallet's balance is calculated by collecting
    all the UTXOs whose addresses match the public key counterpart of the user's private
    key.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密货币中拥有资金归结为声明寄送给用户的交易输出。钱包的余额通过收集所有地址与用户私钥的公钥对应的UTXO来计算。
- en: 'Since our application maintains a single private key per wallet, all the UTXOs
    of the user will be referenced to a single public address, which isn''t the case
    in implementations where user-owned UTXOs will be addressed to multiple addresses. The
    following method finds the sum of all the funds amounts specified in the UTXOs
    whose addresses match the user''s public key:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序每个钱包维护一个单独的私钥，用户的所有 UTXO 将被引用到一个单独的公共地址上，这在用户拥有的 UTXO 将被寻址到多个地址的实现中并非如此。下面的方法找到与用户公钥匹配的地址中指定的所有资金金额的总和：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The public address in our application is a public key. This isn't the case in
    other cryptocurrency applications, which may use locking and unlocking scripts,
    and the public address is generated from the public key by using a hashing function.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，公共地址是一个公钥。这在其他加密货币应用程序中并非如此，它们可能使用锁定和解锁脚本，并且公共地址是通过使用哈希函数从公钥生成的。
- en: Creating transactions
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建交易
- en: The process of creating a transaction is simply the construction of a transaction
    object that has a valid set of transaction inputs and outputs that satisfy the
    transaction request of the user.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 创建交易的过程只是构造一个具有有效的交易输入和输出的交易对象，以满足用户的交易请求。
- en: Consuming UTXOs
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消耗 UTXO
- en: 'To create a transaction to transfer funds, you need to combine one or more
    UTXOs, just like gathering coins or cash to pay someone. *Figure 5.6* shows how
    two UTXOs that have the values 40 and 10 are combined to create a transaction
    output of 45 to pay to the other user. The remaining output value of 5 is called
    the change amount, and this will be addressed back to the creator of the transaction
    in a similar way to receiving change when we pay for something in a shop:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用于转移资金的交易，您需要组合一个或多个 UTXO，就像收集硬币或现金支付给某人一样。*图 5.6* 显示了如何将两个值为 40 和 10 的 UTXO
    组合以创建一个输出值为 45 的交易输出以支付给其他用户。剩余的输出值为 5，称为找零金额，这将以类似于在商店支付时收到找零的方式返回给交易的创建者：
- en: '![](img/ab16b3e5-4c1a-40ca-be94-5fe759e66c3b.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab16b3e5-4c1a-40ca-be94-5fe759e66c3b.jpg)'
- en: 'Figure 5.6: The creation of new output transaction outputs from the available
    UTXOs'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：从可用 UTXO 创建新的输出交易输出
- en: 'The user wallet selects a set of UTXOs that could be used to spend a particular
    amount. The total value of the selected UTXOs will always be either equal to or
    greater than the required amount. The following method traverses serially and
    selects all the transaction outputs that are enough to satisfy the requested amount.
    The excess amount, which is required to create a new transaction output, is calculated,
    and this is sent to the transaction creator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 用户钱包选择一组可以用于花费特定金额的 UTXO。所选 UTXO 的总值将始终等于或大于所需金额。下面的方法串行遍历并选择所有足以满足请求金额的交易输出。计算剩余金额，这是创建新交易输出所需的金额，并将其发送给交易创建者：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Constructing a transaction
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造交易
- en: 'Transactions are created by constructing valid transaction inputs and outputs.
    Consumable UTXOs are fetched by the `find_tx_outs_for_amount` method, as described
    in the previous section. Transaction inputs will be created for these UTXOs. The
    leftover amount is used to create a change transaction:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造有效的交易输入和输出来创建交易。可消耗的 UTXO 将通过 `find_tx_outs_for_amount` 方法获取，如前一节所述。将为这些
    UTXO 创建交易输入。剩余金额用于创建一个找零交易：
- en: '[PRE50]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'User''s unspent transactions are filtered and will be referenced in the transaction
    inputs:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的未花费交易将被过滤，并将在交易输入中引用：
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Transaction inputs are created using the `TxIn` class by initially keeping
    the signature field empty:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 交易输入是通过最初保持签名字段为空的 `TxIn` 类创建的：
- en: '[PRE52]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The transaction is created with the unsigned transaction input and output values
    created with the `create_tx_outs` method. This method creates the recipient and
    change transaction output:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是使用 `create_tx_outs` 方法创建的未签名交易输入和输出值。此方法创建了接收方和找零交易输出：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, the unsigned transaction inputs are signed by the wallet owner using
    the private key:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，未签名的交易输入由钱包所有者使用私钥签名：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Transaction management
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易管理
- en: Once the transactions are created, they should be included in the blockchain
    in order to update the global transaction state. Transactions that haven't yet
    been included in the blockchain are called **unconfirmed transactions**. Unconfirmed
    transactions are always locally stored in a pool called a transaction pool. This
    is the same as Bitcoin's mempool.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易创建完成，它们应当被包含在区块链中，以更新全局交易状态。尚未被包含在区块链中的交易被称为**未确认交易**。未确认交易总是被本地存储在一个名为交易池的池中。这与比特币的内存池相同。
- en: Transaction pool
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易池
- en: 'All the unconfirmed transactions created by the user and other nodes are included
    in the transaction pool. The transaction pool could be a local file or an in-memory
    pool. We will maintain all the transactions in a list stored in memory:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和其他节点创建的所有未确认交易都包含在交易池中。交易池可以是一个本地文件或一个内存池。我们将在内存中维护一个存储所有交易的列表：
- en: '[PRE55]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Whenever a transaction is created by a node, it is added to the local transaction
    pool before broadcasting. The following `send_transaction` method adds the transaction
    to the pool after creating the transaction:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点创建一个交易时，它会在广播之前将交易添加到本地交易池中。以下`send_transaction`方法在创建交易后将交易添加到池中：
- en: '[PRE56]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These transactions remain in the pool until they are included in the blockchain.
    The pool of transactions needs to be updated once the transaction is included
    in a block. The node updates its pool whenever it receives a new block. The following
    method removes the transaction from the pool when it fails to find the UTXO referenced
    by the transaction input:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交易在未被包含在区块链中时会保留在交易池中。一旦交易被包含在一个区块中，交易池就需要更新。每当节点接收到一个新区块时，节点都会更新其交易池。当未能找到交易输入引用的UTXO时，以下方法会从池中移除该交易：
- en: '[PRE57]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The missing UTXO signifies that the transaction has been included in the blockchain,
    and so the transaction can be removed from the pool.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的UTXO表示该交易已被包含在区块链中，因此该交易可以从池中删除。
- en: Broadcasting
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播
- en: A user node can mine a block for transactions itself or propagate transactions
    to the blockchain network so that some other node can mine the transactions. Our
    blockchain application has only communicated block information so far. Since not
    all transaction creators want to mine blocks themselves, transactions need to
    communicate to the nodes. We will add two more message types to the application.
    Refer to the message types described in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml),
    *Networking in Blockchain*, for more details.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 用户节点可以为交易挖掘一个区块，也可以将交易传播到区块链网络，以便其他节点可以挖掘这些交易。到目前为止，我们的区块链应用程序只通信了区块信息。由于并非所有交易创建者都想亲自挖掘区块，交易需要与节点进行通信。我们将向应用程序添加另外两种消息类型。更多细节请参考[第4章](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml)中描述的消息类型，*区块链中的网络*。
- en: 'These are the formats of query and response messages that will be exchanged
    between the nodes. Similar to the broadcasting of blocks, transactions are broadcast
    when a new transaction is created by a node and when it receives an unconfirmed
    transaction from other nodes. The node will broadcast a transaction pool query
    message when it first connects to another node:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是节点之间将要交换的查询和响应消息的格式。与区块的广播类似，当节点创建新的交易或从其他节点接收到未确认交易时，交易将被广播。节点首次连接到另一个节点时，将广播一个交易池查询消息：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Blockchain
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链
- en: Although the blockchain part of the application is pretty similar to the application
    created in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml), *Networking
    in Blockchain*, we have added some functionality due to the introduction of the
    transaction data structure.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序的区块链部分与[第4章](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml)中创建的应用程序非常相似，但我们由于交易数据结构的引入添加了一些功能。
- en: 'Mining a blockchain without transactions is straightforward; it just entails
    the construction of a block with a header and data. But when the arbitrary data
    is replaced with transaction data, the node needs to fetch the transactions from
    the local transaction pool:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘没有交易的区块链是直截了当的；它只涉及构建一个带有头部和数据的区块。但是当任意数据被替换为交易数据时，节点需要从本地交易池中获取交易：
- en: '[PRE59]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This method constructs and mines a block's data, which contains a coinbase transaction
    and transactions from the pool. The block will be added to the blockchain once
    the block header and transactions are validated.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Application endpoints
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the application has an HTTP interface that it uses to
    manage the nodes and a WebSocket interface for P2P communication between the nodes.
    Here are some of the endpoints that are required to manage the nodes:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`/blocks`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/block/<hash>`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mineBlock`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/transaction/<id>`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sendTransaction`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sendTransaction` endpoint will basically create the transaction and add
    it to the pool, as explained in the *Transaction Management* section. Unconfirmed
    transactions are included in the blockchain by using the `/mineBlock` endpoint.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the state of the blockchain before any other transactions
    are performed because it contains a genesis block:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once a transaction is confirmed by inserting it to the blockchain, it can be
    viewed by sending an HTTP GET request to the `blocks` or `transaction` endpoint.
    Here is the transaction result thrown out when hitting the transaction endpoint
    with the transaction ID:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This transaction consumed the transaction output of the genesis block, which
    had a value of 50\. Since a transaction totaling 20 coins was created, the remaining
    30 coins were sent back to the owner.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: The entire application's code can be found in the GitHub repository. Since not
    all the components of the application are described here, refer to the code in
    the repository in order to understand and execute the implementation. You will
    also find a block explorer and wallet UI for this application.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the concept of blockchain originated from a cryptocurrency, the best way
    to understand the true implementation of the blockchain technology is through
    a cryptocurrency application. In this chapter, we have covered all the concepts
    of cryptocurrency with the help of Bitcoin in order to understand how cryptocurrency
    functions in a decentralized network.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: We started with the basics of Bitcoin and how they are set up to form a decentralized
    network. Then we dived into several concepts, such as keys, addresses, and wallets,
    used in Bitcoin. Bitcoin transactions were explored in depth since those are the
    events that bring value to the Bitcoin network. We also dived into the essence
    of blockchain, including mining and consensus of Bitcoin. Finally, we concluded
    the chapter by creating a simple cryptocurrency application.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a reference because it elaborates on most of the concepts
    used to deploy a basic cryptocurrency. Now that we are familiar with the key concepts
    of a decentralized application, we will dive into blockchain by creating an application
    using the existing platform in the next chapter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
