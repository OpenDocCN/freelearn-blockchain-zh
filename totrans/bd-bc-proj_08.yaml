- en: Building Enterprise Level Smart Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建企业级智能合约
- en: Until now, we were using browser Solidity to write and compile Solidity code.
    And we were testing our contracts using web3.js. We could have also used the Solidity
    online IDE to test them. This seemed alright as we were only compiling a single
    small contract and it had very few imports. As you start building large and complicated
    smart contracts, you will start facing problems with compiling and testing using
    the current procedure. In this chapter, we will learn about truffle, which makes
    it easy to build enterprise-level DApps, by building an altcoin. All the crypto-currencies
    other than bitcoin are called altcoins.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用浏览器 Solidity 来编写和编译 Solidity 代码。 我们使用 web3.js 来测试我们的合同。 我们也可以使用
    Solidity 在线 IDE 进行测试。 因为我们只编译了一个小合同，而且导入的内容很少，所以这似乎没问题。 当您开始构建大型和复杂的智能合约时，您将开始遇到使用当前流程进行编译和测试的问题。
    在本章中，我们将学习有关 truffle 的知识，它使得构建企业级 DApps 变得容易，通过构建一个另类币。 除了比特币之外的所有加密货币都被称为另类币。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What the `ethereumjs-testrpc` node is and how to use it?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 `ethereumjs-testrpc` 节点，以及如何使用它？
- en: What are topics of events?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件主题是什么？
- en: Working with contracts using the `truffle-contract` package.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `truffle-contract` 包处理合同。
- en: Installing truffle and exploring the truffle command-line tool and configuration
    file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 truffle 并探索 truffle 命令行工具和配置文件
- en: Compiling, deploying, and testing Solidity code using truffle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 truffle 编译、部署和测试 Solidity 代码
- en: Package management via NPM and EthPM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 NPM 和 EthPM 进行包管理
- en: Using the truffle console and writing external scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 truffle 控制台和编写外部脚本
- en: Building clients for the DApp using truffle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 truffle 构建 DApp 的客户端
- en: Exploring ethereumjs-testrpc
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 ethereumjs-testrpc
- en: '`ethereumjs-testrpc` is a Node.js-based Ethereum node used for testing and
    development. It simulates full-node behavior and makes the development of Ethereum
    applications much faster. It also includes all popular RPC functions and features
    (such as events) and can be run deterministically to make development a breeze.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ethereumjs-testrpc` 是一个基于 Node.js 的以太坊节点，用于测试和开发。 它模拟完整节点行为，使以太坊应用程序的开发速度加快。
    它还包括所有流行的 RPC 函数和功能（例如事件），并且可以以确定性的方式运行，以使开发变得轻松愉快。'
- en: It's written in JavaScript and is distributed as an `npm` package. At the time
    of writing this, the latest version of `ethereumjs-testrpc` is 3.0.3 and requires
    at least Node.js version 6.9.1 to run properly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它是用 JavaScript 编写的，并作为一个 `npm` 包分发。 在撰写本文时，最新版本的 `ethereumjs-testrpc` 是 3.0.3，至少需要
    Node.js 版本 6.9.1 才能正常运行。
- en: It holds everything in memory; therefore, whenever the node is restarted, it
    loses the previous state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它将所有内容保存在内存中； 因此，每次节点重新启动时，它都会丢失先前的状态。
- en: Installation and usage
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用
- en: There are three ways to simulate an Ethereum node using `ethereumjs-testrpc`.
    Each of these ways has its own use cases. Let's explore them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以使用 `ethereumjs-testrpc` 模拟以太坊节点。 每种方法都有自己的用例。 让我们来探索一下。
- en: The testrpc command-line application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: testrpc 命令行应用程序
- en: 'The `testrpc` command can be used to simulate an Ethereum node. To install
    this command-line app, you need to install `ethereumjs-testrpc` globally:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: testrpc 命令可用于模拟以太坊节点。 要安装此命令行应用程序，您需要全局安装 `ethereumjs-testrpc`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the various options that can be provided:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可以提供的各种选项：
- en: '`-a` or `--accounts`: This specifies the number of accounts to be generated
    at startup.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a` 或 `--accounts`：这指定了启动时要生成的帐户数。'
- en: '`-b` or `--blocktime`: This specifies the blocktime in seconds for automatic
    mining. The default is 0, and there''s no auto-mining.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b` 或 `--blocktime`：这指定了自动挖矿的秒数。 默认值为 0，没有自动挖矿。'
- en: '`-d` or `--deterministic`: Whenever the node is run, it will generate 10 deterministic
    addresses; that is, when you provide this flag, the same set of addresses are
    generated every time. This option can be used to generate deterministic addresses
    based on a predefined mnemonic as well.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 或 `--deterministic`：每次运行节点时，它将生成 10 个确定性地址； 也就是说，当您提供此标志时，每次都会生成相同的地址集。
    这个选项还可以根据预定义的助记词生成确定性地址。'
- en: '`-n` or `--secure`: Locks the available accounts by default. When this option
    is used without the `--unlock` option, the HD wallet will not be created.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n` 或 `--secure`：默认情况下锁定可用帐户。 当此选项在不带 `--unlock` 选项的情况下使用时，将不会创建 HD 钱包。'
- en: '`-m` or `--mnemonic`: Uses a specific HD wallet mnemonic to generate initial
    addresses.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m` 或 `--mnemonic`：使用特定的 HD 钱包助记词来生成初始地址。'
- en: '`-p` or `--port`: The port number to listen on. Defaults to 8545.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`或`--port`：要监听的端口号。默认为8545。'
- en: '`-h` or `--hostname`: The hostname to listen on. Defaults to Node''s `server.listen()`
    default.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`或`--hostname`：要监听的主机名。默认为Node的`server.listen()`默认值。'
- en: '`-s` or `--seed`: The arbitrary data to generate the HD wallet mnemonic to
    be used.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`或`--seed`：生成HD钱包助记词所需的任意数据。'
- en: '`-g` or `--gasPrice`: Uses a custom gas price (defaults to 1). If the gas price
    is not provided while sending the transaction to the node, then this gas price
    is used.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g`或`--gasPrice`：使用自定义的gas价格（默认为1）。如果在向节点发送交易时未提供gas价格，则将使用此gas价格。'
- en: '`-l` or `--gasLimit`: Uses a custom limit (defaults to 0x47E7C4). If the gas
    limit is not provided while sending the transaction to node, then this gas limit
    is used.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`或`--gasLimit`：使用自定义的gas限制（默认为0x47E7C4）。如果在向节点发送交易时未提供gas限制，则将使用此gas限制。'
- en: '`-f` or `--fork`: This is the fork from another currently running Ethereum
    node at a given block. The input should be the HTTP location and port of the other
    client; for example, `http://localhost:8545`. Optionally, you can specify the
    block to fork from using an @ sign: `http://localhost:8545@1599200`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`或`--fork`：这是从另一个当前运行的以太坊节点在给定块中分叉。输入应该是其他客户端的HTTP位置和端口；例如，`http://localhost:8545`。可以选择指定要从中分叉的块，使用@标记：`http://localhost:8545@1599200`。'
- en: '`--debug`: Outputs VM opcodes for debugging.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--debug`：输出用于调试的虚拟机操作码。'
- en: '`--account`: This option is used to import accounts. It specifies `--account=...`
    any number of times, passing arbitrary private keys and their associated balances
    to generate initial addresses. An `testrpc --account="privatekey,balance" [--account="privatekey,balance"]` an
    HD wallet will not be created for you when using `--account`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--account`：此选项用于导入账户。它可以任意多次指定`--account=...`，传递任意的私钥和它们关联的余额来生成初始地址。在使用`--account`时，不会为你创建一个HD钱包。'
- en: '`-u` or `--unlock`: Specifies `--unlock ...` any number of times, passing either
    an address or an account index to unlock specific accounts. When used in conjunction
    with `--secure`, `--unlock` will override the locked state of the specified accounts:
    `testrpc --secure --unlock "0x1234..." --unlock "0xabcd..."`. You can also specify
    a number, unlocking accounts by their index: `testrpc --secure -u 0 -u 1`. This
    feature can also be used to impersonate accounts and unlock addresses you wouldn''t
    otherwise have access to. When used with the `--fork` feature, you can use the
    `testrpc` to make transactions as any address on the blockchain, which is very
    useful in testing and dynamic analysis.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`或`--unlock`：指定`--unlock ...`任意次数，传递要解锁的特定账户的地址或账户索引。当与`--secure`同时使用时，`--unlock`将覆盖指定帐户的锁定状态：`testrpc
    --secure --unlock "0x1234..." --unlock "0xabcd..."`。还可以通过编号指定解锁账户：`testrpc --secure
    -u 0 -u 1`。该功能也可以用于冒充帐户和解锁您原本无法访问的地址。在与`--fork`功能一起使用时，可以使用`testrpc`以任何区块链上的地址进行交易，这在测试和动态分析中非常有用。'
- en: '`--networkId`: Used to specify a network ID that this node is part of.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--networkId`：用于指定此节点所属的网络ID。'
- en: Note that private keys are 64 characters long and must be input as a 0x-prefixed
    hex string. The balance can either be input as an integer or a 0x-prefixed hex
    value specifying the amount of wei in that account.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，私钥长度为64个字符，必须输入为带有0x前缀的十六进制字符串。余额可以输入为整数，也可以输入为以太币金额的0x前缀十六进制值。
- en: Using ethereumjs-testrpc as a web3 provider or as an HTTP server
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`ethereumjs-testrpc`用作web3提供者或作为HTTP服务器
- en: 'You can use `ethereumjs-testrpc` as a `web3` provider like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样将`ethereumjs-testrpc`用作`web3`提供者：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can use `ethereumjs-testrpc` as a general HTTP server like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样将`ethereumjs-testrpc`用作通用HTTP服务器：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Both `provider()` and `server()` take a single object that allows you to specify
    the behavior of the `ethereumjs-testrpc`. This parameter is optional. The available
    options are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider()`和`server()`都接受一个允许您指定`ethereumjs-testrpc`行为的对象。此参数是可选的。可用选项如下：'
- en: '`accounts`: Value is an array of objects. Each object should have a balance
    key with a hexadecimal value. The secretKey key can also be specified, which represents
    the account''s private key. If there''s no secretKey, the address is autogenerated
    with the given balance. If specified, the key is used to determine the account''s
    address.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accounts`：值是对象的数组。每个对象都应该有一个带有十六进制值的余额键。也可以指定secretKey键，它表示帐户的私钥。如果没有secretKey，地址将根据给定的余额自动生成。如果指定，密钥用于确定帐户的地址。'
- en: '`debug`: Outputs VM opcodes for debugging.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`: 输出用于调试的 VM 操作码。'
- en: '`logger`: Value is an object that implements a `log()` function.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger`: 值是实现 `log()` 函数的对象。'
- en: '`mnemonic`: Uses a specific HD wallet mnemonic to generate initial addresses.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnemonic`: 使用特定的 HD 钱包助记词生成初始地址。'
- en: '`port`: The port number to listen on when running as a server.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`: 作为服务器运行时要监听的端口号。'
- en: '`seed`: Arbitrary data to generate the HD wallet mnemonic to be used.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed`: 生成 HD 钱包助记词所需的任意数据。'
- en: '`total_accounts`: The number of accounts to generate at start up.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total_accounts`: 启动时要生成的帐户数。'
- en: '`fork`: The same as the preceding `--fork` option.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork`: 与前述 `--fork` 选项相同。'
- en: '`network_id`: The same as the `--networkId` option. Used to specify a network
    ID that this node is part of.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network_id`: 与 `--networkId` 选项相同。用于指定此节点所属的网络 ID。'
- en: '`time`: The date that the first block should start. Use this feature along
    with the `evm_increaseTime` method to test `time-dependent` code.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`: 第一个区块应该开始的日期。与 `evm_increaseTime` 方法一起使用此功能来测试“依赖于时间”的代码。'
- en: '`locked`: Specifies whether or not accounts are locked by default.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locked`: 指定默认情况下是否锁定帐户。'
- en: '`unlocked_accounts`: An array of addresses or address indexes specifying which
    accounts should be unlocked.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlocked_accounts`: 一个指定应解锁哪些帐户的地址或地址索引的数组。'
- en: Available RPC methods
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的 RPC 方法
- en: 'Here is the list of RPC methods made available with `ethereumjs-testrpc`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `ethereumjs-testrpc` 提供的 RPC 方法列表：
- en: '`eth_accounts`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_accounts`'
- en: '`eth_blockNumber`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_blockNumber`'
- en: '`eth_call`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_call`'
- en: '`eth_coinbase`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_coinbase`'
- en: '`eth_compileSolidity`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_compileSolidity`'
- en: '`eth_estimateGas`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_estimateGas`'
- en: '`eth_gasPrice`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_gasPrice`'
- en: '`eth_getBalance`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getBalance`'
- en: '`eth_getBlockByNumber`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getBlockByNumber`'
- en: '`eth_getBlockByHash`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getBlockByHash`'
- en: '`eth_getBlockTransactionCountByHash`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getBlockTransactionCountByHash`'
- en: '`eth_getBlockTransactionCountByNumber`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getBlockTransactionCountByNumber`'
- en: '`eth_getCode (only supports block number "latest")`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getCode (仅支持区块号“latest”)`'
- en: '`eth_getCompilers`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getCompilers`'
- en: '`eth_getFilterChanges`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getFilterChanges`'
- en: '`eth_getFilterLogs`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getFilterLogs`'
- en: '`eth_getLogs`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getLogs`'
- en: '`eth_getStorageAt`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getStorageAt`'
- en: '`eth_getTransactionByHash`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getTransactionByHash`'
- en: '`eth_getTransactionByBlockHashAndIndex`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getTransactionByBlockHashAndIndex`'
- en: '`eth_getTransactionByBlockNumberAndIndex`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getTransactionByBlockNumberAndIndex`'
- en: '`eth_getTransactionCount`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getTransactionCount`'
- en: '`eth_getTransactionReceipt`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_getTransactionReceipt`'
- en: '`eth_hashrate`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_hashrate`'
- en: '`eth_mining`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_mining`'
- en: '`eth_newBlockFilter`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_newBlockFilter`'
- en: '`eth_newFilter (includes log/event filters)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_newFilter (包括日志/事件过滤器)`'
- en: '`eth_sendTransaction`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_sendTransaction`'
- en: '`eth_sendRawTransaction`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_sendRawTransaction`'
- en: '`eth_sign`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_sign`'
- en: '`eth_syncing`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_syncing`'
- en: '`eth_uninstallFilter`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth_uninstallFilter`'
- en: '`net_listening`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_listening`'
- en: '`net_peerCount`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_peerCount`'
- en: '`net_version`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_version`'
- en: '`miner_start`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`miner_start`'
- en: '`miner_stop`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`miner_stop`'
- en: '`rpc_modules`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpc_modules`'
- en: '`web3_clientVersion`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3_clientVersion`'
- en: '`web3_sha3`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3_sha3`'
- en: 'There are also special nonstandard methods that aren''t included within the
    original RPC specification:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些特殊的非标准方法未包含在原始 RPC 规范中：
- en: '`evm_snapshot`: Snapshots the state of the blockchain at the current block.
    Takes no parameters. Returns the integer ID of the snapshot created.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evm_snapshot`: 在当前区块中快照区块链的状态。不带参数。返回创建的快照的整数 ID。'
- en: '`evm_revert`: Reverts the state of the blockchain to a previous snapshot. Takes
    a single parameter, which is the snapshot ID to revert to. If no snapshot ID is
    passed, it will revert to the latest snapshot. Returns true.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evm_revert`: 将区块链状态恢复到先前的快照。接受一个参数，即要恢复到的快照 ID。如果未传递快照 ID，则将恢复到最新的快照。返回 true。'
- en: '`evm_increaseTime`: Jumps forward in time. Takes one parameter, which is the
    amount of time to increase in seconds. Returns the total time adjustment in seconds.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evm_increaseTime`: 向前跳转时间。带一个参数，即要增加的秒数。返回秒数的总时间调整。'
- en: '`evm_mine`: Forces a block to be mined. Takes no parameters. Mines a block
    independent of whether or not mining is started or stopped.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evm_mine`: 强制挖掘一个区块。不带参数。独立于挖矿是否启动或停止而挖掘一个区块。'
- en: What are event topics?
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件主题是什么？
- en: Topics are values used for indexing events. You cannot search for events without
    topics. Whenever an event is invoked, a default topic is generated, which is considered
    the first topic of the event. There can be up to four topics for an event. Topics
    are always generated in the same order. You can search for an event using one
    or more of its topics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是用于索引事件的值。您不能没有主题搜索事件。每当调用事件时，都会生成一个默认主题，该主题被视为事件的第一个主题。一个事件最多可以有四个主题。主题始终以相同的顺序生成。您可以使用一个或多个主题搜索事件。
- en: The first topic is the signature of the event. The rest of the three topics
    are the values of indexed parameters. If the index parameter is `string`, `bytes`,
    or `array`, then the keccak-256 hash of it is the topic instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主题是事件的签名。剩下的三个主题是索引参数的值。如果索引参数是`string`、`bytes`或`array`，那么其keccak-256哈希就是主题。
- en: 'Let''s take an example to understand topics. Suppose there is an event of this
    form:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个示例来理解主题。假设有这样一个事件：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, these four topics are generated. They are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里生成了四个主题。它们分别是：
- en: '`0xb62a11697c0f56e93f3957c088d492b505b9edd7fb6e7872a93b41cdb2020644`: This
    is the first topic. It is generated using `web3.sha3("ping(string,int256,uint256,string,int256)")`.
    Here, you can see that all types are of a canonical form.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xb62a11697c0f56e93f3957c088d492b505b9edd7fb6e7872a93b41cdb2020644`：这是第一个主题。它是使用`web3.sha3("ping(string,int256,uint256,string,int256)")`生成的。在这里，您可以看到所有类型都是规范形式的。'
- en: '`0x30ee7c926ebaf578d95b278d78bc0cde445887b0638870a26dcab901ba21d3f2`: This
    is the second topic. It is generated using `web3.sha3("Random String")`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x30ee7c926ebaf578d95b278d78bc0cde445887b0638870a26dcab901ba21d3f2`：这是第二个主题。它是使用`web3.sha3("随机字符串")`生成的。'
- en: The third and fourth topics are `0x000000000000000000000000000000000000000000000000000000000000000c`
    and `0x0000000000000000000000000000000000000000000000000000000000000017`, respectively,
    that is, hexadecimal representation of the values . They are calculated using
    `EthJS.Util.bufferToHex(EthJS.Util.setLengthLeft(12, 32))` and `EthJS.Util.bufferToHex(EthJS.Util.setLengthLeft(23,
    32))`, respectively.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三和第四个主题分别为`0x000000000000000000000000000000000000000000000000000000000000000c`和`0x0000000000000000000000000000000000000000000000000000000000000017`，也就是值的十六进制表示。它们分别使用`EthJS.Util.bufferToHex(EthJS.Util.setLengthLeft(12,
    32))`和`EthJS.Util.bufferToHex(EthJS.Util.setLengthLeft(23, 32))`计算得出。
- en: Internally, your Ethereum node will build indexes using topics so that you can
    easily find events based on signatures and indexed values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，您的以太坊节点将使用主题构建索引，以便您可以轻松找到基于签名和索引值的事件。
- en: 'Suppose you want to get event calls of the preceding event, where the first
    argument is `Random String` and the third argument is either `23` or `78`; then,
    you can find them using `web3.eth.getFilter` this way:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想获取前述事件的事件调用，其中第一个参数是`随机字符串`，第三个参数是`23`或`78`；那么，您可以通过以下方式使用`web3.eth.getFilter`找到它们：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So here, we are asking the node to return all events from the blockchain that
    have been fired by the `0x853cdcb4af7a6995808308b08bb78a74de1ef899` contract address,
    whose first topic is `0xb62a11697c0f56e93f3957c088d492b505b9edd7fb6e7872a93b41cdb2020644`,
    the second topic is `0x30ee7c926ebaf578d95b278d78bc0cde445887b0638870a26dcab901ba21d3f2`,
    and the third topic is either `0x0000000000000000000000000000000000000000000000000000000000000017`
    or `0x000000000000000000000000000000000000000000000000000000000000004e`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里要求节点返回所有已被`0x853cdcb4af7a6995808308b08bb78a74de1ef899`合约地址触发的来自区块链的事件，其第一个主题为`0xb62a11697c0f56e93f3957c088d492b505b9edd7fb6e7872a93b41cdb2020644`，第二个主题为`0x30ee7c926ebaf578d95b278d78bc0cde445887b0638870a26dcab901ba21d3f2`，第三个主题为`0x0000000000000000000000000000000000000000000000000000000000000017`或`0x000000000000000000000000000000000000000000000000000000000000004e`。
- en: In the preceding code, note the order of the `topics` array values. The order
    is important.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意`topics`数组值的顺序。顺序很重要。
- en: Getting started with truffle-contract
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用truffle-contract
- en: It is important to learn `truffle-contract` before learning truffle because
    `truffle-contract` is tightly integrated into truffle. Truffle tests, code to
    interact with contracts in truffle, deployment code, and so on are written using
    `truffle-contract`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习truffle之前，学习`truffle-contract`非常重要，因为`truffle-contract`与truffle紧密集成。 truffle测试、与truffle中的合约交互的代码、部署代码等都是使用`truffle-contract`编写的。
- en: 'The `truffle-contract` API is a JavaScript and Node.js library, which makes
    it easy to work with ethereum smart contracts. Until now, we have been using web3.js
    to deploy and call smart contracts functions, which is fine, but `truffle-contract`
    aims to make it even easier to work with ethereum smart contracts. Here are some
    features of `truffle-contract` that make it a better choice then web3.js in order
    to work with smart contracts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`truffle-contract` API是一个JavaScript和Node.js库，它使得与以太坊智能合约的交互变得容易。到目前为止，我们一直在使用web3.js来部署和调用智能合约函数，这很好，但`truffle-contract`旨在使与以太坊智能合约的交互变得更加容易。下面是一些`truffle-contract`的特点，这使得它在处理智能合约方面比web3.js更优秀：'
- en: Synchronized transactions for better control flow (that is, transactions won't
    finish until you're guaranteed they've been mined).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步事务以更好地控制流程（即，直到您保证它们已经被挖掘，事务才会完成）。
- en: Promise-based API. No more callback hell. Works well with ES6 and async/await.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Promise 的 API。不再有回调地狱。与 ES6 和 async/await 很好地配合使用。
- en: Default values for transactions, such as from `address` or `gas`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的默认值，例如来自 `address` 或 `gas`。
- en: Returning logs, transaction receipt, and transaction hash of every synchronized
    transaction.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回每个同步交易的日志、交易收据和交易哈希。
- en: Before we get into `truffle-contract`, you need to know that it doesn't allow
    us to sign transactions using accounts stored outside of the ethereum node; that
    is, it doesn't have anything similar to `sendRawTransaction`. The `truffle-contract`
    API assumes that every user of your DApp has their own ethereum node running and
    they have their accounts stored in that node. Actually this is how DApps should
    work because if every DApp's client starts letting users create and manage accounts,
    then it will be a concern for users to manage so many accounts and painful for
    developers to develop a wallet manager every time for every client they build.
    Now, the question is how will clients know where the user has stored the accounts
    and in what format? So, for portability reasons, it's recommended that you assume
    that users have their accounts stored in their personal node, and to manage the
    account, they use something like the ethereum Wallet app. As accounts stored in
    the Ethereum node are signed by the ethereum node itself, there is no need for
    `sendRawTransaction` anymore. Every user needs to have their own node and cannot
    share a node because when an account is unlocked, it will be open for anyone to
    use it, which will enable users to steal other's ether and make transactions from
    others' accounts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 `truffle-contract` 之前，你需要知道它不允许我们使用存储在以太坊节点之外的账户来签署交易；也就是说，它没有类似于 `sendRawTransaction`
    的功能。`truffle-contract` API 假设你的 DApp 的每个用户都有自己的以太坊节点运行，并且他们的账户存储在该节点中。实际上，这就是
    DApp 应该工作的方式，因为如果每个 DApp 的客户端都开始让用户创建和管理账户，那么用户将需要管理这么多账户，并且对于开发人员来说，每次构建客户端都要为每个客户端开发钱包管理器都是痛苦的。现在，问题是客户端如何知道用户在哪里存储账户以及以什么格式？因此，出于可移植性的考虑，建议你假设用户的账户存储在他们的个人节点中，并且为了管理账户，他们使用类似以太坊钱包应用的东西。由于以太坊节点中存储的账户由以太坊节点本身签名，因此不再需要
    `sendRawTransaction`。每个用户都需要有自己的节点，并且不能共享节点，因为当一个账户被解锁时，任何人都可以使用它，这将使用户能够窃取他人的以太币并从他人的账户中进行交易。
- en: If you are using an app that requires you to host your own node and manage accounts
    in it, then make sure you don't allow everyone to make JSON-RPC calls to that
    node; instead, only local apps should be able to make calls. Also, make sure that
    you don't keep the accounts unlocked for very long and lock them as soon as you
    don't need the account.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的应用需要你托管自己的节点并在其中管理账户，请确保不允许所有人对该节点进行 JSON-RPC 调用；相反，只有本地应用程序才能进行调用。另外，请确保不要将账户长时间保持解锁状态，并在不再需要账户时立即将其锁定。
- en: If your applications require the functionality of creating and signing raw transactions,
    then you can use `truffle-contract` just to develop and test smart contracts,
    and in your application, you can interact with contracts just like we were doing
    earlier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要创建和签署原始交易的功能，那么你可以使用 `truffle-contract` 来开发和测试智能合约，而在你的应用程序中，你可以像之前一样与合约交互。
- en: Installing and importing truffle-contract
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和引入 truffle-contract
- en: At the time of writing this, the latest version of the `truffle-contract` API
    is 1.1.10\. Before importing `truffle-contract`, you need to first import web3.js
    as you will need to create a provider to work with the `truffle-contract` APIs
    so that `truffle-contract` will internally use the provider to make JSON-RPC calls.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本的 `truffle-contract` API 是 1.1.10。在引入 `truffle-contract` 之前，你需要先引入
    web3.js，因为你需要创建一个提供程序来与 `truffle-contract` API 一起工作，这样 `truffle-contract` 将在内部使用提供程序来进行
    JSON-RPC 调用。
- en: 'To install `truffle-contract` in the Node.js app, you need to simply run this
    in your app directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 应用中安装 `truffle-contract`，只需在应用目录中运行以下命令：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And then use this code to import it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码进行引入：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To use `truffle-contract` in a browser, you can find the browser distribution
    inside the dist directory in the [https://github.com/trufflesuite/truffle-contract](https://github.com/trufflesuite/truffle-contract)
    repository.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在浏览器中使用 `truffle-contract`，你可以在 [https://github.com/trufflesuite/truffle-contract](https://github.com/trufflesuite/truffle-contract)
    仓库的 dist 目录中找到浏览器分发版。
- en: 'In HTML, you can enqueue it this way:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，你可以这样排队：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you will have a `TruffleContract` global variable available.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将拥有一个全局变量 `TruffleContract`。
- en: Setting up a testing environment
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一个测试环境
- en: Before we start learning about `truffle-contract` APIs, we need to set up a
    testing environment, which will help us test our code while learning.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习关于`truffle-contract` API之前，我们需要建立一个测试环境，这将帮助我们在学习过程中测试我们的代码。
- en: First of all, run the `ethereumjs-testrpc` node representing network ID 10 by
    just running the `testrpc --networkId 10` command. We have randomly chosen network
    ID 10 for development purposes, but you are free to choose any other network ID.
    Just make sure it's not 1 as mainnet is always used in live apps and not for development
    and testing purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过仅运行`testrpc --networkId 10`命令来运行代表网络ID 10的`ethereumjs-testrpc`节点。我们随机选择了网络ID
    10 用于开发目的，但您可以自由选择其他网络ID。只需确保它不是1，因为主网始终用于实时应用程序，而不用于开发和测试目的。
- en: 'Then, create an HTML file and place this code in it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个HTML文件并将此代码放入其中：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Download `web3.min.js` and `truffle-contract.min.js`. You can find the `truffle-contract`
    browser build at [https://github.com/trufflesuite/truffle-contract/tree/master/dist](https://github.com/trufflesuite/truffle-contract/tree/master/dist).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`web3.min.js` 和 `truffle-contract.min.js`。您可以在[https://github.com/trufflesuite/truffle-contract/tree/master/dist](https://github.com/trufflesuite/truffle-contract/tree/master/dist)找到`truffle-contract`的浏览器构建。
- en: The truffle-contract API
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: truffle-contract API
- en: 'Now let''s explore `truffle-contract` APIs. Basically, `truffle-contract` has
    two APIs, that is, the contract abstraction API and the contract instance API.
    A contract abstraction API represents various kinds of information about the contract
    (or a library), such: as its ABI; unlinked byte code; if the contract is already
    deployed, then its address in various ethereum networks; addresses of the libraries
    it depends on for various ethereum networks if deployed; and events of the contract.
    The abstraction API is a set of functions that exist for all contract abstractions.
    A contract instance represents a deployed contract in a specific network. The
    instance API is the API available to contract instances. It is created dynamically
    based on functions available in your `Solidity` source file. A contract instance
    for a specific contract is created from a contract abstraction that represents
    the same contract.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索`truffle-contract`的API。基本上，`truffle-contract`有两个API，即合同抽象API和合同实例API。合同抽象API表示关于合同（或库）的各种信息，例如其ABI；未链接的字节码；如果合同已部署，则其在各个以太坊网络中的地址；如果已部署，则其依赖的库在各个以太坊网络中的地址；以及合同的事件。抽象API是为所有合同抽象存在的一组函数。合同实例表示特定网络中部署的合同。实例API是向合同实例提供的API。它是根据您的`Solidity`源文件中可用的函数动态创建的。针对特定合同的合同实例是通过表示相同合同的合同抽象创建的。
- en: The contract abstraction API
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同抽象 API
- en: 'The contract abstraction API is something that makes `truffle-contract` very
    special compared to web3.js. Here is why it''s special:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 合同抽象API是使`truffle-contract`与web3.js相比非常特殊的东西。这里是它的特殊之处：
- en: It will automatically fetch default values, such as library addresses, contract
    addresses, and so on, depending on which network it's connected to; therefore,
    you don't have to edit the source code every time you change the network.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将根据连接的网络自动获取默认值，如库地址、合同地址等，因此每次更改网络时都不必编辑源代码。
- en: You may choose to listen to certain events in certain networks only.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择只在某些网络中监听某些事件。
- en: It makes it easy to link libraries to contract's byte code at runtime. There
    are several other benefits you will find out once you have explored how to use
    the API.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使在运行时轻松将库链接到合同的字节码。一旦您探索了如何使用API，您将发现还有其他几个好处。
- en: 'Before we get into how to create a contract abstraction and its methods, let''s
    write a sample contract, which the contract abstraction will represent. Here is
    the sample contract:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何创建合同抽象及其方法之前，让我们编写一个样本合同，该合同抽象将代表。这是样本合同：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This contract converts `uint` into `bytes32` and `bytes32` into `uint` using
    the `StringLib` library. `StringLib` is available at the `0xcca8353a18e7ab7b3d094ee1f9ddc91bdf2ca6a4`
    address on the main network, but on other networks, we need to deploy it to test
    the contract. Before you proceed further, compile it using browser Solidity, as
    you will need the ABI and byte code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该合同将`uint`转换为`bytes32`，并使用`StringLib`库将`bytes32`转换为`uint`。`StringLib`在主网络上的地址为`0xcca8353a18e7ab7b3d094ee1f9ddc91bdf2ca6a4`，但在其他网络上，我们需要部署以测试合同。在继续之前，请使用浏览器Solidity编译它，因为您将需要ABI和字节码。
- en: 'Now let''s create a contract abstraction representing the `Sample` contract
    and the `StringLib` library. Here is the code for this. Place it in the `HTML`
    file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个代表`Sample`合同和`StringLib`库的合同抽象。这是代码，请将其放入`HTML`文件中：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is how the preceding code works:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的工作原理：
- en: At first, we create a provider. Using this provider, `truffle-contract` will
    communicate with the node.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个提供者。使用此提供者，`truffle-contract`将与节点通信。
- en: Then, we create a contract abstraction for the `Sample` contract. To create
    a contract abstraction, we use the `TruffleContract` function. This function takes
    an object, which contains various kinds of information about the contract. This
    object can be termed as an artifacts object. The `abi` and `unlinked_binary` properties
    are compulsory. The other properties of the object are optional. The `abi` property
    points to the ABI of the contract, whereas the `unlinked_binary` property points
    to the unlinked binary code of the contract.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`Sample`合同创建一个合同抽象。要创建合同抽象，我们使用`TruffleContract`函数。此函数接受一个包含有关合同的各种信息的对象。此对象可以称为工件对象。`abi`和`unlinked_binary`属性是强制的。对象的其他属性是可选的。`abi`属性指向合同的ABI，而`unlinked_binary`属性指向合同的未链接二进制代码。
- en: Then, we have a property network that indicates various kinds of information
    about the contract in various networks. Here, we are saying that in network ID
    1, the `StringLib` dependency is deployed at the `0xcca8353a18e7ab7b3d094ee1f9ddc91bdf2ca6a4`
    address so that at the time of deploying the `Sample` contract in network 1, it
    will link it automatically. Under a network object, we can also put an `address`
    property, indicating that the contract is already deployed to this network and
    this is the contract address. We also have an `events` objects in the `networks`
    object, which specifies the events of the contract we are interested in catching.
    The keys of the `events` object are topics of events and the `values` are the
    ABI of events.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有一个网络属性，指示各种网络中有关合同的信息。在这里，我们说在网络ID 1中，`StringLib`依赖项部署在`0xcca8353a18e7ab7b3d094ee1f9ddc91bdf2ca6a4`地址，因此在网络1中部署`Sample`合同时，它会自动链接它。在网络对象下，我们还可以放置一个`address`属性，指示合同已部署到此网络并且这是合同地址。在`networks`对象中还有一个`events`对象，指定我们感兴趣捕获的合同事件。`events`对象的键是事件的主题，而`values`是事件的ABI。
- en: Then, we call the `setProvider` method of the `SampleContract` object by passing
    a new provider instance. This is a way to pass the provider so that `truffle-contract`
    can communicate with the node. The `truffle-contract` API doesn't provide a way
    to set the provider globally; instead, you need to set a provider for every contract
    abstraction. This is a feature that lets us connect and work on multiple networks
    at once with ease.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过传递新的提供者实例调用`SampleContract`对象的`setProvider`方法。这是传递提供者的一种方式，以便`truffle-contract`可以与节点通信。`truffle-contract`
    API不提供全局设置提供者的方法；相反，您需要为每个合同抽象设置提供者。这是一个功能，使我们可以轻松连接和处理多个网络。
- en: Then, we call the `detectNetwork` method of the `SampleContract` object. This
    is the way to set the network ID that the contract abstraction is currently representing;
    that is, during all the operations on the contract abstraction, the values mapped
    to this network ID are used. This method will automatically detect which network
    ID our node is connected to and will set it automatically. If you want to manually
    set the network ID or change it at runtime, then you can use `SampleContract.setNetwork(network_id)`.
    If you change the network ID, then make sure that the provider is also pointing
    to the node of the same network since `truffle-contract` won't be able to map
    the network ID with correct links, addresses, and events otherwise.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`SampleContract`对象的`detectNetwork`方法。这是设置合同抽象当前表示的网络ID的方法；也就是说，在合同抽象的所有操作中，使用映射到此网络ID的值。此方法将自动检测我们的节点连接到哪个网络ID，并将其自动设置。如果您想要手动设置网络ID或在运行时更改它，则可以使用`SampleContract.setNetwork(network_id)`。如果更改网络ID，则确保提供者也指向相同网络的节点，因为否则`truffle-contract`将无法将网络ID与正确的链接、地址和事件进行映射。
- en: Then, we set default values for transactions made for `SampleContract`. This
    method gets and, optionally, sets transaction defaults. If called without any
    parameters, it will simply return an object representing the current defaults.
    If an object is passed, this will set new defaults.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`SampleContract`进行了交易的默认值设置。此方法获取并可选地设置交易默认值。如果没有传递任何参数调用，它将简单地返回表示当前默认值的对象。如果传递了对象，则将设置新的默认值。
- en: We did the same for the `StringLib` library in order to create a contract abstraction
    for it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`StringLib`库执行了相同的操作，以便为其创建一个合约抽象。
- en: Creating contract instances
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建合约实例
- en: 'A contract instance represents a deployed contract in a particular network.
    Using a contract abstraction instance, we need to create a contract instance.
    There are three methods to create a contract instance:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 合约实例表示特定网络中部署的合约。使用合约抽象实例，我们需要创建合约实例。创建合约实例有三种方法：
- en: '`SampleContract.new([arg1, arg2, ...], [tx params])`: This function takes whatever
    constructor parameters your contract requires and deploys a new instance of the
    contract to the network to which the contract abstraction is set to use. There''s
    an optional last argument, which you can use to pass transaction parameters, including
    the transaction from address, gas limit, and gas price. This function returns
    a promise that resolves into a new instance of the contract abstraction at the
    newly deployed address when the transaction is mined. This method doesn''t make
    any changes to the artifacts object the contract abstraction represents. Before
    using this method, make sure that it can find the libraries'' addresses that the
    byte code is dependent on for the network it''s set to use.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SampleContract.new([arg1, arg2, ...], [tx params])`: 此函数接受您的合约所需的任何构造函数参数，并将合约的新实例部署到合约抽象设置要使用的网络中。最后一个参数是可选的，您可以使用它来传递事务参数，包括事务来自地址、燃气限制和燃气价格。此函数返回一个承诺，当交易被挖掘时，它会解析为新部署地址处的合约抽象实例。此方法不会对合约抽象所代表的构件对象进行任何更改。在使用此方法之前，请确保它能找到字节码所依赖的库的地址，以供设置要使用的网络。'
- en: '`SampleContract.at(address)`: This function creates a new instance of the contract
    abstraction representing the contract at the passed-in address. It returns a "thenable"
    object (not yet an actual promise for backward compatibility). It resolves to
    a contract abstraction instance after ensuring that the code exists at the specified
    address in the network it''s set to use.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SampleContract.at(address)`: 此函数创建一个新的合约抽象实例，表示传入地址处的合约。它返回一个“可被解析的”对象（出于向后兼容性，尚未实际承诺）。在确保代码存在于指定地址所在的网络之后，它会解析为一个合约抽象实例。'
- en: '`SampleContract.deployed()`: This is just like `at()`, but the address is retrieved
    from the artifacts object. `Like at()`, `deployed()` is tenable and will resolve
    to a contract instance representing the deployed contract after ensuring that
    the code exists at that location and that the address exists on the network that
    the contract abstraction is set to use.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SampleContract.deployed()`: 这就像`at()`一样，但地址是从构件对象中检索的。像`at()`一样，`deployed()`是可解析的，并且将解析为代表部署合约的合约实例，以确保代码存在于该位置，并且地址存在于设置为使用的网络上。'
- en: 'Let''s deploy and get a contract instance of the `Sample` contract. In `network
    ID 10`, we need to use `new()` to deploy the `StringLib` library first and then
    add the deployed address of the `StringLib` library to the `StringLib` abstraction,
    link the `StringLib` abstraction to the `SampleContract` abstraction, and then
    deploy the `Sample` contract using `new()` to get an instance of the `Sample`
    contract. But in `network ID 1`, we just need to deploy `SampleContract` and get
    its instance, as we already have `StringLib` deployed there. Here is the code
    to do all this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署并获取`Sample`合约的合约实例。在`网络ID 10`中，我们需要使用`new()`首先部署`StringLib`库，然后将`StringLib`库的部署地址添加到`StringLib`抽象中，将`StringLib`抽象链接到`SampleContract`抽象，然后使用`new()`部署`Sample`合约以获取`Sample`合约的实例。但在`网络ID
    1`中，我们只需要部署`SampleContract`并获取其实例，因为我们已经在那里部署了`StringLib`。这是执行所有这些操作的代码：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is how the preceding code works:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的工作原理：
- en: At first, we detect the network ID. If the network ID is `10`, then we deploy
    both the contract and library, and if the network ID is `10`, then we only deploy
    the contract.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检测网络ID。如果网络ID是`10`，那么我们部署合约和库，如果网络ID是`10`，那么我们只部署合约。
- en: In `network ID 10`, we deploy the `StringLib` contract and get the contract
    instance of it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `网络 ID 10`，我们部署了 `StringLib` 合同并获得了它的合同实例。
- en: Then, we update the `StringLib` abstraction so that it knows about the address
    of the contract in the current network it represents. The interface to update
    the abstraction is similar to updating the artifacts object directly. If you are
    connected to network ID 1, then it will override the `StringLib` address, which
    is already set.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们更新 `StringLib` 抽象，以便它知道当前网络中合同的地址。更新抽象的界面类似于直接更新 artifacts 对象。如果你连接到网络
    ID 1，那么它将覆盖已设置的 `StringLib` 地址。
- en: Then, we link the deployed `StringLib` to the `SampleContract` abstraction.
    Linking updates the links and copies the events of the library to the `SampleContract`
    abstraction's current network it represents. Libraries can be linked multiple
    times and will overwrite their previous linkage.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将部署的 `StringLib` 链接到 `SampleContract` 抽象中。链接将更新链接并将库的事件复制到该抽象当前网络所代表的 `SampleContract`。库可以被多次链接，并且会覆盖其先前的链接。
- en: We deploy `SampleContract` to the current network.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `SampleContract` 部署到当前网络。
- en: We update the `SampleContract` abstraction to store the address of the contract
    in the current network it's representing so that we can use `deployed()` to get
    the instance later on.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新 `SampleContract` 抽象以存储在其代表的当前网络中合同的地址，以便以后可以使用 `deployed()` 获取实例。
- en: In the case of network ID 1, we just deploy `SampleContract` and that's it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络 ID 1 的情况下，我们只部署 `SampleContract` 就可以了。
- en: Now you can simply change the network that your node is connected to and restart
    your app, and your app will behave accordingly. So for example, on a developer's
    machine, the app will be connected to a development network and on a production
    server, it will be connected to the main network. Obviously, you may not want
    to deploy the contracts every time the preceding file is run, so you can actually
    update the artifacts objects once the contracts are deployed and in the code you
    can check whether the contract is deployed or not. If not deployed, only then
    should you deploy it. Instead of updating the artifacts object manually, you can
    store the artifacts in a DB or in a file and write code to update them automatically
    after the contract deployment is done.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你只需简单地更改连接的网络并重新启动你的应用程序，你的应用程序就会相应地运行。例如，在开发者的机器上，应用程序将连接到开发网络，而在生产服务器上，它将连接到主网络。显然，你可能不希望每次运行前述文件时都部署合同，因此在部署合同后，你可以实际上更新
    artifacts 对象并在代码中检查合同是否已部署。如果尚未部署，则只需部署。而不是手动更新 artifacts 对象，你可以将 artifacts 存储在数据库中或文件中，并编写代码在合同部署完成后自动更新它们。
- en: The contract instance API
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同实例 API
- en: 'Each contract instance is different based on the source Solidity contract,
    and the API is created dynamically. Here are the various the APIs of a contract
    instance:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合同实例都是基于 Solidity 合同源不同，并且 API 是动态创建的。以下是合同实例的各种 API：
- en: '`allEvents`: This is a function of a contract instance that takes a callback
    that is invoked whenever an event is fired by the contract matching the event
    signature under the current network ID in the contract artifacts object. You can
    also use `event name-specific` functions to catch specific events instead of all
    of them. In the preceding contract, to catch ping events, you can use `SampleContract_Instance.ping(function(e,
    r){})`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allEvents`：这是合同实例的一个函数，它接受一个回调，每当合同在当前网络 ID 下触发符合事件签名的事件时就会调用。你也可以使用`特定事件名`的函数来捕捉特定事件，而不是全部事件。在前述合同中，要捕捉
    ping 事件，你可以使用 `SampleContract_Instance.ping(function(e, r){})`。'
- en: '`send`: This function is used to send ether to the contract. It takes two arguments;
    that is, the first argument is the amount of wei to transfer and the second argument
    is an optional object that can used to set the `from` of the transaction, which
    indicates from which address the ether is being sent. This call returns a promise,
    and the promise resolves to the details about the transaction when its mined.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`：此函数用于向合同发送以太币。它接受两个参数；即第一个参数是要传输的 wei 数量，第二个参数是一个可选对象，可用于设置交易的 `from`，指示以太币是从哪个地址发送的。此调用返回一个
    promise，并且当其被挖掘时，该 promise 解析为交易的详细信息。'
- en: We can invoke any method of the contract using `SampleContract.functionName()`
    or `SampleContract.functionName.call()`. The first one sends a transaction, whereas
    the second one invokes the method on the EVM only, and the changes are not persistent.
    Both of these methods return a promise. In the first case, the promise resolves
    to the result of the transaction, that is, an object holding a transaction hash,
    logs, and transaction receipt. And in the second case, it resolves to the return
    value of the method `call`. Both the methods take function arguments and an optional
    last argument, which is an object to set `from`, `gas`, `value`, and so on of
    the transaction.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `SampleContract.functionName()` 或 `SampleContract.functionName.call()`
    调用合约的任何方法。前者发送交易，而后者仅在 EVM 上调用方法，并且更改不是持久的。这两种方法都返回一个 promise。在第一种情况下，promise
    解析为交易的结果，即一个包含交易哈希、日志和交易收据的对象。而在第二种情况下，它解析为方法 `call` 的返回值。这两种方法都接受函数参数和一个可选的最后一个参数，该参数是一个对象，用于设置交易的
    `from`、`gas`、`value` 等。
- en: Introduction to truffle
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle 简介
- en: Truffle is a development environment (providing a command-line tool to compile,
    deploy, test, and build), framework (providing various packages to make it easy
    to write tests, deployment code, build clients, and so on) and asset pipeline
    (publishing packages and using packages published by others) to build ethereum-based
    DApps.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 是一个开发环境（提供命令行工具来编译、部署、测试和构建）、框架（提供各种包来编写测试、部署代码、构建客户端等）和资产管道（发布包并使用其他人发布的包）来构建基于以太坊的
    DApps。
- en: Installing truffle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Truffle
- en: 'Truffle works on OS X, Linux, and Windows. Truffle requires you to have Node.js
    version 5.0+ installed. At the time of writing this, the latest stable version
    of truffle is 3.1.2, and we will be using this version. To install truffle, you
    just need to run this command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 可在 OS X、Linux 和 Windows 上运行。Truffle 要求你安装 Node.js 版本 5.0+。在撰写本文时，Truffle
    的最新稳定版本是 3.1.2，我们将使用此版本。要安装 Truffle，只需运行以下命令：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before we go ahead, make sure you are running testrpc with network ID 10\. The
    reason is the same as the one discussed earlier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你正在运行 network ID 为 10 的 testrpc。原因与前面讨论的相同。
- en: Initializing truffle
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle 初始化
- en: 'First, you need to create a directory for your app. Name the directory altcoin.
    Inside the altcoin directory, run this command to initialize your project:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为你的应用创建一个目录。将目录命名为`altcoin`。在`altcoin`目录内，运行以下命令来初始化你的项目：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once completed, you''ll have a project structure with the following items:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将得到一个项目结构，其中包括以下项目：
- en: 'contracts: The directory where truffle expects to find `Solidity` contracts.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: contracts：Truffle 期望找到 `Solidity` 合约的目录。
- en: 'migrations: The directory to place files that contain contract deployment code.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: migrations：包含合约部署代码的文件目录。
- en: '`test`: The location of test files to test your smart contracts.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：用于测试智能合约的测试文件位置。'
- en: '`truffle.js`: The main truffle configuration file.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truffle.js`：主要的 Truffle 配置文件。'
- en: By default, `truffle init` gives you a set of example contracts (`MetaCoin`
    and `ConvertLib`), which act like a simple altcoin built on top of ethereum.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`truffle init` 会为你提供一组示例合约（`MetaCoin` 和 `ConvertLib`），它们就像是建立在以太坊之上的一个简单的代币。
- en: 'Here is the source code of the MetaCoin smart contract just for reference:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 MetaCoin 智能合约的源代码，仅供参考：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`MetaCoin` assigns 10 k metacoins to the account address that deployed the
    contract. 10 k is the total amount of bitcoins that exists. Now this user can
    send these metacoins to anyone using the `sendCoin()` function. You can find the
    balance of your account using `getBalance()`anytime. Assuming that one metacoin
    is equal to two ethers, you can get the balance in ether using `getBalanceInEth()`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaCoin` 将 10 k metacoins 分配给部署合约的账户地址。10 k 是存在的比特币的总量。现在这个用户可以使用 `sendCoin()`
    函数将这些 metacoins 发送给任何人。你可以随时使用 `getBalance()` 来查找你的账户余额。假设一个 metacoin 等于两个以太币，你可以使用
    `getBalanceInEth()` 获取以太币的余额。'
- en: The `ConvertLib` library is used to calculate the value of `metacoins` in ether.
    For this purpose, it provides the `convert()` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertLib` 库用于计算以太中 `metacoins` 的价值。为此，它提供了 `convert()` 方法。'
- en: Compiling contracts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合约编译
- en: 'Compiling contracts in truffle results in generating artifact objects with
    the `abi` and `unlinked_binary` set. To compile, run this command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Truffle 中编译合约会生成带有 `abi` 和 `unlinked_binary` 设置的构建对象。要编译，请运行以下命令：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Truffle will compile only the contracts that have been changed since the last
    compilation in order to avoid any unnecessarily compilation. If you'd like to
    override this behavior, run the preceding command with the `--all` option.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 只会编译自上次编译以来发生变化的合约，以避免不必要的编译。如果你想要覆盖这种行为，可以在前面的命令中加上`--all`选项。
- en: You can find the artifacts in the `build/contracts` directory. You are free
    to edit these files according to your needs. These files get modified at the time
    of running the `compile` and `migrate` commands.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`build/contracts`目录中找到这些构建文件。你可以根据需要自由编辑这些文件。这些文件在运行`compile`和`migrate`命令时会被修改。
- en: 'Here are a few things you need to take care of before compiling:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，以下是需要注意的几件事：
- en: 'Truffle expects your contract files to define contracts that match their filenames
    exactly. For instance, if you have a file called `MyContract.sol`, one of these
    should exist within the contract file: contract `MyContract{}` or `library myContract{}`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle 期望你的合约文件定义与其文件名完全匹配的合约。例如，如果你有一个名为`MyContract.sol`的文件，那么合约文件中应该存在其中一个：`contract
    MyContract{}`或`library myContract{}`。
- en: Filename matching is case-sensitive, which means that if your filename isn't
    capitalized, your contract name shouldn't be capitalized either.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名匹配区分大小写，这意味着如果你的文件名没有大写，那么你的合约名也不应该有大写。
- en: You can declare contract dependencies using Solidity's `import` command. Truffle
    will compile contracts in the correct order and link libraries automatically when
    necessary. Dependencies must be specified as relative to the current Solidity
    file, beginning with either `./` or `../`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Solidity 的`import`命令声明合约依赖关系。Truffle 将按照正确的顺序编译合约，并在必要时自动链接库。依赖关系必须相对于当前
    Solidity 文件指定，并以`./`或`../`开头。
- en: Truffle version 3.1.2 uses compiler version 0.4.8\. Truffle doesn't currently
    support changing the compiler version, so it's fixed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 版本 3.1.2 使用的编译器版本是 0.4.8。目前 Truffle 不支持更改编译器版本，因此是固定的。
- en: Configuration files
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'The `truffle.js` file is a JavaScript file used to configure the project. This
    file can execute any code necessary to create the configuration for the project.
    It must export an object representing your project configuration. Here is the
    default content of the file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`truffle.js`文件是用于配置项目的 JavaScript 文件。该文件可以执行任何必要的代码来创建项目的配置。它必须导出一个代表你的项目配置的对象。以下是文件的默认内容：'
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are various properties this object can contain. But the most basic one
    is `networks`. The `networks` property specifies which networks are available
    for deployment as well as specific transaction parameters when interacting with
    each network (such as `gasPrice`, `from`, `gas`, and so on). The default `gasPrice`
    is 100,000,000,000, `gas` is 4712388, and `from` is the first available contract
    in the ethereum client.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象可以包含各种属性。但最基本的一个是`networks`。`networks`属性指定了哪些网络可用于部署，以及在与每个网络交互时的特定交易参数（例如`gasPrice`、`from`、`gas`等）。默认的`gasPrice`是
    100,000,000,000，`gas`是 4712388，`from`是以太坊客户端中的第一个可用合约。
- en: 'You can specify as many networks as you want. Go ahead and edit the configuration
    file to this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定任意数量的网络。请编辑配置文件为以下内容：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are defining two networks with the names `development`
    and `live`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了两个名为`development`和`live`的网络。
- en: When using Command Prompt on Windows, the default configuration filename can
    cause a conflict with the `truffle` executable. If this is the case, we recommend
    that you use Windows PowerShell or Git BASH as these shells do not have this conflict.
    Alternatively, you can rename the configuration file to `truffle-config.js` in
    order to avoid this conflict.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Windows 上使用命令提示符时，默认的配置文件名称可能会与`truffle`可执行文件发生冲突。如果是这种情况，我们建议您使用 Windows
    PowerShell 或 Git BASH，因为这些 shell 不会出现此冲突。或者，您可以将配置文件重命名为`truffle-config.js`以避免此冲突。
- en: Deploying contracts
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署合约
- en: 'Even the smallest project will interact with at least two blockchains: one
    on the developer''s machine, such as the EthereumJS TestRPC, and the other representing
    the network where the developer will eventually deploy their application (this
    could be the main ethereum network or a private consortium network, for instance).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最小的项目也会与至少两个区块链进行交互：一个是开发者机器上的，比如 EthereumJS TestRPC，另一个代表着开发者最终将部署其应用程序的网络（例如主
    Ethereum 网络或私有联盟网络）。
- en: Because the network is auto-detected by the contract abstractions at runtime,
    it means that you only need to deploy your application or frontend once. When
    your application is run, the running ethereum client will determine which artifacts
    are used, and this will make your application very flexible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网络在运行时由合约抽象自动检测，这意味着您只需要部署一次您的应用或前端。当您的应用运行时，运行的以太坊客户端将确定使用哪些 artifacts，并且这将使您的应用非常灵活。
- en: JavaScript files that contain code to deploy contracts to the ethereum network
    are called migrations. These files are responsible for staging your deployment
    tasks, and they're written under the assumption that your deployment needs will
    change over time. As your project evolves, you'll create new migration scripts
    to further this evolution on the blockchain. A history of previously run migrations
    is recorded on the blockchain through a special `Migrations` contract. If you
    have seen the contents of the `contracts` and `build/contracts` directory, then
    you would have noticed the `Migrations` contract's existence there. This contract
    should always be there and shouldn't be touched unless you know what you are doing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 包含将合约部署到以太坊网络的代码的 JavaScript 文件称为迁移。这些文件负责分阶段执行部署任务，并且根据您的部署需求会随着时间而变化。随着项目的发展，您将创建新的迁移脚本以在区块链上进一步发展。先前运行的迁移历史记录在区块链上通过特殊的
    `Migrations` 合约记录。如果您已经看过 `contracts` 和 `build/contracts` 目录的内容，那么您会注意到 `Migrations`
    合约的存在。该合约应始终存在，并且除非您知道自己在做什么，否则不应触摸它。
- en: Migration files
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移文件
- en: In the migrations directory, you will notice that the filenames are prefixed
    with a number; that is, you will find `1_initial_migration.js` and `2_deploy_contracts.js`
    files. The numbered prefix is required in order to record whether the migration
    ran successfully.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移目录中，您会注意到文件名以数字为前缀；也就是说，您会找到 `1_initial_migration.js` 和 `2_deploy_contracts.js`
    文件。要记录迁移是否成功运行，需要带有编号前缀。
- en: The `Migrations` contract stores (in `last_completed_migration`) a number that
    corresponds to the last applied migration script found in the `migrations` folder.
    The `Migrations` contract is always deployed first. The numbering convention is
    `x_script_name.js`, with x starting at 1\. Your app contracts would typically
    come in scripts starting at 2.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Migrations` 合约（存储在 `last_completed_migration` 中）存储着对应于 `migrations` 文件夹中找到的最后一个应用的迁移脚本的编号。`Migrations`
    合约总是首先部署。编号约定为 `x_script_name.js`，其中 x 从 1 开始。你的应用合约通常从编号为 2 的脚本开始。'
- en: So, as this `Migrations` contract stores the number of the last deployment script
    applied, truffle will not run these scripts again. On the other hand, in future,
    your app may need to have a modified, or new, contract deployed. For that to happen,
    you create a new script with an increased number that describes the steps that
    need to take place. Then, again, after they have run once, they will not run again.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于 `Migrations` 合约存储了应用的最后部署脚本的编号，truffle 将不会再次运行这些脚本。另一方面，未来，您的应用可能需要部署修改过的或新的合约。为了实现这一点，您会创建一个增加编号的新脚本，描述需要发生的步骤。然后，再次运行一次后，它们将不会再次运行。
- en: Writing migrations
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写迁移
- en: At the beginning of a migration file, we tell truffle which contracts we'd like
    to interact with via the `artifacts.require()` method. This method is similar
    to Node's `require`, but in our case, it specifically returns a contract abstraction
    that we can use within the rest of our deployment script.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移文件的开头，我们通过 `artifacts.require()` 方法告诉 truffle 我们想要与之交互的合约。这个方法类似于 Node 的
    `require`，但在我们的情况下，它具体返回一个合约抽象，我们可以在部署脚本的其余部分中使用它。
- en: All migrations must export a function via the `module.exports` syntax. The function
    exported by each migration should accept a `deployer` object as its first parameter.
    This object assists in deployment both by providing a clear API to deploy smart
    contracts as well as performing some of the deployment's more mundane duties,
    such as saving deployed artifacts in the artifacts files for later use, linking
    libraries, and so on. The `deployer` object is your main interface for the staging
    of deployment tasks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所有迁移必须通过 `module.exports` 语法导出一个函数。每个迁移导出的函数应将一个 `deployer` 对象作为其第一个参数。该对象通过提供清晰的
    API 来部署智能合约，并执行一些部署的更普通的职责，例如保存部署后的 artifacts 文件以供以后使用，链接库等，来协助部署。`deployer` 对象是您进行部署任务分阶段的主要接口。
- en: 'Here are the methods of the deployer object. All the methods are synchronous:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 deployer 对象的方法。所有方法都是同步的：
- en: '`deployer.deploy(contractAbstraction, args..., options)`: Deploys a specific
    contract specified by the contract abstraction object, with optional constructor
    arguments. This is useful for singleton contracts, so that only one instance of
    this contract exists for your DApp. This will set the address of the contract
    after deployment (that is, the `address` property in the artifacts file will equal
    the newly deployed address), and it will override any previous address stored.
    You can optionally pass an array of contracts, or an array of arrays, to speed
    up the deployment of multiple contracts. Additionally, the last argument is an
    optional object that can contain a single key, `overwrite`. If `overwrite` is
    set to `false`, the deployer won''t deploy this contract if one has already been
    deployed. This method returns a promise.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployer.deploy(contractAbstraction, args..., options)`: 部署由合约抽象对象指定的特定合约，可选择传入构造函数参数。对于单例合约非常有用，这样您的
    DApp 只存在一个该合约的实例。这将在部署后设置合约的地址（也就是 artifacts 文件中的`address`属性将等于新部署的地址），并覆盖存储的任何先前地址。您还可以选择传递一个合约数组或数组的数组，以加速多个合约的部署。此外，最后一个参数是一个可选对象，它可以包含一个单一键，即`overwrite`。如果`overwrite`设置为`false`，则如果已经部署了合约，则部署器将不会部署此合约。此方法返回一个
    promise。'
- en: '`deployer.link(library, destinations)`: Links an already deployed library to
    a contract or multiple contracts. The `destinations` argument can be a single
    contract abstraction or an array of multiple contract abstractions. If any contract
    within the destination doesn''t rely on the library being linked, the deployer
    will ignore that contract. This method returns a promise.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployer.link(library, destinations)`: 将已部署的库链接到一个或多个合约。`destinations`参数可以是单个合约抽象或多个合约抽象的数组。如果目标中的任何合约不依赖于被链接的库，则部署器将忽略该合约。此方法返回一个
    promise。'
- en: '`deployer.then(function(){})`: This is used to run an arbitrary deployment
    step. Use it to call specific contract functions during your migration to add,
    edit, and reorganize contract data. Inside the callback function, you would use
    the contract abstraction APIs to deploy and link contracts.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployer.then(function(){})`: 用于运行任意的部署步骤。在迁移期间调用特定合约函数以添加、编辑和重新组织合约数据时使用它。在回调函数内部，您将使用合约抽象
    API 部署和链接合约。'
- en: 'It is possible to run the deployment steps conditionally based on the network
    being deployed to. To conditionally stage the deployment steps, write your migrations
    so that they accept a second parameter called `network`. One example use case
    can be that many of the popular libraries are already deployed to the main network;
    therefore, when using these networks, we will not deploy the libraries again and
    just link them instead. Here is a code example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据要部署到的网络条件性地运行部署步骤。为了有条件地分阶段部署步骤，编写迁移以便它们接受名为`network`的第二个参数。一个示例用例可以是，许多流行的库已经部署到了主网络；因此，当使用这些网络时，我们不会再次部署库，而只会链接它们。以下是一个代码示例：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the project, you will find two migration files, that is, `1_initial_migration.js`
    and `2_deploy_contracts.js`. The first file shouldn''t be edited unless you know
    what you are doing. You are free to do anything with the other file. Here is the
    code for the `2_deploy_contracts.js` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，您会发现两个迁移文件，即`1_initial_migration.js`和`2_deploy_contracts.js`。第一个文件不应该被编辑，除非您知道自己在做什么。您可以自由处理另一个文件。以下是`2_deploy_contracts.js`文件的代码：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are creating abstractions for the `CovertLib` library and the `MetaCoin`
    contract at first. Regardless of which network is being used, we are deploying
    the `ConvertLib` library and then linking the library to the `MetaCoin` network
    and finally deploying the `MetaCoin` network.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先为`CovertLib`库和`MetaCoin`合约创建了抽象。无论使用哪个网络，我们都会部署`ConvertLib`库，然后将库链接到`MetaCoin`网络，最后部署`MetaCoin`网络。
- en: 'To run the migrations, that is, to deploy the contracts, run this command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行迁移，也就是部署合约，请运行以下命令：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are telling truffle to run migrations on the development network. If
    we don't provide the `--network` option, then it will use the network with the
    name `development` by default.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 truffle 在开发网络上运行迁移。如果我们不提供`--network`选项，则默认使用名称为`development`的网络。
- en: After you run the preceding command, you will notice that truffle will automatically
    update the `ConvertLib` library and `MetaCoin` contract addresses in the artifacts
    files and also update the `links`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前述命令后，您会注意到 truffle 将自动更新 artifacts 文件中的`ConvertLib`库和`MetaCoin`合约地址，并更新链接。
- en: 'Here are some other important options you can provide to the migrate sub-command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以提供给 migrate 子命令的一些其他重要选项：
- en: '`--reset`: Runs all migrations from the beginning instead of running from the
    last completed migration.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--reset`：从头开始运行所有迁移，而不是从上次完成的迁移开始运行。'
- en: '-`f number`: Runs contracts from a specific migration.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -`f number`：从特定迁移运行合同。
- en: You can find the address of the contracts and libraries of your project in various
    networks using the `truffle networks` command anytime.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时使用 `truffle networks` 命令在各种网络中找到项目的合同和库的地址。
- en: Unit testing contracts
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试合同
- en: Unit testing is a type of testing an app. It is a process in which the smallest
    testable parts of an application, called units, are individually and independently
    examined for proper operation. Unit testing can be done manually but is often
    automated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试应用程序的一种类型。这是一个过程，其中应用程序的最小可测试部分（称为单元）被单独和独立地检查是否正确运行。单元测试可以手动进行，但通常是自动化的。
- en: Truffle comes with a unit testing framework by default to automate the testing
    of your contracts. It provides a clean room environment when running your test
    files; that is, truffle will rerun all of your migrations at the beginning of
    every test file to ensure you have a fresh set of contracts to test against.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 默认提供了一个单元测试框架来自动化测试你的合同。它在运行测试文件时提供了一个干净的环境；也就是说，truffle 会在每个测试文件开始时重新运行所有迁移，以确保你有一套新鲜的合同进行测试。
- en: 'Truffle lets you write simple and manageable tests in two different ways:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 让你以两种不同的方式编写简单易管理的测试：
- en: In JavaScript, to exercise your contracts from the app client
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，从应用客户端执行你的合同
- en: In Solidity, to exercise your contracts from other contracts
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Solidity 中，从其他合同执行你的合同
- en: Both styles of tests have their advantages and drawbacks. We will learn both
    ways of writing tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 两种测试方式都有各自的优点和缺点。我们将学习两种编写测试的方式。
- en: 'All test files should be located in the `./test` directory. Truffle will run
    test files only with these file extensions: `.js`, `.es`, `.es6`, and `.jsx`,
    and `.sol`. All other files are ignored.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试文件都应位于 `./test` 目录中。Truffle 只会运行具有以下文件扩展名的测试文件：`.js`、`.es`、`.es6`、`.jsx`
    和 `.sol`。所有其他文件都会被忽略。
- en: The `ethereumjs-testrpc` is significantly faster than other clients when running
    automated tests. Moreover, `testrpc` contains special features that truffle takes
    advantage of to speed up the test runtime by almost 90 percent. As a general workflow,
    we recommend that you use `testrpc` during normal development and testing and
    then run your tests once against go-ethereum or another official ethereum client
    when you're gearing up to deploy to live or production networks.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行自动化测试时，`ethereumjs-testrpc` 比其他客户端快得多。此外，`testrpc` 包含 truffle 利用的特殊功能，可将测试运行时间加速近
    90%。作为一般的工作流程，我们建议你在正常开发和测试期间使用 `testrpc`，然后在准备部署到实时或生产网络时，再对 go-ethereum 或其他官方以太坊客户端运行一次测试。
- en: Writing tests in JavaScript
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JavaScript 编写测试
- en: Truffle's JavaScript testing framework is built on top of mocha. Mocha is a
    JavaScript framework to write tests, whereas chai is an assertion library.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 的 JavaScript 测试框架是基于 mocha 构建的。Mocha 是一个用于编写测试的 JavaScript 框架，而 chai
    是一个断言库。
- en: Testing frameworks are used to organize and execute tests, whereas assertion
    libraries provide utilities to verify that things are correct. Assertion libraries
    make it a lot easier to test your code so you don't have to perform thousands
    of if statements. Most of the testing frameworks don't have an assertion library
    included and let the user plug which one they want to use.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架用于组织和执行测试，而断言库提供了验证事物是否正确的工具。断言库使得测试代码变得更容易，这样你就不必执行成千上万的 if 语句。大多数测试框架不包含断言库，并允许用户插入他们想要使用的库。
- en: Before continuing further, you need to learn how to write tests with mocha and
    chai. To learn mocha, visit [https://mochajs.org/](https://mochajs.org/) and to
    learn chai, visit [http://chaijs.com/](http://chaijs.com/).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要学习如何使用 mocha 和 chai 编写测试。要学习 mocha，请访问 [https://mochajs.org/](https://mochajs.org/)，要学习
    chai，请访问 [http://chaijs.com/](http://chaijs.com/)。
- en: Your tests should exist in the `./test` directory, and they should end with
    a `.js` extension.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试应该存在于 `./test` 目录中，并且它们应该以 `.js` 扩展名结尾。
- en: Contract abstractions are the basis for making contract interaction possible
    from JavaScript. Because truffle has no way of detecting which contracts you'll
    need to interact with within your tests, you'll need to ask for these contracts
    explicitly. You do this by using the `artifacts.require()` method. So the first
    thing that should be done in test files is to create abstractions for the contracts
    that you want to test.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 合约抽象是从 JavaScript 实现合约交互的基础。因为 truffle 无法检测到你在测试中需要与哪些合约交互，所以你需要显式地请求这些合约。你可以通过使用`artifacts.require()`方法来实现。因此，在测试文件中应该首先为你想要测试的合约创建抽象。
- en: 'Then, the actual tests should be written. Structurally, your tests should remain
    largely unchanged from those of mocha. The test files should contain code that
    mocha will recognize as an automated test. What makes truffle tests different
    from mocha is the `contract()` function: this function works exactly like `describe()`,
    except that it signals truffle to run all migrations. The `contract()` function
    works like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应该编写实际的测试。结构上，你的测试应该与 mocha 的大部分测试保持基本一致。测试文件应该包含 mocha 可识别为自动化测试的代码。使 truffle
    测试与 mocha 不同的是`contract()`函数：此函数的工作方式与`describe()`完全相同，只是它会告诉 truffle 运行所有迁移。`contract()`函数的工作方式如下：
- en: Before each `contract()` function is run, your contracts are redeployed to the
    running ethereum node, so the tests within it run with a clean contract state
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行每个`contract()`函数之前，你的合约都会被重新部署到运行中的以太坊节点上，因此其中的测试会以清洁的合约状态运行。
- en: The `contract()` function provides a list of accounts made available by your
    ethereum node, which you can use to write tests
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contract()`函数提供了由你的以太坊节点提供的一系列帐户，你可以用它们来编写测试。'
- en: Since truffle uses mocha under the hood, you can still use `describe()` to run
    normal mocha tests whenever truffle features are unnecessary.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 truffle 在内部使用 mocha，所以当 truffle 功能不必要时，仍然可以使用`describe()`来运行普通的 mocha 测试。
- en: 'Here is the default test code generated by truffle to test the `MetaCoin` contract.
    You will find this code in the `metacoin.js` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 truffle 生成的用于测试`MetaCoin`合约的默认测试代码。你可以在`metacoin.js`文件中找到这段代码：
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, you can see that all the contract's interaction code
    is written using the `truffle-contract` library. The code is self-explanatory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，你可以看到所有合约的交互代码都是使用`truffle-contract`库编写的。这段代码很容易理解。
- en: 'Finally, truffle gives you access to mocha''s configuration so you can change
    how mocha behaves. mocha''s configuration is placed under a `mocha` property in
    the `truffle.js` file''s exported object. For example, take a look at this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，truffle为你提供了对 mocha 配置的访问，以便你可以更改 mocha 的行为。mocha 的配置放在`truffle.js`文件导出的对象的`mocha`属性下。例如，看一下这个：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Writing tests in Solidity
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Solidity 中编写测试
- en: 'Solidity test code is put in `.sol` files. Here are the things you need to
    note about Solidity tests before writing tests using Solidity:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 测试代码放在`.sol`文件中。在使用 Solidity 编写测试之前，请注意以下事项：
- en: Solidity tests shouldn't extend from any contract. This makes your tests as
    minimal as possible and gives you complete control over the contracts you write.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity 测试不应该继承任何合约。这样可以使你的测试尽可能简洁，并完全控制你编写的合约。
- en: Truffle provides a default assertion library for you, but you can change this
    library at any time to fit your needs.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle为你提供了默认的断言库，但你可以随时更改此库以满足你的需求。
- en: You should be able to run your Solidity tests against any ethereum client.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该能够针对任何以太坊客户端运行你的 Solidity 测试。
- en: 'To learn how to write tests in Solidity, let''s explore the default Solidity
    test code generated by truffle. This is the code, and it can be found in the `TestMetacoin.sol`
    file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在 Solidity 中编写测试，让我们来探索 truffle 生成的默认 Solidity 测试代码。这是代码，可以在`TestMetacoin.sol`文件中找到：
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is how the preceding code works:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的工作原理：
- en: Assertion functions such as `Assert.equal()` are provided to you by the `truffle/Assert.sol`
    library. This is the default assertion library; however, you can include your
    own assertion library as long as the library loosely integrates with truffle's
    test runner by triggering the correct assertion events. Assertion functions fire
    events, which are caught by truffle, and information is displayed. This is the
    architecture of Solidity assertion libraries in truffle. You can find all the
    available assertion functions in `Assert.sol` ([https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol](https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol)).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如`Assert.equal()`之类的断言函数由`truffle/Assert.sol`库提供。这是默认的断言库；但是，只要该库触发正确的断言事件，您就可以包含自己的断言库，以便与truffle的测试运行器松散集成。断言函数触发事件，这些事件被truffle捕获，并显示信息。这是truffle中Solidity断言库的架构。您可以在`Assert.sol`中找到所有可用的断言函数（[https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol](https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol)）。
- en: In the import path, `truffle/Assert.sol`, `truffle` is the package name. We
    will learn more about packages later.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入路径中，`truffle/Assert.sol`，`truffle`是包名。我们稍后将详细了解包。
- en: The addresses of your deployed contracts (that is, contracts that were deployed
    as part of your migrations) are available through the `truffle/DeployedAddresses.sol`
    library. This is provided by truffle and is recompiled and relinked before each
    test suite is run. This library provides functions for all of your deployed contracts
    in the form of `DeployedAddresses.<contract name>()`. This will return an address
    that you can then use to access that contract.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您部署的合约地址（即作为迁移的一部分部署的合约）可通过`truffle/DeployedAddresses.sol`库获得。这由truffle提供，并在运行每个测试套件之前重新编译和重新链接。此库提供了所有已部署合约的函数，形式为`DeployedAddresses.<contract
    name>()`。然后，这将返回一个地址，您可以使用该地址访问该合约。
- en: In order to use the deployed contract, you'll have to import the contract code
    into your test suite. Notice `import "../contracts/MetaCoin.sol";` in the preceding
    example. This import is relative to the test contract, which exists in the `./test`
    directory, and it goes outside of the test directory in order to find the `MetaCoin`
    contract. It then uses that contract to cast the address to the `MetaCoin` type.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用部署的合约，您必须将合约代码导入测试套件。请注意，上述示例中的`import "../contracts/MetaCoin.sol";`。此导入是相对于测试合约的，测试合约存在于`./test`目录中，它会超出测试目录以找到`MetaCoin`合约。然后，它使用该合约将地址转换为`MetaCoin`类型。
- en: All test contracts must start with `Test`, using an uppercase T. This distinguishes
    this contract from test helpers and project contracts (that is, the contracts
    under test), letting the test runner know which contracts represent test suites.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有测试合约都必须以大写字母`Test`开头。这将其与测试辅助工具和项目合约（即受测试约束的合约）区分开来，让测试运行器知道哪些合约代表测试套件。
- en: Like test contract names, all test functions must start with `test`, in lowercase.
    Each test function is executed as a single transaction in order of appearance
    in the test file (such as your JavaScript tests). Assertion functions provided
    by `truffle/Assert.sol` trigger events that the test runner evaluates to determine
    the result of the test. Assertion functions return a Boolean that represents the
    outcome of the assertion, which you can use to return from the test early to prevent
    execution errors (that is, errors that `testrpc` will expose).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像测试合约名称一样，所有测试函数都必须以小写字母`test`开头。每个测试函数都按照其在测试文件中的出现顺序作为单个事务执行（例如您的JavaScript测试）。由`truffle/Assert.sol`提供的断言函数触发测试运行器评估以确定测试结果的事件。断言函数返回一个表示断言结果的布尔值，您可以使用它来提前返回测试以防止执行错误（即`testrpc`将暴露的错误）。
- en: 'You are provided with many test hooks, shown in the following example. These
    hooks are `beforeAll`, `beforeEach`, `afterAll`, and `afterEach`, which are the
    same hooks provided by mocha in your JavaScript tests. You can use these hooks
    to perform setup and teardown actions before and after each test or before and
    after each suite is run. Like test functions, each hook is executed as a single
    transaction. Note that some complex tests will need to perform a significant amount
    of setup that might overflow the gas limit of a single transaction; you can get
    around this limitation by creating many hooks with different suffixes, as shown
    in the following example:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你提供了许多测试钩子，如下例所示。这些钩子是`beforeAll`、`beforeEach`、`afterAll`和`afterEach`，与你的JavaScript测试中mocha提供的相同钩子。你可以使用这些钩子在每个测试之前和之后或在每个套件运行之前和之后执行设置和拆卸操作。像测试函数一样，每个钩子都作为单个事务执行。注意，一些复杂的测试需要执行大量设置可能会超出单个事务的燃气限制；你可以通过创建带有不同后缀的多个钩子来避免这种限制，如下例所示：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test contract also shows that your `test` functions and `hook` functions
    all share the same contract state. You can set up the contract data before the
    test, use that data during the test, and reset it afterward in preparation for
    the next one. Note that just like your JavaScript tests, your next test function
    will continue from the state of the previous test function that ran.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个测试合约还显示了你的`test`函数和`hook`函数都共享相同的合约状态。你可以在测试之前设置合约数据，在测试期间使用该数据，并在准备下一个测试之前重置它。注意，就像你的JavaScript测试一样，你的下一个测试函数将从上一个运行的测试函数的状态继续。
- en: Truffle doesn't provide a direct way to test whether your contract should and
    shouldn't throw exception (that is, for contracts that use throw to signify an
    expected error). But a hacky solution is there for this, which you can find at
    [http://truffleframework.com/tutorials/testing-for-throws-in-Solidity-tests](http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle没有直接的方法来测试你的合约是否应该抛出异常（也就是说，对于使用throw来表示预期错误的合约）。但是有一个笨拙的解决方案，你可以在这里找到：[http://truffleframework.com/tutorials/testing-for-throws-in-Solidity-tests](http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests)。
- en: How to send ether to a test contract
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何向测试合约发送以太币
- en: 'To send ether to your Solidity test contract, it should have a public function
    that returns `uint`, called `initialBalance` in that contract. This can be written
    directly as a function or a public variable. When your test contract is deployed
    to the network, truffle will send that amount of ether from your test account
    to your test contract. Your test contract can then use that ether to script ether
    interactions within your contract under test. Note that `initialBalance` is optional
    and not required. For example, take a look at the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要向你的Solidity测试合约发送以太币，它应该有一个名为`initialBalance`的返回`uint`的公共函数。这可以直接写成一个函数或一个公共变量。当你的测试合约部署到网络上时，truffle会从你的测试账户向你的测试合约发送那个金额的以太币。然后，你的测试合约可以使用那个以太币在你的测试合约中脚本以太交互。注意，`initialBalance`是可选的，不是必需的。例如，看看下面的代码：
- en: '[PRE25]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Truffle sends ether to your test contract in a way that does not execute a fallback
    function, so you can still use the fallback function within your Solidity tests
    for advanced test cases.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle以一种不执行回退函数的方式向你的测试合约发送以太币，所以你仍然可以在你的Solidity测试中使用回退函数进行高级测试用例。
- en: Running tests
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'To run your test scripts, just run this command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的测试脚本，只需运行这个命令：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, you can specify a path to a specific file you want to run. For
    example, take a look at this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以指定要运行的特定文件的路径。例如，看看这个：
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Package management
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理
- en: 'A truffle package is a collection of smart contracts and their artifacts. A
    package can depend on zero or more packages, that is, you use the package''s smart
    contracts and artifacts. When using a package within your own project, it is important
    to note that there are two places where you will be using the package''s contracts
    and artifacts: within your project''s contracts and within your project''s JavaScript
    code (migrations and tests).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个truffle包是智能合约和它们的构件的集合。一个包可以依赖于零个或多个包，也就是说，你可以使用包的智能合约和构件。当在你自己的项目中使用包时，重要的是要注意有两个地方你将使用包的合约和构件：在你的项目的合约中和在你的项目的JavaScript代码中（迁移和测试）。
- en: 'Projects created with truffle have a specific layout by default, which enables
    them to be used as packages. The most important directories in a `truffle` package
    are the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用truffle创建的项目默认具有特定的布局，使它们可以被用作包。`truffle`包中最重要的目录如下：
- en: '`/contracts`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/contracts`'
- en: '`/build/contracts` (created by truffle)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/build/contracts`（由truffle创建）'
- en: The first directory is your contracts directory, which includes your raw Solidity
    contracts. The second directory is the `/build/contracts` directory, which holds
    build artifacts in the form of `.json` files.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目录是你的合约目录，包括原始的Solidity合约。第二个目录是`/build/contracts`目录，其中保存着以`.json`文件形式的构建产物。
- en: 'Truffle supports two kinds of package builds: `npm` and `ethpm` packages. You
    must know what `npm` packages are, but let''s look at what `ethpm` packages are.
    `Ethpm` is a package registry for ethereum. You can find all `ethpm` packages
    at [https://www.ethpm.com/](https://www.ethpm.com/). It follows the ERC190 ([https://github.com/ethereum/EIPs/issues/190](https://github.com/ethereum/EIPs/issues/190))
    spec for publishing and consuming smart contract packages.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle支持两种包构建方式：`npm`和`ethpm`包。你必须知道什么是`npm`包，但让我们来看看什么是`ethpm`包。`Ethpm`是以太坊的包注册表。你可以在[https://www.ethpm.com/](https://www.ethpm.com/)找到所有的`ethpm`包。它遵循ERC190
    ([https://github.com/ethereum/EIPs/issues/190](https://github.com/ethereum/EIPs/issues/190))
    规范来发布和消费智能合约包。
- en: Package management via NPM
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过NPM进行包管理
- en: Truffle comes with npm integration by default and is aware of the `node_modules`
    directory in your project, if it exists. This means that you can use and distribute
    contracts or libraries via npm, making your code available to others and other's
    code available to you. You can also have a `package.json` file in your project.
    You can simply install any `npm` package in your project and import it in any
    of the JavaScript files, but it would be called a truffle package only if it contains
    the two directories mentioned earlier. Installing an `npm` package in a truffle
    project is the same as installing an `npm` package in any `Node.js` app.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle默认带有npm集成，并且知道项目中的`node_modules`目录（如果存在）。这意味着你可以通过npm使用和分发合约或库，使你的代码对其他人可用，其他人的代码对你可用。你的项目中也可以有一个`package.json`文件。你可以在项目中简单地安装任何`npm`包，并在任何JavaScript文件中导入它，但只有包含前面提到的两个目录的情况下，它才会被称为truffle包。在truffle项目中安装`npm`包与在任何`Node.js`应用程序中安装`npm`包相同。
- en: Package management via EthPM
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过EthPM进行包管理
- en: When installing EthPM packages, an `installed_contracts` directory is created
    if it doesn't exist. This directory can be treated in a manner similar to the
    `node_modules` directory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装EthPM包时，如果不存在，将创建一个`installed_contracts`目录。该目录可以类似于`node_modules`目录进行处理。
- en: 'Installing a package from EthPM is nearly as easy as installing a package via
    NPM. You can simply run the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过EthPM安装包几乎与通过NPM安装包一样简单。你只需运行以下命令：
- en: '[PRE28]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also install a package at a specific version:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以安装特定版本的包：
- en: '[PRE29]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like NPM, EthPM versions follow semver. Your project can also define an `ethpm.json`
    file, which is similar to `package.json` for npm packages. To install all dependencies
    listed in the `ethpm.json` file, run the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 像NPM一样，EthPM版本遵循语义版本规范。你的项目也可以定义一个`ethpm.json`文件，它类似于npm包的`package.json`。要安装`ethpm.json`文件中列出的所有依赖项，请运行以下命令：
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An example `ethpm.json` file looks like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例的`ethpm.json`文件如下所示：
- en: '[PRE31]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating and publishing an `npm` package for truffle is the same process as
    creating any other `npm` package. To learn how to create and publish an `ethpm` package,
    visit [http://truffleframework.com/docs/getting_started/packages-ethpm#publishing-your-own-package](http://truffleframework.com/docs/getting_started/packages-ethpm#publishing-your-own-package).
    Regardless of whether you are publishing your package as an `npm` package or `ethpm`
    package, you need to run the `truffle networks --clean` command. When this command
    is run, it deletes artifacts for all those networks IDs that match only the `*`
    wildcard character in the configuration file. This is done as these addresses
    will be invalid for the other projects consuming this package, as these networks
    are most likely to be private as they are used for development purpose only. You
    shouldn't omit this command unless you know what you are doing. It will fail to
    delete any artifacts for private networks listed as a constant, so you need to
    delete them manually.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和发布一个truffle的`npm`包与创建任何其他`npm`包的过程相同。要了解如何创建和发布一个`ethpm`包，请访问[http://truffleframework.com/docs/getting_started/packages-ethpm#publishing-your-own-package](http://truffleframework.com/docs/getting_started/packages-ethpm#publishing-your-own-package)。无论您将包发布为`npm`包还是`ethpm`包，都需要运行`truffle
    networks --clean`命令。运行此命令时，它会删除配置文件中仅匹配`*`通配符的所有网络ID的构件。这是因为这些地址对于消费此包的其他项目来说是无效的，因为这些网络很可能是私有的，因为它们仅用于开发目的。除非你知道你在做什么，否则不应省略此命令。它将无法删除作为常量列出的私有网络的任何构件，因此您需要手动删除它们。
- en: Using contracts of packages within your contracts
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的合同内使用包的合同
- en: 'To use a package''s contracts within your contracts, it can be as simple as
    Solidity''s `import` statement. When your `import` path isn''t explicitly relative
    or absolute, it signifies to truffle that you''re looking for a file from a specific
    named package. Consider this example using the `example-truffle-library` ([https://github.com/ConsenSys/example-truffle-library](https://github.com/ConsenSys/example-truffle-library)):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的合同内使用包的合同，只需像Solidity的`import`语句一样简单。当您的`import`路径不是明确相对或绝对时，它表示您正在寻找特定命名包中的文件。考虑使用`example-truffle-library`（[https://github.com/ConsenSys/example-truffle-library](https://github.com/ConsenSys/example-truffle-library)）的示例：
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since the path didn't start with `./`, truffle knows to look in your project's
    `node_modules` or `installed_contracts` directory for the `example-truffle-library`
    folder. From there, it resolves the path to provide you with the contract you
    requested.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路径没有以`./`开头，truffle知道要在您的项目的`node_modules`或`installed_contracts`目录中查找`example-truffle-library`文件夹。从那里，它解析路径以提供您请求的合同。
- en: Using artifacts of packages within your JavaScript code
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript代码中使用包的构件
- en: 'To interact with a package''s artifacts within JavaScript code, you simply
    need to require that package''s `.json` files and then use `truffle-contract`
    to turn them into usable abstractions:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript代码中与包的构件进行交互，您只需要求该包的`.json`文件，然后使用`truffle-contract`将它们转换为可用的抽象：
- en: '[PRE33]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Accessing a package's contracts deployed addresses in Solidity
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Solidity中包的合同部署地址
- en: Sometimes, you may want your contracts to interact with the package's previously
    deployed contracts. Since the deployed addresses exist within the package's `.json`
    files, Solidity code cannot directly read contents of these files. So, the flow
    of making Solidity code access the addresses in `.json` files is by defining functions
    in Solidity code to set dependent contract addresses, and after the contract is
    deployed, call those functions using JavaScript to set the dependent contract
    addresses.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望你的合同与包先前部署的合同进行交互。由于部署的地址存在于包的`.json`文件中，Solidity代码不能直接读取这些文件的内容。因此，使Solidity代码访问`.json`文件中的地址的流程是通过在Solidity代码中定义函数来设置依赖合同地址，并在合同部署后使用JavaScript调用这些函数来设置依赖合同地址。
- en: 'So you can define your contract code like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以像这样定义你的合同代码：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is what your migration should look like:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的迁移应该看起来像的：
- en: '[PRE35]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using truffle's console
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用truffle的控制台
- en: Sometimes, it's nice to work with your contracts interactively for testing and
    debugging purposes or to execute transactions by hand. Truffle provides you with
    an easy way to do this via an interactive console, with your contracts available
    and ready to use.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了测试和调试目的或手动执行交易，与您的合同交互是很好的。Truffle为您提供了通过交互式控制台轻松执行此操作的方式，您的合同可用并且可以立即使用。
- en: 'To open the console, run this command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开控制台，请运行此命令：
- en: '[PRE36]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The console connects to an ethereum node based on your project configuration.
    The preceding command also takes a `--network` option to specify a specific node
    to connect to.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台基于您的项目配置连接到以太坊节点。前述命令还接受`--network`选项，以指定要连接的特定节点。
- en: 'Here are the features of the console:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制台的特点：
- en: You can run the command in the console. For instance, you can type `migrate
    --reset` within the console, and it will be interpreted the same as if you ran
    `truffle migrate --reset` from outside the console.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在控制台中运行该命令。例如，您可以在控制台中键入`migrate --reset`，它将被解释为在控制台外部运行`truffle migrate
    --reset`的方式一样。
- en: All of your compiled contracts are available and ready for use.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有编译的合约都可供使用并准备就绪。
- en: After each command (such as `migrate --reset`), your contracts are re-provisioned,
    so you can start using the newly assigned addresses and binaries immediately.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个命令（如`migrate --reset`）之后，您的合约都将重新提供，因此您可以立即开始使用新分配的地址和二进制文件。
- en: The `web3` object is made available and is set to connect to your ethereum node.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3`对象已经可用，并设置为连接到您的以太坊节点。'
- en: 'All commands that return a promise will automatically be resolved and the result
    printed, removing the need to use `.then()` for simple commands. For example,
    you can write code like this: `MyContract.at("0xabcd...").getValue.call();`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有返回Promise的命令都将自动解析并打印结果，无需对简单命令使用`.then()`。例如，您可以编写如下代码：`MyContract.at("0xabcd...").getValue.call();`
- en: Running external scripts in truffle's context
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在truffle的上下文中运行外部脚本
- en: Often, you may want to run external scripts that interact with your contracts.
    Truffle provides an easy way to do this, bootstrapping your contracts based on
    your desired network and connecting to your ethereum node automatically as per
    your project configuration.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能希望运行与您的合约交互的外部脚本。Truffle提供了一种简单的方法来实现这一点，根据您所需的网络引导您的合约，并根据项目配置自动连接到您的以太坊节点。
- en: 'To run an external script, run this command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行外部脚本，请运行此命令：
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order for external scripts to be run correctly, truffle expects them to export
    a function that takes a single parameter as a callback. You can do anything you'd
    like within this script as long as the callback is called when the script finishes.
    The callback accepts an error as its first and only parameter. If an error is
    provided, execution will halt and the process will return a nonzero exit code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确运行外部脚本，truffle期望它们导出一个接受单个参数作为回调函数的函数。只要在此脚本中调用回调函数，您可以随意执行任何操作。回调函数接受一个错误作为其唯一参数。如果提供了错误，执行将停止，并且进程将返回一个非零退出代码。
- en: 'This is the structure external scripts must follow:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 外部脚本必须遵循以下结构：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Truffle's build pipeline
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle的构建流水线
- en: Now that you know how to compile, deploy, and test smart contracts using truffle,
    it's time to build a client for our altcoin. Before we get into how to build a
    client using truffle, you need to know that it doesn't allow us to sign transactions
    using accounts stored outside of the ethereum node; that is, it doesn't have anything
    similar to `sendRawTransaction` and the reasons are the same as those for `truffle-contract`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何使用truffle编译、部署和测试智能合约，是时候为我们的代币构建一个客户端了。在介绍如何使用truffle构建客户端之前，您需要知道它不允许我们使用存储在以太坊节点外部的账户进行交易签名；也就是说，它没有类似于`sendRawTransaction`的东西，原因与`truffle-contract`相同。
- en: Building a client using truffle means first integrating truffle's artifacts
    in your client source code and then preparing the client's source code for deployment.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用truffle构建客户端首先意味着在客户端源代码中集成truffle的构件，然后准备客户端源代码以进行部署。
- en: 'To build a client, you need to run this command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建客户端，您需要运行此命令：
- en: '[PRE39]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When this command is run, truffle will check how to build the client by inspecting
    the `build` property in the project's configuration file.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此命令时，truffle将通过检查项目配置文件中的`build`属性来确定如何构建客户端。
- en: Running an external command
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行外部命令
- en: A command-line tool can be used to build a client. When the `build` property
    is a string, truffle assumes that we want to run a command to build the client,
    so it runs the string as a command. The command is given ample environment variables
    with which to integrate with truffle.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命令行工具构建客户端。当`build`属性为字符串时，truffle会假定我们要运行一个命令来构建客户端，因此会将字符串作为命令运行。该命令会获得充足的环境变量以与truffle集成。
- en: 'You can make truffle run a command-line tool to build the client using similar
    configuration code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过类似的配置代码让truffle运行命令行工具来构建客户端：
- en: '[PRE40]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Running a custom function
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行自定义函数
- en: A JavaScript function can be used to build a client. When the `build` property
    is a function, truffle will run that function whenever we want to build the client.
    The function is given a lot of information about the project with which to integrate
    with truffle.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数可用于构建客户端。当 `build` 属性是一个函数时，松露将在我们想要构建客户端时运行该函数。该函数提供了有关项目如何与松露集成的大量信息。
- en: 'You can make truffle run a function to build the client using similar configuration
    code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让松露运行一个函数来构建客户端，使用类似的配置代码：
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You could also create an object, which contains a `build` method like the one
    here. This is great for those who want to publish a package to build a client.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个对象，其中包含一个像这里的 `build` 方法。这对于想要发布一个构建客户端的包的人来说是很好的。
- en: Truffle's default builder
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松露的默认构建器
- en: Truffle provides the `truffle-default-builder npm` package, which is termed
    the default builder for truffle. This builder exports an object, which has a build
    method, which works exactly like the previously mentioned method.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 松露提供了 `truffle-default-builder npm` 包，被称为松露的默认构建器。该构建器导出一个对象，其中有一个与之前提到的方法完全相同的构建方法。
- en: The default builder can be used to build a web client for your DApp, whose server
    only serves static files, and all the functionality is on the frontend.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构建器可用于为你的 DApp 构建 web 客户端，其服务器仅提供静态文件，并且所有功能都在前端。
- en: 'Before we get further into how to use the default builder, first install it
    using this command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何使用默认构建器之前，首先使用以下命令安装它：
- en: '[PRE42]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now change your configuration file to this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的配置文件更改为这样：
- en: '[PRE43]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The default builder gives you complete control over how you want to organize
    the files and folders of your client.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构建器让你完全控制你想要组织客户端文件和文件夹的方式。
- en: This configuration describes `targets` (left-hand side) with files, folders,
    and arrays of files that make up the `targets` contents (right-hand side). Each
    target will be produced by processing the files on the right-hand side based on
    their file extension, concatenating the results together, and then saving the
    resultant file (the target) into the build destination. Here, a string is specified
    on the right-hand side instead of an array, and that file will be processed, if
    needed, and then copied over directly. If the string ends in a `"/"`, it will
    be interpreted as a directory and the directory will be copied over without further
    processing. All paths specified on the right-hand side are relative to the `app/`
    directory.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置描述了 `targets`（左侧）的文件、文件夹和构成 `targets` 内容的文件数组（右侧）。每个目标将通过处理右侧的文件根据它们的文件扩展名进行生成，将结果连接在一起，然后将结果文件（目标）保存到构建目标中。在这里，右侧指定了一个字符串而不是一个数组，如果需要，该文件将被处理，然后直接复制过去。如果字符串以
    `"/"` 结尾，它将被解释为一个目录，目录将被直接复制过去而不进行进一步处理。右侧指定的所有路径都是相对于 `app/` 目录的。
- en: You can change this configuration and directory structure at any time. You aren't
    required to have a `javascripts` and `stylesheets` directory, for example, but
    make sure you edit your configuration accordingly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时更改此配置和目录结构。例如，你不需要 `javascripts` 和 `stylesheets` 目录，但请确保你相应地编辑你的配置。
- en: If you want the default builder to integrate truffle on the frontend of your
    web application, make sure you have a build target called `app.js`, which the
    default builder can append code to. It will not integrate truffle with any other
    filename.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望默认的构建器将松露集成到你的 web 应用程序的前端，请确保你有一个名为 `app.js` 的构建目标，该默认构建器可以将代码追加到其中。它不会将松露与任何其他文件名集成。
- en: 'Here are the features of the default builder:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是默认构建器的特点：
- en: Automatically imports your compiled contract artifacts, deployed contract information,
    and ethereum node configuration into the client source code
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动导入你的编译合同构件、部署的合同信息和以太坊节点配置到客户端源代码中
- en: Includes recommended dependencies, including web3 and `truffle-contract`
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括建议的依赖项，包括 web3 和 `truffle-contract`
- en: Compiles `ES6` and `JSX` files
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 `ES6` 和 `JSX` 文件
- en: Compiles `SASS` files
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译`SASS`文件
- en: Minifies `asset` files
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化 `asset` 文件
- en: You can use the `truffle watch` command, which watches for changes in the `contracts`
    directory, the `app` directory, and the configuration file. When there's a change,
    it recompiles the contracts and generates new artifact files and then rebuilds
    the client. But it doesn't run migrations and tests.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `truffle watch` 命令，它会监视 `contracts` 目录、`app` 目录和配置文件的更改。当有更改时，它会重新编译合约并生成新的构建文件，然后重新构建客户端。但它不会运行迁移和测试。
- en: Building a client
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个客户端
- en: 'Now let''s write a client for our DApp and build it using truffle''s default
    builder. First of all, create files and directories based on the preceding configuration
    we set: create an `app` directory and inside it, create an `index.html` file and
    two directories called `javascripts` and `styelsheets`. Inside the `javascripts`
    directory, create a file called `index.js` and in the `stylesheets` directory,
    download and place the CSS file of Bootstrap 4\. You can find it at [https://v4-alpha.getbootstrap.com/getting-started/download/#bootstrap-css-and-js](https://v4-alpha.getbootstrap.com/getting-started/download/#bootstrap-css-and-js).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的 DApp 编写一个客户端，并使用 truffle 的默认构建器构建它。首先，根据我们设置的先前配置创建文件和目录：创建一个 `app`
    目录，在其中创建一个 `index.html` 文件和两个名为 `javascripts` 和 `styelsheets` 的目录。在 `javascripts`
    目录中，创建一个名为 `index.js` 的文件，在 `stylesheets` 目录中，下载并放置 Bootstrap 4 的 CSS 文件。你可以在
    [https://v4-alpha.getbootstrap.com/getting-started/download/#bootstrap-css-and-js](https://v4-alpha.getbootstrap.com/getting-started/download/#bootstrap-css-and-js)
    找到它。
- en: 'In the `index.html` file, place this code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件中，放置以下代码：
- en: '[PRE44]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, we are loading the `bootstrap.min.css` and `app.js`
    files. We have two forms: one is to send metacoins to a different account and
    the other one is to check the metacoins balance of an account. In the first form,
    the user has to select an account and then enter the amount of metacoin to send
    and the address that it wants to send to. And in the second form, the user simply
    has to select the address whose metacoin balance it wants to check.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们加载了 `bootstrap.min.css` 和 `app.js` 文件。我们有两个表单：一个用于向不同账户发送 metacoins，另一个用于检查账户的
    metacoins 余额。在第一个表单中，用户必须选择一个账户，然后输入要发送的 metacoin 金额和要发送到的地址。而在第二个表单中，用户只需选择其想要检查
    metacoin 余额的地址。
- en: 'In the `index.js` file, place this code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 文件中，放置以下代码：
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is how the code works:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: The `truffle-default-builder` makes artifacts objects available under the `__contracts__`
    global object.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`truffle-default-builder` 使构件对象可在 `__contracts__` 全局对象下使用。'
- en: It also makes available contract abstractions for all the contracts available
    as global variables with the variable name the same as the contract name.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还通过将变量名设置为合约名，为所有可用的合约提供了合约抽象作为全局变量。
- en: It also provides the web3 object by already setting the provider. It also sets
    the provider for the contract abstractions. It makes the web3 object connect to
    the network with the name `development` and if it doesn't exist, then the default
    value is `http://localhost:8545`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还通过已设置提供程序为 web3 对象提供了支持。它还为合约抽象设置了提供程序。它使得 web3 对象连接到名为 `development` 的网络，如果不存在，则默认值为
    `http://localhost:8545`。
- en: In the preceding code, at first, we wait for the page to load, and once loaded,
    we retrieve the list of accounts in the connected node and display them in both
    the forms. And we call the `detectNetwork()` method of the `MetaCoin` abstraction
    as well.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码中，首先，我们等待页面加载完成，一旦加载完成，我们就检索连接节点中的账户列表，并在两个表单中显示它们。我们还调用 `MetaCoin` 抽象的
    `detectNetwork()` 方法。
- en: Then, we have `submit` event handlers for both the forms. They both do what
    they are supposed to do and display the result in a popup.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为两个表单都设置了 `submit` 事件处理程序。它们都按预期执行其操作，并在弹出窗口中显示结果。
- en: When the first form is submitted, we get the `MetaCoin` contract's deployed
    instance and call the `sendCoin` method with the correct arguments.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一个表单提交时，我们获取 `MetaCoin` 合约的部署实例，并使用正确的参数调用 `sendCoin` 方法。
- en: When the second form is submitted, we retrieve the balance of the selected account
    by calling the `getBalance` method in the EVM instead of broadcasting a transaction.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第二个表单提交时，我们通过调用 EVM 中的 `getBalance` 方法而不是广播交易来检索所选账户的余额。
- en: Now go ahead and run the truffle build command, and you will notice that truffle
    will create `index.html`, `app.js`, and `bootstrap.min.css` files in the `build`
    directory and put the client's final deployment code in them.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续运行 truffle build 命令，你会注意到 truffle 将在 `build` 目录中创建 `index.html`、`app.js`
    和 `bootstrap.min.css` 文件，并在其中放置客户端的最终部署代码。
- en: Truffle's server
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle的服务器
- en: Truffle comes with an in-built web server. This web server simply serves the
    files in the `build` directory with a proper MIME type set. Apart from this, it's
    not configured to do anything else.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle带有内置的Web服务器。这个Web服务器只是以适当的MIME类型设置提供`build`目录中的文件。除此之外，它没有配置为执行任何其他操作。
- en: 'To run the web server, run this command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Web服务器，请运行此命令：
- en: '[PRE46]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The server runs on port number 8080 by default. But you can use the `-p` option
    to specify a different port number.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器在端口号8080上运行。但你可以使用`-p`选项指定不同的端口号。
- en: Similar to truffle watch, this web server also watches for changes in the `contracts`
    directory, the `app` directory, and the configuration file. When there's a change,
    it recompiles the contracts and generates new artifacts files and then rebuilds
    the client. But it doesn't run migrations and tests.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于truffle watch，这个Web服务器还监视`contracts`目录、`app`目录和配置文件中的更改。当有更改时，它重新编译合约并生成新的工件文件，然后重建客户端。但它不会运行迁移和测试。
- en: As the truffle-default-builder places the final deployable code in the build
    directory, you can simply run `truffle serve` to serve the files via the Web.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于truffle-default-builder将最终可部署的代码放在构建目录中，你只需运行`truffle serve`即可通过Web提供文件。
- en: 'Let''s test our web client. Visit `http://localhost:8080`, and you will see
    this screenshot:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的Web客户端。访问`http://localhost:8080`，你会看到这个截图：
- en: '![](img/image_08_001.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_001.png)'
- en: 'The account addresses in the selected boxes will differ for you. Now at the
    time of deploying the contract, the contract assigns all the metacoins to the
    address that deploys the contract; so here, the first account will have a balance
    of 10,000 metacoins. Now send five metacoins from the first account to the second
    account and click on Submit. You will see a screen similar to what is shown in
    the following screenshot:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 所选框中的帐户地址对你而言会有所不同。现在在部署合约时，合约将所有的metacoins分配给部署合约的地址；所以在这里，第一个帐户将有10,000个metacoins的余额。现在从第一个帐户发送五个metacoins到第二个帐户，然后点击提交。你会看到类似以下截图的屏幕：
- en: '![](img/image_08_002.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_002.png)'
- en: 'Now check the balance of the second account by selecting the second account
    in the select box of the second form and then click on the Check Balance button.
    You will see a screen similar to what is shown in the following screenshot:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在第二个表单的选择框中选择第二个帐户然后点击“检查余额”按钮来检查第二个帐户的余额。你会看到类似以下截图的屏幕：
- en: '![](img/image_08_003.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_003.png)'
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned in depth how to build DApps and their respective
    clients using truffle. We look at how truffle makes it really easy to write, compile,
    deploy, and test DApps. We also saw how easy it is to switch between networks
    in clients using `truffle-contract` without touching the source code. Now you
    are ready to start building enterprise-level DApps using truffle.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了如何使用truffle构建DApps及其相应的客户端。我们看到truffle如何简化编写、编译、部署和测试DApps的过程。我们还看到了使用`truffle-contract`在客户端之间轻松切换网络而无需触及源代码的简便之处。现在，你已经准备好开始使用truffle构建企业级DApps了。
- en: In the next chapter, we will build a decentralized alarm clock app that pays
    you to wake up on time using the truffle and ethereum alarm clock DApp.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用truffle和以太坊闹钟DApp构建一个分散式闹钟应用程序，该应用程序在时间上为你支付报酬。
- en: Just replace the `i.e.` with a colon `":"`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 只需用冒号`":"`替换`i.e.`。
