- en: Creating a Blockchain-based Social Media Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Ethereum development starts with a lot of theory and technicality,
    but, at some point you'll have to take the leap in order to start applying your
    recently-acquired knowledge on real-world scenarios that build your portfolio.
    That's why we're going to create a blockchain-based social media platform, since
    it's one of the best use cases of blockchain technology, given that we provide
    people with trust. Unfortunately, many centralized social media companies are
    abusing that trust by stealing and monetizing users' privacy. Social media platforms
    such as Twitter or Facebook are famous because they give people the power to stay
    in touch with many individuals in one single interface that takes advantage of
    the internet's capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will take you through the challenge of creating a dynamic social
    media platform that lives entirely on the blockchain without centralized servers.
    You will understand how to create a beautiful user interface with React. Then
    you'll explore how to organize the information better so that you allow people
    to find the content that they want using smart contracts. Finally, you'll tie
    everything together using web3 and you'll be able to use your social media platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding decentralized social media
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the smart contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finishing the dApp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding decentralized social media
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to Ethereum-based social media dApps, we help people solve many
    problems that current centralized companies can''t solve efficiently yet. We can
    help with the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Preserving users' privacy on a decentralized blockchain
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteeing total freedom by not allowing censorship from external, centralized
    entities since information on the blockchain is permanent
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An unchanging, fixed storage system that will be accessible decades after the
    content was created
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, when we think of building a decentralized social media platform, we
    lose a few of the following important aspects that are essential to modern applications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Users won''t be able to use the dApp as fast as normal centralized
    applications for depending on a huge, slow network of interconnected computers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage limitations**: Ethereum''s space is limited so every byte is costly,
    resulting in a huge limitation on what you can store on the blockchain, so we''ll
    have to find ways to overcome these natural limitations while preserving as much
    decentralization as possible.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gas costs**: Normal centralized applications don''t have to face gas fees
    for each action taken on their system because they understand that all those costs
    are paid in a centralized server. In the blockchain, every transaction has a cost
    that could be significant. We''ll solve this by using testnets, where gas has
    no value until the final application is created.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another big problem is that we can't store images and videos on the blockchain;
    we'll have to rely on decentralized storage solutions, such as IPFS, if we wish
    to preserve the decentralization from the main system; however it isn't mandatory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个大问题是我们无法在区块链上存储图像和视频；如果我们希望保留主系统的去中心化，我们将不得不依赖于分布式存储解决方案，例如 IPFS，但这并不是强制性的。
- en: The initial concept
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始概念
- en: Our goal is to create an effective social media platform that overcomes or completely
    avoids the limitations of the blockchain. To simplify the complexity of our dApp,
    we will build an application similar to Twitter in the sense that users only share
    text messages without the option to share images or video.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个有效的社交媒体平台，克服或完全避免区块链的限制。为了简化我们的 dApp 的复杂性，我们将构建一个类似于 Twitter 的应用程序，用户只分享文本消息，而不提供分享图像或视频的选项。
- en: 'Since we are developers, we''ll create a Twitter for programmers, designers,
    developers, and all kinds of technology-related fields where people can feel welcome
    in a community of shared interests. We want it to have the following functionalities:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是开发人员，我们将创建一个面向程序员、设计师、开发人员和各种技术相关领域的 Twitter，让人们可以在共同兴趣的社区中感到受欢迎。我们希望它具有以下功能：
- en: The capacity to share strings of text limited only by smart contract's capacity
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅受智能合约容量限制的文本字符串分享能力
- en: The capacity to add hashtags to each piece of content
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个内容添加标签的能力
- en: A function to be able to view hashtags that people have included in their content
    by clicking on a hashtag
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击标签来查看人们在他们的内容中包含的标签的功能
- en: A function to subscribe to hashtags
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅标签的功能
- en: We don't want people to follow others, we'll simply give them the capacity to
    follow hashtags so that they focus on the content rather than the messenger. Let's
    start working on the user interface that will become our social media dApp for
    tech enthusiasts to focus on content via hashtags, rather than specific users.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望人们关注其他人，我们只会给他们提供关注标签的能力，这样他们就会专注于内容而不是信使。让我们开始着手设计用户界面，这将成为我们的社交媒体 dApp，供技术爱好者通过标签而不是特定用户来关注内容。
- en: Creating the user interface
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: The user interface for this particular project will be focused around content
    and hashtags since hashtags are the way users will discover new trending content.
    Users will be able to subscribe to particular hashtags to receive content from
    those topics on their feed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此特定项目的用户界面将围绕内容和标签展开，因为标签是用户发现新趋势内容的方式。用户将能够订阅特定标签，以在他们的订阅中接收来自这些主题的内容。
- en: 'As usual, we start by setting up a new project with Truffle. Follow these steps
    to set up your project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先用 Truffle 设置一个新项目。按照以下步骤设置你的项目：
- en: 'Clone the startup repository ([https://github.com/merlox/dapp](https://github.com/merlox/dapp))
    which includes the initial configuration to work on your React dApp:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆初创仓库（[https://github.com/merlox/dapp](https://github.com/merlox/dapp)），其中包含了在你的
    React dApp 上工作的初始配置：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Rename the repository to `social-media-dapp` to organize the content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库重命名为`social-media-dapp`以整理内容：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new empty GitHub repository by going to GitHub (without a license
    or `.gitignore` since they are already included in your project) and use the following
    command to update the pull/push URL:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 GitHub 创建一个新的空仓库（不包含许可证或`.gitignore`，因为它们已经包含在你的项目中），并使用以下命令来更新拉取/推送 URL：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Push the first commit. Install the dependencies with `npm i` and run `webpack`
    with `webpack -wd`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送第一个提交。使用`npm i`安装依赖项，并使用`webpack -wd`运行`webpack`。
- en: 'Open up your application by running a static server with `http-server dist/`
    and going to `http://localhost: 8080` to see whether everything was set up properly.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行静态服务器`http-server dist/`来打开你的应用程序，并访问`http://localhost:8080`，查看是否一切都设置正确。
- en: Now you can start creating your user interface. You already know how to do it,
    so why not go ahead and create your own before seeing mine? You'll be amazed at
    what you're capable of doing by yourself at this point, so I encourage you to
    experiment to build your own systems. The idea is that we build this dApp together
    by guiding you through the steps until you have a high-quality dApp that you can
    use to build your resume or develop further for an ICO, or as open source software
    for the betterment of humanity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始创建你的用户界面了。你已经知道如何做了，那为什么不先自己试试呢？你会惊讶于此时你能够做到的事情，所以我鼓励你尝试建立自己的系统。我们的想法是通过指导你的步骤来一起构建这个
    dApp，直到你拥有一个高质量的 dApp，可以用来建立你的简历或进一步为 ICO 或作为人类进步的开源软件的开发。
- en: Configuring the webpack style
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 webpack 样式
- en: 'At the end, you''ll have to have two sections: one with the most popular hashtags,
    which will come from a mapping in our smart contract, and one where you can read
    more about each specific hashtag while being able to publish content. You may
    want to set up the style loader to be able to use css on your dApp, which is not
    set up on the default dApp that you just cloned. To do so, install the following
    dependencies after stopping webpack:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将必须有两个部分：一个是最受欢迎的标签，这将来自我们智能合约中的映射，另一个是你可以在其中阅读更多关于每个具体标签的内容，同时能够发布内容。你可能想设置样式加载程序以能够在你的
    dApp 上使用 CSS，这在你刚刚克隆的默认 dApp 上并没有设置。为了这样做，在停止 webpack 后安装以下依赖项：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you installed the required libraries to be able to use CSS files inside
    your project, you can update your webpack configuration file by adding a new loader
    inside the `loaders` block for the `css` files. Pay attention to the fact that
    we''re using both loaders – `style-loader` goes first. Otherwise, it won''t work:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了所需的库，可以在项目中使用 CSS 文件，你可以通过在`css`文件的`loaders`块中添加一个新的 loader 来更新 webpack
    配置文件。请注意，我们使用了两个 loaders，`style-loader`排在第一个。否则它将无法工作：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up the initial structure
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立初始结构
- en: 'Open the `index.js` file and start creating your user interface. First, I start
    with the constructor by creating some necessary variables that we''ll use later
    on:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`index.js`文件，并开始创建你的用户界面。首先，通过创建一些以后会用到的必要变量来设置构造函数：
- en: 'Set up the required imports for any React project plus the `css` file that
    we can now import thanks to the style and css loaders:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为任何 React 项目设置所需的导入，以及我们现在可以通过样式和 css 加载器导入的`css`文件：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Set up the constructor with some dummy data to see how the final application
    will look once we populate it with variables from the smart contract:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置构造函数并填入一些虚拟数据，以查看最终应用程序在填入来自智能合约的变量后的外观：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `render()` function with the `ReactDOM` render:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建带有`ReactDOM`渲染的`render()`函数：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the state of our application contains the `content` object with
    an Ethereum address as the author of that piece, the message, the hashtags, and
    the time. We may later change that, but for now it's good enough. We also added
    two arrays, which contain the top hashtags and the followed tags for this particular
    user. Those display subscribe variables are a necessary evil to display a subscribe
    button every time a user hovers a hashtag so that they have the choice to subscribe
    to improve interactivity of the dApp.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们应用程序的状态包含了`content`对象，其中包含了一个以太坊地址作为该文章的作者，消息，标签和时间。我们以后可能会更改它，但现在已经足够好了。我们还添加了两个数组，其中包含了最热门的标签和这个特定用户关注的标签。这些显示订阅变量是为了在用户悬停在标签上时显示一个订阅按钮，以便他们有选择关注以改善
    dApp 的互动性。
- en: Rendering hashtags
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染标签
- en: 'We can now create the render function with all the logic, but be warned: it''s
    a bit complex given that we are displaying all the arrays from the state, so be
    patient and see the code in chunks to understand it. Follow these steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建带有所有逻辑的渲染函数，但要警告你：由于我们要显示状态中的所有数组，所以有点复杂，请耐心地分段查看代码以理解。按照以下步骤进行：
- en: 'Create a new function to generate the hashtag''s HTML, because we want to add
    variable logic to the buttons to be sure that the `hashtag` text reacts to the
    user displaying the subscribe or unsubscribe button. Remember that we want users
    to be able to follow hashtags; that''s why we need subscribe and unsubscribe buttons:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数来生成标签的 HTML，因为我们希望在按钮上添加可变逻辑，以确保`hashtag`文本对用户展示订阅或取消订阅按钮有反应。记住，我们希望用户能够关注标签；这就是我们需要订阅和取消订阅按钮的原因：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the `render()` function to generate the content and hashtag blocks because
    we need a simple way of creating the content to be displayed; all the logic will
    be executed in the `render()` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`render()`函数以生成内容和标签块，因为我们需要一种简单的方法来创建要显示的内容；所有逻辑将在`render()`函数中执行：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the hashtag blocks, whose only job is to create the JSX objects that will
    be displayed to the user, with the `generateHashtags()` function that we just
    used:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加标签块，其唯一工作是创建将显示给用户的JSX对象，使用我们刚刚使用的`generateHashtags()`函数：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the end of the `render()` function, add the `return` block with the block
    variables that we just set up:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render()`函数的末尾，添加带有我们刚刚设置的块变量的`return`块：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added a function named `generateHashtags` since we have to add the same logic
    to display the subscribe button in many places, so it made sense to craft a function
    that does precisely that when needed without duplicating these long blocks of
    code. Then, in the `render()` function, you can see that we are using that function
    to generate the hashtag logic in the many places where hashtags will be used.
    Before the return, we have three variables that are simply generating JSX components
    dynamically with our state data. Finally, the `render()` function is displaying
    those blocks nicely.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`generateHashtags`的函数，因为我们必须在许多地方添加相同的逻辑来显示订阅按钮，所以制作一个只在需要时执行此操作而不重复这些长代码块的函数是有意义的。然后，在`render()`函数中，您可以看到我们在许多地方使用该函数来生成标签逻辑。在返回之前，我们有三个变量，只是使用我们的状态数据动态生成JSX组件。最后，`render()`函数很好地显示了这些块。
- en: Improving the appearance
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善外观
- en: 'I''ve also imported the `index.css` file, which includes grid components for
    displaying our application in the best way possible, with a clean structure that
    is easy to maintain:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我还导入了`index.css`文件，其中包含用于以最佳方式显示我们的应用程序的网格组件，具有干净的结构，易于维护：
- en: 'Add the general styling to the main components of your application, such as
    the body and buttons, to make them look better:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主要组件的一般样式到您的应用程序，例如body和按钮，以使它们看起来更好：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the general hidden and spacer styles to hide elements and to create a dynamic
    spacer:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一般隐藏和间隔样式添加到隐藏元素并创建动态间隔：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the container''s styles to position them with the grid system that is now
    accepted on all major browsers:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器的样式添加到位置上，该位置现在在所有主要浏览器上都被接受的网格系统中：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Format the input and text areas to create a better-looking design that is easy
    to use:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化输入和文本区域，以创建一个外观更好，易于使用的设计：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Provide a great-looking design for all the elements for the content block,
    which is similar to a tweet in Twitter:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为内容块提供一个看起来很棒的设计，类似于Twitter中的推文：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Format those hashtags to position them in the right places while also increasing
    their size:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化这些标签，以将它们放置在正确的位置，并增加它们的大小：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can copy and paste that css if you want to achieve the same look. Here''s
    the appearance of the dApp right now:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望实现相同的外观，可以复制并粘贴该css。这是dApp目前的外观：
- en: '![](img/75137204-3f49-4c9f-8b63-407e6950bda0.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75137204-3f49-4c9f-8b63-407e6950bda0.png)'
- en: You can check the completed code on GitHub at [https://github.com/merlox/social-media-dapp/tree/master/src](https://github.com/merlox/social-media-dapp/tree/master/src).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在GitHub上查看完成的代码，网址是[https://github.com/merlox/social-media-dapp/tree/master/src](https://github.com/merlox/social-media-dapp/tree/master/src)。
- en: I tried to emulate a simple sort of cartoon design to make it more interesting
    to visualize, while keeping a clear interface that people can read easily without
    confusion. Pay attention to the user interfaces that you create because they are
    a major component of every dApp. A dApp that looks professional will draw more
    attention. More attention usually transforms into more revenue as you are capable
    of directing people's attention to the right places at the right moments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图模拟一种简单的卡通设计，以使可视化更有趣，同时保持一个清晰的界面，人们可以轻松阅读而不会混淆。注意您创建的用户界面，因为它们是每个dApp的主要组成部分。外观专业的dApp会引起更多关注。更多的关注通常会转化为更多的收入，因为您能够在正确的时刻引导人们的注意力到正确的地方。
- en: Building the smart contract
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建智能合约
- en: The smart contract that we are going to build will serve as the backend for
    our decentralized application by storing all the messages, hashtags, and users.
    In our application, we want to keep users anonymous; that's why they are represented
    as addresses instead of usernames – to direct people's attention to what's being
    talked about, not to who is delivering the message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的智能合约将作为我们的分散式应用的后端，存储所有消息、主题标签和用户。在我们的应用中，我们希望保持用户的匿名性；这就是为什么他们被表示为地址而不是用户名——将人们的注意力集中在谈论的内容上，而不是消息的发布者。
- en: As you already know, we'll create a hashtag-focused social media platform without
    images or video. That's why all of our data will be stored in a combination of
    mappings and arrays.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，我们将创建一个以主题为中心的社交媒体平台，不包含图像或视频。这就是为什么我们所有的数据将存储在映射和数组的组合中。
- en: Planning the design process
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划设计流程
- en: 'Before getting straight to the code, I want you to understand the process that
    we''ll follow to optimize the entire process, avoid confusion, and save time by
    avoiding bugs with a clear head about what needs to be done. The process looks
    like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接进入代码之前，我想让您了解我们将遵循的优化整个流程、避免混乱并通过清晰地了解需要完成的工作来节省时间的过程。该过程如下所示：
- en: Create a smart contract file and write in the comments a description of the
    purpose of the contract, such as how the functions will work and who will use
    it. Be as concise as possible since it will help you and the maintainers understand
    what it is all about.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个智能合约文件，并在注释中写下合约的目的描述，例如函数的工作方式以及谁将使用它。尽量简洁，因为这将有助于您和维护人员了解它的全部内容。
- en: Start creating variables and function signatures, that is, functions without
    body, just the name and parameters. Document each function using the NatSpec format
    for additional clarifications.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建变量和函数签名，即，没有主体的函数，只有名称和参数。使用NatSpec格式为每个函数编写文档以进行额外的澄清。
- en: Start implementing each function independently until all of them are done. You
    can add more if you need to.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立实现每个函数，直到所有函数都完成。如果需要，您可以添加更多函数。
- en: Manually test the contract by copy-pasting it to remix or any other IDE to quickly
    find problems and run all the functions in a virtual EVM where you don't have
    to pay any gas or wait for confirmations. Ideally, you'd write Truffle tests to
    verify that everything is working, but sometimes it can be skipped to save time.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将合约复制粘贴到remix或任何其他IDE中手动测试合约，以快速发现问题并在虚拟EVM中运行所有函数，在那里您无需支付任何gas费用或等待确认。理想情况下，您会编写Truffle测试来验证一切是否正常工作，但有时可以跳过以节省时间。
- en: 'Here''s a graphic of the process so you can keep it in mind:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该流程的图形表示，以便您牢记：
- en: '![](img/d46217b7-b58c-45b8-ba74-6131798e3d3b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d46217b7-b58c-45b8-ba74-6131798e3d3b.png)'
- en: This type of process is the one I follow for maximizing my productivity without
    going crazy with specs. If you start coding immediately on a solution, you risk
    getting stuck in a place where you have to remake the entire code base while creating
    unneeded bugs in the process. That's why planning is so important. Besides, it
    will make your life much easier knowing exactly what to do, and when.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的流程是我用来最大化生产力而不至于因规格而疯狂的流程。如果您立即开始编写解决方案，您可能会陷入一个需要重新制作整个代码库的地方，同时在此过程中创建不必要的错误。这就是为什么规划如此重要。此外，确切地知道该做什么以及何时做将使您的生活变得轻松得多。
- en: 'Now we can start creating our smart contract by describing the idea behind
    it. Create a file named `SocialMusic.sol` inside your `contracts/` folder and
    write a description of what should be in the final version of that contract at
    the top of the file in comments. Try to do it yourself before looking at my own
    solution since the only way to learn is to practice by yourself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始创建我们的智能合约，描述其背后的想法。在您的`contracts/`文件夹中创建一个名为`SocialMusic.sol`的文件，并在文件顶部的注释中写下该合约最终版本应该包含的内容的描述。在查看我的解决方案之前，请尝试自己完成，因为学习的唯一方法就是自己练习：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Whether you realize it or not, you''ve clarified your mind a whole lot by writing
    the description. Now you can start creating the functions and variables. Given
    that you have a user interface already in place, you''ll want to break that interface
    into blocks and create the functions that will provide the data shown in those
    blocks; for instance, take a look at the following block of your application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是否意识到，通过编写描述，您的思维都得到了很大程度的澄清。现在您可以开始创建函数和变量了。鉴于您已经有了用户界面，您将想将该界面分解为块，并创建将提供这些块中显示的数据的函数；例如，看一下您应用程序的以下块：
- en: '![](img/04337a64-1a6c-4d78-beb8-c844baacfce8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04337a64-1a6c-4d78-beb8-c844baacfce8.png)'
- en: You can obviously see the top hashtags with some random hashtags. You must ask
    yourself when looking at the interface, what do I need to implement in my smart
    contract to make that possible? Well, it seems obvious, but often it is not that
    easy. In this case, you have to create a function to retrieve the top hashtags.
    That function will get the data from a sorted array or mappings to send it to
    the user, maybe a parameter to determine how many top hashtags to retrieve at
    any moment so that you can experiment with different quantities. To create that
    function, you'll have to implement some kind of sorting mechanism, probably a
    view or pure function that doesn't consume gas to process. On the other hand,
    how do you determine the order of those hashtags? Probably a score system that
    increases the value of each hashtag, depending on the use.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看着界面时，你显然能看到顶部的标签和一些随机的标签。当你看着界面时，你必须问自己，我需要在我的智能合约中实现什么来使这成为可能？嗯，这似乎显而易见，但往往并不那么容易。在这种情况下，你必须创建一个函数来检索顶部的标签。该函数将从排序数组或映射中获取数据并将其发送给用户，也许还有一个参数，用于确定在任何时刻要检索多少顶部标签，以便你可以尝试不同的数量。要创建该函数，你必须实现某种排序机制，可能是一个不消耗gas的纯函数或视图函数来进行处理。另一方面，你如何确定这些标签的顺序？可能是一个增加每个标签值的分数系统，具体取决于使用情况。
- en: 'You see, from a small obvious piece of our entire application, you came to
    the realization that you need the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，从我们整个应用程序中一个小明显的部分，你意识到你需要以下内容：
- en: An array or mapping with the top tags that need to be sorted.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含需要排序的顶部标签的数组或映射。
- en: A function to retrieve those hashtags with an optional parameter to determine
    how many so that you can experiment with them.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检索那些标签的函数，还可以使用可选参数来确定要实验的标签数量。
- en: A function to sort existing hashtags in a way that makes sense considering the
    limitations of the blockchain. It must be a pure or view function to avoid excessive
    gas costs.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对现有标签进行排序的函数，考虑到区块链的限制，必须是一个纯函数或视图函数，以避免过高的gas成本。
- en: A system to give a score for each hashtag so that we can order them depending
    on their popularity.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个标签分配一个分数的系统，这样我们可以根据它们的受欢迎程度对它们进行排序。
- en: You have to do the same analytical process for each component of your application.
    No matter how obvious it may seem, try to describe those pieces in your mind so
    that you visualize what's needed and what's possible beforehand to save yourself
    hours of frustration and buggy code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须为应用程序的每个组件进行相同的分析过程。无论它看起来多么显而易见，试着在脑海中描述这些部分，这样你就可以预先可视化所需和可能的内容，从而节省你数小时的沮丧和错误代码。
- en: Setting up the data structures
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据结构
- en: 'After doing the required planning, feel free to write the function signatures
    for all of the needed parts by performing the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行必要的规划之后，可以依次执行以下步骤为所有所需部分编写函数签名：
- en: 'Define the variables that you''ll use later on with structs and events first:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先用结构体和事件定义以后要使用的变量：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the mappings, arrays, and remaining state variables:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加映射、数组和剩余的状态变量：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the function signatures:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数签名：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Are you surprised by the number of functions and variables that we came up with
    in a moment? You probably didn't consider functions such as `checkExistingSubscription`
    or `getContentIdsByHashtag` during that process. I'll be honest, I didn't know
    that those functions were needed before writing the contract; it's just after
    creating the entire code that they became necessary. It's okay if you don't come
    up with all the required variables and functions before creating the code. They
    will surface at the right moment as you develop. You don't have to write all the
    functions and plan every single function and variable beforehand; that would be
    insane. So be patient, and know that, after implementing your initial functions,
    you may need to add a few additional ones to have the desired functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否对我们在一瞬间想出的函数和变量的数量感到惊讶？在进行这个过程时，你可能没有考虑到像`checkExistingSubscription`或`getContentIdsByHashtag`这样的函数。老实说，我在编写合同之前并不知道这些函数是必需的；只是在创建整个代码之后，它们变得必要起来。如果你在创建代码之前没有想出所有必需的变量和函数，也没关系。它们将在适当的时刻浮出水面，当你开发时，你不必事先编写所有函数并计划每一个函数和变量；那将是疯狂的。所以要有耐心，并且知道，在实施你的初始函数之后，你可能需要添加一些额外的函数来实现所需的功能。
- en: Documenting the future functions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录未来函数
- en: 'Those function are not clear enough yet, so why don''t you write the NatSpec
    documentation about each one of them? It''s a tedious process but you''ll thank
    yourself for it since it will remind you of what you''re doing while coding. Here
    is my version with the included documentation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那些功能还不够清晰，为什么不为它们中的每一个编写 NatSpec 文档？这是一个繁琐的过程，但在编码时会提醒您自己在做什么，所以您会感谢自己的。这是我的版本，包含了文档：
- en: 'Start with the add content, subscribe, and unsubscribe functions:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从添加内容、订阅和取消订阅函数开始：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The getter functions for the top and followed hashtags. We need these functions
    to display them on the sidebar of the user interface:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于顶部和已关注标签的获取器函数。我们需要这些函数将它们显示在用户界面的侧边栏上：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The getter functions by ID. We need them to return the struct variables broken
    down into individual pieces:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 ID 的获取器函数。我们需要它们将结构变量分解为单独的部分返回：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The helper functions to sort hashtags and check existing subscriptions. These
    will be used when a user subscribes to update the score of the entire hashtags
    by ordering them, depending on the score:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助函数用于对标签进行排序和检查现有订阅情况。当用户订阅以更新整个标签的分数并根据分数排序它们时，将使用这些函数：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The NatSpec documentation describes all of your functions with a basic description,
    the parameters, and the return values for other coders to see, so that they can
    maintain your code. They also help you understand what's going on when the code
    base grows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: NatSpec 文档描述了所有函数的基本描述、参数和其他程序员的返回值，以便他们可以维护您的代码。它们还帮助您理解代码基础增长时发生的情况。
- en: Next, we must implement all the functions one by one until all of them are completed.
    This is the most time-extensive process since some parts are harder than others,
    considering the limitations of Solidity. Try to stay positive while doing it.
    You'll finish it earlier than you expect if you set up a one- or two-hour timer
    where you can't get distracted before completing it. That's the famous **Pomodoro**
    technique to maximize productivity, and I suggest you to use it to get more stuff
    done in less time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须逐一实现所有函数，直到所有函数都完成。这是最耗时的过程，因为考虑到 Solidity 的限制，一些部分比其他部分更难。在执行此操作之前，尽量保持积极。如果您设置了一个一到两小时的计时器，在完成之前不能分心，您会比预期完成得更早。这就是著名的**番茄工作法**，以最大程度地提高生产力，我建议您使用它以在较短时间内完成更多工作。
- en: Implementing the adding content function
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现添加内容功能。
- en: 'The adding content function is the most complex in the dApp that we''re building
    because we need to complete the following tasks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加内容功能是我们正在构建的 dApp 中最复杂的，因为我们需要完成以下任务：
- en: Check whether the content given by the user is valid
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户提供的内容是否有效。
- en: Add new content to the right state variables
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新内容添加到正确的状态变量中。
- en: Increase the score of the hashtags included in the content piece
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加包含在内容片段中的标签的分数。
- en: Dynamically store contents in a `general` hashtag that people can use to find
    random content without sorting
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容动态存储在`general`标签中，人们可以使用它来查找未排序的随机内容。
- en: Add the user to the array of users if they're a new customer
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是新客户，则将用户添加到用户数组中。
- en: 'Because of the many functions that we must implement, the function will inevitably
    be complex. That''s why it is important to take your time to get it right, since
    we could easily create gas traps that consume all the available gas. Before seeing
    my solution, go to your computer to implement them as best as possible on your
    own by performing the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须实现的函数很多，该函数不可避免地会很复杂。这就是为什么要花时间做好它很重要，因为我们很容易创建消耗所有可用燃气的燃气陷阱。在看到我的解决方案之前，请先去您的计算机上实施它们，尽量在自己的计算机上执行以下步骤：
- en: 'Add the `require()` checks to be sure that the content is valid:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`require()`检查以确保内容有效：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Depending on whether the user added a hashtag, we''ll execute the corresponding
    functionality to sort and increase the value of those hashtags:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户是否添加了标签，我们将执行相应的功能来对这些标签进行排序并增加其值：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sort the arrays by score using the function described earlier and we create
    the user while emitting the right events:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面描述的函数按分数对数组进行排序，并在创建用户时发出正确的事件：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s a breakdown of what I did in that function step by step:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在那个函数中逐步完成的拆分：
- en: I checked that the `_content` variable that contains the message is not empty,
    by converting it to bytes and checking the length of it. It's one of the ways
    that you can check whether a string is empty since you can't get the length of
    a string type.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我检查了包含消息的 `_content` 变量是否为空，方法是将其转换为字节并检查其长度。这是检查字符串是否为空的一种方法，因为无法获取字符串类型的长度。
- en: I created the `Content` struct instance with the required parameters and worked
    on populating the mappings that use that struct, so that we can find that piece
    of content later.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我使用所需的参数创建了 `Content` 结构体实例，并开始填充使用该结构体的映射，以便稍后找到该内容。
- en: The user is free to not specify any tags, in which case the content will be
    added to the `#general` hashtag to organize it in some way for those that want
    to get general information from the application. Remember that we interact via
    hashtags mainly, so it's imperative to organize each message into one.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以选择不指定任何标签，此时内容将被添加到 `#general` 标签中，以某种方式为希望从应用程序获取一般信息的人组织起来。请记住，我们主要通过标签进行交互，因此将每条消息组织到一个标签中至关重要。
- en: If the user specified a few hashtags, we add the content to all of those while
    also creating new hashtags that people can follow. For now, we don't have any
    limits on how many hashtags people can use, since we are experimenting with how
    the application will work. We can focus on those details later, if we decide to
    set up such limitations.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户指定了一些标签，我们将内容添加到所有这些标签中，同时创建新的标签供人们关注。目前，我们对人们可以使用多少个标签没有任何限制，因为我们正在尝试应用程序的工作方式。如果我们决定设置此类限制，我们以后可以关注这些细节。
- en: Add the user to the array of users and emit the `ContentAdded` event to notify
    others about new content.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户添加到用户数组中，并发出 `ContentAdded` 事件，以通知其他人有关新内容的情况。
- en: Creating the promotion engine
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建推广引擎
- en: We need a way to tell users which accounts are performing the best by creating
    a scoring system that increases hashtags' value. That's why we created the `hashtagScore`
    mapping, as a measurement of the popularity of the hashtags being used. The promotion
    engine is simply a way of rating hashtags by popularity. So, the score of the
    hashtag will increase when someone subscribes to that hashtag or adds new content
    for that hashtag. It will decrease when someone unsubscribes. This will all be
    invisible, so that users just see the top hashtags.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法告诉用户哪些帐户表现最佳，方法是创建一个增加标签价值的评分系统。这就是我们创建 `hashtagScore` 映射的原因，作为衡量正在使用的标签受欢迎程度的方法。推广引擎只是一种按照受欢迎程度评分标签的方法。因此，当有人订阅该标签或为该标签添加新内容时，该标签的分数将会增加。当有人取消订阅时，分数将减少。这一切都是不可见的，所以用户只会看到热门标签。
- en: 'Let''s continue with the subscribe functions to give people the power to follow
    particular topics that interest them. To implement the promotion engine, we simply
    have to update the score of the particular hashtag being used in the subscribe
    and unsubscribe functions. Again, try to implement it yourself before seeing the
    solution, to sharpen your skills while learning and gaining experience. The following
    is the subscribe function, which increases the score of the selected hashtag for
    that particular user:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写订阅函数，让人们有权关注他们感兴趣的特定主题。要实现推广引擎，我们只需在订阅和取消订阅函数中更新正在使用的特定标签的分数。再次强调，在看解决方案之前，尝试自己实现它，以锻炼你的技能并获取经验。以下是订阅函数，它增加了该特定用户选择的标签的分数：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we have the unsubscribe function, which reduces the hashtag value because
    it''s becoming less relevant:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有取消订阅函数，它减少了标签的价值，因为它变得不太相关：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `subcribeToHashtag` function simply checks whether the user is subscribed
    already to add that new topic to their list of interests, while also sorting the
    hashtags since the score of that particular one has been increased. In our smart
    contract, hashtags are valued by use. The more people that subscribe to them and
    the more content that gets created for that particular tag, the higher its ranking
    will be.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`subcribeToHashtag` 函数简单地检查用户是否已订阅，以便将新主题添加到他们的兴趣列表中，同时对标签进行排序，因为该标签的分数已经增加。在我们的智能合约中，标签的价值取决于使用情况。订阅该标签的人越多，为该标签创建的内容越多，其排名就越高。'
- en: The `unsubscribeToHashtag` function loops through all the hashtags for that
    particular user and removes the selected one from their list. This loop shouldn't
    cause any gas problems since we don't expect people to follow hundreds of thousands
    of topics. Regardless, the right thing to do is to limit the number of subscribable
    tags to avoid gas errors. I'll leave that up to you. Finally, we reduce the score
    of that hashtag and we sort all of them with the changes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsubscribeToHashtag`函数循环遍历该特定用户的所有标签，并从其列表中移除选定的标签。此循环不应引起任何 gas 问题，因为我们不期望用户关注数十万个主题。无论如何，正确的做法是限制可订阅标签的数量，以避免
    gas 错误。我会把这交给你。最后，我们降低该标签的评分，并对所有标签进行排序处理。'
- en: Implementing the getter functions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 getter 函数
- en: 'Next, let''s see the getter functions that we''ll use to show data to our users.
    These functions don''t cost any gas because they are reading data from the downloaded
    and synchronized blockchain, which is always available without depending on an
    internet connection. Let''s take a look at the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们将用来向用户显示数据的 getter 函数。这些函数不需要任何 gas 费用，因为它们是从已下载和同步的区块链中读取数据，始终可用，而不依赖于互联网连接。让我们看看以下步骤：
- en: 'Create the `getTopHashtags()` function, which returns a list of names in bytes32
    format to the user so that they can see which ones are trending. This is the main
    discovery system for new content:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getTopHashtags()`函数，以 bytes32 格式返回用户可见的名称列表，以便查看哪些标签正在流行。这是发现新内容的主要系统：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the function to get the followed hashtags, which is quite straightforward
    because it returns the specified list using the `subscribedHashtags[]` mapping:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加获取已关注标签的函数，这很简单，因为它使用`subscribedHashtags[]`映射返回指定列表：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the `getContentIdsByHashtag()` function. This will be responsible
    for returning an array of IDs that contain all the pieces of content for a particular
    hashtag that a user may be subscribed to:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getContentIdsByHashtag()`函数。这将负责返回包含用户可能订阅的特定标签的所有内容片段的 ID 数组：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the simple `getContentById()` function, required to get the struct of IDs
    broken down into digestible variables, since we can''t return structs yet:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加简单的`getContentById()`函数，用于将 ID 结构转换为可理解的单独变量，因为我们目前无法返回结构体：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding functions are pretty straightforward . The `getContentIdsByHashtag`
    function is a bit tricky since we wouldn't normally need it, but, because Solidity
    doesn't allow us to return arrays of structs or arrays of strings, we have to
    get the IDs so that to later we can get each piece of content independently with
    the `getContentById` function, which does return each variable successfully.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数相当简单。`getContentIdsByHashtag` 函数有点棘手，因为通常情况下我们不需要它，但由于 Solidity 不允许我们返回结构体数组或字符串数组，所以我们必须获得这些
    ID，以便稍后可以使用`getContentById`函数逐个获取各个内容片段，该函数可以成功返回每个变量。
- en: 'Here are the two last helper functions that we need to make everything possible:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要使一切成为可能的最后两个辅助函数：
- en: 'The `sortHashtagsByScore()` function is used to return a list of tags sorted
    by the popularity of each one since we''re reading the values of each tag:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortHashtagsByScore()`函数用于返回按照每个标签的受欢迎程度排序的标签列表，因为我们正在读取每个标签的值：'
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `checkExistingSubscription()` function returns a Boolean for whether a
    user is subscribed:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkExistingSubscription()`函数返回用户是否已订阅的布尔值：'
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The sort function is quite difficult to read because of its apparent complexity.
    Nevertheless, it's just a couple of `for` loops, a normal one, and a reversed
    one inside the other which continuously moves the higher-score hashtags, to the
    top until the best one is in the first position of our `sortedHashtags` array.
    This will be used to replace the past, unsorted-state `hashtags` array.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 排序函数因其明显的复杂性而难以阅读。尽管如此，它只是一对`for`循环，一个正常的循环和一个内部的倒序循环，连续将得分较高的标签移到顶部，直到最好的标签位于我们的`sortedHashtags`数组的第一个位置。这将用于替换过去的、未排序状态`hashtags`数组。
- en: The `checkExistingSubscription` function loops through all of your subscribed
    hashtags and returns `true` if the provided one is in your list. This is needed
    for the subscription functions to keep the arrays clean without duplicating subscriptions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkExistingSubscription` 函数循环遍历所有已订阅的标签，并在提供的标签在列表中时返回`true`。这对订阅函数很重要，以保持数组清洁，避免重复订阅。'
- en: The updated, complete code can be seen on my GitHub at [https://github.com/merlox/social-media-dapp](https://github.com/merlox/social-media-dapp).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完整更新的代码可以在我的 GitHub 上查看，网址为[https://github.com/merlox/social-media-dapp](https://github.com/merlox/social-media-dapp)。
- en: What's left now is to test that all of those functions work. Go ahead and paste
    the code into Remix or any other IDE so that it points you to the errors that
    must be fixed. Then deploy the contract to the JavaScript VM, which doesn't have
    any costs, and run those functions one by one. Note, that you'll have to convert
    the `bytes32` variables to hexadecimal, which you can do with the `web3.toHex()`
    function in the developer tools of your browser if you have MetaMask installed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的是测试所有这些功能是否正常工作。将代码粘贴到 Remix 或任何其他 IDE 中，以便它指出必须修复的错误。然后将合同部署到 JavaScript
    VM 中，这不会产生任何费用，并逐一运行这些函数。注意，你将需要将`bytes32`变量转换为十六进制，如果你安装了 MetaMask，则可以在浏览器的开发者工具中使用`web3.toHex()`函数进行转换。
- en: Ideally, you could write tests in Truffle to automatically check for errors
    caused by new changes. I'll leave that for you to decide.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你可以在 Truffle 中编写测试，自动检查由新更改引起的错误。我会留下这个决定给你。
- en: The contract is ready to run, the next step is to implement it in your dApp
    so that the information comes from the decentralized backend that we just created.
    See how it's done in the following section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 合约准备就绪后，下一步是在你的 dApp 中实施它，以便信息来自我们刚刚创建的去中心化后端。在下一节中看看如何实现它。
- en: Finishing the dApp
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 dApp
- en: Your React.js web application looks great, what's left is to connect the smart
    contract to the functions in your application so they talk to each other while
    preserving that decentralization, since anybody is free to use the React application
    where they want without relying on a centralized server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 React.js Web 应用程序看起来很棒，剩下的就是连接智能合约到你的应用程序中的功能，以便它们互相交流，同时保持去中心化，因为任何人都可以在不依赖于集中式服务器的情况下自由使用
    React 应用程序。
- en: The first step in connecting a smart contract with a web application is to install
    web3.js since it's the bridge between Ethereum and web browsers, although you
    may not need it as we already have MetaMask. In any case, it's important to have
    it to select a stable version that won't change for our dApp. Go ahead and run
    `npm i -S web3` on your project folder.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 连接智能合约与 Web 应用程序的第一步是安装 web3.js，因为它是以太坊和 Web 浏览器之间的桥梁，尽管我们已经有了 MetaMask，你可能不需要它，但是重要的是选择一个稳定版本，不会为我们的
    dApp 更改。请在项目文件夹中运行`npm i -S web3`。
- en: Setting up the smart contract instance
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置智能合约实例
- en: 'The first thing that must be done when implementing a smart contract inside
    a React application is the contract instance so that we can start calling methods
    from that contract all over the decentralized application. We''ll use the compiled
    contract provided by Truffle and the address of it. Let''s perform the following
    steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序中实施智能合约时，必须首先完成合约实例，以便我们可以在整个去中心化应用程序中调用该合约的方法。我们将使用 Truffle 提供的编译合约和其地址。让我们执行以下步骤：
- en: 'Import web3 into your project:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 web3 导入到你的项目中：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Why do you think I've named the variable `Web3Js` instead of just `Web3`? Because
    MetaMask injects its own version of web3, which is precisely named `Web3`, so
    when we develop, we may be used the injected version of web3, instead of the one
    that we are interested in importing. It's important to use a slightly different
    name to avoid interfering with the injected web3 by MetaMask.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得为什么我将变量命名为 `Web3Js` 而不直接用 `Web3` 呢？因为 MetaMask 注入了自己版本的 web3，准确地命名为 `Web3`，因此当我们开发时，可能会使用
    MetaMask 注入的 web3 版本，而不是我们想要导入的版本。为了避免与 MetaMask 注入的 web3 发生干扰，重要的是使用略微不同的名称。
- en: Set up web3 with the current provider globally so that you can use it with in
    your entire application without having to worry about scope problems.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局使用当前提供程序设置 web3，这样你就可以在整个应用程序中使用它，而不必担心范围问题。
- en: 'Create a function named `setup()` that contains the MetaMask setup logic. This
    function will be executed in the constructor, right when the page loads:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setup()`的函数，其中包含 MetaMask 设置逻辑。这个函数将在构造函数中执行，页面加载时执行：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We created a new setup function because we can't use await on the constructor,
    given that it's not an asynchronous function. Inside it, we created a global `web3js`
    variable which is not called `web3` (in lowercase), since MetaMask is already
    using that variable name and we risk using the wrong version. As you can see,
    the provider in this case is called `ethereum`, a global variable coming from
    MetaMask that includes all we need to start using web3; it's a new way of initializing
    a web3 instance that is compatible with older dApps because of some changes the
    MetaMask team made regarding security. Then we wait for the `enable()` function
    to get permission from the user to inject web3 because we don't want to expose
    user keys without the user's consent. If the user doesn't allow it, we show an
    error to let them know that we need them to grant permission for this dApp in
    order to work properly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的设置函数，因为我们无法在构造函数上使用 await，因为它不是一个异步函数。在其中，我们创建了一个名为`web3js`的全局变量，该变量不叫做`web3`（小写），因为
    MetaMask 已经使用了该变量名，我们有可能使用错误的版本。如您所见，在本例中，提供程序称为`ethereum`，这是来自 MetaMask 的全局变量，其中包含了我们启动使用
    web3 所需的一切；这是一种新的初始化 web3 实例的方式，与旧版 dApp 兼容，因为 MetaMask 团队对安全性进行了一些更改。然后我们等待`enable()`函数获得用户的许可以注入
    web3，因为我们不希望在没有用户同意的情况下暴露用户密钥。如果用户不允许，我们会显示一个错误，让他们知道我们需要他们授予权限以使此 dApp 正常工作。
- en: 'Set up the smart contract instance. Because we have Truffle installed, we can
    compile our smart contract to generate the JSON file that contains the ABI, which
    is required to use the application. Then we can deploy our contract to `ropsten`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置智能合约实例。因为我们已经安装了 Truffle，我们可以编译我们的智能合约以生成包含 ABI 的 JSON 文件，该文件是使用该应用程序所必需的。然后我们可以将合约部署到`ropsten`：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You might get the following message:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到以下消息：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This means that you didn''t set up the Truffle config file properly with the
    `ropsten` network. Install the wallet provider with `npm i -S truffle-hdwallet-provider`.
    Then modify `truffle-config.js` with the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着您没有正确设置 Truffle 配置文件以使用`ropsten`网络。使用`npm i -S truffle-hdwallet-provider`安装钱包提供程序。然后使用以下代码修改`truffle-config.js`：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Tell Truffle to deploy your contract by creating a `2_deploy_contract.js` filename
    inside your `migrations/` folder with the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 Truffle 通过在`migrations/`文件夹中创建一个名为`2_deploy_contract.js`的文件来部署您的合约，其中包含以下代码：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, we only have the minimal configuration parameters so keep it
    clean. Create a `.secret` file in your project folder and paste your Ethereum
    seed phrase, which you can get by resetting MetaMask or installing it in another
    browser if you are worried about making your seed public. That seed phrase will
    be used by Truffle to deploy the contracts, so be sure to have enough `ropsten`
    Ether in your first account. Then run `truffle deploy --network ropsten --reset`
    again.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们只有最小的配置参数，因此保持它简洁。在您的项目文件夹中创建一个`.secret`文件，并粘贴您的以太坊种子短语，您可以通过重置 MetaMask
    或在另一个浏览器中安装它来获取该种子短语，如果您担心使您的种子公开。该种子短语将被 Truffle 用于部署合约，所以请确保您的第一个账户中有足够的`ropsten`以太币。然后再次运行`truffle
    deploy --network ropsten --reset`。
- en: 'Update your `setup` function with the following to create a contract instance:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容更新您的`setup`函数以创建合约实例：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We've set up the user account in the app's state to have easy access whenever
    we need it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了应用程序状态中的用户账户，以便在需要时轻松访问它。
- en: Decentralizing your data
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的数据去中心化
- en: 'To fully implement the smart contract, we have to take a look at each section
    of the website to update its contents with data from the smart contract. Let''s
    go from top-left to bottom-right. In that order, the first thing we have to decentralize
    is the top hashtags sections, using the `getTopHashtags()` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全实现智能合约，我们必须查看网站的每个部分，以使用智能合约中的数据更新其内容。让我们从左上角到右下角进行。按照顺序，我们必须首先去中心化顶部的标签部分，使用`getTopHashtags()`函数：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You''ll also have to update your `render()` function for when you don''t have
    any top hashtags, since you just deployed your smart contract. We''ll get the
    content from another function named `getContent()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当您没有任何热门标签时，您还必须更新您的`render()`函数，因为您刚刚部署了智能合约。我们将从另一个名为`getContent()`的函数中获取内容：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So it looks like this after the changes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的代码如下所示：
- en: '![](img/a9955266-a836-4781-9b0f-1023b74684a4.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9955266-a836-4781-9b0f-1023b74684a4.png)'
- en: 'Let''s update the get content function to generate data based on whether the
    user has any active subscriptions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新获取内容函数，以根据用户是否有任何活动订阅来生成数据：
- en: 'To get all the content the user will be seeing, we need to get `latestContentId`,
    which is a number of how many pieces of content are available at that moment,
    in case the user is not subscribed to any hashtags yet:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取用户将要看到的所有内容，我们需要获取 `latestContentId`，这是一个表示当前时刻可用多少个内容片段的数字，以防用户尚未订阅任何标签：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Get the content pieces if the user is following hashtags by looping through
    all the IDs:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户正在关注标签，则通过循环遍历所有 ID 获取内容片段：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the user isn''t subscribed to any hashtags yet, update the `counter` variable
    to loop inversely so that we get the most recent pieces first:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尚未订阅任何标签，则更新 `counter` 变量以反向循环，以便首先获取最新的内容片段：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Generate `contentsBlock`, which contains all the elements that create a piece
    of content, which is similar to a tweet or a Facebook post:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成 `contentsBlock`，其中包含创建内容片段的所有元素，类似于推特或 Facebook 的帖子：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This `getContent()` function checks whether the user has any active subscriptions
    so that it can retrieve up to three pieces of content per hashtag. It will also
    get up to the 10 most recent articles uploaded to the dApp. It is quite large
    because it generates data based on the number of hashtags that are available on
    the smart contract. If you follow 100 hashtags, you'll see 300 new pieces of content
    since we're getting 3 articles per hashtag in the feed. We're also adding 10 random
    contents that will be taken from the array of `contents` in the smart contract.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `getContent()` 函数检查用户是否有任何活动订阅，以便它可以获取每个标签最多三个内容片段。它还将获取 dApp 上载的最近 10 篇文章。它相当庞大，因为它根据智能合约上可用的标签数量生成数据。如果您关注
    100 个标签，您将看到 300 个新的内容片段，因为我们在 feed 中每个标签获取 3 篇文章。我们还将添加 10 个随机内容，这些内容将从智能合约中的
    `contents` 数组中取出。
- en: Creating the hashtag component
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签组件
- en: Each hashtag is a little machine that contains lots of logic to detect whether
    the user is subscribed. It may seem simple, but remember that we need to get the
    state of each hashtag for each user, which means that we have to execute a lot
    of requests that could slow our dApp's performance. Be clean when creating the
    function so that they run smoothly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签都是一个小型机器，包含了大量的逻辑来检测用户是否已订阅。这可能看起来很简单，但请记住，我们需要获取每个用户对每个标签的状态，这意味着我们必须执行大量请求，可能会减慢我们的
    dApp 的性能。创建函数时要保持清洁，以便它们运行顺畅。
- en: 'We''re using a new component named Hashtag, which is an HTML object that returns
    an interactive hashtag text that can be clicked to subscribe to it, or unsubscribe.
    This is the cleanest way of creating such functionality to reduce complexity:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个名为 Hashtag 的新组件，它是一个 HTML 对象，返回一个交互式的标签文本，可以点击进行订阅或取消订阅。这是创建这种功能的最简洁方式，以减少复杂性：
- en: 'Create the constructor with a few state variables to display or hide the hashtag
    depending on the user''s behavior:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建构造函数，带有一些状态变量，根据用户的行为显示或隐藏标签：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create the `bytes32()` and `checkExistingSubscription()` functions to check
    whether the current user is already following this particular hashtag:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `bytes32()` 和 `checkExistingSubscription()` 函数来检查当前用户是否已经关注了特定的标签：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `render()` function is quite large, so we''ll break it down into two main
    pieces: the functionality to detect whether a user is subscribed and the functionality
    to display the right buttons:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render()` 函数相当庞大，因此我们将其分解为两个主要部分：检测用户是否已订阅的功能，以及显示正确按钮的功能：'
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the subscribe or unsubscribe buttons that will be shown when the
    user hovers over the hashtag:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现订阅或取消订阅按钮，当用户悬停在标签上时显示：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `render()` function displays the hashtag, which shows a subscribe or unsubscribe
    button when hovered. The `checkExistingSubscription()` function gets the state
    of a particular hashtag subscription to display the right type of button for the
    user that wishes to unsubscribe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 函数显示标签，当鼠标悬停时显示订阅或取消订阅按钮。`checkExistingSubscription()` 函数获取特定标签订阅的状态，以显示适合取消订阅的用户的按钮类型。'
- en: Creating the hashtag getter
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签获取器
- en: We can now create a function to get the top hashtags and the followed hashtags
    from the smart contract when the page loads. We'll do it by retrieving the followed
    and top hashtags. Those will be shown to the user by looping through all of them
    until the interface is filled with data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，我们现在可以创建一个函数，从智能合约中获取顶级标签和已关注的标签。我们将通过检索已关注的和顶级标签来完成。这些标签将通过循环遍历它们直到界面填满数据，显示给用户。
- en: 'Try to implement it yourself and see the following result once you''re done:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，请尝试自行实现并查看以下结果：
- en: 'Define the variables needed to create the resulting hashtag JSX:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义创建结果标签 JSX 所需的变量：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Start looping through the hashtag blocks until we fill the list of top hashtags:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始循环遍历标签块，直到我们填满顶部标签列表：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the user isn''t following any hashtags, we''ll display a message. If they
    are, we''ll loop through all the followed hashtags to generate the Hashtag component
    with the required data. Update the state with the new blocks that we just created
    to display them on the `render()` function:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户没有关注任何标签，我们将显示一条消息。如果他们有，我们将循环遍历所有关注的标签，生成具有所需数据的 Hashtag 组件。使用刚刚创建的新块更新状态，以便在
    `render()` 函数中显示它们：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating the publishing functionality
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发布功能
- en: Publishing new pieces of content is a simple task that requires that we verify
    that all the inputs contain valid strings of text. Since we are storing hashtags
    in a bytes32 variable, we need to format the hashtags introduced by the user properly
    so that the smart contract is able to process them securely.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 发布新的内容是一个简单的任务，需要验证所有输入是否包含有效的文本字符串。由于我们将标签存储在一个 bytes32 变量中，所以需要正确格式化用户输入的标签，以便智能合约能够安全处理它们。
- en: 'Let''s make the publish function work so that we can start generating content
    by performing the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让发布功能起作用，这样我们就可以开始生成内容，执行以下步骤：
- en: 'Create the `bytes32()` function if you haven''t done so, because we''ll need
    it soon:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请创建 `bytes32()` 函数，因为我们很快会需要它：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the `publishContent()` function to process the message with the hashtags.
    The hashtags will be given in a string format that contains a list of comma-separated
    strings without the hash symbol (`#`). Make sure that the hashtags are properly
    separated and formatted for the contract:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `publishContent()` 函数来处理带有标签的消息。标签将以字符串格式给出，其中包含不带散列符号（`#`）的逗号分隔字符串列表。确保标签被正确分隔和格式化，以供合约安全处理：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here''s the explanation for the two functions we just added:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们刚刚添加的两个函数的解释：
- en: '`bytes32()`: This function is used to convert normal strings into hexadecimals
    valid for Solidity, since the new update forces web3 users to convert data to
    hexadecimal when dealing with `bytes` types of variables.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes32()`: 这个函数用于将普通字符串转换为 Solidity 可用的十六进制，因为新的更新强制 web3 用户在处理 `bytes` 类型的变量时将数据转换为十六进制。'
- en: '`publishContent()`: This function looks a bit messy because we are using regex
    to convert the hashtag input from the user to a valid array of clear strings per
    hashtag. It''s doing things such as removing spaces, removing duplicate commas
    and tag symbols, and then breaking the string into a valid array that can be used
    in our smart contract.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publishContent()`: 这个函数看起来有点凌乱，因为我们正在使用正则表达式将用户输入的标签转换为有效的清晰字符串数组。它正在执行一些操作，比如删除空格、删除重复逗号和标签符号，然后将字符串拆分成一个有效的数组，可以在我们的智能合约中使用。'
- en: 'Remember to update your `setup()` function so that it gets the latest contents
    when loading:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得更新你的 `setup()` 函数，以便在加载时获取最新的内容：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It''s time to focus on creating the subscription functions. They will be executed
    when the user clicks on subscribe or unsubscribe, depending on the current state.
    Try to implement them yourself and come back once you''re done to compare your
    solution with mine. Remember, this is about trying and failing until the code
    becomes good enough. Here''s my solution:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候专注于创建订阅功能了。它们将在用户点击订阅或取消订阅时执行，取决于当前状态。尝试自己实现它们，然后一旦完成，请返回比较你的解决方案和我的。记住，这是尝试和失败，直到代码变得足够好的过程。这是我的解决方案：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Both functions are quite simple. They run the appropriate subscribe or unsubscribe
    functions when the user presses the button next to the hashtag name. Notice how
    we're using a try catch to avoid breaking the entire application if something
    fails when calling the contract; that's also because sometimes it has a weird
    failing system where it stops executing for no reason. Just add try catch blocks
    when you feel like you need to.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都相当简单。当用户按下标签名称旁边的按钮时，它们运行适当的订阅或取消订阅函数。注意我们如何使用 try catch 避免在调用合约时出现故障时破坏整个应用程序；这也是因为有时它有一个奇怪的故障系统，在没有原因的情况下停止执行。当你觉得需要时，只需添加
    try catch 块。
- en: You can find the updated version in GitHub at [https://github.com/merlox/social-media-dapp](https://github.com/merlox/social-media-dapp)
    with the complete implementation code for your reference. That's about it! You
    now have a new project in your blockchain development resume that you can show
    to employers, or build upon creating a better decentralized social media platform
    for raising funds.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到更新版本，网址为 [https://github.com/merlox/social-media-dapp](https://github.com/merlox/social-media-dapp)，其中包含完整的实现代码供您参考。就是这样！现在你的区块链开发简历上有了一个新项目，你可以向雇主展示，或者在此基础上构建一个更好的去中心化社交媒体平台来筹集资金。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That's about it when it comes to creating a fully-decentralized social media
    platform for users to publish content freely. In this chapter, you learned about
    the benefits of creating this type of application on the blockchain versus creating
    it on a centralized system. Then you created the user interface by setting up
    everything from scratch with Truffle and React. After that, you developed the
    smart contract and connected it to the dApp to make it interactive. Overall, you
    gained a big chunk of experience that you can expand upon to create a different
    type of social media platform with interesting features, such as following users
    and adding oracles for interacting with different APIs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为用户自由发布内容创建一个完全去中心化的社交媒体平台时，就是这些了。在本章中，您了解了在区块链上创建这种类型的应用程序与在集中式系统上创建它之间的优势。然后，您通过使用
    Truffle 和 React 从头开始设置了用户界面。之后，您开发了智能合约并将其连接到 dApp 以使其交互式。总的来说，您获得了一大块经验，可以将其扩展为创建具有各种有趣功能的不同类型的社交媒体平台，例如关注用户和添加用于与不同
    API 交互的 Oracle。
- en: In the next chapter, we'll explore the build process behind a decentralized
    e-commerce marketplace on the blockchain, where you'll create a fully-functioning
    shop for your business.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在区块链上构建去中心化电子商务市场的构建过程，您将为您的业务创建一个完全功能的商店。
