- en: Exposing Network Assets and Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露网络资产和交易
- en: If you have reached this far, congratulations! You have built the core of your
    blockchain application and the smart contract that directly reads, and more importantly,
    manipulates, the ledger that is the System-of-Record for your network. But, you
    are not close to finishing yet. As you can imagine, the contract is a sensitive
    piece of code that must be protected from misuse or tampering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经走到这一步，恭喜您！您已经建立了区块链应用程序的核心以及直接读取、更重要的是操纵您网络的记录系统的智能合约。但是，您还没有完成。正如您所能想象的那样，合约是一段敏感的代码，必须受到不当使用或篡改的保护。
- en: To produce a robust and secure application that is safe to release to business
    users, you must wrap the smart contract with one or more layers of protection
    and engineer it as a service that clients can access remotely through appropriate
    safeguards. In addition, the various stakeholders that wish to share a ledger
    and a smart contract may have unique and specific business logic needs that only
    they, and not the others, need to implement over and above the contract. For this
    reason, one blockchain application running one smart contract may end up offering
    different views and capabilities to different stakeholders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个健壮且安全的应用程序，安全地发布给业务用户，您必须将智能合约与一层或多层保护包装起来，并将其设计为客户端可以通过适当的保障远程访问的服务。此外，希望共享分类帐和智能合约的各方可能具有独特和特定的业务逻辑需求，这些需求只有他们需要实现，其他人不需要。因此，运行一个智能合约的区块链应用程序可能最终会为不同的利益相关者提供不同的视图和功能。
- en: In this chapter, you will first learn how to build a complete blockchain application
    from the ground up using our trade application as a guide and example. Later,
    you will learn about the various considerations that go into designing this application
    for a scenario of your choice and how to integrate that application with existing
    systems and processes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将首先学习如何从头开始构建一个完整的区块链应用程序，使用我们的贸易应用程序作为指南和示例。稍后，您将了解到设计这个应用程序所需考虑的各种因素，以及如何将该应用程序与现有系统和流程集成。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building a complete application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建完整的应用程序
- en: Integrating the application with existing systems and processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序与现有系统和流程集成
- en: Building a complete application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建完整的应用程序
- en: In this section, you will learn how to build a complete application around the
    core smart contract that can be readily used by the business entities that have
    joined together to form a network. We will begin with a recap of the Hyperledger
    Fabric transaction pipeline to remind the reader what (and how) a blockchain application
    does from the perspective of the user (or client). Using code samples, we will
    show you how to build, design, and organize a network around the needs of business
    entities, create appropriate configurations, and effect the different stages of
    a blockchain transaction from start to finish. At the end of this process, the
    reader will understand how to engineer a Fabric application and expose its capabilities
    through a simple web interface. The only asset we need to possess in the beginning
    of this chapter is the contract, or chaincode, which was developed using either
    hands-on Go programming (see [*Chapter 4*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml), *Designing
    a data and transaction model with Golang*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何围绕核心智能合约构建一个完整的应用程序，该应用程序可以被已经加入一起形成网络的商业实体方便地使用。我们将从回顾 Hyperledger
    Fabric 交易流程开始，以提醒读者用户（或客户端）的角度，一个区块链应用程序是如何做的（以及如何做的）。通过代码示例，我们将向您展示如何根据商业实体的需求构建、设计和组织网络，创建适当的配置，并完成从开始到结束的区块链交易的不同阶段。在此过程结束时，读者将了解如何设计一个
    Fabric 应用程序，并通过一个简单的 web 界面展示其功能。在本章开始时，我们唯一需要拥有的资产是合约或链代码，它是使用 Go 编程（请参阅 [*第
    4 章*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)，*使用 Golang 设计数据和交易模型*）手工开发的。
- en: In the back-end of this chapter, we will guide the experienced enterprise developer
    through more advanced topics, such as service design patterns, reliability, and
    other common engineering concerns. Although these concerns apply to every distributed
    application, we will discuss the special needs and issues of blockchain-based
    applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后端，我们将引导经验丰富的企业开发人员深入了解更高级的主题，例如服务设计模式、可靠性和其他常见的工程问题。尽管这些问题适用于每个分布式应用程序，但我们将讨论基于区块链的应用程序的特殊需求和问题。
- en: The nature of a Hyperledger Fabric application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 应用的性质
- en: In earlier chapters, we saw how Hyperledger Fabric can be viewed as a distributed
    transaction processing system, with a staged pipeline of operations that may eventually
    result in a change to the state of the shared replicated ledger maintained by
    the network peers. To the developer, a blockchain application is a collection
    of processes through which a user may submit transactions to, or read state from,
    a smart contract. Under the cover, the developer must channel a user request into
    the different stages of the transaction pipeline and extract results to provide
    feedback at the end of the process. Essentially, it is the application developer's
    job to implement one or more layers of wrappers around the smart contract, regardless
    of whether the contract was implemented by hand (see [*Chapter 4*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml), *Designing
    a data and transaction model with Golang*) or using Hyperledger Composer (see
     [*Chapter 6*](a016f64e-9db7-44d4-a393-f9797d0b1e6f.xhtml), *Business Networks*).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看到 Hyperledger Fabric 可以被视为一个分布式事务处理系统，具有分阶段的操作流水线，这些操作最终可能导致由网络对等方维护的共享复制分类帐的状态发生变化。对于开发者来说，区块链应用程序是一组过程，通过这些过程，用户可以向智能合约提交事务，或者从智能合约中读取状态。在底层，开发者必须将用户请求引导到事务流水线的不同阶段，并提取结果以在流程结束时提供反馈。基本上，无论合约是手工实现的（参见
    [*第 4 章*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)，*使用 Golang 设计数据和事务模型*）还是使用
    Hyperledger Composer 实现的（参见 [*第 6 章*](a016f64e-9db7-44d4-a393-f9797d0b1e6f.xhtml)，*业务网络*），应用程序开发者的工作都是在智能合约周围实现一个或多个包装层。
- en: 'An application developed with the smart contract (or the asset-entity model)
    at its core can be viewed as a transaction-processing database application with
    a set of views or a service API. However, the developer must keep in mind that
    every Hyperledger Fabric transaction is asynchronous, that is, the result of the
    transaction will not be available in the same communication session that it was
    submitted in. This is because, as we have seen in previous chapters, a transaction
    must be collectively approved by the peers in the network through consensus. As
    such, consensus may potentially take an unbounded amount of time, and the communication
    of a transaction result is designed as a publish/subscribe mechanism. The following
    diagram illustrates the blockchain application and transaction pipeline from the
    perspective of the developer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以智能合约（或资产实体模型）为核心开发的应用可以被视为具有一组视图或服务 API 的事务处理数据库应用程序。然而，开发人员必须牢记每个 Hyperledger
    Fabric 事务都是异步的，也就是说，事务的结果在提交的通信会话中不会立即可用。这是因为，正如我们在之前的章节中所看到的，一个事务必须通过共识被网络中的对等方集体批准。因此，共识可能需要花费不确定的时间，并且事务结果的通信被设计为发布/订阅机制。以下图表从开发者的角度说明了区块链应用程序和事务流水线：
- en: '![](img/89fa0e47-d4c1-475e-9c6f-1d256edffb9b.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89fa0e47-d4c1-475e-9c6f-1d256edffb9b.png)'
- en: 'Figure 5.1: The stages in the creation and operation of a blockchain application'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：区块链应用程序创建和运行中的阶段
- en: In the next section, the operations mentioned in this diagram will be described
    in more detail and mapped to specific Fabric mechanisms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，将详细描述图中提到的操作，并将其映射到特定的 Fabric 机制。
- en: Application and transaction stages
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序和事务阶段
- en: The first step in the creation of an application is the instantiation of the
    blockchain, or the shared ledger itself. In Fabric parlance, an instance of a
    blockchain is referred to as a channel, and therefore the first step in a blockchain
    application is the creation of a channel and the bootstrapping of the network
    ordering service with the channel's genesis block.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序的第一步是实例化区块链，或者说共享分类帐本身。在 Fabric 的术语中，区块链的一个实例被称为通道，因此区块链应用程序的第一步是创建一个通道，并使用通道的创世区块引导网络排序服务。
- en: The next step is the initialization of the peer network, whereby all the peer
    nodes selected to run the application must be joined to the channel, a process
    that allows each peer to maintain a copy of the ledger, which is initialized to
    a blank key-value store. Every peer that's joined to the channel will possess
    ledger commitment privileges and may participate in a gossip protocol in order
    to sync ledger state with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对等网络的初始化，所有被选中运行应用程序的对等节点必须加入通道，这个过程允许每个对等方维护一个分类帐的副本，该副本被初始化为一个空白的键值存储。加入通道的每个对等方都将拥有分类帐提交特权，并可以参与八卦协议以与其他对等方同步分类帐状态。
- en: After the creation of the peer network comes the installation of the smart contract
    on that network. A subset of the peers joined to the channel preceding it will
    be selected to run the smart contract; in other words, they will possess endorsement
    privileges. The contract code will be deployed to these peers and built for subsequent
    operation. As you know, by this point, the contract is referred to as chaincode
    in Fabric parlance, and that is the term that will be used for the rest of this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等网络创建完成后，将在该网络上安装智能合约。在此之前连接到通道的一部分对等方将被选中来运行智能合约；换句话说，它们将拥有背书特权。合约代码将部署到这些对等方并构建以进行后续操作。如你所知，到这一步，合约在Fabric术语中被称为链码，本章的其余部分将使用这个术语。
- en: Once the chaincode has been installed on the endorsing peers, it will be initialized
    as per the logic that has been embedded in it (see [*Chapter 4*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml), *Designing
    a Data and Transaction Model with Golang*, for examples).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链码被安装在背书对等方上，将根据嵌入其中的逻辑进行初始化（参见[*第4章*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)，*使用Golang设计数据和交易模型*，以获取示例）。
- en: At this point, unless something has gone wrong in one or more of the preceding
    steps, the application is up and running. Now, transactions may be sent to the
    chaincode to either update the state of the ledger (invocations) or to read the
    ledger state (queries) for the lifetime of the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点为止，除非在前面的一个或多个步骤中出现了问题，否则应用程序已经启动并运行。现在，可以将交易发送到链码，以更新分类帐的状态（调用）或读取分类帐状态（查询）在应用程序的生命周期内。
- en: The application may change or evolve over time, requiring special operations
    to be carried out that are not captured in *Figure 5.1: The stages in the creation
    and operation of a blockchain application.* Those will be described in [*Chapter
    9*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml), *Life In A Blockchain Network*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用可能随着时间的推移而发生变化或演化，需要执行一些未在*图5.1：区块链应用创建和运行阶段*中捕获的特殊操作。这些将在[*第9章*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml)中描述，*区块链网络中的生活*。
- en: In the section titled <q>Building the Application</q> and onward, we will show
    how a trade application can be built around the chaincodes developed in [*Chapter
    4*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml), *Designing a Data and Transaction
    Model with Golang*, using suitable code and instructions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题为<q>构建应用</q>及其后面的部分，我们将展示如何围绕[*第4章*](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)中开发的链码构建贸易应用，使用适当的代码和说明。
- en: Application model and architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用模型和架构
- en: 'The process of writing a Fabric application begins with chaincode, but ultimately
    the developer must make judicious decisions about how an end user or a software
    agent must interface with that chaincode. How the assets of the chaincode, and
    the operations of the blockchain network running that chaincode, ought to be exposed
    to the user is a question that ought to be dealt with carefully. Significant damage
    is possible if these capabilities are exposed without restriction, especially
    the ones involving blockchain bootstrapping and configurations. Proper operation
    of the chaincode itself relies not just on its internal logic, but suitable access
    controls being built above it. As we saw in the previous section, setting up an
    application and preparing it for use is a complex process. In addition, the asynchronous
    nature of ledger-update transactions requires an arbitration layer between the
    chaincode and the user. To allow the user to focus on transactions that impact
    the application rather than the details of the network modules, all this complexity
    ought to be hidden as much as possible. It is for this reason that a three-layer
    architecture has evolved as the standard for a Fabric application, as illustrated
    in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Fabric应用程序的过程始于链码，但最终开发人员必须就终端用户或软件代理如何与该链码进行接口设计做出明智的决策。链码的资产以及运行该链码的区块链网络的操作应该如何暴露给用户是一个需要仔细处理的问题。如果这些功能暴露出去而没有限制，特别是涉及区块链引导和配置的功能，可能会造成严重的损害。链码本身的正确运行不仅依赖于其内部逻辑，还依赖于在其上构建的适当访问控制。正如我们在前一节中看到的，设置应用程序并为其准备使用是一个复杂的过程。此外，分类帐更新事务的异步性质需要在链码和用户之间设置一个仲裁层。为了让用户专注于影响应用程序而不是网络模块的细节，所有这些复杂性都应该尽可能隐藏起来。因此，一个三层架构作为Fabric应用程序的标准已经成为标准，如下图所示：
- en: '![](img/f51a2b7c-1eaf-409a-a9c4-be83b96bb12a.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f51a2b7c-1eaf-409a-a9c4-be83b96bb12a.png)'
- en: Figure 5.2 Typical three-layer architecture of a Hyperledger Fabric application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 Hyperledger Fabric应用程序的典型三层架构
- en: At the lowest layer lies the smart contract that operates directly on the shared
    ledger, which may be written using one or more chaincode units. These chaincodes
    run on the network peers, exposing a service API for invocations and queries,
    and publishing event notifications of transaction results, as well as configuration
    changes occurring on the channel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在最底层是直接在共享账本上运行的智能合约，可以使用一个或多个链码单元编写。这些链码在网络对等体上运行，为调用和查询提供服务API，并发布事务结果的事件通知，以及通道上发生的配置更改。
- en: In the middle layer lies the functions to orchestrate the various stages of
    a blockchain application (see *Figure 5.1: The stages in the creation and operation
    of a blockchain application*). Hyperledger Fabric provides an SDK (currently available
    in `Node.js` as well as in Java) to perform functions such as channel creation
    and joining, registration, and enrollment of users, as well as chaincode operations.
    In addition, the SDK offers mechanisms to subscribe to transaction and configuration-related
    events emanating from the network. Depending on application needs, an off-chain
    database may be maintained for convenience, or as a cache of ledger state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间层中，存在着协调区块链应用程序各个阶段的功能（参见*图5.1：区块链应用程序创建和运行的各个阶段*）。Hyperledger Fabric提供了一个SDK（目前在`Node.js`和Java中都可用）来执行诸如通道创建和加入、用户注册和注册、以及链码操作等功能。此外，SDK提供了机制来订阅来自网络的事务和配置相关事件。根据应用程序的需求，可以维护一个离链数据库以方便使用，或者作为分类帐状态的缓存。
- en: At the topmost layer lies a user-facing application that exports a service API
    consisting mostly of application-specific capabilities, though administrative
    operations such as channel and chaincode operations may also be exposed for system
    administrators. Typically, a user interface should also be provided for ease of
    use, though a well-defined API may suffice if the user is a software agent. We
    refer to this layer simply as the application, as this is what the end user (or
    agent) will see. Also, given that any blockchain application and network is an
    agglomeration of diverse participants, this layer will often consist of multiple
    application stacks tailored to the different participants.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶层是一个面向用户的应用程序，导出一个服务API，主要由特定于应用程序的功能组成，尽管管理员操作（如频道和链码操作）也可能暴露给系统管理员。通常，提供用户界面以便使用，尽管如果用户是软件代理，一个明确定义的API可能就足够了。我们简单地称这一层为应用程序，因为这是最终用户（或代理）将看到的内容。此外，考虑到任何区块链应用程序和网络都是多样参与者的聚合体，这一层通常将由为不同参与者量身定制的多个应用程序堆栈组成。
- en: This architecture should not be set in stone; it is meant to serve purely as
    a guideline for developers. Depending on the complexity of the application, both
    the number of layers and the verticals (or distinct applications) may vary. For
    a very simple application that has a small number of capabilities, the developer
    may even choose to compress the middleware and application layers into one. More
    generally though, this decoupling enables different sets of capabilities to be
    exposed to different network participants. For example, in our trade use case,
    a regulator and an exporter would view the blockchain in different ways and have
    diverging needs, and therefore it would be useful to build distinct service sets
    for them rather than force-fit all capabilities into one monolithic application
    with a uniform interface. Yet both these applications ought to hide the complexities
    of network operations, such as the creation and joining of channels, or privileged
    operations such as the installation of chaincode onto peers in similar ways, which
    would therefore benefit from a common middleware layer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构不应该被定死；它的目的纯粹是为开发人员提供一个指导方针。根据应用程序的复杂性，层的数量和垂直方面（或不同的应用程序）可能会有所不同。对于一个非常简单的应用程序，具有少量功能的开发人员甚至可以选择将中间件和应用程序层压缩到一起。然而更普遍的是，这种解耦使不同的能力集可以暴露给不同的网络参与者。例如，在我们的交易用例中，监管机构和出口商会以不同的方式查看区块链并有不同的需求，因此建立为它们构建不同服务集比强行将所有功能适配成一个单片应用程序并具有统一界面更有用。但是这两个应用程序都应该隐藏网络操作的复杂性，比如频道的创建和加入，或特权操作，例如将链码安装到对等体上，这样从一个共同的中间件层中可以受益。
- en: The ways in which the application layers the users directly interact with can
    be designed present many choices and complexities, and we will delve into those
    in the latter part of this chapter. First, though, we will describe how to implement
    the guts of a Fabric application, focusing on the essential elements. For instructive
    purposes, our topmost layer will be a simple web server exposing a *RESTful* service
    API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用户直接互动的应用程序层可以设计出许多选择和复杂性，我们将在本章的后半部分深入探讨这些内容。不过，首先，我们将描述如何实现Fabric应用程序的关键部分，重点放在基本要素上。出于指导目的，我们的最顶层将是一个简单的Web服务器，提供*RESTful*服务API。
- en: The thinking behind this architecture and the principles driving it are independent
    of the underlying blockchain technology. To implement an identical application
    on a different blockchain platform than Hyperledger Fabric, only the smart contract
    and some parts of the middleware have to be reimplemented. The rest of the application
    can remain untouched with the end user not noticing any difference.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构背后的思想和推动它的原则独立于基础的区块链技术。要在与Hyperledger Fabric不同的区块链平台上实现相同的应用程序，只需重新实现智能合约和一些中间件的部分。应用程序的其余部分可以保持不变，最终用户不会注意到任何差异。
- en: Building the application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: Now that we have understood not just the methodology of designing a layered
    Fabric application but also the philosophy behind it, we can dive into the implementation.
    In the previous two chapters, we discussed how to implement and test the lowest
    layer, or the chaincode. Therfore, we can assume that the reader is now ready
    to add the middleware and application layers, which is what we will demonstrate
    in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不仅了解了设计分层Fabric应用程序的方法，还了解了其背后的哲学，我们可以深入实施了。在前两章中，我们讨论了如何实现和测试最底层，或者说链代码。因此，我们可以假设读者现在已经准备好添加中间件和应用层，这正是我们将在以下章节中演示的内容。
- en: A prerequisite for the testing of middleware and application code is a running
    network. Before proceeding to the next section, please ensure that the sample
    four-organization network we configured and launched in the *Setting up the development
    environment section* in [*Chapter 3*](5a4b5cba-356c-4997-b816-0676a2c503c2.xhtml),
    *Setting the stage with a business scenario*, is still up and running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中间件和应用程序代码的先决条件是运行网络。在继续下一节之前，请确保我们在*第3章*中配置和启动的示例四组织网络仍在运行中。
- en: Middleware – wrapping and driving the chaincode
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件 - 封装和驱动链代码
- en: 'The following diagram maps the transaction stages discussed in the <q>Application
    and Transaction Stages</q> section and illustrated in *Figure 5.1: The stages
    in the creation and operation of a blockchain application,* to Fabric terms and
    using Fabric terminology:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了在《应用与交易阶段》部分讨论的交易阶段，并在*图5.1：区块链应用创建和运行阶段*中加以说明，以Fabric术语和使用Fabric术语来表示：
- en: '![](img/3111cf77-037e-44bd-b5fd-8f6b70d31d27.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3111cf77-037e-44bd-b5fd-8f6b70d31d27.png)'
- en: 'Figure 5.3: The stages in the creation and operation of a blockchain application'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：区块链应用创建和运行阶段
- en: 'Fabric peers, orderers, and CAs (or MSPs) communicate using gRPC ([https://grpc.io/](https://grpc.io/)),
    as well as the process spawned by the peer to run the chaincode (the process is
    really a Docker container). This process exports a service endpoint implementing
    the JSON RPC 2.0 specification ([http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification))
    for channel and chaincode operations. We can write a wrapper application that
    communicates directly with chaincode using the service specification, but then
    we would have to write logic to parse and interpret the payload as well. With
    the Fabric platform and its specification likely to change in the future, this
    is not necessarily the best and most maintainable way to write an application,
    especially for production purposes. Fortunately, Hyperledger Fabric provides the
    means to run chaincode operations while hiding the details of the interface specifications
    and the communication protocol, in two different ways:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric对等方、排序器和CA（或MSP）使用gRPC（[https://grpc.io/](https://grpc.io/)）进行通信，以及由对等方生成的用于运行链代码的进程（该进程实际上是一个Docker容器）。该进程导出一个实现JSON
    RPC 2.0规范（[http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification)）的服务端点，用于通道和链代码操作。我们可以编写一个直接使用服务规范与链代码通信的包装应用程序，但然后我们将不得不编写逻辑来解析和解释负载。由于Fabric平台及其规范可能会在未来发生变化，因此这不一定是编写应用程序的最佳和最可维护的方式，特别是对于生产目的而言。幸运的是，Hyperledger
    Fabric提供了两种不同的方式来运行链代码操作，同时隐藏接口规范和通信协议的细节：
- en: '**Command-Line Interface** (**CLI**): Fabric provides commands that can be
    run from a Terminal to perform the various operations indicated in *Figure 5.3: The
    stages in the creation and operation of a blockchain application*. The tool to
    run these commands is `peer`, which is generated upon downloading the Fabric source
    code and building it (using `make`, or just `make peer`). Different switches can
    be used with this command to perform different channel and chaincode operations,
    and you will see some examples in this section.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行界面**（**CLI**）：Fabric提供了可以从终端运行的命令，用于执行*图5.3：区块链应用创建和运行阶段*中指示的各种操作。运行这些命令的工具是`peer`，它在下载Fabric源代码并构建它（使用`make`或只是`make
    peer`）时生成。可以使用不同的开关与此命令一起使用以执行不同的通道和链代码操作，在本节中您将看到一些示例。'
- en: '**Software Development Kit** (**SDK**): Hyperledger provides a toolkit and
    set of libraries for the easy development of applications to wrap the channel
    and chaincode operations in multiple languages, such as Node.js, Java, Go, and
    Python. These SDKs also provide functions to interact with MSPs, or instances
    of the Fabric CA.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件开发工具包**（**SDK**）：Hyperledger提供了一个工具包和一组库，用于轻松开发多种语言（如Node.js、Java、Go和Python）的应用程序，以包装通道和链码操作。这些SDK还提供了与MSPs或Fabric
    CA实例进行交互的功能。'
- en: Although CLI tools can be used for testing and demonstration purposes, they
    are inadequate for application development. The SDK libraries, in addition to
    the functions mentioned previously, provide the ability to subscribe to events
    emanating from the network, communicating information about state changes that
    are needed to drive the application logic. We will use the Node.js SDK to demonstrate
    how to build both our middleware and the higher-layer application. It is left
    to the reader to build equivalent applications in other languages of their choice
    using one of the other SDKs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CLI工具可用于测试和演示目的，但它们不足以用于应用程序开发。SDK库除了前面提到的功能外，还提供了订阅来自网络的事件的能力，传达关于需要驱动应用程序逻辑的状态变化的信息。我们将使用Node.js
    SDK演示如何构建我们的中间件和更高层次的应用程序。读者可以使用其他SDK之一来构建自己选择的其他语言中的等效应用程序。
- en: Installation of tools and dependencies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具和依赖项的安装
- en: The functions that we will show how to build as part of our middleware can be
    found in the middleware folder in the code repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何在我们的中间件中构建的函数可以在代码库的中间件文件夹中找到。
- en: Prerequisites for creating and running the middleware
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行中间件的先决条件
- en: 'The reader is expected to be familiar with Node.js/JavaScript programming (especially
    the `Promise` pattern) and with the usage of the Node.js and `npm` tools:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读者应该熟悉Node.js/JavaScript编程（尤其是`Promise`模式）以及Node.js和`npm`工具的用法：
- en: Install Node.js ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
    and `npm` ([https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm)).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Node.js ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
    和 `npm` ([https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm))。
- en: 'Install the `fabric-client` and `fabric-ca-client npm` libraries:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `fabric-client` 和 `fabric-ca-client npm` 库：
- en: 'You can install these packages from the `npm` registry, either manually by
    running `npm install <package-name>` or by setting the names and versions in your
    `package.json` file. As an example, the `package.json` in the middleware folder
    contains the following entries in the dependencies section:'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从`npm`注册表中安装这些包，可以手动运行 `npm install <package-name>` 或者通过在 `package.json`
    文件中设置名称和版本。例如，中间件文件夹中的 `package.json` 在依赖项部分包含以下条目：
- en: '`fabric-ca-client`: ^1.1.0'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fabric-ca-client`: ^1.1.0'
- en: '`fabric-client`: ^1.1.0'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fabric-client`: ^1.1.0'
- en: 'This instructs `npm` to install versions 1.1.0 of both of these packages:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉`npm`安装这两个包的1.1.0版本：
- en: 'Alternatively, you can clone the Fabric SDK node ([https://github.com/hyperledger/fabric-sdk-node/](https://github.com/hyperledger/fabric-sdk-node/))
    source code repository and import the two libraries locally as follows:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以克隆 Fabric SDK node ([https://github.com/hyperledger/fabric-sdk-node/](https://github.com/hyperledger/fabric-sdk-node/))
    源代码库，并按如下方式本地导入这两个库：
- en: Run `npm` install in the `fabric-client` and `fabric-ca-client` folders
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 `fabric-client` 和 `fabric-ca-client` 文件夹中运行 `npm install` '
- en: Install these packages as dependencies, either manually by specifying the path
    to the preceding folders in middleware/`package.json`, or by using the `npm` link
    command to add symbolic links to the packages in middleware/`node_modules`
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装这些包作为依赖项，可以手动在中间件/`package.json`文件中指定路径，也可以使用`npm`链接命令将符号链接添加到中间件/`node_modules`中的包中
- en: In the following sections, we will use the `fabric-client` library to perform
    channel and chaincode operations involving the peer and the orderer, and the `fabric-ca-client`
    library to perform user registration and enrolment operations involving the CA
    (or MSP).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用 `fabric-client` 库执行涉及对等体和订购者的通道和链码操作，以及 `fabric-ca-client` 库执行涉及CA（或MSP）的用户注册和注册操作。
- en: Installation of dependencies
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项的安装
- en: Run `npm` install in the middleware folder to install the packages (libraries)
    specified in the `package.json` and their dependencies. You should see the packages
    downloaded to the `node_modules` folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件文件夹中运行 `npm install` 来安装 `package.json` 中指定的包（库及其依赖项）。您应该会看到这些包下载到 `node_modules`
    文件夹中。
- en: A cleaner way of installing dependencies and configuring the middleware for
    regular operation is automated building using `Makefile`. You can simply run `make`
    in the `middleware` folder; see [*Chapter 8*](112a5075-378d-4bb0-9b9e-db81c18a35f5.xhtml),
    *Agility In A Blockchain Network*, for more details on setting up and building
    your development and testing environment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项和配置中间件以进行常规操作的更干净的方法是使用 `Makefile` 进行自动构建。您只需在 `middleware` 文件夹中运行 `make`；有关设置和构建您的开发和测试环境的更多详细信息，请参阅
    [*第 8 章*](112a5075-378d-4bb0-9b9e-db81c18a35f5.xhtml) *区块链网络中的灵活性*。
- en: Creating and running the middleware
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行中间件
- en: We will now write functions to execute and orchestrate the stages illustrated
    in *Figure 5.3: The stages in the creation and operation of a blockchain application*.
    But first, we will give an overview of the various configuration parameters that
    must be set for the application to work as intended
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写函数来执行和编排图 5.3 中所示的阶段：*区块链应用程序的创建和操作中的各个阶段*。但首先，我们将概述必须设置的各种配置参数，以使应用程序按预期工作。
- en: Network configuration
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络配置
- en: 'The first step in writing middleware is collecting all the configuration information
    necessary to identify and connect to the various elements of the network we created
    and launched in the previous section. It is useful, especially when writing code
    in JavaScript, to express such configurations in JSON format. In our sample code,
    the `config.json` file serves this purpose. This file contains the description
    of a network, whose attributes are contained in the trade-network object. Each
    property of this object describes the configuration of each unique organization
    that is part of the network, except for a property called the orderer, which simply
    refers to the orderer node. (Note: this is sufficient for our simple network containing
    just one orderer node.) Let''s examine what must be specified in each organization''s
    description by taking the `Exporterorg` property as an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编写中间件的第一步是收集所有必要的配置信息，以识别并连接到我们在上一节中创建和启动的网络的各个元素。在 JavaScript 中编写代码时，将这些配置表示为
    JSON 格式是很有用的。在我们的示例代码中，`config.json` 文件用于此目的。此文件包含一个网络的描述，其属性包含在 trade-network
    对象中。此对象的每个属性描述了网络中每个唯一组织的配置，除了一个称为 orderer 的属性，它只是指向订购者节点。（注意：这对于我们的简单网络足够了，只包含一个订购者节点。）让我们通过以
    `Exporterorg` 属性为例来检查每个组织描述中必须指定的内容：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mspid` value must match the one specified in `network/configtx.yaml` for
    our middleware to be compatible with the channel artefacts and cryptographic material
    created for the network. The name and port information for the CA must match what
    was specified in `network/docker-compose-e2e.yaml`. Since we have just one peer
    in each organization, we name it peer for convenience, though one can easily define
    a different schema for a multi-peer organization setup. Note that the peer exports
    services for peer requests as well as for event subscriptions, and the ports match
    those exposed in `network/base/docker-compose-base.yaml`. The `server-hostname`
    must also match that specified in both `configtx.yaml` and the docker-compose
    configurations. As our network elements connect using TLS, the path to the peer's
    TLS certificate must also be specified here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mspid` 值必须与在 `network/configtx.yaml` 中指定的值相匹配，以使我们的中间件与为网络创建的通道工件和加密材料兼容。
    CA 的名称和端口信息必须与在 `network/docker-compose-e2e.yaml` 中指定的内容相匹配。由于每个组织只有一个对等体，我们为方便起见将其命名为对等体，尽管可以轻松地为多对等体组织设置定义不同的模式。请注意，对等体导出对等体请求和事件订阅的服务，端口与
    `network/base/docker-compose-base.yaml` 中公开的端口相匹配。`server-hostname` 也必须与 `configtx.yaml`
    和 docker-compose 配置中指定的内容相匹配。由于我们的网络元素使用 TLS 连接，因此还必须在此指定对等体的 TLS 证书路径。'
- en: Lastly, if you compare the preceding schema snippet with the configurations
    of the other organizations, you will notice that the ports listed exactly matches
    those exposed in the docker-compose configurations. For example, the peers in
    the exporter, importer, carrier, and regulator organizations listen for requests
    on ports `7051`, `8051`, `9051`, and `10051`, respectively. The hostnames in the
    URLs simply refer to localhost, as that is where all our network element's containers
    are running.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您将前面的模式片段与其他组织的配置进行比较，您将注意到列出的端口与 docker-compose 配置中公开的端口完全匹配。例如，出口商、进口商、承运商和监管机构组织中的对等体分别在端口
    `7051`、`8051`、`9051` 和 `10051` 上监听请求。 URL 中的主机名仅指向 localhost，因为这是我们所有网络元素容器运行的地方。
- en: Endorsement policy
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持政策
- en: 'The next step is to frame an endorsement policy for our chaincode that will
    be committed to the ledger during the instantiation. This endorsement policy dictates
    how many peers, belonging to what roles and organizations, need to endorse a ledger
    commitment transaction (or invocation). In the sample code, different endorsement
    policies are listed in `constants.js`, which contains various settings and keywords
    used by our middleware. The one that we will employ is `ALL_FOUR_ORG_MEMBERS`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的链码制定一个认可策略，该策略将在实例化期间提交到分类帐。该认可策略规定了需要多少个角色和组织的对等方认可分类帐承诺事务（或调用）。在示例代码中，`constants.js`列出了不同的认可策略，其中包含我们中间件使用的各种设置和关键字。我们将使用的是`ALL_FOUR_ORG_MEMBERS`：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The list of principals is specified in the identities attribute of the policy
    and refers to member (or ordinary) users of the four peer organizations, as well
    as administrator users of the orderer organization. The policy attribute here
    states that an endorsement is required from a member of each of the four peer
    organizations; in all, four signatures will be required.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主体列表在策略的identities属性中指定，并且引用了四个对等组织的成员（或普通）用户，以及订购者组织的管理员用户。此处的策略属性声明，需要从每个四个对等组织的成员那里获得认可；总共需要四个签名。
- en: The variable `TRANSACTION_ENDORSEMENT_POLICY` is set to `ALL_FOUR_ORG_MEMBERS`
    in `constants.js` by default, and will be used to configure the channel endorsement
    policy later in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constants.js`中，变量`TRANSACTION_ENDORSEMENT_POLICY`默认设置为`ALL_FOUR_ORG_MEMBERS`，将在本节后面用于配置通道认可策略。
- en: User records
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户记录
- en: 'For both the channel world state and the user keys and certificates for the
    respective organizations, we will use a file-based store, as specified in `clientUtils.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通道状态和各自组织的用户密钥和证书，我们将使用基于文件的存储，如`clientUtils.js`中所指定的那样：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `constants.js`, `tempdir` is initialized as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constants.js`中，`tempdir`被初始化如下：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can also set the storage location to lie in the temporary
    folder designated by your operating system using the `os.tmpdir()` function; you
    will just need to create a subfolder there(say `<folder-name>`.) On a typical
    Linux, system, this storage location will default to `/tmp/<folder-name>/`, and
    folders will be created there for each organization. As we run the various operations,
    we will see these folders getting generated and files getting added to them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您还可以使用`os.tmpdir()`函数将存储位置设置为位于操作系统临时文件夹中的子文件夹（比如`<folder-name>`）。在典型的Linux系统上，此存储位置将默认为`/tmp/<folder-name>/`，并且将在那里为每个组织创建文件夹。在我们运行各种操作时，我们会看到这些文件夹被生成，并且文件被添加到其中。
- en: Client registration and enrollment
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端注册和注册
- en: 'Although cryptographic material for organization users can be created statically
    using the cryptogen tool, we must build capabilities in the middleware to dynamically
    create user identities and credentials, and enable those users to sign in to the
    network to submit transactions and query the ledger state. These operations require
    the mediation of users with privileged access (or administrators), who must be
    created when `fabric-ca-server` is started. By default, an administrative user
    is given the ID admin and the password `adminpw`, which is what we will use for
    our exercise in this section. The network that we created and launched uses these
    defaults, and it is left to the reader to modify them in `fabric-ca-server` and
    start commands in `network/docker-compose-e2e.yaml` (the following is from the
    `exporter-ca` section):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用`cryptogen`工具静态创建组织用户的加密材料，但是我们必须在中间件中构建能力，动态创建用户身份和凭证，并使这些用户登录到网络以提交交易和查询分类帐状态。这些操作需要特权访问的用户（或管理员）的介入，在`fabric-ca-server`启动时必须创建他们。默认情况下，管理用户被赋予ID`admin`和密码`adminpw`，这是我们在本节练习中将要使用的。我们创建和启动的网络使用这些默认值，读者可以在`fabric-ca-server`和`network/docker-compose-e2e.yaml`的开始命令中进行修改（以下是`exporter-ca`部分的内容）。
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The steps to create a user through an administrator are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管理员创建用户的步骤如下：
- en: Load administrative user credentials from the local storage
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本地存储加载管理员用户凭据
- en: If thee credentials don't exist, enroll, or sign in, the administrator to the
    Fabric CA server and obtain their credentials (private key and enrollment certificate)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果凭据不存在，则管理员需要注册或登录到Fabric CA服务器，并获取他们的凭据（私钥和注册证书）
- en: Have the administrative user register another user with a given ID, specifying
    roles and affiliations, with the Fabric CA server
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由管理用户注册另一个具有给定ID的用户，并指定角色和affiliations与Fabric CA服务器
- en: Using a secret returned upon registration, enroll the new user and obtain credentials
    for that user
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注册时返回的秘钥，enroll新用户并获得该用户的凭据
- en: Save the credentials to the local storage
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将凭据保存到本地存储
- en: 'Sample code for this can be found in `clientUtils.js`, with the following code
    snippets mostly being from the `getUserMember` function, which takes administrator
    credentials, the name of the organization to which the user must be enrolled,
    and the name/ID of the user to enroll. A handle to a client (an instance of `fabric-client`,
    or a client object ([https://fabric-sdk-node.github.io/Client.html](https://fabric-sdk-node.github.io/Client.html))
    must also be passed to the function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`clientUtils.js`中找到相关示例代码，以下代码片段大多来自`getUserMember`函数，该函数使用管理员凭据，需要用户必须enrolled的组织名称/ID。还需要传递一个客户端的handle（`fabric-client`的实例，或一个客户端对象）给该函数：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code associates the client handle with the local store, partitioned
    by organization, to store the credentials of  the administrator and other users
    created on the fly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将客户端句柄与本地存储（按组织进行分区）关联，以存储管理员和临时创建的其他用户的凭据：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code ensures that the administrator user handle will be associated with
    our store:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码确保管理员用户句柄将与我们的存储关联：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use the `fabric-ca-client` library to connect to the `fabric-ca-server`
    instance associated with a given organization (whose URL can be obtained from
    our `config.json`; for example, the `caUrl` for the exporter organization will
    be `https://localhost:7054`). The enroll function allows the administrator to
    log in with the MSP, and obtain the enrollment key and certificate.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`fabric-ca-client`库连接到与给定组织关联的`fabric-ca-server`实例（其URL可以从我们的`config.json`获得；例如，出口商组织的`caUrl`将是`https://localhost:7054`）。enroll函数允许管理员使用MSP登录，并获取enrollment密钥和证书。
- en: 'Now that we have a handle to the administrator user in the form of the member
    object, we can use it to enroll a new user with the user ID, which is represented
    by their username, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获取了管理员用户的句柄，形式上是member对象，我们可以使用它来为用户ID（用户名表示）enroll一个新用户，如下所示：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: During registration, we can specify what the user's roles will be, which in
    the preceding code is client, allowing the username to submit invocations and
    queries to the chaincode. The affiliation specified here is one of the subdivisions
    within an organization that are specified in a Fabric CA server's configuration
    ([http://hyperledger-fabric-ca.readthedocs.io/en/latest/serverconfig.html](http://hyperledger-fabric-ca.readthedocs.io/en/latest/serverconfig.html))
    (updating this configuration is left as an exercise to the reader; here, we will
    use the default affiliation). Using the returned secret, the username is now enrolled
    with the server, and its key and enrollment certificate are saved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册过程中，我们可以指定用户的角色，上面的代码中是客户端，允许用户名提交调用和查询到链码。此处指定的affiliation是组织内的一个细分，它在Fabric
    CA服务器的配置中指定（[http://hyperledger-fabric-ca.readthedocs.io/en/latest/serverconfig.html](http://hyperledger-fabric-ca.readthedocs.io/en/latest/serverconfig.html)）（更新此配置留给读者作为练习；在这里，我们将使用默认的affiliation）。使用返回的秘钥，用户名现在已经与服务器enrolled，并且其密钥和enrollment证书被保存。
- en: The call to `client.setUserContext` associates this user with the client handle,
    and `client.saveUserToStateStore` saves the user's credentials to our local store
    on the file system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`client.setUserContext`将该用户与客户端句柄关联，`client.saveUserToStateStore`将用户的凭据保存到我们在文件系统上的本地存储。
- en: Similar functions to get handles to administrator users are `getAdmin` and `getMember`,
    also defined in `clientUtils.js`. The former retrieves an administrator user whose
    credentials were created using `cryptogen`, whereas the latter creates a new `admin`
    member dynamically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与获取管理员用户句柄相似的函数还有`getAdmin`和`getMember`，也在`clientUtils.js`中定义。前者检索使用`cryptogen`创建的管理员用户凭据，而后者动态创建一个新的`admin`
    member。
- en: Creating a channel
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个通道
- en: 'To create our trade channel, we first need to instantiate a `fabric-client`
    instance and a handle to the orderer using the configuration in `config.json`
    (see the `createChannel` function in `create-channel.js`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的交易通道，我们首先需要实例化一个`fabric-client`实例，并使用`config.json`中的配置获得一个到orderer的handle（参见`create-channel.js`中的`createChannel`函数）：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use a file-based key-value store to save the ledger world state as follows
    (it is left as an exercise to the reader to try out other types of store, such
    as `CouchDB`, using `CouchDBKeyValueStore.js`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于文件的键值存储来保存分类帐的世界状态，如下所示（读者可以尝试其他类型的存储，比如使用 `CouchDB`，使用 `CouchDBKeyValueStore.js`）：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we must enroll an administrator user for the orderer (using the mechanisms
    discussed in the previous segment). After a successful enrollment, the channel
    configuration that we created using the `configtxgen` tool (see `network/channel-artifacts/channel.tx`)
    must be extracted. The path to this configuration file is set in `constants.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为订购者注册一个管理员用户（使用前一部分讨论的机制）。成功注册后，必须提取使用 `configtxgen` 工具创建的通道配置（参见 `network/channel-artifacts/channel.tx`）。此配置文件的路径在
    `constants.js` 中设置：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now need to enroll an administrator user for each of our four organizations.
    Each of these four admins, as well as the orderer admin, must sign the channel
    configuration, and the signatures collected as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的四个组织中的每个管理员用户注册。这四个管理员以及订购者管理员必须对通道配置进行签名，签名如下收集：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `getSubmitter` function is defined in `clientUtils.js`, and is an indirect
    way of associating a member (either ordinary or administrator) of a given organization
    with the client object. In other words, it associates the client object with the
    *signing identity* (credentials and MSP identifications) of a user. Underneath,
    `getSubmitter` uses the functions `getAdmin`, `getUserMember`, and `getMember`,
    which we described in an earlier section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSubmitter` 函数定义在 `clientUtils.js` 中，它是将给定组织的成员（普通成员或管理员）与客户端对象关联的间接方式。换句话说，它将客户端对象与用户的*签名身份*（凭证和
    MSP 标识）关联起来。在底层，`getSubmitter` 使用了我们在前面章节中描述的 `getAdmin`、`getUserMember` 和 `getMember`
    函数。'
- en: '`getOrderAdminSubmitter` is analogous to `getSubmitter` and returns a handle
    to an `admin` user of the orderer’s organization.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrderAdminSubmitter` 类似于 `getSubmitter`，返回一个与订购者组织的 `admin` 用户关联的句柄。'
- en: 'Finally, we are ready to build a channel creation request and submit it to
    the orderer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备构建一个通道创建请求，并将其提交给订购者：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The actual creation of the channel may take a few seconds, so the application
    logic should wait for a while before returning a successful result. The `channel_name`
    parameter is set in `clientUtils.js` to `tradechannel`, which is what we set it
    to when we launched our network (see `network/trade.sh`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际创建通道可能需要几秒钟，因此应用逻辑在返回成功结果之前应该等待一段时间。`channel_name` 参数在 `clientUtils.js` 中设置为
    `tradechannel`，这是我们启动网络时设置的（参见 `network/trade.sh`）。
- en: The channel creation step involves initializing the blockchain with the genesis
    block we created earlier in this chapter using `configtxgen`. The genesis block
    is just the first *configuration block* that is appended to the chain. A configuration
    block consists a specification of the channel and the organizations that are part
    of it, among other things; such a block contains no chaincode transactions. We
    will deal with configuration blocks again in [*Chapter 9*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml),
    *Life in a Blockchain Network*, when we discuss how to augment networks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通道创建步骤涉及使用 `configtxgen` 在本章早些时候创建的创世块来初始化区块链。创世块只是追加到链上的第一个*配置块*。配置块包含对通道的规范以及其中所包含的组织等内容；这样的块不包含链码交易。在[*第
    9 章*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml)，*区块链网络中的生活*中，我们将再次处理配置块，讨论如何扩展网络。
- en: 'Now, all we need to do to create a channel is call the `createChannel(''tradechannel'')` function
    and wait for the result. This is the first step in our test code, `createTradeApp.js`,
    which executes the basic sequence of operations illustrated in *Figure 5.3: The
    stages in the creation and operation of a blockchain application*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个通道所需做的就是调用 `createChannel('tradechannel')` 函数并等待结果。这是我们测试代码 `createTradeApp.js`
    的第一步，它执行了*图 5.3：区块链应用创建和操作阶段*中所示的基本操作序列：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code we use to associate different signing identities with a common client
    object, and then sign a channel configuration, all in a single process, is purely
    for demonstrative purposes. In a real-life production application, the signing
    identities of different users belonging to different organizations are private
    and must be guarded; hence there is no question of pooling them together in a
    common location. Instead, the channel configuration must be signed independently
    by different organizations’ administrators and passed around using some out-of-band
    mechanism to accumulate the signatures (and also verify them.) Similar mechanisms
    must be employed when a configuration is updated (see [*Chapter 9*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml), *Life
    in a Blockchain Network*) Independent, decentralized procedures must also be followed
    for channel joining and chaincode installation, though we demonstrate the basic
    mechanisms using centralized processes for convenience.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于将不同签名标识与一个通用客户端对象关联起来，然后在单个过程中对频道配置进行签名的代码纯粹是为了演示目的。在实际生产应用中，属于不同组织的不同用户的签名标识是私有的，并且必须受到保护；因此，没有将它们汇集到一个共同位置的问题。相反，频道配置必须由不同组织的管理员独立签名，并使用某种带外机制传递以累积签名（并验证签名）。在更新配置时也必须使用类似的机制（见[*第9章*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml)，*区块链网络中的生活*）。加入通道和安装链码时也必须遵循独立的、去中心化的程序，尽管我们为了方便演示使用了集中式过程来展示基本机制。
- en: Joining a channel
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入通道
- en: 'Now that `tradechannel` has been created, our four peers, one in each organization,
    must be joined to the channel, a step that initializes the ledger on each node
    and prepares the peer to run chaincode and transactions on it. For this, we will
    need to reuse the client handle created in the previous step or instantiate one
    using a similar sequence of operations. In addition, we must instantiate a handle
    to the channel, register the orderer, and obtain the genesis block (implicitly
    sent to the orderer in the creation step using the channel configuration), as
    indicated by the following code snippets from the `joinChannel` function in `join-channel.js`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `tradechannel` 已经创建，我们的四个对等方，每个组织一个，必须加入通道，这一步骤在每个节点上初始化分类帐，并准备对等方在其上运行链码和交易。为此，我们需要重用在前一步骤中创建的客户端句柄，或者使用类似操作序列实例化一个。此外，我们必须实例化一个通道句柄，注册订购方，并获取创世块（在使用通道配置在创建步骤中隐式发送到订购方），如
    `join-channel.js` 中 `joinChannel` 函数中的以下代码片段所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The transaction ID argument is optional in the preceding `getGenesisBlock`
    call. Now, for each organization, we must obtain a handle to an administrator
    user who will then submit a channel joining request for the peer belonging to
    that organization:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的 `getGenesisBlock` 调用中，交易 ID 参数是可选的。现在，对于每个组织，我们必须获取一个管理员用户的句柄，然后为属于该组织的对等方提交通道加入请求：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As in the channel creation process, the `getSubmitter` function associates the
    signing identity of an administrator of a particular organization with the client
    object before submitting the channel join request. This request contains the genesis
    block as well as the configuration of every peer in that organization (loaded
    from the attributes containing the `peer` prefix within each organization in `config.json`,
    as you can see in the above code.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与通道创建过程一样，`getSubmitter` 函数在提交通道加入请求之前将特定组织的管理员的签名标识与客户端对象关联起来。此请求包含创世块以及该组织中每个对等方的配置（从
    `config.json` 中每个组织中包含 `peer` 前缀的属性中加载，如上面的代码所示）。
- en: 'A generous wait time of 40 seconds is indicated above as this process can take
    a while to complete. This join process needs to be executed independently by an
    administrator in each organization; hence, the function `joinChannel(<org-name>)`
    is called 4 times in sequence the main function `processJoinChannel`, which is
    called in our test script in `createTradeApp.js` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，给出了宽裕的等待时间，因为此过程可能需要一段时间才能完成。这个加入过程需要由每个组织的管理员独立执行；因此，在我们的测试脚本 `createTradeApp.js`
    中，`processJoinChannel` 主函数依次调用了 4 次 `joinChannel(<org-name>)` 函数：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In a typical production network, each organization will independently run the
    join process, but only for its peers. The orchestration code (`processJoinChannel`
    in `join-channel.js`) that we use in our repository is meant for convenience and
    testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的生产网络中，每个组织将独立运行加入过程，但仅针对其对等方。我们在存储库中使用的编排代码（`join-channel.js` 中的 `processJoinChannel`）旨在方便和测试。
- en: Installation of chaincode
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码的安装
- en: 'Installation of chaincode results in the copying of source code to the peers
    we have selected to be endorsers, and every installation is associated with a
    user-defined version. The main function `installChaincode` is implemented in `install-chaincode.js`.
    This function in turn calls the `installChaincodeInOrgPeers` function for each
    of the 4 organizations in sequence; the latter function installs chaincode on
    the peers of a given organization. As in the case of a channel join, we create
    both client and channel handles for a given organization, enroll an administrator
    user for that organization, and associate that user with the client handle. This
    next step is to create an installation proposal and submit it to the orderer as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 链码的安装导致将源代码复制到我们选择作为背书人的对等方，并且每个安装都与用户定义的版本相关联。主要函数`installChaincode`在`install-chaincode.js`中实现。该函数依次为每个组织调用`installChaincodeInOrgPeers`函数；后者在给定组织的对等体上安装链码。与频道加入一样，在给定组织创建客户端和频道句柄，为该组织的管理员用户注册，并将该用户与客户端句柄关联。下一步是创建安装建议并将其提交给订购者，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The targets refer to the configurations of the endorsing peers in the organization,
    and are loaded from `config.json`. `chaincodeId` and `chaincodeVersion` can be
    set by the caller (and defaults are set in `constants.js` as `tradecc` and `v0`,
    respectively), but the `chaincodePath` must refer to a location that contains
    the source code. In our scenario, the location refers to a path on the local file
    system: `github.com/trade_workflow`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目标指的是组织中认可的对等体的配置，从`config.json`加载。`chaincodeId`和`chaincodeVersion`可以由调用者设置（默认值在`constants.js`中分别设置为`tradecc`和`v0`），但`chaincodePath`必须指向包含源代码的位置。在我们的场景中，该位置指的是本地文件系统上的路径：`github.com/trade_workflow`。
- en: Internally in the SDK, the installation request packages the chaincode’s source
    code into a prescribed format called `ChaincodeDeploymentSpec` (CDS)([https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/chaincode.proto](https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/chaincode.proto)).
    This package is then signed (by the organization administrator associated with
    the client object) to create a `SignedChaincodeDeploymentSpec`([https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/signed_cc_dep_spec.proto](https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/signed_cc_dep_spec.proto)),
    which is then sent to the *lifecycle system chaincode* (LSCC) for installation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在SDK内部，安装请求将链码的源代码打包到一种称为`ChaincodeDeploymentSpec`（CDS）的规定格式中（[https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/chaincode.proto](https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/chaincode.proto)）。然后对该包进行签名（由与客户端对象关联的组织管理员签名），以创建`SignedChaincodeDeploymentSpec`（[https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/signed_cc_dep_spec.proto](https://github.com/hyperledger/fabric/blob/release-1.1/protos/peer/signed_cc_dep_spec.proto)），然后将其发送到*生命周期系统链码*（LSCC）进行安装。
- en: The above procedure describes the *simple* case where each instance of a Signed
    CDS has only the signature of the identity associated with the client that issues
    the installation request. A more *complex* scenario is supported by Fabric whereby
    a CDS can be passed (out-of-band) to different clients (of the various organizations)
    and signed by each before the installation requests are received. The reader is
    encouraged to try out this variation using the available API functions and Fabric
    data structures([http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html](http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程描述了每个Signed CDS实例仅具有签发安装请求的客户端相关联的标识的签名的*简单*情况。Fabric支持更*复杂*的场景，其中CDS可以（在带外）传递给不同组织的不同客户端，并在收到安装请求之前由每个客户端签名。鼓励读者使用可用的API函数和Fabric数据结构尝试此变体（[http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html](http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html)）。
- en: 'The success of an installation request is determined by checking the proposal
    response from each target peer as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 安装请求的成功取决于检查每个目标对等体的建议响应，如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, to orchestrate the installation on the entire network, we call the
    `installChaincode` function defined in `install-chaincode.js`. For the `fabric-client`
    to know where to load the `chaincode` source from, we temporarily set the `GOPATH`
    in the process to point to the right location in our project, which is the `chaincode`
    folder:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在整个网络上进行安装协调，我们调用了`install-chaincode.js`中定义的`installChaincode`函数。为了让`fabric-client`知道从哪里加载`chaincode`源代码，我们暂时将进程中的`GOPATH`设置为指向我们项目中的正确位置，即`chaincode`文件夹：
- en: This only works for `chaincode` written in Go
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅适用于用Go编写的`chaincode`
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For a successful installation, the `chaincode` folder must contain a subfolder
    named `src`, within which the `chaincode` path sent in the installation proposal
    must point to the actual code. As you can see, this finally resolves to `chaincode/src/github.com/trade_workflow`
    in our code repository, which indeed contains the source code we developed in
    *[Chapter 4](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)*, *Designing a Data and
    Transaction Model with Golang*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功安装，`chaincode` 文件夹必须包含一个名为`src`的子文件夹，在其中，安装提案中发送的`chaincode`路径必须指向实际代码。正如你所看到的，这最终解析为我们代码库中的`chaincode/src/github.com/trade_workflow`，其中确实包含了我们在*[第四章](a557efde-d161-4451-b5ee-cb3e481010be.xhtml)*中开发的源代码，*使用Golang设计数据和事务模型*。
- en: 'In our `createTradeApp.js` script, we can now simply call:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`createTradeApp.js`脚本中，我们现在可以简单地调用：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a typical production network, each organization will independently run the
    installation process (defined in the `installChaincodeInOrgPeers` function), but
    only for its endorsing peers. The orchestration code (`installChaincode` in `install-chaincode.js`)
    that we use in our repository is meant for convenience and testing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的生产网络中，每个组织将独立运行安装过程（在`installChaincodeInOrgPeers`函数中定义），但仅针对其背书对等体。我们在仓库中使用的编排代码（`install-chaincode.js`中的`installChaincode`）是为了方便和测试而设计的。
- en: Instantiation of chaincode
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链码的实例化
- en: Now that the endorsing peers in the network have the chaincode, we must instantiate
    that chaincode across our channel to ensure that all copies of the ledger are
    initialized with the right dataset (or key-value pairs). This is the final step
    in the setup of our smart contract before we can open it up for regular operation.
    Instantiation is a transaction that invokes the LSCC to initialize a chaincode
    on a channel, thereby binding the two and isolating the former’s state to the
    latter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网络中的背书对等体有了链码后，我们必须在我们的通道上实例化该链码，以确保所有分类账副本都使用正确的数据集（或键值对）初始化。这是我们的智能合约设置的最后一步，然后我们才能将其用于常规操作。实例化是调用LSCC来初始化通道上的链码的事务，从而将两者绑定并将前者的状态隔离到后者。
- en: This operation should be triggered centrally by any of the organizations authorized
    to initialize the chaincode (in our sample code, we use the administrator of the
    Importer's organization). Again, this follows the simple scenario (described in
    the installation section earlier) where the chaincode package is signed by a single
    organization administrator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作应由授权初始化链码的任何组织中心触发（在我们的示例代码中，我们使用进口商组织的管理员）。同样，这遵循了先前安装部分中描述的简单场景，其中链码包由单个组织管理员签名。
- en: The default channel instantiation policy requires any channel MSP administrator
    to trigger the operation, but a different policy can be set in the Signed CDS
    structure if required.) In addition, the entity that triggers the instantiation
    operation must also be configured as a writer on the channel. Our procedure to
    create a channel configuration using `configtxgen` implicitly gave write permissions
    to administrators of the 4 organizations. (A detailed discussion of channel configuration
    policy is beyond the scope of this book.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的通道实例化策略要求任何通道MSP管理员触发该操作，但如果需要，可以在签名的CDS结构中设置不同的策略。此外，触发实例化操作的实体还必须在通道上配置为写入者。我们使用`configtxgen`隐含地授予了4个组织的管理员写入权限，以创建通道配置的过程。（关于通道配置策略的详细讨论超出了本书的范围。）
- en: 'The main function to implement chaincode instantiation is implemented in `instantiate-chaincode.js`
    as `instantiateOrUpgradeChaincode`. This function can be used both to instantiate
    a newly deployed chaincode or update one that has already been running on the
    channel (see [*Chapter 9*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml), *Life
    in a Blockchain Network*) As in the previous stages, we must create client and
    channel handles, and associate the channel handle with the client. In addition,
    all the endorsing peers in the network must be added to the channel, and then
    the channel object must be initialized with the MSPs associated with the channel
    (from each of the four organizations):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现链码实例化的主要函数在`instantiate-chaincode.js`中作为`instantiateOrUpgradeChaincode`实现。此函数既可用于实例化新部署的链码，也可用于更新已在通道上运行的链码（见[*第9章*](72e0e4f7-a8e3-49e6-935f-2c478d0ac891.xhtml)，*在区块链网络中的生活*）与之前的阶段一样，我们必须创建客户端和通道句柄，并将通道句柄与客户端关联。此外，必须将网络中的所有背书对等方添加到通道中，然后必须使用与通道关联的通道对象来初始化通道的与通道相关联的MSP（来自四个组织中的每一个）：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This sets up the channel to verify certificates and signatures, for example,
    from endorsements received from the peers. Next, we build a proposal for instantiation
    and submit it to all of the endorsing peers on the channel (snippet from the `buildChaincodeProposal`
    function):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了通道以验证证书和签名，例如，来自对等方收到的背书。接下来，我们构建了一个实例化提案并将其提交给通道上的所有背书对等方（从`buildChaincodeProposal`函数的片段）：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The path to the chaincode, and the ID and version, must match what was supplied
    in the installation proposal. In addition, we must supply the function name and
    argument list that will be sent to the chaincode and executed. (In our chaincode,
    this will execute the `Init` function.) Also note that the proposal contains the
    endorsement policy (`Constants.TRANSACTION_ENDORSEMENT_POLICY`) we set earlier,
    which requires a member from each of the four organizations to endorse a chaincode
    invocation. The proposal responses (one for each endorsing peer) returned by the
    orderer must be validated in the same way as in the installation stage. Using
    the result of the preceding `channel.sendInstantiateProposal` call, we must now
    build an instantiation transaction request and submit it to the orderer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 链码的路径、ID 和版本必须与安装提案中提供的内容匹配。此外，我们必须提供将发送到链码并执行的函数名和参数列表（在我们的链码中，这将执行 `Init`
    函数）。还请注意，提案中包含了我们之前设置的背书策略（`Constants.TRANSACTION_ENDORSEMENT_POLICY`），该策略要求来自四个组织的成员对链码调用进行背书。顺序服务返回的提案响应（每个背书对等方一个）必须像在安装阶段一样进行验证。利用前面`channel.sendInstantiateProposal`调用的结果，我们现在必须构建一个实例化交易请求，并将其提交给顺序服务：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A successful response to `channel.sendTransaction` will allow our middleware
    to proceed on the basis that the instantiation was successfully submitted. This
    does not indicate, though, that the instantiation will successfully conclude with
    a commitment to the shared ledger; for that, our code will have to subscribe to
    events, and we will see how to do that later in this section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对`channel.sendTransaction`的成功响应将使我们的中间件在实例化成功提交的基础上继续进行。然而，这并不意味着实例化将成功地在共享分类账上提交；为此，我们的代码将必须订阅事件，我们将在本节后面看到如何做到这一点。
- en: 'Our script in `createTradeApp.js` triggers chaincode instantiation as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本`createTradeApp.js`触发链码实例化如下：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last parameter is set to `false`, indicating that an instantiation must
    be performed and not an upgrade. The first parameter (`Constants.IMPORTER_ORG`)
    indicates that the instantiation request must be submitted by a member (administrator
    in this context) of the importer’s organization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数设置为`false`，表示必须执行实例化而不是升级。第一个参数（`Constants.IMPORTER_ORG`）表示实例化请求必须由进口商组织的成员（在这个上下文中是管理员）提交。
- en: 'If the instantiation was successful, the chaincode will be built in Docker
    containers, one corresponding to each endorsing peer, and deployed to receive
    requests on behalf of their peers. If you run `docker ps -a`, you should see something
    like this in addition to the ones created upon launching the network:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例化成功，链码将在 Docker 容器中构建，每个背书对等方对应一个容器，并部署以代表它们接收请求。如果你运行 `docker ps -a`，你应该会看到除了在启动网络时创建的容器外，还有类似以下的内容：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Invoking the chaincode
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用链码
- en: Now that we have finished setting up our channel and installing chaincode for
    trade, we need to implement functions to execute chaincode invocations. Our code
    for this lies in the `invokeChaincode` function in `invoke-chaincode.js`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了频道的设置，并为交易安装了链码，我们需要实现函数来执行链码调用。我们的代码在`invoke-chaincode.js`的`invokeChaincode`函数中。
- en: 'The procedure to invoke the `chaincode` is the same as we did for instantiation,
    and the code is similar as well. The caller must build a transaction proposal
    consisting of the name of the `chaincode` function to be invoked and the arguments
    to be passed to it. Just providing the `chaincode` ID (`tradecc` in our implementation)
    is sufficient to identify the `chaincode` process to guide the request to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`chaincode`的过程与我们进行实例化时相同，代码也类似。调用者必须构建一个包含要调用的`chaincode`函数的事务提议，以及要传递给它的参数。仅提供`chaincode`ID（在我们的实现中为`tradecc`）就足以识别`chaincode`进程以引导请求：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'One difference with the instantiation proposal is that this operation does
    not typically require an administrative user in the organization; any ordinary
    member may suffice. This proposal must be sent to enough endorsing peers to collect
    the right set of signatures to satisfy our endorsement policy. This is done by
    adding all four peers in our network to the channel object (which must be created
    and initialized in the same way as in the previous stages). Once the proposal
    responses have been collected and validated in the same way as the instantiation
    proposals were, a transaction request must be built and sent to the orderer:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例化提议的一个区别是，这个操作通常不需要组织中的管理用户；任何普通成员可能就足够了。这个提议必须发送给足够的背书对等体以收集满足我们的背书策略的正确签名集。这是通过将我们网络中的所有四个对等体添加到频道对象中来完成的（必须与之前的阶段一样创建和初始化频道对象）。一旦提议响应被收集并得到验证，与实例化提议一样的方式，必须构建一个交易请求并发送给订购方：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We call `invokeChaincode` from our test script in `createTradeApp.js`. The
    chaincode function we would like to execute is `requestTrade`, which chronologically
    is the first function that ought to be invoked by a user in an importer''s role
    (recall that we built access control logic within our `chaincode` to ensure that
    only a member of the Importer''s organization may submit a `requestTrade`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`createTradeApp.js`中的测试脚本中调用`invokeChaincode`。我们希望执行的链码函数是`requestTrade`，按时间顺序来说，这是应该由进口商角色的用户调用的第一个函数（请回忆我们在`chaincode`中构建了访问控制逻辑，以确保只有进口商组织的成员可以提交`requestTrade`）：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last parameter (`'Importer'`) simply indicates the ID of the user in the
    importer’s organization who is to submit this transaction request. In the code,
    the credentials for this user are loaded if the user has already enrolled with
    the CA, otherwise a new user with that ID is registered using the `clientUtils.getUserMember`
    function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数（`'Importer'`）只是表明进口商组织中要提交此交易请求的用户的ID。在代码中，如果用户已经在CA进行了注册，那么将加载该用户的凭证，否则将使用`clientUtils.getUserMember`函数注册一个具有该ID的新用户。
- en: As in the instantiation case, a successful `channel.sendTransaction` call simply
    indicates that the orderer accepted the transaction. Only subscribing to an event
    will tell us whether the transaction was successfully committed to the ledger.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例化案例一样，成功的`channel.sendTransaction`调用只表示订购方接受了交易。只有订阅事件才能告诉我们交易是否成功提交到总账簿。
- en: Querying the chaincode
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询链码
- en: A chaincode query is somewhat simpler to implement as it involves the entire
    network, but simply requires communication from client to peer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查询链码的实现相对简单一些，因为它涉及到整个网络，但只需从客户端到对等体的通信。
- en: 'Client and channel handles should be created as in the previous stages, but
    this time, we will select just one or more peers from the caller''s (or client''s)
    organization to associate with the channel object. Then, we must create a query
    request (identical to an invocation proposal request) and submit it to the selected
    peers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和频道句柄应该如同之前的阶段一样创建，但这次，我们将选择来自调用者（或客户端）组织的一个或多个对等体与频道对象关联。然后，我们必须创建一个查询请求（与调用提议请求相同）并将其提交给所选的对等体：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The responses to the query can be collected and compared before being returned
    to the caller. The complete implementation can be found in the `queryChaincode`
    function in `query-chaincode.js`. We test this function by running a `getTradeStatus`
    chaincode query in our `createTradeApp.js` script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在将响应返回给调用者之前，可以收集和比较查询的响应。完整的实现可以在 `query-chaincode.js` 中的 `queryChaincode`
    函数中找到。我们通过在 `createTradeApp.js` 脚本中运行 `getTradeStatus` 链码查询来测试此函数：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As with an invocation, we specify a user ID (`‘Exporter’`) and organization:
    here we want a member of the exporter’s organization to check the status of a
    trade request.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用一样，我们指定了一个用户 ID（`‘Exporter’`）和组织：这里我们希望出口商组织的成员检查交易请求的状态。
- en: Since a query is local to the client and its associated peers, the response
    is returned immediately to the client and does not have to be subscribed to (as
    in the case of invocation).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询是对客户端及其相关节点的本地查询，因此响应会立即返回给客户端，无需订阅（如调用的情况）。
- en: Completing the loop – subscribing to blockchain events
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成循环 - 订阅区块链事件
- en: 'As we have seen in previous chapters, commitments to the shared ledger on a
    permissioned blockchain require a consensus among the network peers. Hyperledger
    Fabric in its v1 incarnation has an even more unique process to commit to the
    ledger: the transaction execution, ordering, and commitment processes are all
    decoupled from each other and framed as stages in a pipeline where endorsers,
    orderers, and committers carry out their tasks independent of each other. Therefore,
    any operation that results in a commitment of a block to the ledger is asynchronous
    in the Fabric scheme of things. Three of the operations we have implemented in
    our middleware fall into that category:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所见，权限区块链上的共享账本承诺需要网络节点之间的共识。Hyperledger Fabric 在其 v1 版本中有一个更独特的过程来提交到账本：交易执行、排序和提交过程都是彼此解耦的，并被构建为管道中的阶段，在其中背书者、排序者和提交者独立执行其任务。因此，在
    Fabric 方案中，导致区块提交到账本的任何操作都是异步的。我们在中间件中实现的三个操作都属于这一类别：
- en: Channel join
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道加入
- en: Chaincode instantiation
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链码实例化
- en: Chaincode invoke
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链码调用
- en: In our description of these operations, we stopped at the point where a request
    is successfully sent to the orderer. But to complete the operation loop, any application
    that uses our middleware needs to know the final result of the request to drive
    the application logic forward. Fortunately, Fabric provides a publish/subscribe
    mechanism for the communication of results of asynchronous operations. This includes
    events for the commitment of a block, the completion of a transaction (successfully
    or otherwise), as well as custom events that can be defined and emitted by a chaincode.
    Here, we will examine block and transaction events, which cover the operations
    we are interested in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对这些操作的描述中，我们停在成功发送请求到排序者的地方。但是，为了完成操作循环，任何使用我们中间件的应用程序都需要知道请求的最终结果，以推动应用程序逻辑向前发展。幸运的是，Fabric
    提供了用于异步操作结果通信的发布/订阅机制。这包括用于提交块、完成交易（成功或否）以及可以由链码定义和发出的自定义事件的事件。在这里，我们将检查区块和交易事件，它们涵盖了我们感兴趣的操作。
- en: Fabric offers a mechanism for event subscription in the SDK through an `EventHub`
    class, with the relevant subscription methods being `registerBlockEvent`, `registerTxEvent`,
    and `registerChaincodeEvent`, respectively, to which callback functions can be
    passed for actions to perform at the middleware layer (or higher) whenever an
    event is available.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 在 SDK 中通过 `EventHub` 类提供了一个事件订阅机制，相关的订阅方法分别是 `registerBlockEvent`、`registerTxEvent`
    和 `registerChaincodeEvent`，可以传递回调函数以在中间件层（或更高层）执行操作，每当事件可用时。
- en: 'Let''s see how we can catch the event of a successful join in our middleware
    code. Going back to the `joinChannel` function in `join-channel.js`, the following
    code instantiates an `EventHub` object for a given peer, whose configuration is
    loaded from `config.json`. For example, to subscribe to events from the exporter
    organization''s sole peer, the URL our `fabric-client` instance will listen to
    (under the covers) is `grpcs://localhost:7053`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的中间件代码中捕获成功加入的事件。回到 `join-channel.js` 中的 `joinChannel` 函数，以下代码为给定的节点实例化了一个
    `EventHub` 对象，其配置从 `config.json` 中加载。例如，要订阅来自出口商组织唯一节点的事件，我们 `fabric-client` 实例将监听的
    URL（在内部）是 `grpcs://localhost:7053`：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The listener, or callback, for each block event is defined as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个块事件，监听器或回调被定义如下：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Whenever a block event is received, the code matches the expected channel name
    (`tradechannel` in our scenario) with the one extracted from the block. (The block
    payloads are constructed using standard schemas available in the Fabric source
    code, in the `protos` folder. Understanding and playing with these formats is
    left as an exercise to the reader.) We will set a timeout in the code (40 seconds
    here) to prevent our event subscription logic from waiting indefinitely and holding
    up the application. Finally, the outcome of a channel join is made contingent,
    not just on the success of a `channel.joinChannel` call, but also on the availability
    of block events, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每当接收到区块事件时，代码会将预期的通道名称（在我们的场景中为`tradechannel`）与从区块中提取的通道名称进行匹配。（区块有效载荷是使用Fabric源代码中的标准模式构造的，在`protos`文件夹中可用。理解和玩弄这些格式留给读者作为练习。）我们将在代码中设置超时时间（这里为40秒），以防止我们的事件订阅逻辑无限等待并阻塞应用程序。最后，通道加入的结果不仅取决于`channel.joinChannel`调用的成功，还取决于区块事件的可用性，如下所示：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For instantiation and invocation, we register callbacks not for blocks but
    for specific transactions, which are identified by IDs set during the transaction
    proposal creation. Code for the subscription can be found in the `instantiateChaincode`
    and `invokeChaincode` functions, in `instantiate-chaincode.js` and `invoke-chaincode.js`
    respectively. A code snippet from the latter illustrates the basic working of
    transaction event handling:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例化和调用，我们不是为区块注册回调，而是为特定事务注册回调，这些事务由事务建议创建时设置的ID标识。订阅代码可以在`instantiate-chaincode.js`和`invoke-chaincode.js`中找到的`instantiateChaincode`和`invokeChaincode`函数中找到。后者的代码片段说明了事务事件处理的基本工作原理：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The parameters passed to the callback include a handle to the transaction and
    a status code, which can be checked to see whether the chaincode invocation result
    was successfully committed to the ledger. Once the event has been received, the
    event listener is unregistered to free up system resources (our code may also
    listen to block events in lieu of specific transaction events, but it will then
    have to parse the block payload and find and interpret information about the transaction
    that was submitted).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调的参数包括事务句柄和状态码，可以检查链码调用结果是否成功提交到分类帐。一旦收到事件，事件监听器就会被注销以释放系统资源（我们的代码也可能会监听区块事件而不是特定的事务事件，但那样就必须解析区块有效载荷并查找和解释提交的事务的信息）。
- en: Putting it all together
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'The sequence of steps described previously can be run in one go through a suitably
    coded script. As mentioned earlier, `createTradeApp.js` contains such a script,
    which results in the creation of `tradechannel`, the joining of the four peers
    to that channel, the installation of the `trade_workflow` chaincode on all four
    peers, and its subsequent instantiation on the channel, which finally concludes
    with the creation of a trade request from the importer to the exporter and a follow-up
    querying the request status. You can run the following command and see the various
    steps being conducted on your console:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的步骤序列可以通过适当编码的脚本一次性运行。如前所述，`createTradeApp.js`包含这样一个脚本，该脚本导致创建`tradechannel`，将四个对等体加入该通道，将`trade_workflow`链码安装在所有四个对等体上，并在通道上进行实例化，最终以进口商向出口商创建贸易请求并跟踪查询请求状态而结束。您可以运行以下命令，然后在控制台上查看各种步骤的执行：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Just as an exercise, and to test out both the middleware library functions
    and the chaincode, you can complete the trade scenario that the createTradeApp.js
    script began by starting with a trade request acceptance by an exporter and culminating
    with full payment made to the exporter by the importer for a successfully delivered
    shipment. To view this in operation, run the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，也是为了测试中间件库函数和链码，您可以通过开始接受出口商的贸易请求，并最终由进口商向出口商支付完整的货物运输费用来完成`createTradeApp.js`脚本开始的贸易场景。要查看这个操作，请运行以下命令：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: User application – exporting the service and API
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户应用程序 - 导出服务和API
- en: The exercise in creating a set of functions for our middleware lays down the
    plumbing for a user-facing application we can build on top. Although we can architect
    the application in different ways, the set of capabilities it should offer will
    remain the same. Before demonstrating an approach to building an application for
    a blockchain user, we will discuss the salient features such an application should
    possess.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的中间件创建一组函数的练习为我们可以在其上构建的面向用户的应用程序奠定了基础。虽然我们可以以不同的方式设计应用程序，但它应该提供的功能集合将保持不变。在演示为区块链用户构建应用程序的方法之前，我们将讨论这样一个应用程序应该具备的显著特征。
- en: Applications
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: 'Referring to *Figure 5.2: Typical three-layer architecture of a Hyperledger
    Fabric application,* and our discussion in the <q>Application Model and Architecture</q>
    section of this chapter, different users of a Hyperledger Fabric application may
    need different and distinct applications. Our trade scenario is an example of
    this: users representing trading parties, banks, shippers, and governmental authorities
    may need different things from our application, even while they are collectively
    participating in the trade network and endorsing smart contract operations.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参考*图 5.2：Hyperledger Fabric 应用程序的典型三层架构*，以及本章的 <q>应用模型和架构</q> 部分的讨论，Hyperledger
    Fabric 应用程序的不同用户可能需要不同且独特的应用程序。我们的交易场景就是一个例子：代表交易方、银行、承运人和政府部门的用户可能需要我们的应用程序中的不同内容，即使他们共同参与交易网络并认可智能合约操作。
- en: There are common operations that administrators of the different organizations
    must have the capability to perform. This includes the stages from the creation
    of a channel up to the instantiation of chaincode. Therefore, if we need to build
    different applications for each network participant, we should expose these capabilities
    to every instance of those applications. Once we get to the application itself,
    which consists of the set of invoke and query functions offered by the chaincode,
    we must create space for differentiation. An application designed for the trading
    parties and their banks must expose trade and Letter of Credit operations to the
    users. However, there is no need to expose these operations to a carrier, and
    therefore an application designed for the latter can and ought to limit the capabilities
    offered to those that impact the carrier's role, such as the functions to create
    Bills of Lading and to record the location of a shipment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不同组织的管理员必须具备执行的共同操作。这包括从创建通道到实例化链码的各个阶段。因此，如果我们需要为每个网络参与者构建不同的应用程序，我们应该向这些应用程序的每个实例提供这些功能。一旦我们进入应用程序本身，它由链码提供的一组调用和查询功能组成，我们必须为区分留出空间。为交易方及其银行设计的应用程序必须向用户公开交易和信用证操作。然而，并不需要将这些操作暴露给承运人，因此，为后者设计的应用程序可以并且应该限制提供给其的功能，仅限于影响承运人角色的功能，例如创建提单和记录货物位置的功能。
- en: Here, for simplicity, we will amalgamate all the applications into one and demonstrate
    how to make it work. Diversification based on user roles and requirements is left
    as an exercise for the reader. Our amalgamated application will be implemented
    as a web server, loosely connecting the smart contract and the middleware, sounding
    it from the end users.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了简单起见，我们将所有应用程序汇集成一个，并演示如何使其工作。基于用户角色和要求的多样化留给读者作为一项练习。我们的汇编应用程序将作为一个 Web
    服务器实现，松散地连接智能合约和中间件，从最终用户那里发出声音。
- en: User and session management
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户和会话管理
- en: The design of any service-oriented application requires the determination of
    users who will be allowed to access the application and perform various actions.
    For a Hyperledger Fabric application, special consideration ought to be given
    to the differentiation between user classes. Every Fabric network has a set of
    privileged users (who we have been referring to as administrators of organizations)
    and ordinary members. This differentiation of roles must be reflected in the design
    of the user-facing application, too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 任何面向服务的应用程序的设计都需要确定可以访问应用程序并执行各种操作的用户。对于 Hyperledger Fabric 应用程序，应该特别考虑用户类别之间的区别。每个
    Fabric 网络都有一组特权用户（我们一直称之为组织的管理员）和普通成员。这种角色的区分必须反映在面向用户的应用程序的设计中。
- en: The application must have an authentication layer as well as a mechanism for
    session management, allowing an already-authenticated user to exercise the application,
    limited by their role. In our example application, we will use **JSON Web Tokens**
    (**JWT**) for this purpose.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须具有身份验证层以及会话管理机制，允许已经通过身份验证的用户行使应用程序，其权限受其角色的限制。 在我们的示例应用程序中，我们将使用**JSON
    Web Tokens**（**JWT**）来实现这一目的。
- en: Designing an API
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 API
- en: 'Before building our application, we must design a service API to cover the
    capabilities exposed by our middleware. We will design our API to be `RESTful`,
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序之前，我们必须设计一个服务 API，以涵盖我们中间件暴露的功能。 我们将设计我们的 API 为 `RESTful`，如下所示：
- en: '`POST/login`: Register a new user (administrative or ordinary) or log in as
    an existing one'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/login`: 注册一个新用户（管理或普通用户）或登录为现有用户'
- en: '`POST/channel/create`: Create a channel'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/channel/create`: 创建一个通道'
- en: '`POST/channel/join`: Join the network peers to the channel created in this
    user''s session'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/channel/join`: 将网络对等体加入到此用户会话中创建的通道中'
- en: '`POST/chaincode/install`: Install the `chaincode` on the peers'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/chaincode/install`: 在对等体上安装 `chaincode`'
- en: '`POST/chaincode/instantiate`: Instantiate the `chaincode` on the channel'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/chaincode/instantiate`: 在通道上实例化 `chaincode`'
- en: '`POST/chaincode/:fcn`: Invoke the `chaincode` function `fcn` with passed arguments
    (in the body); examples for `fcn` are `requestTrade`, `acceptLC`, and so on'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST/chaincode/:fcn`: 调用传递参数的 `chaincode` 函数 `fcn`（在请求体中）； `fcn` 的示例包括 `requestTrade`，`acceptLC`
    等'
- en: '`GET/chaincode/:fcn`: Query the `chaincode` function `fcn` with passed arguments
    (in the body); examples for `fcn` are `getTradeStatus`, `getLCStatus`, and so
    on'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET/chaincode/:fcn`: 查询传递参数的 `chaincode` 函数 `fcn`（在请求体中）； `fcn` 的示例包括 `getTradeStatus`，`getLCStatus`
    等'
- en: Collectively, these API functions cover the transaction stages in *Figure 5.3: The
    stages in the creation and operation of a blockchain application*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 函数共同覆盖了 *图 5.3：区块链应用程序创建和操作阶段* 中的事务阶段。
- en: Creating and launching a service
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和启动服务
- en: We will implement an express ([https://expressjs.com/](https://expressjs.com/))
    web application in Node.js to expose the preceding API. The code lies in the application
    folder in our repository, with the source code in `app.js` and the dependencies
    defined in `package.json`. As a prerequisite to running the web application, the
    dependencies must be installed either by running `npm install` or `make` (see
    [*Chapter 8*](112a5075-378d-4bb0-9b9e-db81c18a35f5.xhtml), *Agility In A blockchain
    network*) within that folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Node.js 中实现一个 express（[https://expressjs.com/](https://expressjs.com/)）web
    应用程序，以暴露前述 API。 代码位于我们仓库的应用程序文件夹中，源代码在 `app.js` 中，依赖项在 `package.json` 中定义。 作为运行
    web 应用程序的先决条件，必须安装依赖项，可以通过运行 `npm install` 或 `make`（参见[*Chapter 8*](112a5075-378d-4bb0-9b9e-db81c18a35f5.xhtml)，*区块链网络中的灵活性*)
    在该文件夹中。
- en: 'The following code snippet shows how to instantiate and run the *express* server:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何实例化和运行 *express* 服务器：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To summarize, a web server is launched to listen for HTTP requests on port `4000`.
    Middleware is configured to enable CORS, automatically parsing both JSON payloads
    and forming data in POST requests.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，启动一个 web 服务器以在端口 `4000` 上监听 HTTP 请求。 配置中间件以启用 CORS，自动解析 JSON 负载并在 POST
    请求中形成数据。
- en: Our web server listens to requests over an insecure HTTP. In a production application,
    we would start an HTTPS server for secure, confidential communication with clients.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 web 服务器通过不安全的 HTTP 监听请求。 在生产应用中，我们将启动一个 HTTPS 服务器，以与客户端进行安全、机密的通信。
- en: Now, let's see how to configure the various express routes to implement our
    service API functions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何配置各种 express 路由来实现我们的服务 API 功能。
- en: User and session management
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户和会话管理
- en: 'Before performing a network (channel) or chaincode operation, a user must establish
    an authenticated session. We will implement the `/login` API function as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行网络（通道）或链码操作之前，用户必须建立经过身份验证的会话。 我们将实现 `/login` API 函数如下：
- en: Create a JWT token for a user with an expiration time of 60 seconds
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户创建一个具有 60 秒过期时间的 JWT 令牌
- en: Register or log the user in
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册或登录用户
- en: If successful, return the token to the client
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，将令牌返回给客户端
- en: 'The server expects the name of a user and an organization name for registration
    or login to be provided as form data in the request body. An administrative user
    is simply identified by the admin username. The request body format is:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器期望提供请求体中的表单数据，以提供注册或登录的用户名和组织名。 管理用户仅由管理员用户名标识。 请求体格式为：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A password must be supplied, but only if the `<username>` is `admin`. In that
    case, the middleware will simply check whether the supplied password matches the
    one that was used to start the `fabric-ca-server` for the organization's MSP.
    As mentioned earlier in this chapter, our MSP administrator passwords were set
    to the default `adminpw`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: This is a naïve implementation, but as web application security is not the focus
    of this tutorial, this will suffice to show how a server and frontend can be implemented
    over a smart contract and middleware.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for JWT token creation and user registration/login can be found in
    the following express route configured in `app.js`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The reader may experiment with other mechanisms of session management, such
    as session cookies, in lieu of JWT tokens.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Our web application can now be tested. First, bring up the Fabric network using
    `docker-compose` (or `trade.sh`), as shown earlier in this chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If you created fresh cryptographic keys and certificates for the organizations
    using `cryptogen` (or the `trade.sh` script), you MUST clear the temporary folder
    used by the middleware to save world state and user info, otherwise you may see
    errors if you try to register users with IDs that were used in a previous run
    of your application. For example: if the temporary folder is `network/client-certs`
    on your machine, you can simply run `rm -rf client-certs` from the `network` folder
    to clear the contents.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'In a different terminal window, start the web application by running the following
    command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In a third terminal window, send a request to the web server using the `curl`
    command to create an ordinary user named `Jim` in the `importerorg` organization
    (this is the organization name specified in `middleware/config.json`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see an output like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the middleware, the function that gets executed here is `getUserMember` in
    `clientUtils.js`, which was discussed earlier in this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an administrative user in the same organization, run:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see an output as follows (the admin user was already registered,
    so this ended up being a login call):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the middleware, the function that gets executed here is `getMember` in `clientUtils.js`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Network administration
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see in `app.js`, the API functions from channel creation to chaincode
    instantiation are implemented as express routes:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To exercise these routes, the end user must log in as an administrator and
    use the returned token. Taking the output from the previous call, we can request
    channel creation as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that the format for the authorization header is `Bearer <JWT token value>`.
    The web server implicitly assumes that the channel name is `tradechannel`, which
    is set in `middleware/constants.js`. (You may augment the server API to accept
    a channel name in the request body if you wish.) The output ought to be as follows
    if everything goes well:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Similar queries can be run by an administrator for channel join, chaincode
    installation, and chaincode instantiation. As an example, the instantiation API
    endpoint expects the chaincode path, chaincode version, and a list of arguments
    for the chaincode as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以运行类似的查询以加入通道、安装链码和实例化链码。例如，实例化API端点预期的链码路径、链码版本和链码参数列表如下：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output, if everything goes well, will be:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，输出将是：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the implementation of each of these routes, a check is made to ensure that
    the user (identified by the JWT token) is an administrative user, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个路由的实现中，都会检查用户（由JWT令牌标识）是否是管理员用户，如下所示：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we were to use the token for the user registered as Jim, the web server would
    return a `403` error code to the client.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用Jim注册的用户令牌，Web服务器将向客户端返回`403`错误代码。
- en: Exercising the application
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Once the chaincode has been initialized by an administrative user, our application
    is open for business. Now, any ordinary user (such as Jim in the importer''s organization)
    may request a chaincode invocation or query. For example, a trade request can
    be made as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦由管理员用户初始化了链码，我们的应用程序就开放了。现在，任何普通用户（例如进口商组织中的Jim）都可以请求链码调用或查询。例如，可以发出交易请求如下：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that the chaincode version must be supplied in the request body. The output,
    if all goes well, will be:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，请求体中必须提供链码版本。如果一切顺利，输出将是：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Subsequently, the status of the trade can be queried (again by `Jim`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，可以查询交易的状态（再次由`Jim`）：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, the output ought to contain the chaincode response:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出应包含链码响应：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: User/client interaction modes
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户/客户端交互模式
- en: Although running curl commands is sufficient to test our web application, the
    proper way to expose the application to the user would be through one or more
    web pages, with widgets for the user to trigger those commands.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行curl命令足以测试我们的Web应用程序，但向用户公开应用程序的适当方式是通过一个或多个网页，其中包含用户触发这些命令的小部件。
- en: As we saw in the middleware implementation section, various operations, including
    chaincode invocations, are asynchronous. In our implementation, we masked this
    asynchronous behavior by making the wrapper function return to the caller, but
    only when the request had been successfully sent to the orderer and the events
    subscribed for had been received and validated. We can also choose to expose this
    asynchronous behavior to the web application client. Using Web Sockets ([https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)),
    the contents of a web interface presented to the end user may be dynamically updated
    whenever the event notification arrives at the callback registered with the event
    hub.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在中间件实现部分看到的，包括链码调用在内的各种操作都是异步的。在我们的实现中，我们通过使包装函数返回给调用者来遮蔽了这种异步行为，但仅当请求已成功发送到订购者并且已收到并验证了已订阅的事件时才返回。我们还可以选择将此异步行为暴露给Web应用程序客户端。使用Web
    Sockets ([https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API))，当事件通知到达与事件中心注册的回调时，向最终用户呈现的Web界面内容可以动态更新。
- en: Designing good web interfaces is beyond the scope of this book, and it is left
    to the reader to leverage other sources of knowledge to build ones suitable for
    their applications.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的Web界面超出了本书的范围，读者可以利用其他知识源来构建适合其应用程序的界面。
- en: Testing the Middleware and Application
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试中间件和应用程序
- en: We have shown how to exercise the Node JS-based middleware and application capabilities
    using sample scripts and `curl` commands. By observing the console output, you
    can find out if the application works as expected. For a production application,
    you will need a more robust and maintainable testing methodology that can evaluate
    correctness of the library functions and API endpoints on an ongoing basis. Both
    unit tests and integration tests should be part of your evaluation process. A
    hands-on demonstration of such testing is beyond the scope of this chapter, and
    writing unit and integration tests is left as an exercise to the reader. Mocha,
    which is a feature-rich JavaScript framework for asynchronous testing([https://mochajs.org/](https://mochajs.org/)),
    can be used for this purpose.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Integration with existing systems and processes
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When discussing end-to-end solutions with customers, we often explain that blockchain-related
    components represent a very small percentage of the overall footprint. This is
    still a very important set of components, but nonetheless they represent a small
    footprint.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on the touch point between our traditional systems and
    the Hyperledger Fabric and Composer API.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the various patterns of integration we have leveraged and see
    how some of the non-functional requirements can influence the integration deployment.
    Finally, we will explore some additional considerations that integrators will
    need to keep in mind when designing their integration layer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, in this section, you will:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Understand the design consideration of the integration layer
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the integration design patterns
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the impact of non-functional requirements on the integration
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have experience with Fabric SDK and by the end of [*Chapter 7*](2e166a5f-eff3-4317-9a8f-fb74bdb68915.xhtml),
    *A Business Network Example*, you will have experienced using the `Composer REST`
    gateway. While those are certainly the main tools of the trade when it comes to
    integration, they are part of an ecosystem, and there needs to be an alignment
    of the business processes of the enterprise to make sure the integration makes
    sense.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the design considerations, we will look at the following aspects:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Impact of decentralization
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process alignment
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message affinity
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity mapping
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralization
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many attempts have been made to standardize IT functions and capabilities, but
    the reality is that no two organizations have the same IT landscape. Even for
    those who have selected the same ERP vendor, the systems will have been customized
    to meet the organization processes and needs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: This means that when planning your integration design, you should keep in mind
    that each organization may have their own way of invoking smart contracts and
    may not have the same IT capabilities or policies.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: As an example, exposing events through Web Socket may make sense for an organization
    who is familiar with cloud-based technologies, but other organizations may not
    have the skills, or their IT security policies may not allow them to use the protocol.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem surprising to some, keep in mind that a network can be a mix
    of Fortune 500 organizations and start-ups. Consider the supply-chain industry
    for a moment; you will find some trucking company with little to no IT infrastructure,
    all the way to industry behemoths. Clearly, one size may not fit all.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, from a network perspective, you should consider the degree
    of support the network wants to provide to joining organizations. There are two
    possible approaches:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**The network provides an integration asset**: This can take the form of a
    gateway that each participant deploys in their own infrastructure. The gateway
    is standard for everyone and manages the invocation of the smart contracts in
    a consistent manner.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can provide the benefit of accelerating the on-boarding process, but requires
    consideration about who owns, manages, and supports this IT component. Furthermore,
    some organizations may not want to deploy this piece of infrastructure due to
    trust issues.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Each participant builds their own integration layer**: The obvious downside
    of this approach is the recreation of the wheel by all participants, but it reduces
    the potential support issues created by deploying a common component in every
    organization.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may also be the preferred approach for use cases requiring deep system
    integration to achieve the benefit of process optimizations.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Process alignment
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integration layer will have to deal with two different viewpoints:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Organization IT system and business process viewpoint**: An organization
    business process may be hosted in an ERP such as SAP. In such a situation, when
    a specific business event warrants the invocation of a smart contract, this may
    be issued through a **Business API** (**BAPI**) call from the SAP system. The
    API call from the ERP may contain a variety of data structures, some of which
    will be completely irrelevant to the blockchain network.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart contract viewpoint**: This viewpoint has the particularity of having
    a data representation that is application agnostic. This means that all participants
    of the network will understand the nature of the data being processed.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is up to the integration layer to reconcile the two and ensure that the
    proper semantic of the transaction is maintained in both systems. This may imply:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**Mapping**: Moving data from one field name to the another'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformation**: Aggregating, splitting, or computing a new value based
    on input'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-referencing**: Leveraging a reference table to map application-specific
    codes to values recognized by the network'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point here is that even if your network agrees to use the Hyperledger Composer
    REST gateway presented in [Chapter 7](2e166a5f-eff3-4317-9a8f-fb74bdb68915.xhtml),
    *A Business Network Example*, there is still work that needs to be done by each
    participant to ensure that the integration fits into the overall business processes
    of the organization.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Message affinity
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this is not an issue often discussed, ignoring it can lead to serious
    issues that will typically surface during integration or performance testing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: We refer to message affinity as a situation that occurs when a system issues
    a series of inter-dependent transactions, which are issued in a short period of
    time. Because each transaction is issued separately, they are subject to be processed
    in a different order than when they are issued by the client.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'The result may be unpredictable, as the following example shows. To make it
    concrete, let''s look at an Order process that would issue three separate transactions,
    as shown in the following diagram:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05a9b3bf-eb3a-4aec-94ff-da5d84218061.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Processing service requests in order'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the Service Provider is multi-threaded, the order of processing can
    vary depending on the load at the time. A potential result is illustrated in the
    following diagram:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c721e3c-759b-45cc-b086-fc5fdba9fa3b.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Potential service processing result'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The first item being processed out of order would be rejected because the order
    object hasn't been created yet. However, the two subsequent objects would succeed
    and leave the system in a state where the order is recorded as having a single
    item instead of two.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with this situation is that it is hard to troubleshoot. An unaware
    developer may not be able to reproduce this behavior on his/her development platform.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may be wondering, how does that relate to blockchain and Hyperledger
    Fabric? Considering that Fabric transactions are asynchronously processed and
    that they are validated against every world state, this situation can arise. The
    client will issue the transaction and may asynchronously receive a message saying
    that the transaction was invalid because it did not correspond to the world state.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story here is that when designing an API, make sure that they
    are at a granularity level that completely describes a business event. Too many
    fine-grained transactions only leads to message affinity, increased latency, and
    the potential for issues, as described here.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the context of the integration to Hyperledger Fabric and Composer, the concept
    of service discovery is focussed on documenting and exposing the artifacts from
    Fabric: CA, peers, and orderers to the calling application.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: As we now have experienced, in order for the application to get a transaction
    endorsed and added to the ledger, it needs to be able to interact with numerous
    components of these types. Having a way to maintain this information as a service
    configuration element will enable teams to quickly adapt to the evolving nature
    of the network.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Currently, when developing client applications using the Fabric SDK, the developer
    is responsible for managing and applying this service configuration.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Part of the roadmap of Hyperledger Fabric is the intent to facilitate this configuration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of relying on a component such as the  `Composer REST` gateway
    is that service discovery is provided by the gateway. Concretely, as you will
    soon discover, it provides the concept of a business card which contains both
    the identity information along with a  connection profile, which has the list
    of Hyperledger Fabric services that can be used to execute transactions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Identity mapping
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity mapping is the process of converting the identity of an individual
    or an organization to an identity that is recognized on the network.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the solution from a business network perspective, what is the
    granularity of the identity that needs to be recognized? Will other organizations
    care whether Bob or Ann from ACME issued the transaction? In most cases, the answer
    will be no. Knowing that the transaction was issued by ACME will be sufficient.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Why is that, you may wonder. It is directly related to the concept of trust.
    Remember the concepts presented in [*Chapter 1*](ccf97c50-561e-41ae-99fa-784b3217619d.xhtml), *Blockchain
    – Enterprise and Industry Perspective*; blockchain solves the problem of time
    and trust. Understanding where the trust issues come from helps us rationalize
    what identities should be used to transact on the network. In most cases, our
    experience has been that trust issues occur between organizations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: If you think about a use case where a bank customer transacts through their
    bank portal, the customer will not care about the backend systems; they trust
    their bank's security system.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, there are situations where an identity will need to be mapped:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Business partners transacting through the integration layer of the organization
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different departments with varying levels of privilege
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users with different roles that drive different access privileges
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the integration layer will need to convert the inbound credentials
    (API Key, User ID and Password, JTW token, and so on) into a Hyperledger Fabric
    identity.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: When working with the Hyperledger `Composer REST` gateway, you can configure
    it to support multiple users. The server leverages the node passport framework
    to manage this authentication. This provides the flexibility of supporting different
    models (for example, user ID/password, JWT, and OAUTH).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Once the client is authenticated to the server, there is an additional step
    that consists of loading the Hyperledger Composer business card into the server's
    user repository. There needs to be implicit trust between the client and the server,
    as the business card contains the private key.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Integration design pattern
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at some of the viable integration patterns we have seen in
    the industry. The list is by no means exhaustive, and given that we are still
    in the early days of the Hyperledger Fabric and Composer solutions, we expect
    that new patterns will emerge as people and organizations become more comfortable
    with the technology.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise system integration
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this category, we consider any organization's pre-existing systems that predate
    the joining of the network. As such, these systems have their own concepts and
    paradigms, and we will require a form of abstraction to reconcile the two worlds.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with an existing system of record
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is a diagram to illustrate the blockchain network to an existing
    system of record:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ace45f87-b12c-4ea7-9b2d-0011fd97732d.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Integrating the blockchain network to an existing system of record'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Most large enterprises looking at joining with a business network will eventually
    aim at integrating their system of record to make sure that they benefit from
    the real-time transparent distribution of transactions. In these circumstances,
    the process alignment we previously mentioned will be tremendously important.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in the preceding diagram, the approach will consist of leveraging
    an adaptor pattern to act as a data mapper between the two worlds. The adaptor
    will adopt the enterprise system application protocol and data structure to receive
    transaction requests. Optionally, it can also leverage existing foundations such
    as messaging services to propagate ledger events.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that this type of integration will be specific
    to an organization, and very little reuse will be possible.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'As a variant of this pattern, some organizations will break the adaptor into
    two parts:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**REST gateway**: Exposing a REST interface aligned with the Fabric smart contract'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration bus**: Mapping the fields and connecting the enterprise systems'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in this variant reuse is higher, the same considerations only get moved
    one layer down.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with an operational data store
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a diagram that illustrates integrating the blockchain network to an
    operational data store:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7b1f220-6a7b-4734-9cf6-bd325cf463d7.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Integrating the blockchain network to an operational data store'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, organizations are looking at ways of running analytics on the information
    from their ledgers. However, issuing multiple/large queries against the organization's
    peers will only impact the online performance of the system. Generally, the recognized
    approach in enterprise system design is to move the data to an operational data
    store. The data can then be easily queried. Additional views on the data can be
    created by enriching the data using different data sources.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组织正在寻找方法对其分类帐中的信息进行分析。然而，对组织的对等方发出多个/大型查询将仅影响系统的在线性能。通常，在企业系统设计中公认的方法是将数据移动到运行数据存储中。然后可以轻松查询数据。可以通过使用不同的数据来源使数据进行丰富处理，从而创建数据的附加视图。
- en: In this pattern, the event listener subscribes to the Fabric organization events.
    As such, it can receive transactions from all channels the organization is entitled
    to. If the preservation of the data's integrity is important, the event listener
    can calculate a hash of every record and store them alongside the records.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，事件监听器订阅了Fabric组织的事件。因此，它可以接收组织有权访问的所有通道的交易。如果数据的完整性保护很重要，事件监听器可以计算每条记录的哈希值，并将其与记录一起存储。
- en: You will notice that the pattern also accounts for a `syncAll` function that
    would allow the event listener to re-synchronize the data store with the latest
    view of the world state. Keep in mind that the implementation of this `syncAll` function
    will need to be done carefully and will most likely require that the function
    supports the pagination of the resultsets.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到该模式还考虑了一个名为`syncAll`的函数，它将允许事件监听器与世界状态的最新视图重新同步数据存储。请记住，这个`syncAll`函数的实现需要谨慎进行，并且很可能需要支持结果集的分页。
- en: Microservice and event-driven architecture
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和事件驱动架构
- en: 'The following diagram illlustrates microservice and event-driven architecture
    for a blockchain application:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了区块链应用的微服务和事件驱动架构：
- en: '![](img/93b7c097-cabb-4d7f-9633-abcff03632ab.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93b7c097-cabb-4d7f-9633-abcff03632ab.png)'
- en: 'Figure 5.8: Microservice and event-driven architecture for a blockchain application'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：区块链应用的微服务和事件驱动架构
- en: We've labeled this pattern as microservice and event-driven because this is
    the pattern most often seen for those types of architectures. However, the particularity
    of this pattern comes from the gateway. Such a system will not perform any data
    mapping; it will leverage a common communication protocol (HTTP) and data format
    (typically JSON, but it could be XML). There is also an expectation that the services
    will already be designed to understand the semantics of the data being transacted.
    Events are also propagated through the same protocol and data format.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此模式标记为微服务和事件驱动，因为这是这些类型架构中最常见的模式。然而，该模式的特殊之处来自于网关。这样的系统不会执行任何数据映射；它将利用共同的通信协议（HTTP）和数据格式（通常为JSON，但也可以是XML）。此外，服务已经设计为理解所进行交易数据的语义也是一个期望。事件也通过相同的协议和数据格式传播。
- en: Again, microservice applications tend to be newer applications, and they benefit
    from a more fine-grained interface. As such, they tend to evolve more quickly
    and be in a position to adapt and adhere to the transactions from the network.
    Similarly, event-driven applications will benefit from their low coupling to the
    other components of the system, and so are good candidates for this pattern.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，微服务应用往往是较新的应用程序，并且会从更细粒度的接口受益。因此，它们 tend to evolve more quickly and be
    in a position to adapt and adhere to the transactions from the network. Similarly,
    event-driven applications will benefit from their low coupling to the other components
    of the system, and so are good candidates for this pattern.
- en: Considering reliability, availability, and serviceability
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑可靠性、可用性和可维护性
- en: The failure of software or hardware components is a fact of life for any industrial
    application, so you must design your application to be robust to failures and
    minimize the probability of downtime. We will discuss three key guidelines that
    are widely used in the industry to build and maintain systems, and briefly examine
    how they apply to an application built using Fabric or Composer tools.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 软件或硬件组件的故障对于任何工业应用来说都是不可避免的事实，因此您必须设计您的应用程序能够抵御故障并最大程度地减少停机的可能性。我们将讨论业界广泛使用的三个关键指导方针，以构建和维护系统，并简要审视它们如何适用于使用Fabric或Composer工具构建的应用程序。
- en: Reliability
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'A reliable system is one that ensures correct operation in the face of failure,
    with high probability. This entails the following things:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Continuous self-monitoring of the system
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of failure or corruption in a component
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the problem and/or failing over to a working component
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although various practices have evolved in the industry to ensure reliability,
    redundancy and failover are commonly (or even universally) used.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: In the context of a Fabric application of the kind we built in Section I, this
    has certain implications. Recall that Fabric has many different components that
    must work in concert (though in a loosely-coupled manner) to ensure successful
    operation. The ordering service is one such key component that, if it were to
    fail, would completely stall the transaction pipeline. Therefore, when building
    a production version of, say, our trade application, you must ensure that the
    orderer has enough redundancy built in. In practice, if your orderer is a Kafka
    cluster, this means ensuring that there are enough Kafka nodes (brokers) to take
    up the slack should one or more fail.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the reliability of peers for endorsement and commitment is key to
    ensuring transaction integrity. Although blockchains, being shared replicated
    ledgers, are designed to be somewhat robust to peer failures, their vulnerabilities
    may vary depending on the application. If an endorsing peer fails, and if its
    signature is necessary to satisfy the transaction endorsement policy, transaction
    requests cannot be created. If an endorsing peer misbehaves, and produces incorrect
    execution results, the transaction will fail to get committed. In either case,
    the throughput of the system will reduce or fall to zero. To prevent this from
    happening, you should ensure that there is adequate redundancy built into the
    set of peers within each organization, especially the ones that are key to satisfying
    an endorsement policy. The following diagram illustrates a possible mechanism
    whereby transaction proposals are made to multiple peers, and absent or incorrect
    responses are discarded using a majority rule:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48ae0c90-7c06-4f14-aa18-4ca441fb8a2e.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 Redundant peers for reliable transaction endorsement
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The level of reliability one gets from a system depends on the amount of resources
    devoted to monitoring and failover. For example, five peers in the preceding diagram
    are sufficient to counter two peer failures, but this now requires four more peers
    in the organization than what we used in our example network. To determine and
    ensure that your network yields the expected level of reliability, you will need
    to run integration tests on your complete system over a period of time.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The availability criterion is closely related to reliability, but it is more
    about ensuring system uptime with high probability, or as a corollary, minimizing
    the probability of system downtime. As with reliability, detection of failed nodes
    and ensuring adequate failover is the key to ensuring that your application will
    remain operational, even when one or more components fails. Determination of the
    desired availability level, allocating an adequate number of resources in the
    form of redundant and self-correcting components, and testing in a production
    environment are necessary to ensure that you get the desired performance from
    your application.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性标准与可靠性密切相关，但更多关乎确保系统的高概率运行时间，或作为推论，最小化系统停机的概率。与可靠性一样，检测故障节点并确保充足的故障转移是确保您的应用仍将正常运行的关键。确定所需的可用性水平，分配足够数量的冗余和自我纠正组件资源，并在生产环境中进行测试，是确保您的应用能够获得期望性能的必要条件。
- en: Serviceability
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: '**Serviceability** or **maintainability** is the ease with which you can replace
    or upgrade parts of your system without impacting the system as a whole.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**可维护性**或**易维护性**是指您可以在不影响整个系统的情况下更换或升级系统部件的便捷程度。'
- en: Consider a situation where you must upgrade the operating system on one or more
    of your ordering service nodes, or if you need to replace a faulty peer within
    an organization. As with reliability or availability, having redundant (or parallel)
    resources to which application operations can be switched seamlessly is the way
    to handle this in an industrial-scale system. So-called Blue-Green deployment
    is one of the popular mechanisms used for this purpose. In a nutshell, you have
    two parallel environments (let's say, for the ordering service), one called Blue
    and one called Green, where the Blue environment is receiving live traffic. You
    can upgrade the operating systems on the Green machines, test them adequately,
    and then switch the traffic from Blue to Green. Now, while Green is serving requests,
    you can upgrade Blue in the same manner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况：您必须在一个或多个订购服务节点上升级操作系统，或者需要在一个组织内替换一个有故障的节点。与可靠性或可用性一样，拥有冗余（或并行）资源，可以让应用操作无缝切换至这些资源，是处理工业规模系统中这类情况的方法。所谓的蓝绿部署是用于这个目的的一种流行机制之一。简而言之，您有两个平行环境（比如，对于订购服务），一个称为蓝色，一个称为绿色，其中蓝色环境正在接收实时流量。您可以升级绿色机器上的操作系统，充分测试它们，然后切换流量从蓝色到绿色。此时，绿色正在提供服务，您可以以同样的方式升级蓝色。
- en: In a blockchain application with loosely coupled components, it is advisable
    to have Blue and Green environments for each of the components (orderers, peers,
    and MSPs) and carry out the upgrades and testing in stages, or one component cluster
    at a time, to minimize the chances of a mishap.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有松散耦合组件的区块链应用中，建议为每个组件（订购者、节点和MSP）都提供蓝色和绿色环境，并分阶段进行升级和测试，或者一次只升级一个组件集群，以减小出错的机会。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Building a complete blockchain application is an ambitious and challenging project,
    not just because of the range of skills it requires—systems, networking, security,
    and web application development, to name a few—but because it requires concerted
    development, testing, and deployment by multiple organizations spanning multiple
    security domains.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个完整的区块链应用是一个雄心勃勃且具有挑战性的项目，不仅因为它需要各种技能——系统、网络、安全和web应用开发等，而且因为它需要跨越多个安全域的多个组织共同进行开发、测试和部署。
- en: In this chapter, we began with a simple smart contract and ended with a four-peer
    blockchain network that was ready to drive trade scenarios and store records in
    a tamper-resistant, shared, replicated ledger. In the process, we learned how
    to design an organization structure and configure a Fabric network. We learned
    how to build a channel, or an instance of a Fabric blockchain, get peers in a
    network to join the channel, and install and instantiate a smart contract on that
    channel, using the Fabric SDK. We learned how to expose the capabilities of our
    network and smart contract to end users through web applications, exposing service
    APIs. We also learned how a Hyperledger Fabric transaction pipeline works, and
    how the asynchronous nature of block commit operations must be factored into the
    implementation of the end-to-end application.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: In the latter part of the chapter, we learned about various design patterns
    and best practices that can be used to build industry-scale blockchain applications.
    We also learned about the considerations to keep in mind while integrating these
    applications with existing systems and processes. Finally, we explored the performance
    aspects of running operational Fabric network and learned about the CAP theorem
    and how Fabric achieves data consistency in distributed environment.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The Hyperledger platforms and tools will, no doubt, evolve over time to serve
    industry and developer needs, but the architecture and methodology we described
    in our application-building exercise, as well as the design and integration patterns,
    should continue to serve as an educational guide in the long term.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Our journey so far has taken us to the foundation of the Hyperledger Fabric
    framework. We have worked with chaincode and integrated an application using the
    Fabric SDK API. These are essential skills.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we will now explore a different approach to modeling
    and implementing a business network.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
