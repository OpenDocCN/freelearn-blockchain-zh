- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interview with Sam McArdle, Quantum Computing Researcher at the University of
    Oxford
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several previous chapters of this book, I have touched upon the barriers
    for quantum computing to go mainstream. One of the major barriers with quantum
    computing is the challenges with error correction. In a classical computer, bits
    have two states, "0" and "1." Therefore, error correction is a lot easier. In
    a quantum computer, qubits can exist in superpositions at any point in time during
    the calculation. As a result, it is harder to observe and correct their values
    without disrupting the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Error correction within quantum computing is a fascinating space and there are
    several techniques being explored. Hence, I wanted to dedicate one interview,
    and thus a chapter, to this topic. I met Sam McArdle at a quantum computing event
    at the University of Bristol. He made a presentation at the event on his research
    at the University of Oxford. The research focused on quantum error correction.
  prefs: []
  type: TYPE_NORMAL
- en: Sam's presentation at the event was fascinating, mainly because he simplified
    the narrative. He still got technical where he had to during the presentation,
    but it was clear that the audience were engaged in his speech and followed up
    with several interesting questions. That was in line with my way of looking at
    this technology. Despite the complexities within the Math and Physics of quantum
    computing, there is always room to keep it all simple from a use case perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, I reached out to Sam about the book and asked if he would be willing
    to be interviewed for it. I wanted to keep the focus of our interview on error
    correction and his research at the University of Oxford. Sam kindly agreed, and
    after a couple of email interactions, we managed to do a recorded interview session.
    The interview is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: We''re recording now. Thanks for making time, Sam.'
  prefs: []
  type: TYPE_NORMAL
- en: I recently had a chat with the CEO of a company who is creating quantum computing
    solutions for healthcare. He told me something that we all know about but don't
    quite put it the way he did.
  prefs: []
  type: TYPE_NORMAL
- en: It was that classical computers take a concept in Physics, use Math to translate
    it to computer-understandable code, and then replicate Physics based on the code.
    It takes three hops before it gets Physics to look like Physics on a classical
    computer. Quantum computers just naturally model Physics without as much translation.
    Therefore, there is less loss of information while simulating nature using quantum
    computers. It's interesting because we are here to discuss loss of information
    within quantum computers. Let's touch upon error correction in quantum computers
    and why that is different from error correction in a classical computing context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: Let''s first touch upon errors in the context of classical and quantum
    computers. In a classical machine, you have to consider "bit-flip" errors; the
    probabilistic flipping of a bit from zero to one. These are also present in a
    quantum computer. However, quantum computers also suffer from another type of
    error, called phase-flip errors, which also need to be corrected.'
  prefs: []
  type: TYPE_NORMAL
- en: These errors can be addressed using error correction techniques. In classical
    error correction code, we can take many copies of our bits and perform majority
    voting schemes. Therefore, you don't need much in the way of error correcting
    properties in classical computers, with the exception of hard drives and other
    things that are going to store memory for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: These have some redundancy built in, which stops the degradation of information
    over time as well, but their fault level is low. It's approximately one part in
    10^(15). In today's classical computers, we focus more on handling errors that
    occur programmatically. Therefore, in a classical computer, we don't really worry
    about error correction as a limitation.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a quantum computer is much more sensitive to the environment. Therefore,
    error correction is a lot more delicate. If it was approximately one part of 10^(15)
    in a classical hard drive, it is closer to one part in 10² or 10³ in the quantum
    computers we have now.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to run a calculation for a long time, you need to correct against
    imperfections arising from interaction with the environment. There are ways of
    doing this using quantum error code. It is another level of difficulty in the
    sense that, when we use classical error correcting code, you can just directly
    interrogate the information in your device. The most common one that people talk
    about is repetition code.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to store a single bit that is "0" or "1", you can just copy it three
    times. If there is an error, it is very unlikely that there are going to be two
    bits affected by it. One error is the most likely thing that's going to occur,
    in which case when you look at your three copy bits, two of them are still the
    same and one of them might have changed. You can majority vote. You can see what
    errors have occurred and fix them. It's different in a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum computing takes advantage of two main quantum effects: superposition
    and entanglement. Superposition is the famous Schrodinger''s cat type effect –
    the ability of particles to be in two places at once, or quantum bits (qubits)
    to be in a joint state of zero or one at the same time – with the outcome only
    being revealed upon measurement. Entanglement can be loosely defined as a stronger-than-classical
    correlation between two particles, whereby it doesn''t really make sense to think
    of the two systems that are entangled as individual entities anymore. These two
    effects can be combined to give quantum computers their touted advantage over
    their classical counterparts.'
  prefs: []
  type: TYPE_NORMAL
- en: However, quantum information is delicate, and these same effects can become
    rather damaging. In a quantum computer, error correction gets more difficult because
    you can't copy information across and you can't directly interrogate the quantum
    bits, because that would reveal in what state they are and interrupt your whole
    calculation. You have to be smarter about how to interrogate the system to try and
    learn what errors have occurred and find ways to correct those.
  prefs: []
  type: TYPE_NORMAL
- en: Our quantum computer has to sit in some kind of environment. The qubits in the
    computer interact with the environment. This manifests as a degradation of our
    quantum state, essentially forcing it to decay back to a classical state. Even
    though experimentalists try to shield their quantum computers from the environment
    (by keeping them at low temperatures, encased in vacuums, and/or shielded from
    magnetic fields), error rates are still much larger than one would find in a classical
    computer. Consequently, without any protection from errors, the quantum nature
    of the system will quickly decay away.
  prefs: []
  type: TYPE_NORMAL
- en: We can provide a level of protection for our quantum systems using error correcting
    code. Loosely speaking, this represents the logical zero and one states of a qubit
    by encoding them in a highly entangled state that is spread over many qubits.
    We can make cleverly designed checks on our qubits that won't tell us exactly
    what the state is, but can at least tell us if certain errors have occurred, where
    they are, and how to correct them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: Interesting. Thanks for that. Can we discuss a few approaches that
    we have today for quantum error connection? What are the most common and the most
    popular ones?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: The primary approach used for error correction is based on code. Most
    code that people are trying to experimentally realize across the world, can be
    described by the *Stabilizer formalism*. It is essentially a mathematical formalism
    that nicely encapsulates how your code behaves. It gives you good ways to describe
    code behavior and makes it easier to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: The *Stabilizer fo**rmalism* has led to a bunch of good code, some of which
    is more experimentally accessible than other code. A widely studied code is known
    as *surface code*, which is a little different to some other ones as it has topological
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: It depends on the topology of surfaces. The appealing thing about *surface code*
    is that you can realize it just with an array of qubits laid out in a grid with
    nearest neighbor interactions. If you're trying to build your quantum computer
    with solid state qubits, superconducting ones or silicon, that is a very attractive
    architecture because that's kind of the natural interactions for your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other useful thing about the surface code is that it has got a very high
    *threshold of the code*. At this point you say: *This is the physical error rate
    in my system*. And the threshold says: *If I can get that error rate below a certain
    value, then I can make my code bigger. I can keep making the overall error rate
    in the computer lower*. Then error correction becomes effective. If you''re above
    that threshold, it doesn''t make sense to do a correction that''s going to make
    everything worse.'
  prefs: []
  type: TYPE_NORMAL
- en: Notably, at the error rates that people are achieving in their hardware systems,
    it gives hope that if those systems can be scaled up while the quality stays high,
    that kind of code might be experimentally realized. Error rates that some research
    groups are achieving in their hardware systems are now comparable to our estimates
    of the surface code threshold.
  prefs: []
  type: TYPE_NORMAL
- en: If these systems can be scaled up while maintaining these error rates, then
    this may be a promising route towards large scale quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: Thank you, that an interesting overview on the about surface code.
    We''ve also come across NISQ computing. Why is that important from a quantum error
    correction perspective? What are the future possibilities using NISQ?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: NISQ stands for Noisy Intermediate Scale Quantum computing. In the
    era we''re in now, we have small quantum computers. If you want to do error correction,
    you need much larger ones. In a fault-tolerant quantum computer, you will generally
    have thousands of physical qubits for error correction. If you want to implement
    the surface code, you might need a thousand physical qubits to encode one error-corrected
    logical qubit.'
  prefs: []
  type: TYPE_NORMAL
- en: A logical question to ask would be, *why don't we do calculations on the noisy
    qubits we have*? If you're going to do that, the algorithms that you run can't be
    too long. If you run them for a long time, there's more chance that errors build
    up and ruin your calculation.
  prefs: []
  type: TYPE_NORMAL
- en: With NISQ, you don't do any error correction; you just run your algorithm. This may
    work well in use cases like chemistry simulation.
  prefs: []
  type: TYPE_NORMAL
- en: However, in such scenarios, the algorithm runs with much shorter circuits. When
    qubits are noisy, the coherence time is low. Shorter circuits typically have lower
    computation time that can arrive at the results quicker with fewer errors.
  prefs: []
  type: TYPE_NORMAL
- en: NISQ takes a very different approach to that of quantum error correction. NISQ
    normally involves trading one long circuit for lots of repetitions of much smaller
    ones. After each repetition, you re-initialize the system.
  prefs: []
  type: TYPE_NORMAL
- en: If the quantum circuit that you apply is short, then one might hope that the
    circuit could be implemented before errors are able to accumulate. As such, to
    do a calculation involving 100 qubits, you just do the calculation with the 100
    noisy qubits that are available, rather than trying to encode 100 error-corrected
    qubits into 100,000 noisy qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, a 100-qubit machine will be easier to build than a 100,000 qubit one,
    but in order to make the NISQ proposal realizable, algorithms must work with short
    circuits.
  prefs: []
  type: TYPE_NORMAL
- en: NISQ algorithms have been developed for problems in chemistry, machine learning,
    optimization, and a range of other problems. However, one issue is that it is
    difficult to show that a NISQ algorithm will possess any advantage over the classical
    algorithms we currently use.
  prefs: []
  type: TYPE_NORMAL
- en: There is ongoing research to demonstrate that circuits can be made small enough
    to lessen the effects of noise. While error mitigation techniques have been proposed
    that can aid in achieving this goal, there is still a lot of work before we can
    get to noise-tolerant short circuits. As such, the next few years will be very
    interesting in this space, as groups around the world develop larger NISQ machines
    (50 to 100 physical qubits) that can test these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: There is a hybrid approach towards NISQ where the quantum computer does something
    that's hard classically and the classical computer does something that it finds
    easy – like an optimization subroutine. You iterate through this process and that
    helps you to solve the problem you're trying to deal with, whether that's machine
    learning, or optimization, or chemistry.
  prefs: []
  type: TYPE_NORMAL
- en: There are error mitigation techniques that work by just taking more data than
    you would need naturally to solve the problem and then combining it in clever
    ways, effectively taking an average that allows you to cancel out some of the
    noise. These techniques can be very useful. They may play a key role in deriving
    us anything useful out of these NISQ quantum computers. But they are also not
    a substitute for error correction in the long term. They can only tolerate small
    amounts of noise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: Conceptually, this is similar to the evolution of cloud computing
    – particularly Amazon Web Services (AWS). In the initial days of AWS, the allocation
    of resources on their infrastructure was done based on low time utilization and
    then almost became a new business model altogether. Let us move on to the next
    point of discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a strong argument that quantum computers may not go mainstream for
    at least another 10 years. If quantum computing gets through some of its major
    hurdles in the next 5 to 10 years, even then I think some of the hybrid solutions
    like digital annealers could still be relevant. The cost involved in going mainstream
    with quantum computers would still be high. But then, in hopefully 15 to 20 years,
    an acceleration could happen to make the cost benefits of quantum infrastructure
    more attractive.
  prefs: []
  type: TYPE_NORMAL
- en: Are there any particular subjects of research that you are closely following?
    Any areas you think will help accelerate the field of quantum computing?
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: On the one hand, experimental groups are trying to implement these
    error correction procedures. That involves computer modeling of routines they''re
    going to implement, to model what the types of errors are, and the best ways to
    overcome those.'
  prefs: []
  type: TYPE_NORMAL
- en: When you introduce this code, you are introducing additional overheads for the
    computation. There are scientists who work on trying to find more resource-efficient
    ways to implement a given algorithm in certain code. There has been a lot of work
    done on that recently, which has reduced the overhead (of error correction). Some
    of these calculations are within the field of chemistry.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are a lot of researchers who will research more exotic
    varieties of code. Rather than the ones that are already in existence, they'll
    look at new varieties that people haven't studied as much before. They hope that
    they may have some advantages in terms of how the algorithms can be expressed
    in that code or if it's better at correcting errors, or if it's more suited to
    a certain type of hardware than other types of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: That''s definitely an interesting insight. I do hope that all the
    hard work converges to something meaningful. What would some success in this space
    do to quantum computing applications in industrial scenarios?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: While there is currently hope that NISQ algorithms may lead to useful
    applications of quantum computers within the next few years, this is currently
    unproven, and will require testing on real hardware systems as they become available.
    In order to run the provably fast algorithms developed for chemistry, machine
    learning, optimization, or cryptography, it is expected that quantum error correction
    will be necessary, as the circuits required are long.'
  prefs: []
  type: TYPE_NORMAL
- en: As such, new developments in quantum error correction will hopefully reduce
    the resources required to implement useful algorithms. This includes both the
    spatial resources (the number of qubits required, which determines how hard it
    is to build the quantum computer) and the time resources (how long the algorithm
    takes to run).
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in the former of these metrics will mean that useful quantum computers
    will become available for industrial applications sooner. Improvements in the
    latter mean that quantum algorithms could become competitive with their classical
    counterparts for smaller problem sizes, again meaning that they may find use in
    the nearer term.
  prefs: []
  type: TYPE_NORMAL
- en: As such, improvements in quantum error correction techniques should be considered
    just as important as both algorithmic advances, and hardware developments, as
    a step toward the goal of realizing industrially useful quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: Great. We will close off with one last question. There are several
    industrial scenarios that quantum computers can be useful in. There is huge potential
    within logistics, and portfolio rebalancing within financial services is interesting
    too. There are a lot of possibilities. What are the use cases that you can think
    of and is there anything in particular that excites you?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sam**: The ones you''ve mentioned are good applications, in the sense that
    people have done a lot of research into solving machine learning problems, optimization
    problems, and problems in finance in general. The simulation of physical systems
    using quantum computers interests me.'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers may be interesting in the pharmaceutical industry in trying
    to work out how a drug is going to work. If you offered them the opportunity to
    take a molecule, look at it in a computer, and work out how it is going to interact
    with other molecules. That could be important to them.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you're a big materials company, you do things with catalysts.
    A study of how a catalyst reacts with chemicals and speeds up the reaction is
    a good area. Industries that are focused on coming up with new materials that
    can withstand certain challenges can look at quantum computing solutions, too.
    For instance, batteries for electric cars are an example of where the best material
    to be used for energy efficiency and fast recharge may be researched using quantum
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: An area of focus is the simulation of a molecule that is present in bacteria
    that are able to use nitrogen in the atmosphere to produce fertilizers. This process
    happens in nature in ambient pressure and temperature. The industrial process
    we have today for fertilizer production is energy-intensive. There has been research
    to determine whether error-corrected quantum computers can aid in the simulation
    of this molecule, which may provide novel insights into this process.
  prefs: []
  type: TYPE_NORMAL
- en: If you could learn how that nitrogen-converting bacteria works and replicate
    its behavior, that could be a huge energy saving that is really useful for the
    world. Similarly, there are range of chemical materials that we would love to
    understand better, but we can't just yet. With quantum computers, we may be able
    to simulate those systems and that's going to give us a whole new understanding
    of materials system, and ultimately may even allow us to design our own molecules
    with the properties that we want them to have.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arun**: Thank you very much for that, Sam. On that high note, let''s close
    the interview.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have so far been focusing on industrial applications of quantum computing
    in all our interviews. We have touched upon applications in financial services,
    healthcare, smart cities, and even politics. The interview with Sam had a different
    focus, and that was deliberate. I wanted to focus on one of the key barriers for
    quantum computing going mainstream – high error rates.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed why error correction in a quantum computer is harder than in a
    classical computer. The superposition property of qubits makes it harder for us
    to capture their states. When we observe qubits, their states collapse. These
    properties of quantum computers make them useful in solving complex algorithms
    and make information on quantum computers more secure. However, they also make
    error correction harder as we cannot observe or copy over the information easily.
  prefs: []
  type: TYPE_NORMAL
- en: We touched upon techniques like using shorter circuits and using certain code
    for certain algorithms and NISQ in detail in this chapter. Sam brought these complex
    concepts to life with a simplified articulation. He described error correcting
    of the methods and touched upon the impact some of the breakthroughs could have
    on quantum computing. We also discussed applications that are possible when error correction
    within quantum computers is no longer such a big barrier. For instance, modeling
    Nitrogen fixation in computers can help the world in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are able to simulate the Nitrogen fixation process that happens in nature
    using quantum computers, we will be able to understand better the feasibility
    of replicating it in an industrial scenario. That could save energy and cut carbon
    emissions. There are many such applications that could have big impact on our
    lives and our planet.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the field of error correction within quantum computers is vast enough
    for a whole book in itself. However, I wanted to provide an overview with inputs
    from a specialist in the field and bring to life the opportunities in the field
    of error correction.
  prefs: []
  type: TYPE_NORMAL
