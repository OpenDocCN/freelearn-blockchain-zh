- en: Understanding Decentralized Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解去中心化应用
- en: Almost all of the Internet-based applications we have been using are centralized,
    that is, the servers of each application are owned by a particular company or
    person. Developers have been building centralized applications and users have
    been using them for a pretty long time. But there are a few concerns with centralized
    applications that make it next to impossible to build certain types of apps and
    every app ends up having some common issues. Some issues with centralized apps
    are that they are less transparent, they have a single point of failure, they
    fail to prevent net censorship, and so on. Due to these concerns, a new technology
    emerged for the building of Internet-based apps called **decentralized applications**
    (**DApps**). In this chapter, we will learn about decentralized apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的几乎所有基于互联网的应用都是集中式的，即每个应用的服务器都由特定公司或个人拥有。开发者一直在构建集中式应用，用户也一直在使用它们很长时间。但是集中式应用存在一些问题，使得几乎不可能构建某些类型的应用程序，并且每个应用程序最终都会有一些共同的问题。集中式应用的一些问题是较不透明，具有单一故障点，未能防止网络审查等等。由于这些问题，出现了一种新技术用于构建基于互联网的应用程序，称为**去中心化应用**（**DApps**）。在本章中，我们将了解去中心化应用。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are DApps?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 DApp？
- en: What is the difference between decentralized, centralized, and distributed applications?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化、集中化和分布式应用之间有什么区别？
- en: Advantages and disadvantages of centralized and decentralized applications.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式和去中心化应用的优缺点。
- en: An overview of the data structures, algorithms, and protocols used by some of
    the most popular DApps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些最流行的 DApp 使用的数据结构、算法和协议概述
- en: Learning about some popular DApps that are built on top of other DApps.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一些建立在其他 DApps 之上的热门 DApps。
- en: What is a DApp?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 DApp？
- en: A DApp is a kind of Internet application whose backend runs on a decentralized
    peer-to-peer network and its source code is open source. No single node in the
    network has complete control over the DApp.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DApp 是一种后端运行在去中心化对等网络上的互联网应用，其源代码是开源的。网络中的没有一个单一节点对 DApp 拥有完全控制权。
- en: Depending on the functionality of the DApp, different data structures are used
    to store application data. For example, the Bitcoin DApp uses the blockchain data
    structure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 DApp 的功能不同，使用不同的数据结构来存储应用数据。例如，比特币 DApp 使用区块链数据结构。
- en: These peers can be any computer connected to the Internet; therefore, it becomes
    a big challenge to detect and prevent peers from making invalid changes to the
    application data and sharing wrong information with others. So we need some sort
    of consensus between the peers regarding whether the data published by a peer
    is right or wrong. There is no central server in a DApp to coordinate the peers
    and decide what is right and wrong; therefore, it becomes really difficult to
    solve this challenge. There are certain protocols (specifically called consensus
    protocols) to tackle this challenge. Consensus protocols are designed specifically
    for the type of data structure the DApp uses. For example, Bitcoin uses the proof-of-work
    protocol to achieve consensus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对等体可以是任何连接到互联网的计算机；因此，检测和防止对等体对应用数据进行无效更改并与他人共享错误信息变成一项重大挑战。因此，我们需要对等体之间就发布的数据是正确还是错误达成共识。在
    DApp 中没有中央服务器来协调对等体并决定什么是对什么是错；因此，解决这个挑战变得非常困难。有一些协议（专门称为共识协议）来解决这个挑战。共识协议是专门为
    DApp 使用的数据结构设计的。例如，比特币使用工作量证明协议来达成共识。
- en: Every DApp needs a client for the user to use the DApp. To use a DApp, we first
    need a node in the network by running our own node server of the DApp and then
    connecting the client to the node server. Nodes of a DApp provide an API only
    and let the developer community develop various clients using the API. Some DApp
    developers officially provide a client. Clients of DApps should be open source
    and should be downloaded for use; otherwise, the whole idea of decentralization
    will fail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 DApp 都需要一个客户端供用户使用。为了使用 DApp，我们首先需要通过运行自己的节点服务器来连接客户端到节点服务器。DApp 的节点仅提供一个
    API 并让开发者社区使用 API 开发各种客户端。一些 DApp 开发者正式提供客户端。DApps 的客户端应该是开源的，应该可以下载使用；否则，去中心化的整个概念将失败。
- en: But this architecture of a client is cumbersome to set up, especially if the
    user is a non-developer; therefore, clients are usually hosted and/or nodes are
    hosted as a service to make the process of using a DApp easier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，客户端体系结构设置是繁琐的，特别是对于非开发人员的用户；因此，客户端通常是托管的，和/或节点作为服务托管，以使使用 DApp 的过程更加简单。
- en: '**What are distributed applications?**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是分布式应用程序？**'
- en: Distributed applications are those applications that are spread across multiple
    servers instead of just one. This is necessary when application data and traffic
    becomes huge and application downtime is not affordable. In distributed applications,
    data is replicated among various servers to achieve high availability of data.
    Centralized applications may or may not be distributed, but decentralized applications
    are always distributed. For example, Google, Facebook, Slack, Dropbox, and so
    on are distributed, whereas a simple portfolio site or a personal blog are not
    usually distributed until traffic is very high.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序是那些分布在多个服务器上而不仅仅是一个的应用程序。当应用程序数据和流量变得巨大且应用程序的停机时间是不可承受的时，就必须采用分布式应用程序。在分布式应用程序中，数据在各个服务器之间复制，以实现数据的高可用性。中心化应用程序可能是分布式的，也可能不是，但去中心化应用程序总是分布式的。例如，谷歌、Facebook、Slack、Dropbox
    等都是分布式的，而简单的投资组合网站或个人博客通常在流量非常高时才会被分布。
- en: Advantages of decentralized applications
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化应用程序的优势
- en: 'Here are some of the advantages of decentralized applications:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是去中心化应用程序的一些优势：
- en: DApps are fault-tolerant as there is no single point of failure because they
    are distributed by default.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DApps 具有容错性，因为它们默认情况下是分布式的，没有单点故障。
- en: They prevent violation of net censorship as there is no central authority to
    whom the government can pressurize to remove some content. Governments cannot
    even block the app's domain or IP address as DApps are not accessed via a particular
    IP address or domain. Obviously the government can track individual nodes in the
    network by their IP address and shut them down, but if the network is huge, then
    it becomes next to impossible to shut down the app, especially if the nodes are
    distributed among various different countries.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以防止网络审查的侵犯，因为没有中央机构可以被政府施压去除一些内容。政府甚至无法屏蔽应用程序的域名或 IP 地址，因为 DApps 不是通过特定的
    IP 地址或域名访问的。显然，政府可以通过 IP 地址追踪网络中的个别节点并关闭它们，但如果网络很庞大，那么关闭应用程序将变得几乎不可能，特别是如果节点分布在不同国家。
- en: It is easy for users to trust the application as it's not controlled by a single
    authority that could possibly cheat the users for profit.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户很容易信任该应用程序，因为它不受可能出于利润目的欺骗用户的单一权威机构的控制。
- en: Disadvantages of decentralized applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化应用程序的缺点
- en: 'Obviously, every system has some advantages and disadvantages. Here are some
    of the disadvantages of decentralized applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个系统都有一些优点和缺点。以下是去中心化应用程序的一些缺点：
- en: Fixing bugs or updating DApps is difficult, as every peer in the network has
    to update their node software.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误或更新 DApps 非常困难，因为网络中的每个对等体都必须更新其节点软件。
- en: Some applications require verification of user identity (that is, KYC), and
    as there is no central authority to verify the user identity, it becomes an issue
    while developing such applications.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些应用程序需要验证用户身份（即 KYC），由于没有中央机构来验证用户身份，因此在开发此类应用程序时会成为一个问题。
- en: They are difficult to build because they use very complex protocols to achieve
    consensus and they have to be built to scale from the start itself. So we cannot
    just implement an idea and then later on add more features and scale it.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们难以构建，因为它们使用非常复杂的协议来实现共识，并且必须从一开始就构建以适应规模。因此，我们不能只是实现一个想法，然后稍后添加更多功能并扩展它。
- en: Applications are usually independent of third-party APIs to get or store something.
    DApps shouldn't depend on centralized application APIs, but DApps can be dependent
    on other DApps. As there isn't a large ecosystem of DApps yet, it is difficult
    to build a DApp. Although DApps can be dependent on other DApps theoretically,
    it is very difficult to tightly couple DApps practically.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序通常独立于第三方 API 来获取或存储内容。DApps 不应依赖于中心化的应用程序 API，但 DApps 可能依赖于其他 DApps。由于目前还没有一个庞大的
    DApps 生态系统，因此构建 DApp 非常困难。尽管理论上 DApps 可能依赖于其他 DApps，但在实际上紧密耦合 DApps 却非常困难。
- en: Decentralized autonomous organization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化自治组织
- en: Typically, signed papers represent organizations, and the government has influence
    over them. Depending on the type of organization, the organization may or may
    not have shareholders.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，签署的文件代表组织，并且政府对其有影响力。根据组织的类型，该组织可能有或没有股东。
- en: '**Decentralized autonomous organization** (**DAO**) is an organization that
    is represented by a computer program (that is, the organization runs according
    to the rules written in the program), is completely transparent, and has total
    shareholder control and no influence of the government.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**分散自治组织**（**DAO**）是由计算机程序代表的组织（也就是说，组织按照程序中编写的规则运行），完全透明，由股东完全控制，且不受政府影响。'
- en: To achieve these goals, we need to develop a DAO as a DApp. Therefore, we can
    say that DAO is a subclass of DApp.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些目标，我们需要开发一个 DAO 作为 DApp。因此，我们可以说 DAO 是 DApp 的子类。
- en: Dash, and the DAC are a few example of DAOs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Dash 和 DAC 是 DAO 的几个示例。
- en: '**What is a decentralized autonomous corporation (DAC)?** There is still no
    clear difference between DAC and DAO. Many people consider them to be the same
    whereas some people define DAC as DAO when DAO is intended to make profits for
    shareholders.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是分散自治公司（DAC）？** 目前仍然没有明确区分 DAC 和 DAO 的差异。许多人认为它们是相同的，而有些人将 DAC 定义为 DAO，当
    DAO 旨在为股东赚取利润时。'
- en: User identity in DApps
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DApps 中的用户身份
- en: One of the major advantages of DApps is that it generally guarantees user anonymity.
    But many applications require the process of verifying user identity to use the
    app. As there is no central authority in a DApp, it become a challenge to verify
    the user identity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: DApps 的一个主要优点是它通常保证用户匿名性。但许多应用程序需要验证用户身份才能使用该应用程序。由于 DApp 中没有中央权威，验证用户身份成为一项挑战。
- en: In centralized applications, humans verify user identity by requesting the user
    to submit certain scanned documents, OTP verification, and so on. This process
    is called **know your customer** (**KYC**). But as there is no human to verify
    user identity in DApps, the DApp has to verify the user identity itself. Obviously
    DApps cannot understand and verify scanned documents, nor can they send SMSes;
    therefore, we need to feed them with digital identities that they can understand
    and verify. The major problem is that hardly any DApps have digital identities
    and only a few people know how to get a digital identity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式应用程序中，人们通过请求用户提交某些扫描文档、OTP 验证等方式来验证用户身份。这个过程称为**了解您的客户**（**KYC**）。但是在 DApps
    中没有人来验证用户身份，DApp 必须自行验证用户身份。显然，DApps 无法理解和验证扫描文档，也无法发送短信；因此，我们需要为它们提供可以理解和验证的数字身份。主要问题在于几乎没有
    DApps 有数字身份，只有少数人知道如何获得数字身份。
- en: There are various forms of digital identities. Currently, the most recommended
    and popular form is a digital certificate. A digital certificate (also called
    a public key certificate or identity certificate) is an electronic document used
    to prove ownership of a public key. Basically, a user owns a private key, public
    key, and digital certificate. The private key is secret and the user shouldn't
    share it with anyone. The public key can be shared with anyone. The digital certificate
    holds the public key and information about who owns the public key. Obviously,
    it's not difficult to produce this kind of certificate; therefore, a digital certificate
    is always issued by an authorized entity that you can trust. The digital certificate
    has an encrypted field that's encrypted by the private key of the certificate
    authority. To verify the authenticity of the certificate, we just need to decrypt
    the field using the public key of the certificate authority, and if it decrypts
    successfully, then we know that the certificate is valid.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数字身份有各种形式。目前，最推荐和流行的形式是数字证书。数字证书（也称为公钥证书或身份证书）是用于证明公钥所有权的电子文档。基本上，用户拥有私钥、公钥和数字证书。私钥是秘密的，用户不应该与任何人分享。公钥可以与任何人分享。数字证书包含公钥和关于谁拥有该公钥的信息。显然，生成此类证书并不困难；因此，数字证书始终由您可以信任的授权实体颁发。数字证书具有一个由证书颁发机构的私钥加密的字段。要验证证书的真实性，我们只需使用证书颁发机构的公钥解密该字段，如果解密成功，则我们知道该证书是有效的。
- en: Even if users successfully get digital identities and they are verified by the
    DApp, there is a still a major issue; that is, there are various digital certificate
    issuing authorities, and to verify a digital certificate, we need the public key
    of the issuing authority. It is really difficult to include the public keys of
    all the authorities and update/add new ones. Due to this issue, the procedure
    of digital identity verification is usually included on the client side so that
    it can be easily updated. Just moving this verification procedure to the client
    side doesn't completely solve this issue because there are lots of authorities
    issuing digital certificates and keeping track of all of them, and adding them
    to the client side, is cumbersome.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户成功获取了数字身份并且它们由 DApp 验证，仍然存在一个主要问题；那就是，存在各种数字证书颁发机构，要验证数字证书，我们需要颁发机构的公钥。要包括所有颁发机构的公钥并更新/添加新的公钥是非常困难的。由于这个问题，数字身份验证程序通常包含在客户端，以便可以轻松更新。将此验证程序移到客户端并不能完全解决这个问题，因为有很多机构颁发数字证书，并跟踪所有机构，并将它们添加到客户端是繁琐的。
- en: '**Why do users not verify each other''s identity?**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么用户不互相验证身份？**'
- en: Often, while we do trading in real life, we usually verify the identity of the
    other person ourselves or we bring in an authority to verify the identity. This
    idea can be applied to DApps as well. Users can verify each other's identity manually
    before performing trade with each other. This idea works for specific kinds of
    DApps, that is, for DApps in which people trade with each other. For example,
    if a DApp is a decentralized social network, then obviously a profile cannot be
    verified by this means. But if the DApp is for people to buy/sell something, then
    before making a payment, the buyer and seller can both verify each other's identity.
    Although this idea may seem fine while doing trading, when you think practically,
    it becomes very difficult because you may not want to do identity verification
    every time you trade and everyone not knows how to do identity verification. For
    example, if the DApp is a cab-booking app, then you will obviously not want to
    perform identity verification before booking a cab every time. But if you trade
    sometimes and you know how to verify identity, then it's fine to follow this procedure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中进行交易时，我们通常会自行验证对方的身份，或者请权威机构来验证身份。这个想法也可以应用于 DApps。用户可以在彼此进行交易之前手动验证对方的身份。这个想法适用于特定类型的
    DApps，即那些人们在其中互相交易的 DApps。例如，如果一个 DApp 是一个去中心化的社交网络，那么显然无法通过这种方式验证个人资料。但如果 DApp
    是用于人们买卖东西的，那么在付款之前，买家和卖家都可以验证对方的身份。虽然在交易时这个想法看起来不错，但实际上思考一下就会发现，这变得非常困难，因为你可能不想每次交易都进行身份验证，而且不是每个人都知道如何进行身份验证。例如，如果一个
    DApp 是一个打车应用程序，那么显然你不会希望每次预订车辆之前都进行身份验证。但如果你偶尔进行交易并且知道如何验证身份，那么遵循这个流程是可以的。
- en: Due to these issues, the only option we are currently left with is verifying
    user identity manually by an authorized person of the company that provides the
    client. For example, to create a Bitcoin account, we don't need an identification,
    but while withdrawing Bitcoin to flat currency, the exchanges ask for proof of
    identification. Clients can omit the unverified users and not let them use the
    client. And they can keep the client open for users whose identity has been verified
    by them. This solution also ends up with minor issues; that is, if you switch
    the client, you will not find the same set of users to interact with because different
    clients have different sets of verified users. Due to this, all users may decide
    to use a particular client only, thus creating a monopoly among clients. But this
    isn't a major issue because if the client fails to properly verify users, then
    users can easily move to another client without losing their critical data, as
    they are stored as decentralized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，我们当前唯一的选择是由提供客户端的公司的授权人员手动验证用户身份。例如，创建比特币帐户时不需要身份证明，但是在将比特币提取到法定货币时，交易所会要求身份证明。客户端可以忽略未经验证的用户，并不让他们使用客户端。他们可以为已由他们验证身份的用户保持客户端开放。这种解决方案也会出现一些小问题；也就是说，如果您更换客户端，您将无法找到相同的一组用户进行交互，因为不同的客户端具有不同的已验证用户集。由于这个原因，所有用户可能决定只使用一个特定的客户端，从而在客户端之间产生垄断。但这并不是一个主要问题，因为如果客户端未能正确验证用户，那么用户可以轻松地切换到另一个客户端，而不会丢失关键数据，因为它们被存储为去中心化。
- en: The idea of verifying user identity in applications is to make it difficult
    for users to escape after performing some sort of fraudulent activity, preventing
    users with a fraud/criminal background from using the application, and providing
    the means for other users in the network to believe a user to be whom the user
    is claiming to be. It doesn't matter what procedure is used to verify user identity;
    they are always ways for users to represent themselves to be someone else. It
    doesn't matter whether we use digital identities or scanned documents for verification
    because both can be stolen and reused. What's important is just to make it difficult
    for users to represent themselves to be someone else and also collect enough data
    to track a user and prove that the user has done a fraudulent activity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中验证用户身份的想法是为了让用户在执行某种欺诈活动后难以逃脱，防止具有欺诈/犯罪背景的用户使用应用程序，并为网络中的其他用户提供相信用户是其声称的身份的手段。无论使用什么程序来验证用户身份，用户都有办法将自己代表成其他人。无论我们使用数字身份还是扫描文档进行验证都无关紧要，因为两者都可以被盗用和重复使用。重要的是要让用户难以将自己代表成其他人，并收集足够的数据来追踪用户并证明用户进行了欺诈活动。
- en: User accounts in DApps
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DApps 中的用户账户
- en: Many applications need user accounts' functionality. Data associated with an
    account should be modifiable by the account owner only. DApps simply cannot have
    the same username- and password-based account functionality as do centralized
    applications because passwords cannot prove that the data change for an account
    has been requested by the owner.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要用户账户的功能。与账户相关的数据应仅由账户所有者修改。DApps 不能像中心化应用程序一样拥有基于用户名和密码的账户功能，因为密码无法证明账户数据变更是由所有者请求的。
- en: There are quite a few ways to implement user accounts in DApps. But the most
    popular way is using a public-private key pair to represent an account. The hash
    of the public key is the unique identifier of the account. To make a change to
    the account's data, the user needs to sign the change using his/her private key.
    We need to assume that users will store their private keys safely. If users lose
    their private keys, then they lose access to their account forever.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以在 DApp 中实现用户账户。但最流行的方法是使用公私钥对来表示账户。公钥的哈希是账户的唯一标识符。要更改账户数据，用户需要使用他/她的私钥签署更改。我们需要假设用户会安全地存储他们的私钥。如果用户丢失了他们的私钥，那么他们将永远无法访问自己的账户。
- en: Accessing the centralized apps
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问中心化应用程序
- en: A DApp shouldn't depend on centralized apps because of a single point of failure.
    But in some cases, there is no other option. For example, if a DApp wants to read
    a football score, then where will it get the data from? Although a DApp can depend
    on another DApp, why will FIFA create a DApp? FIFA will not create a DApp just
    because other DApps want the data. This is because a DApp to provide scores is
    of no benefit as it will ultimately be controlled by FIFA completely.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单点故障，DApp 不应依赖于中心化应用程序。但在某些情况下，别无选择。例如，如果一个 DApp 想要读取足球比分，那么它将从哪里获取数据？尽管一个
    DApp 可以依赖于另一个 DApp，但 FIFA 为什么会创建一个 DApp 呢？FIFA 不会仅因为其他 DApps 需要数据而创建一个 DApp。这是因为提供比分的
    DApp 毫无益处，因为它最终将完全由 FIFA 控制。
- en: So in some cases, a DApp needs to fetch data from a centralized application.
    But the major problem is how the DApp knows that the data fetched from a domain
    is not tampered by a middle service/man and is the actual response. Well, there
    are various ways to resolve this depending on the DApp architecture. For example,
    in Ethereum, for the smart contracts to access centralized APIs, they can use
    the Oraclize service as a middleman as smart contracts cannot make direct HTTP
    requests. Oraclize provides a TLSNotary proof for the data it fetches for the
    smart contract from centralized services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，DApp 需要从中心化应用程序获取数据。但主要问题是 DApp 如何知道从域中获取的数据没有被中间服务/人篡改，而是实际的响应。嗯，根据
    DApp 的架构，有各种解决方法。例如，在以太坊中，为了让智能合约访问中心化的 API，它们可以使用 Oraclize 服务作为中间人，因为智能合约不能直接进行
    HTTP 请求。Oraclize 为智能合约从中心化服务获取的数据提供了 TLSNotary 证明。
- en: Internal currency in DApps
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DApps 中的内部货币
- en: For a centralized application to sustain for a long time, the owner of the app
    needs to make a profit in order to keep it running. DApps don't have an owner,
    but still, like any other centralized app, the nodes of a DApp need hardware and
    network resources to keep it running. So the nodes of a DApp need something useful
    in return to keep the DApp running. That's where internal currency comes into
    play. Most DApps have a built-in internal currency, or we can say that most successful
    DApps have a built-in internal currency.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个中心化的应用程序来说，要长期维持下去，应用程序的所有者需要盈利才能保持其运行。DApps 没有所有者，但是像任何其他中心化应用程序一样，DApp
    的节点需要硬件和网络资源来保持其运行。因此，DApp 的节点需要得到一些有用的回报来维持 DApp 的运行。这就是内部货币发挥作用的地方。大多数 DApps
    都有内置的内部货币，或者我们可以说大多数成功的 DApps 都有内置的内部货币。
- en: The consensus protocol is what decides how much currency a node receives. Depending
    on the consensus protocol, only certain kinds of nodes earn currency. We can also
    say that the nodes that contribute to keeping the DApp secure and running are
    the ones that earn currency. Nodes that only read data are not rewarded with anything.
    For example, in Bitcoin, only miners earn Bitcoins for successfully mining blocks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议决定节点获得多少货币。根据共识协议，只有某些类型的节点才能获得货币。我们还可以说，贡献于保持 DApp 安全运行的节点是获得货币的节点。只读取数据的节点不会得到任何奖励。例如，在比特币中，只有矿工成功挖掘区块才能获得比特币。
- en: The biggest question is since this is a digital currency, why would someone
    value it? Well, according to economics, anything that has demand and whose supply
    is insufficient will have value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的问题是，由于这是一种数字货币，为什么有人会看重它？嗯，根据经济学的观点，任何有需求但供应不足的东西都会有价值。
- en: Making users pay to use the DApp using the internal currency solves the demand
    problem. As more and more users use the DApp, the demand also increases and, therefore,
    the value of the internal currency increases as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用内部货币让用户付费使用 DApp 可以解决需求问题。随着越来越多的用户使用 DApp，需求也会增加，因此内部货币的价值也会相应增加。
- en: Setting a fixed amount of currency that can be produced makes the currency scarce,
    giving it a higher value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设定一个固定数量的可生产货币使货币变得稀缺，从而提高其价值。
- en: The currency is supplied over time instead of supplying all the currency at
    a go. This is done so that new nodes that enter the network to keep it secure
    and running also earn the currency.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 货币是随着时间的推移供应而不是一次性供应的。这样做是为了让进入网络的新节点也能够保持网络的安全运行并获得货币。
- en: Disadvantages of internal currency in DApps
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DApps 中内部货币的缺点
- en: The only demerit of having internal currency in DApps is that the DApps are
    not free for use anymore. This is one of the places where centralized applications
    get the upper hand as centralized applications can be monetized using ads, providing
    premium APIs for third-party apps, and so and can be made free for users.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DApps 中拥有内部货币的唯一缺点是，DApps 不再免费使用。这是中心化应用程序获得优势的地方之一，因为中心化应用程序可以通过广告获利，为第三方应用提供高级
    API 等，可以免费为用户提供服务。
- en: In DApps, we cannot integrate ads because there is no one to check the advertising
    standards; the clients may not display ads because there is no benefit for them
    in displaying ads.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DApps 中，我们无法集成广告，因为没有人来检查广告标准；客户端可能不显示广告，因为对他们来说显示广告没有任何好处。
- en: What are permissioned DApps?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是有权限的 DApps？
- en: Until now, we have been learning about DApps, which are completely open and
    permissionless; that is, anyone can participate without establishing an identity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直在了解完全开放和无需许可的 DApps；也就是说，任何人都可以参与，无需建立身份。
- en: On the other hand, permissioned DApps are not open for everyone to participate.
    Permissioned DApps inherit all properties of permissionless DApps, except that
    you need permission to participate in the network. Permission systems vary between
    permissioned DApps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有权限的 DApps 并不对所有人开放参与。有权限的 DApps 继承了所有无权限 DApps 的属性，除了你需要获得参与网络的许可。有权限的
    DApps 之间的许可制度各不相同。
- en: To join a permissioned DApp, you need permission, so consensus protocols of
    permissionless DApps may not work very well in permissioned DApps; therefore,
    they have different consensus protocols than permissionless DApps. Permissioned
    DApps don't have internal currency.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入一个有权限的 DApp，你需要获得许可，因此无权限 DApps 的共识协议可能在有权限的 DApps 中不太有效；因此，它们具有不同于无权限 DApps
    的共识协议。有权限的 DApps 没有内部货币。
- en: Popular DApps
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热门 DApps
- en: Now that we have some high-level knowledge about what DApps are and how they
    are different from centralized apps, let's explore some of the popular and useful
    DApps. While exploring these DApps, we will explore them at a level that is enough
    to understand how they work and tackle various issues instead of diving too deep.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 DApp 是什么以及它们与中心化应用的不同有一些高层次的了解，让我们探索一些流行且有用的 DApp。在探索这些 DApp 时，我们将对它们进行足够深入的探索，以了解它们的工作原理并解决各种问题，而不是深入挖掘。
- en: Bitcoin
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币
- en: Bitcoin is a decentralized currency. Bitcoin is the most popular DApp and its
    success is what showed how powerful DApps can be and encouraged people to build
    other DApps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是一种分散的货币。比特币是最流行的 DApp，它的成功展示了 DApp 可有多强大，并鼓励人们建立其他 DApp。
- en: Before we get into further details about how Bitcoin works and why people and
    the government consider it to be a currency, we need to learn what ledgers and
    blockchains are.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解比特币的工作原理和为什么人们和政府认为它是一种货币之前，我们需要了解什么是分类帐和区块链。
- en: What is a ledger?
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是分类帐？
- en: A ledger is basically a list of transactions. A database is different from a
    ledger. In a ledger, we can only append new transactions, whereas in a database,
    we can append, modify, and delete transactions. A database can be used to implement
    a ledger.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分类帐基本上是交易的列表。数据库与分类帐不同。在分类帐中，我们只能追加新的交易，而在数据库中，我们可以追加、修改和删除交易。数据库可以用于实现分类帐。
- en: What is blockchain?
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是区块链？
- en: A blockchain is a data structure used to create a decentralized ledger. A blockchain
    is composed of blocks in a serialized manner. A block contains a set of transactions,
    a hash of the previous block, timestamp (indicating when the block was created),
    block reward, block number, and so on. Every block contains a hash of the previous
    block, thus creating a chain of blocks linked with each other. Every node in the
    network holds a copy of the blockchain.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是用于创建分散分类帐的数据结构。区块链以串行方式由块组成。一个块包含一组交易、前一个块的哈希、时间戳（表示块的创建时间）、块奖励、块编号等。每个块都包含前一个块的哈希，从而创建了相互链接的块链。网络中的每个节点都保存着区块链的副本。
- en: Proof-of-work, proof-of-stake, and so on are various consensus protocols used
    to keep the blockchain secure. Depending on the consensus protocol, the blocks
    are created and added to the blockchain differently. In proof-of-work, blocks
    are created by a procedure called mining, which keeps the blockchain safe. In
    the proof-of-work protocol, mining involves solving complex puzzles. We will learn
    more about blockchain and its consensus protocols later in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明、股权证明等是用于保持区块链安全的各种共识协议。根据共识协议的不同，区块以不同的方式创建并添加到区块链中。在工作量证明中，区块是通过称为挖掘的过程创建的，这可以保持区块链的安全。在工作量证明协议中，挖掘涉及解决复杂的难题。我们将在本书后面详细了解更多关于区块链及其共识协议的知识。
- en: The blockchain in the Bitcoin network holds Bitcoin transactions. Bitcoins are
    supplied to the network by rewarding new Bitcoins to the nodes that successfully
    mine blocks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络中的区块链保存着比特币交易。新的比特币通过向成功挖掘区块的节点发放新的比特币来供应到网络中。
- en: The major advantage of blockchain data structure is that it automates auditing
    and makes an application transparent yet secure. It can prevent fraud and corruption.
    It can be used to solve many other problems depending on how you implement and
    use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据结构的主要优势在于自动化审计，并使应用程序透明而安全。它可以防止欺诈和腐败。根据您实现和使用的方式，它可以用于解决许多其他问题。
- en: Is Bitcoin legal?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特币是否合法？
- en: First of all, Bitcoin is not an internal currency; rather, it's a decentralized
    currency. Internal currencies are mostly legal because they are an asset and their
    use is obvious.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，比特币不是一种国际货币；相反，它是一种分散的货币。国际货币大多是合法的，因为它们是一种资产，而且它们的使用是显而易见的。
- en: The main question is whether currency-only DApps are legal or not. The straight
    answer is that it's legal in many countries. Very few countries have made it illegal
    and most are yet to decide.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是只使用货币的 DApp 是否合法。直截了当的答案是，在许多国家都是合法的。只有极少数国家已经将其定为非法，而大多数国家尚未决定。
- en: 'Here are a few reasons why some countries have made it illegal and most are
    yet to decide:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些国家已将之定为非法而大多数尚未决定的原因：
- en: Due to the identity issue in DApps, user accounts don't have any identity associated
    with them in Bitcoin; therefore, it can be used for money laundering
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在 DApp 中存在身份问题，在比特币中用户帐户没有任何与之相关的身份，因此它可以用于洗钱。
- en: These virtual currencies are very volatile, so there is a higher risk of people
    losing money
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些虚拟货币非常波动，因此人们失去金钱的风险更大
- en: It is really easy to evade taxes when using virtual currencies
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用虚拟货币时，逃税真的很容易
- en: Why would someone use Bitcoin?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么有人会使用比特币？
- en: The Bitcoin network is used to only send/receive Bitcoins and nothing else.
    So you must be wondering why there would be demand for Bitcoin.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络仅用于发送/接收比特币，什么都不是。所以你一定会想为什么会有人对比特币有需求。
- en: 'Here are some reasons why people use Bitcoin:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些人们使用比特币的原因：
- en: The major advantage of using Bitcoin is that it makes sending and receiving
    payments anywhere in the world easy and fast
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比特币的主要优势在于，使得在世界任何地方发送和接收支付变得简单和快捷。
- en: Online payment transaction fees are expensive compared to Bitcoin transaction
    fees
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线支付交易费用与比特币交易费用相比昂贵
- en: Hackers can steal your payment information from merchants, but in the case of
    Bitcoin, stealing Bitcoin addresses is completely useless because for a transaction
    to be valid, it must be signed with its associated private key, which the user
    doesn't need to share with anyone to make a payment.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客可以从商家那里窃取你的支付信息，但是在比特币的情况下，窃取比特币地址是完全无用的，因为为了交易有效，必须使用其关联的私钥进行签名，用户不需要与任何人分享私钥来进行付款。
- en: Ethereum
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊
- en: Ethereum is a decentralized platform that allows us to run DApps on top of it.
    These DApps are written using smart contracts. One or more smart contracts can
    form a DApp together. An Ethereum smart contract is a program that runs on Ethereum.
    A smart contract runs exactly as programmed without any possibility of downtime,
    censorship, fraud, and third-party interference.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是一个分散的平台，允许我们在其上运行 DApps。这些 DApps 是使用智能合约编写的。一个或多个智能合约可以一起形成一个 DApp。以太坊智能合约是在以太坊上运行的程序。智能合约会按照编程时的准确程序运行，没有任何的停机、审查、欺诈和第三方的干涉的可能性。
- en: The main advantage of using Ethereum to run smart contracts is that it makes
    it easy for smart contracts to interact with each other. Also, you don't have
    to worry about integrating consensus protocol and other things; instead, you just
    need to write the application logic. Obviously, you cannot build any kind of DApp
    using Ethereum; you can build only those kinds of DApps whose features are supported
    by Ethereum.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以太坊运行智能合约的主要优势在于，它让智能合约之间的互动变得更加容易。此外，你不需要担心集成共识协议和其他事务；相反，你只需要编写应用程序逻辑。明显地，你无法使用以太坊构建任何类型的
    DApp；你只能构建那些被以太坊支持的特性的 DApp。
- en: Ethereum has an internal currency called ether. To deploy smart contracts or
    execute functions of the smart contracts, you need ether.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊有一种内部货币叫做以太。要部署智能合约或执行智能合约的功能，你需要以太。
- en: This book is dedicated to building DApps using Ethereum. Throughout this book,
    you will learn every bit of Ethereum in depth.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书致力于利用以太坊构建 DApps。在本书中，你将深入学习以太坊的每一个方面。
- en: The Hyperledger project
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger 项目
- en: Hyperledger is a project dedicated to building technologies to build permissioned
    DApps. Hyperledger fabric (or simply fabric) is an implementation of the Hyperledger
    project. Other implementations include Intel Sawtooth and R3 Corda.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger 是一个致力于构建用于构建许可 DApps 技术的项目。Hyperledger fabric（简称 fabric）是 Hyperledger
    项目的一个实现。其他的实现包括 Intel Sawtooth 和 R3 Corda。
- en: Fabric is a permissioned decentralized platform that allows us to run permissioned
    DApps (called chaincodes) on top of it. We need to deploy our own instance of
    fabric and then deploy our permissioned DApps on top of it. Every node in the
    network runs an instance of fabric. Fabric is a plug-and-play system where you
    can easily plug and play various consensus protocols and features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 是一个许可的分散平台，允许我们在其上运行许可的 DApps（称为链码）。我们需要部署我们自己的 Fabric 实例，然后在其上部署我们的许可
    DApps。网络中的每个节点都运行 Fabric 的一个实例。Fabric 是一个即插即用的系统，你可以很容易的插拔各种共识协议和功能。
- en: Hyperledger uses the blockchain data structure. Hyperledger-based blockchains
    can currently choose to have no consensus protocols (that is, the **NoOps** protocol)
    or else use the **PBFT** (**Practical Byzantine Fault Tolerance**) consensus protocol.
    It has a special node called certificate authority, which controls who can join
    the network and what they can do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger 使用了区块链数据结构。基于 Hyperledger 的区块链目前可以选择不采用共识协议（即**NoOps** 协议），或者使用**PBFT**（**Practical
    Byzantine Fault Tolerance**）共识协议。它有一个特殊的节点叫做证书颁发机构，它控制着谁可以加入网络以及他们可以做什么。
- en: IPFS
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPFS
- en: '**IPFS** (**InterPlanetary File System**) is a decentralized filesystem. IPFS
    uses **DHT** (**distributed hash table**) and Merkle **DAG** (**directed acyclic
    graph**) data structures. It uses a protocol similar to BitTorrent to decide how
    to move data around the network. One of the advanced features of IPFS is that
    it supports file versioning. To achieve file versioning, it uses data structures
    similar to Git.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPFS**（**星际文件系统**）是一个分散式文件系统。IPFS 使用 **DHT**（**分布式哈希表**）和 Merkle **DAG**（**有向无环图**）数据结构。它使用类似于
    BitTorrent 的协议来决定如何在网络中移动数据。IPFS 的一个高级功能是它支持文件版本控制。为了实现文件版本控制，它使用类似于 Git 的数据结构。'
- en: Although it called a decentralized filesystem, it doesn't adhere to a major
    property of a filesystem; that is, when we store something in a filesystem, it
    is guaranteed to be there until deleted. But IPFS doesn't work that way. Every
    node doesn't hold all files; it stores the files it needs. Therefore, if a file
    is less popular, then obviously many nodes won't have it; therefore, there is
    a huge chance of the file disappearing from the network. Due to this, many people
    prefer to call IPFS a decentralized peer-to-peer file-sharing application. Or
    else, you can think of IPFS as BitTorrent, which is completely decentralized;
    that is, it doesn't have a tracker and has some advanced features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它被称为分散式文件系统，但它并不遵循文件系统的一个主要属性；也就是说，当我们在文件系统中存储某些东西时，它保证会一直存在直到被删除。但 IPFS 并非如此运作。每个节点并不保存所有文件；它存储它所需要的文件。因此，如果一个文件不太受欢迎，那么显然许多节点都不会拥有它；因此，文件从网络中消失的可能性很大。因此，许多人更喜欢将
    IPFS 称为分散式对等文件共享应用程序。或者，您可以将 IPFS 视为完全分散式的 BitTorrent；也就是说，它没有跟踪器并具有一些高级功能。
- en: How does it work?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Let's look at an overview of how IPFS works. When we store a file in IPFS, it's
    split into chunks < 256 KB and hashes of each of these chunks are generated. Nodes
    in the network hold the IPFS files they need and their hashes in a hash table.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 IPFS 的工作概述。当我们将文件存储在 IPFS 中时，它会被分成小于 256 KB 的块，并为每个块生成哈希值。网络中的节点在哈希表中保存它们需要的
    IPFS 文件及其哈希值。
- en: 'There are four types of IPFS files: blob, list, tree, and commit. A blob represents
    a chunk of an actual file that''s stored in IPFS. A list represents a complete
    file as it holds the list of blobs and other lists. As lists can hold other lists,
    it helps in data compression over the network. A tree represents a directory as
    it holds a list of blobs, lists, other trees, and commits. And a commit file represents
    a snapshot in the version history of any other file. As lists, trees, and commits
    have links to other IPFS files, they form a Merkle DAG.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS 文件有四种类型：blob、list、tree 和 commit。blob 表示存储在 IPFS 中的实际文件块。list 表示完整文件，因为它保存了
    blob 和其他 list 的列表。由于列表可以包含其他列表，它有助于通过网络进行数据压缩。tree 表示目录，因为它保存了 blob、list、其他 tree
    和 commit 的列表。而 commit 文件表示任何其他文件版本历史中的快照。由于列表、tree 和 commit 具有指向其他 IPFS 文件的链接，它们形成了
    Merkle DAG。
- en: So when we want to download a file from the network, we just need the hash of
    the IPFS list file. Or if we want to download a directory, then we just need the
    hash of the IPFS tree file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们想要从网络下载文件时，我们只需要 IPFS 列表文件的哈希。或者，如果我们想要下载一个目录，那么我们只需要 IPFS 树文件的哈希。
- en: As every file is identified by a hash, the names are not easy to remember. If
    we update a file, then we need to share a new hash with everyone that wants to
    download that file. To tackle this issue, IPFS uses the IPNS feature, which allows
    IPFS files to be pointed using self-certified names or human-friendly names.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个文件都由哈希值标识，因此名称不容易记住。如果我们更新了一个文件，那么我们需要与想要下载该文件的所有人共享一个新的哈希值。为了解决这个问题，IPFS
    使用了 IPNS 功能，它允许使用自我认证的名称或人性化名称指向 IPFS 文件。
- en: Filecoin
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Filecoin
- en: The major reason that is stopping IPFS from becoming a decentralized filesystem
    is that nodes only store the files they need. Filecoin is a decentralized filesystem
    similar to IPFS with an internal currency to incentivize nodes to store files,
    thus increasing file availability and making it more like a filesystem.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止 IPFS 成为分散式文件系统的主要原因是节点仅存储它们需要的文件。Filecoin 是一个类似于 IPFS 的分散式文件系统，具有内部货币以激励节点存储文件，从而提高文件可用性，使其更像一个文件系统。
- en: Nodes in the network will earn Filecoins to rent disk space, and to store/retrieve
    files, you need to spend Filecoins.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的节点将赚取 Filecoins 来租用磁盘空间，而要存储/检索文件，您需要花费 Filecoins。
- en: Along with IPFS technologies, Filecoin uses the blockchain data structure and
    the proof-of- retrievability consensus protocol.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 IPFS 技术之外，Filecoin 使用了区块链数据结构和可检索性证明共识协议。
- en: At the time of writing this, Filecoin is still under development, so many things
    are still unclear.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Filecoin 仍在开发中，因此许多事情仍不清楚。
- en: Namecoin
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Namecoin
- en: Namecoin is a decentralized key-value database. It has an internal currency
    too, called Namecoins. Namecoin uses the blockchain data structure and the proof-of-work
    consensus protocol.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Namecoin 是一个去中心化的键值数据库。它也有一种内部货币，叫做 Namecoins。Namecoin 使用区块链数据结构和工作量证明共识协议。
- en: In Namecoin, you can store key-value pairs of data. To register a key-value
    pair, you need to spend Namecoins. Once you register, you need to update it once
    in every 35,999 blocks; otherwise, the value associated with the key will expire.
    To update, you need Namecoins as well. There is no need to renew the keys; that
    is, you don't need to spend any Namecoins to keep the key after you have registered
    it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Namecoin 中，您可以存储键值对数据。要注册键值对，您需要花费 Namecoins。一旦注册，您需要在每 35,999 个区块中更新一次；否则，与键关联的值将过期。要更新，您也需要
    Namecoins。无需更新密钥；也就是说，注册密钥后，您无需花费任何 Namecoins 来保留密钥。
- en: Namecoin has a namespace feature that allows users to organize different kinds
    of keys. Anyone can create namespaces or use existing ones to organize keys.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Namecoin 拥有命名空间功能，允许用户组织不同类型的密钥。任何人都可以创建命名空间或使用现有的命名空间来组织密钥。
- en: Some of the most popular namespaces are `a` (application specific data), `d`
    (domain name specifications), `ds` (secure domain name), `id` (identity), `is`
    (secure identity), `p` (product), and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最受欢迎的命名空间包括 `a`（应用程序特定数据）、`d`（域名规范）、`ds`（安全域名）、`id`（身份）、`is`（安全身份）、`p`（产品）等等。
- en: .bit domains
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .bit 域
- en: To access a website, a browser first finds the IP address associated with the
    domain. These domain name and IP address mappings are stored in DNS servers, which
    are controlled by large companies and governments. Therefore, domain names are
    prone to censorship. Governments and companies usually block domain names if the
    website is doing something illegal or making loss for them or due to some other
    reason.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个网站，浏览器首先需要找到与域关联的 IP 地址。这些域名和 IP 地址的映射存储在 DNS 服务器中，由大型公司和政府控制。因此，域名容易受到审查。如果网站做出非法行为、给他们造成损失或出于其他原因，政府和公司通常会阻止域名。
- en: Due to this, there was a need for a decentralized domain name database. As Namecoin
    stores key-value data just like DNS servers, Namecoin can be used to implement
    a decentralized DNS, and this is what it has already been used for. The d and
    ds namespaces contain keys ending with `.bit`, representing `.bit` domain names.
    Technically, a namespace doesn't have any naming convention for the keys but all
    the nodes and clients of Namecoin agree to this naming convention. If we try to
    store invalid keys in `d` and `ds` namespaces, then clients will filter invalid
    keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要建立一个去中心化的域名数据库。由于 Namecoin 像 DNS 服务器一样存储键值数据，因此可以使用 Namecoin 来实现去中心化 DNS，这已经得到了应用。d
    和 ds 命名空间包含以 `.bit` 结尾的键，表示 `.bit` 域名。从技术上讲，命名空间对键没有任何命名约定，但是所有的 Namecoin 节点和客户端都同意这个命名约定。如果我们尝试在
    `d` 和 `ds` 命名空间中存储无效的键，那么客户端将过滤掉无效的键。
- en: A browser that supports `.bit` domains needs to look up in the Namecoin's `d`
    and `ds` namespace to find the IP address associated with the `.bit` domain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 `.bit` 域的浏览器需要在 Namecoin 的 `d` 和 `ds` 命名空间中查找与 `.bit` 域关联的 IP 地址。
- en: The difference between the `d` and `ds` namespaces is that `ds` stores domains
    that support TLS and `d` stores the ones that don't support TLS. We have made
    DNS decentralized; similarly, we can also make the issuing of TLS certificates
    decentralized.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`d` 和 `ds` 命名空间的区别在于 `ds` 存储支持 TLS 的域，而 `d` 存储不支持 TLS 的域。我们已经使 DNS 实现了去中心化；同样，我们也可以使
    TLS 证书的签发去中心化。'
- en: This is how TLS works in Namecoin. Users create self-signed certificates and
    store the certificate hash in Namecoin. When a client that supports TLS for `.bit`
    domains tries to access a secured `.bit` domain, it will match the hash of the
    certificate returned by the server with the hash stored in Namecoin, and if they
    match, then they proceed with further communication with the server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在 Namecoin 中 TLS 的工作原理。用户创建自签名证书并将证书哈希存储在 Namecoin 中。当支持 `.bit` 域的客户端尝试访问安全的
    `.bit` 域时，它将与服务器返回的证书哈希进行匹配，并且如果匹配，则继续与服务器进行进一步的通信。
- en: A decentralized DNS formed using Namecoin is the first solution to the Zooko
    triangle. The Zooko triangle defines applications that have three properties,
    that is, decentralized, identity, and secure. Digital identity is used not only
    to represent a person, but it can also represent a domain, company, or something
    else.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Namecoin形成的分散的DNS是Zooko三角的第一个解决方案。Zooko三角定义了拥有三种属性的应用程序，即分散式、身份和安全。数字身份不仅用于代表一个人，还可以代表域名、公司或其他东西。
- en: Dash
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dash
- en: 'Dash is a decentralized currency similar to Bitcoin. Dash uses the blockchain
    data structure and the proof-of-work consensus protocol. Dash solves some of the
    major issues that are caused by Bitcoin. Here are some issues related to Bitcoin:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Dash是一种类似比特币的分散式货币。Dash使用区块链数据结构和工作量证明共识协议。Dash解决了比特币导致的一些主要问题。以下是与比特币相关的一些问题：
- en: Transactions take a few minutes to complete, and in today's world, we need transactions
    to complete instantly. This is because the mining difficulty in the Bitcoin network
    is adjusted in such a way that a block gets created once in an average of every
    10 minutes. We will learn more about mining later on in this book.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易需要几分钟才能完成，在今天的世界中，我们需要交易立即完成。这是因为比特币网络中的挖矿难度被调整得平均每10分钟创建一个区块。我们将在本书后面更多地了解挖矿。
- en: Although accounts don't have an identity associated with them, trading Bitcoins
    for real currency on an exchange or buying stuff with Bitcoins is traceable; therefore,
    these exchanges or merchants can reveal your identity to governments or other
    authorities. If you are running your own node to send/receive transactions, then
    your ISP can see the Bitcoin address and trace the owner using the IP address
    because broadcasted messages in the Bitcoin network are not encrypted.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然账户没有与其关联的身份，但在交易所将比特币交易为真实货币或用比特币购买东西是可追踪的；因此，这些交易所或商家可以向政府或其他机构透露你的身份。如果你运行自己的节点来发送/接收交易，那么你的ISP可以看到比特币地址，并使用IP地址追溯所有者，因为比特币网络中的广播消息没有加密。
- en: Dash aims to solve these problems by making transactions settle almost instantly
    and making it impossible to identify the real person behind an account. It also
    prevents your ISP from tracking you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Dash旨在通过使交易几乎即时结算并使真实账户的背后的真实人不再被识别来解决这些问题。它还防止你的ISP跟踪你。
- en: In the Bitcoin network, there are two kinds of nodes, that is, miners and ordinary
    nodes. But in Dash, there are three kinds of nodes, that is, miners, masternodes,
    and ordinary nodes. Masternodes are what makes Dash so special.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币网络中，有两种节点，即矿工和普通节点。但在Dash中，有三种节点，即矿工，主节点和普通节点。主节点是使Dash如此特别的原因。
- en: Decentralized governance and budgeting
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分散式治理和预算
- en: To host a masternode, you need to have 1,000 Dashes and a static IP address.
    In the Dash network, both masternodes and miners earn Dashes. When a block is
    mined, 45% reward goes to the miner, 45% goes to the masternodes, and 10% is reserved
    for the budget system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要托管一个主节点，你需要拥有1,000个Dash和一个静态IP地址。在Dash网络中，主节点和矿工都赚取Dash。当一个区块被挖出时，45%的奖励给矿工，45%给主节点，剩下的10%用于预算系统。
- en: Masternodes enable decentralized governance and budgeting. Due to the decentralized
    governance and budgeting system, Dash is called a DAO because that's exactly what
    it is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点实现了分散式治理和预算。由于分散式治理和预算系统，Dash被称为DAO，因为它确实是这样的。
- en: Masternodes in the network act like shareholders; that is, they have rights
    to take decisions regarding where the 10% Dash goes. This 10% Dash is usually
    used to funds other projects. Each masternode is given the ability to use one
    vote to approve a project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的主节点就像股东一样；他们有权决定10%的Dash去向。这10%的Dash通常用于资助其他项目。每个主节点有权利使用一票来批准一个项目。
- en: Discussions on project proposals happen out of the network. But the voting happens
    in the network.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 项目提案的讨论发生在网络之外。但投票在网络中进行。
- en: Masternodes can provide a possible solution to verify user identity in DApps;
    that is, masternodes can democratically select a node to verify user identity.
    The person or business behind this node can manually verify user documents. A
    part of this reward can also go to this node. If the node doesn't provide good
    service, then the masternodes can vote for a different node. This can be a fine
    solution to the decentralized identity issue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点可以为 DApps 中的用户身份验证提供可能的解决方案；也就是说，主节点可以民主地选择一个节点来验证用户身份。这个节点背后的人或企业可以手动验证用户文件。部分奖励也可以给这个节点。如果节点不能提供良好的服务，那么主节点可以投票选举另一个节点。这可以是去中心化身份问题的一个良好解决方案。
- en: Decentralized service
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化服务
- en: Instead of just approving or rejecting a proposal, masternodes also form a service
    layer that provides various services. The reason that masternodes provide services
    is that the more services they provide, the more feature-rich the network becomes,
    thus increasing users and transactions, which increases prices for Dash currency
    and the block reward also gets high, therefore helping masternodes earn more profit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点不仅仅是批准或拒绝提案，还构成了提供各种服务的服务层。主节点提供服务的原因是，它们提供的服务越多，网络就变得越功能丰富，从而增加了用户和交易量，这就增加了
    Dash 货币的价格和区块奖励，从而帮助主节点赚取更多利润。
- en: Masternodes provide services such as PrivateSend (a coin-mixing service that
    provides anonymity), InstantSend (a service that provides almost instant transactions),
    DAPI (a service that provides a decentralized API so that users don't need to
    run a node), and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点提供诸如 PrivateSend（提供匿名的币混合服务）、InstantSend（提供几乎即时的交易服务）、DAPI（提供去中心化 API，以便用户不需要运行节点）等服务。
- en: At a given time, only 10 masternodes are selected. The selection algorithm uses
    the current block hash to select the masternodes. Then, we request a service from
    them. The response that's received from the majority of nodes is said to be the
    correct one. This is how consensus is achieved for services provided by the masternodes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间，只有 10 个主节点被选中。选择算法使用当前区块哈希来选择主节点。然后，我们从他们那里请求服务。从大多数节点接收到的响应被认为是正确的。这就是如何实现对主节点提供的服务达成共识的方式。
- en: The proof-of-service consensus protocol is used to make sure that the masternodes
    are online, are responding, and have their blockchain up-to-date.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务证明共识协议用于确保主节点在线、响应正常，并且其区块链是最新的。
- en: BigChainDB
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigChainDB
- en: BigChainDB allows you to deploy your own permissioned or permissionless decentralized
    database. It uses the blockchain data structure along with various other database-specific
    data structures. BigChainDB, at the time of writing this, is still under development,
    so many things are not clear yet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: BigChainDB 允许您部署自己的权限或无权限的去中心化数据库。它使用区块链数据结构以及各种其他特定于数据库的数据结构。在撰写本文时，BigChainDB
    仍在开发中，因此许多事情尚不清楚。
- en: It also provides many other features, such as rich permissions, querying, linear
    scaling, and native support for multi-assets and the federation consensus protocol.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供许多其他功能，如丰富的权限、查询、线性扩展和对多资产以及联盟共识协议的本地支持。
- en: OpenBazaar
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenBazaar
- en: OpenBazaar is a decentralized e-commerce platform. You can buy or sell goods
    using OpenBazaar. Users are not anonymous in the OpenBazaar network as their IP
    address is recorded. A node can be a buyer, seller, or a moderator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBazaar 是一个去中心化的电子商务平台。您可以使用 OpenBazaar 购买或出售商品。在 OpenBazaar 网络中，用户并不匿名，因为他们的
    IP 地址被记录下来。一个节点可以是买家、卖家或调解员。
- en: It uses a Kademlia-style distributed hash table data structure. A seller must
    host a node and keep it running in order to make the items visible in the network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 Kademlia 风格的分布式哈希表数据结构。卖家必须托管一个节点并保持其运行，以使商品在网络中可见。
- en: It prevents account spam by using the proof-of-work consensus protocol. It prevents
    ratings and reviews spam using proof-of-burn, CHECKLOCKTIMEVERIFY, and security
    deposit consensus protocols.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过使用工作量证明共识协议来防止账户垃圾邮件。它使用 proof-of-burn、CHECKLOCKTIMEVERIFY 和安全存款共识协议来防止评分和评论垃圾邮件。
- en: Buyers and sellers trade using Bitcoins. A buyer can add a moderator while making
    a purchase. The moderator is responsible for resolving a dispute if anything happens
    between the buyer and the seller. Anyone can be a moderator in the network. Moderators
    earn commission by resolving disputes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 买家和卖家使用比特币进行交易。买家在购买商品时可以添加一个调解员。调解员负责解决买家和卖家之间发生的任何纠纷。任何人都可以成为网络中的调解员。调解员通过解决纠纷来赚取佣金。
- en: Ripple
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ripple
- en: Ripple is decentralized remittance platform. It lets us transfer fiat currencies,
    digital currencies, and commodities. It uses the blockchain data structure and
    has its own consensus protocol. In ripple docs, you will not find the term blocks
    and blockchain; they use the term ledger instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple 是一个去中心化的汇款平台。它允许我们转移法定货币、数字货币和大宗商品。它使用区块链数据结构，并拥有自己的共识协议。在 Ripple 的文档中，你不会找到
    blocks 和 blockchain 这个术语；他们使用 ledger 这个术语。
- en: In ripple, money and commodity transfer happens via a trust chain in a manner
    similar to how it happens in a hawala network. In ripple, there are two kinds
    of nodes, that is, gateways and regular nodes. Gateways support deposit and withdrawal
    of one or more currencies and/or commodities. To become a gateway in a ripple
    network, you need permission as gateways to form a trust chain. Gateways are usually
    registered financial institutions, exchanges, merchants, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ripple 中，货币和商品的转移通过信任链方式进行，类似于哈瓦拉网络的运作方式。在 Ripple 中，有两种类型的节点，即网关和常规节点。网关支持一个或多个货币和/或商品的存款和提款。要成为
    Ripple 网络中的网关，您需要作为网关获得许可以形成信任链。网关通常是注册的金融机构、交易所、商家等。
- en: Every user and gateway has an account address. Every user needs to add a list
    of gateways they trust by adding the gateway addresses to the trust list. There
    is no consensus to find whom to trust; it all depends on the user, and the user
    takes the risk of trusting a gateway. Even gateways can add the list of gateways
    they trust.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户和网关都有一个帐户地址。每个用户都需要将他们信任的网关的地址添加到信任列表中。没有共识找到信任谁；这完全取决于用户，并且用户承担信任网关的风险。甚至网关也可以添加他们信任的网关列表。
- en: Let's look at an example of how user X living in India can send 500 USD to user
    Y living in the USA. Assuming that there is a gateway XX in India, which takes
    cash (physical cash or card payments on their website) and gives you only the
    INR balance on ripple, X will visit the XX office or website and deposit 30,000
    INR and then XX will broadcast a transaction saying I owe X 30,000 INR. Now assume
    that there is a gateway YY in the USA, which allows only USD transactions and
    Y trusts YY gateway. Now, say, gateways XX and YY don't trust each other. As X
    and Y don't trust a common gateway, XX and YY don't trust each other, and finally,
    XX and YY don't support the same currency. Therefore, for X to send money to Y,
    he needs to find intermediary gateways to form a trust chain. Assume there is
    another gateway, ZZ, that is trusted by both XX and YY and it supports USD and
    INR. So now X can send a transaction by transferring 50,000 INR from XX to ZZ
    and it gets converted to USD by ZZ and then ZZ sends the money to YY, asking YY
    to give the money to Y. Now instead of X owing Y $500, YY owes $500 to Y, ZZ owes
    $500 to YY, and XX owes 30,000 INR to ZZ. But it's all fine because they trust
    each other, whereas earlier, X and Y didn't trust each other. But XX, YY, and
    ZZ can transfer the money outside of ripple whenever they want to, or else a reverse
    transaction will deduct this value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，用户 X 住在印度，想向住在美国的用户 Y 发送 500 美元。假设印度有一个名为 XX 的网关，它接受现金（实体现金或网站上的卡支付）并仅在
    Ripple 上给你印度卢比余额，X 将访问 XX 的办事处或网站，存入 30,000 印度卢比，然后 XX 将广播一笔交易，表示我欠 X 30,000 印度卢比。现在假设美国有一个名为
    YY 的网关，它仅允许美元交易，并且 Y 信任 YY 网关。现在，假设网关 XX 和 YY 互不信任。由于 X 和 Y 不信任一个共同的网关，XX 和 YY
    互不信任，最终 XX 和 YY 不支持相同的货币。因此，要让 X 向 Y 发送资金，他需要找到中间网关以形成信任链。假设还有另一个网关 ZZ，它被 XX 和
    YY 信任，并支持美元和印度卢比。因此，现在 X 可以通过将 50,000 印度卢比从 XX 转移到 ZZ 发送交易，并由 ZZ 转换为美元，然后 ZZ 将资金发送给
    YY，要求 YY 将资金交给 Y。现在，与其说 X 欠 Y 500 美元，不如说 YY 欠 Y 500 美元，ZZ 欠 YY 500 美元，XX 欠 ZZ
    30,000 印度卢比。但这都没关系，因为他们彼此信任，而之前 X 和 Y 不信任对方。但是 XX、YY 和 ZZ 可以随时在 Ripple 外转移资金，否则逆向交易会扣除这个价值。
- en: Ripple also has an internal currency called XRP (or ripples). Every transaction
    sent to the network costs some ripples. As XRP is the ripple's native currency,
    it can be sent to anyone in the network without trust. XRP can also be used while
    forming a trust chain. Remember that every gateway has its own currency exchange
    rate. XRP isn't generated by a mining process; instead, there are total of 100
    billion XRPs generated in the beginning and owned by the ripple company itself.
    XRP is supplied manually depending on various factors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple还有一种名为XRP（或水波）的内部货币。发送到网络的每笔交易都会消耗一些水波。由于XRP是水波的本地货币，因此可以向网络中的任何人发送，而无需信任。XRP也可以在形成信任链时使用。请记住，每个网关都有自己的货币兑换率。XRP不是通过挖矿过程生成的；相反，在开始时生成了总共1000亿个XRP，并由水波公司自己拥有。根据各种因素手动提供XRP。
- en: All the transactions are recorded in the decentralized ledger, which forms an
    immutable history. Consensus is required to make sure that all nodes have the
    same ledger at a given point of time. In ripple, there is a third kind of node
    called validators, which are part of the consensus protocol. Validators are responsible
    for validating transactions. Anyone can become a validator. But other nodes keep
    a list of validators that can be actually trusted. This list is known as UNL (unique
    node list). A validator also has a UNL; that is, the validators it trusts as validators
    also want to reach a consensus. Currently, ripple decides the list of validators
    that can be trusted, but if the network thinks that validators selected by ripple
    are not trustworthy, then they can modify the list in their node software.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有交易都记录在去中心化账本中，形成不可变的历史。需要共识确保所有节点在某一时间点具有相同的账本。在Ripple中，还有一种称为验证者的第三种节点，它们是共识协议的一部分。验证者负责验证交易。任何人都可以成为验证者。但其他节点会保留可以实际信任的验证者列表。这个列表被称为UNL（唯一节点列表）。验证者也有一个UNL；即，它信任的验证者也希望达成共识。目前，Ripple决定了可以信任的验证者列表，但如果网络认为Ripple选择的验证者不值得信任，那么他们可以在其节点软件中修改列表。
- en: You can form a ledger by taking the previous ledger and applying all the transactions
    that have happened since then. So to agree on the current ledger, nodes must agree
    on the previous ledger and the set of transactions that have happened since then.
    After a new ledger is created, a node (both regular nodes and validators) starts
    a timer (of a few seconds, approximately 5 seconds) and collects the new transactions
    that arrived during the creation of the previous ledger. When the timer expires,
    it takes those transactions that are valid according to at least 80% of the UNLs
    and forms the next ledger. Validators broadcast a proposal (a set of transactions
    they think are valid to form the next ledger) to the network. Validators can broadcast
    proposals for the same ledger multiple times with a different set of transactions
    if they decide to change the list of valid transactions depending on proposals
    from their UNLs and other factors. So you only need to wait 5-10 seconds for your
    transaction to be confirmed by the network.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过获取前一个账本并应用自那时起发生的所有交易来形成一个账本。因此，要就当前账本达成一致，节点必须就前一个账本和自那时起发生的交易集达成一致。创建新账本后，节点（包括普通节点和验证者）启动计时器（几秒钟，大约5秒钟），并收集在上一个账本创建期间到达的新交易。当计时器到期时，它会选择至少80%的UNL认为有效的那些交易，并形成下一个账本。验证者向网络广播一个提案（一组他们认为有效的交易，以形成下一个账本）。验证者可以多次广播对同一个账本的提案，如果他们决定根据来自其UNL和其他因素的提案更改有效交易的列表。因此，您只需要等待5-10秒，即可确保您的交易已被网络确认。
- en: Some people wonder whether this can lead to many different versions of the ledger
    since each node may have a different UNL. As long as there is a minimal degree
    of inter-connectivity between UNLs, a consensus will rapidly be reached. This
    is primarily because every honest node's primary goal is to achieve a consensus.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人想知道这是否会导致账本出现许多不同版本，因为每个节点可能有不同的UNL。只要UNL之间存在最小程度的互联性，就会迅速达成共识。这主要是因为每个诚实的节点的主要目标是达成共识。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what DApps are and got an an overview of how they
    work. We looked at some of the challenges faced by DApps and the various solutions
    to these issues. Finally, we saw some of the popular DApps and had an overview
    of what makes them special and how they work. Now you should be comfortable explaining
    what a DApp is and how it works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是 DApps，并简要了解了它们的工作原理。我们看到了一些 DApps 面临的挑战，以及这些问题的各种解决方案。最后，我们了解了一些流行的
    DApps，并对它们的特点和工作原理有了一个概览。现在，你应该能够清楚地解释什么是 DApp，以及它是如何工作的。
