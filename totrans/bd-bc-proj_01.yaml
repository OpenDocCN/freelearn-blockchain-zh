- en: Understanding Decentralized Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all of the Internet-based applications we have been using are centralized,
    that is, the servers of each application are owned by a particular company or
    person. Developers have been building centralized applications and users have
    been using them for a pretty long time. But there are a few concerns with centralized
    applications that make it next to impossible to build certain types of apps and
    every app ends up having some common issues. Some issues with centralized apps
    are that they are less transparent, they have a single point of failure, they
    fail to prevent net censorship, and so on. Due to these concerns, a new technology
    emerged for the building of Internet-based apps called **decentralized applications**
    (**DApps**). In this chapter, we will learn about decentralized apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are DApps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between decentralized, centralized, and distributed applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and disadvantages of centralized and decentralized applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the data structures, algorithms, and protocols used by some of
    the most popular DApps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about some popular DApps that are built on top of other DApps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a DApp?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DApp is a kind of Internet application whose backend runs on a decentralized
    peer-to-peer network and its source code is open source. No single node in the
    network has complete control over the DApp.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the functionality of the DApp, different data structures are used
    to store application data. For example, the Bitcoin DApp uses the blockchain data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: These peers can be any computer connected to the Internet; therefore, it becomes
    a big challenge to detect and prevent peers from making invalid changes to the
    application data and sharing wrong information with others. So we need some sort
    of consensus between the peers regarding whether the data published by a peer
    is right or wrong. There is no central server in a DApp to coordinate the peers
    and decide what is right and wrong; therefore, it becomes really difficult to
    solve this challenge. There are certain protocols (specifically called consensus
    protocols) to tackle this challenge. Consensus protocols are designed specifically
    for the type of data structure the DApp uses. For example, Bitcoin uses the proof-of-work
    protocol to achieve consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Every DApp needs a client for the user to use the DApp. To use a DApp, we first
    need a node in the network by running our own node server of the DApp and then
    connecting the client to the node server. Nodes of a DApp provide an API only
    and let the developer community develop various clients using the API. Some DApp
    developers officially provide a client. Clients of DApps should be open source
    and should be downloaded for use; otherwise, the whole idea of decentralization
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: But this architecture of a client is cumbersome to set up, especially if the
    user is a non-developer; therefore, clients are usually hosted and/or nodes are
    hosted as a service to make the process of using a DApp easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are distributed applications?**'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed applications are those applications that are spread across multiple
    servers instead of just one. This is necessary when application data and traffic
    becomes huge and application downtime is not affordable. In distributed applications,
    data is replicated among various servers to achieve high availability of data.
    Centralized applications may or may not be distributed, but decentralized applications
    are always distributed. For example, Google, Facebook, Slack, Dropbox, and so
    on are distributed, whereas a simple portfolio site or a personal blog are not
    usually distributed until traffic is very high.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of decentralized applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the advantages of decentralized applications:'
  prefs: []
  type: TYPE_NORMAL
- en: DApps are fault-tolerant as there is no single point of failure because they
    are distributed by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They prevent violation of net censorship as there is no central authority to
    whom the government can pressurize to remove some content. Governments cannot
    even block the app's domain or IP address as DApps are not accessed via a particular
    IP address or domain. Obviously the government can track individual nodes in the
    network by their IP address and shut them down, but if the network is huge, then
    it becomes next to impossible to shut down the app, especially if the nodes are
    distributed among various different countries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy for users to trust the application as it's not controlled by a single
    authority that could possibly cheat the users for profit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of decentralized applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, every system has some advantages and disadvantages. Here are some
    of the disadvantages of decentralized applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs or updating DApps is difficult, as every peer in the network has
    to update their node software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some applications require verification of user identity (that is, KYC), and
    as there is no central authority to verify the user identity, it becomes an issue
    while developing such applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are difficult to build because they use very complex protocols to achieve
    consensus and they have to be built to scale from the start itself. So we cannot
    just implement an idea and then later on add more features and scale it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications are usually independent of third-party APIs to get or store something.
    DApps shouldn't depend on centralized application APIs, but DApps can be dependent
    on other DApps. As there isn't a large ecosystem of DApps yet, it is difficult
    to build a DApp. Although DApps can be dependent on other DApps theoretically,
    it is very difficult to tightly couple DApps practically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized autonomous organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, signed papers represent organizations, and the government has influence
    over them. Depending on the type of organization, the organization may or may
    not have shareholders.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized autonomous organization** (**DAO**) is an organization that
    is represented by a computer program (that is, the organization runs according
    to the rules written in the program), is completely transparent, and has total
    shareholder control and no influence of the government.'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve these goals, we need to develop a DAO as a DApp. Therefore, we can
    say that DAO is a subclass of DApp.
  prefs: []
  type: TYPE_NORMAL
- en: Dash, and the DAC are a few example of DAOs.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a decentralized autonomous corporation (DAC)?** There is still no
    clear difference between DAC and DAO. Many people consider them to be the same
    whereas some people define DAC as DAO when DAO is intended to make profits for
    shareholders.'
  prefs: []
  type: TYPE_NORMAL
- en: User identity in DApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major advantages of DApps is that it generally guarantees user anonymity.
    But many applications require the process of verifying user identity to use the
    app. As there is no central authority in a DApp, it become a challenge to verify
    the user identity.
  prefs: []
  type: TYPE_NORMAL
- en: In centralized applications, humans verify user identity by requesting the user
    to submit certain scanned documents, OTP verification, and so on. This process
    is calledÂ **know your customer** (**KYC**). But as there is no human to verify
    user identity in DApps, the DApp has to verify the user identity itself. Obviously
    DApps cannot understand and verify scanned documents, nor can they send SMSes;
    therefore, we need to feed them with digital identities that they can understand
    and verify. The major problem is that hardly any DApps have digital identities
    and only a few people know how to get a digital identity.
  prefs: []
  type: TYPE_NORMAL
- en: There are various forms of digital identities. Currently, the most recommended
    and popular form is a digital certificate. A digital certificate (also called
    a public key certificate or identity certificate) is an electronic document used
    to prove ownership of a public key. Basically, a user owns a private key, public
    key, and digital certificate. The private key is secret and the user shouldn't
    share it with anyone. The public key can be shared with anyone. The digital certificate
    holds the public key and information about who owns the public key. Obviously,
    it's not difficult to produce this kind of certificate; therefore, a digital certificate
    is always issued by an authorized entity that you can trust. The digital certificate
    has an encrypted field that's encrypted by the private key of the certificate
    authority. To verify the authenticity of the certificate, we just need to decrypt
    the field using the public key of the certificate authority, and if it decrypts
    successfully, then we know that the certificate is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Even if users successfully get digital identities and they are verified by the
    DApp, there is a still a major issue; that is, there are various digital certificate
    issuing authorities, and to verify a digital certificate, we need the public key
    of the issuing authority. It is really difficult to include the public keys of
    all the authorities and update/add new ones. Due to this issue, the procedure
    of digital identity verification is usually included on the client side so that
    it can be easily updated. Just moving this verification procedure to the client
    side doesn't completely solve this issue because there are lots of authorities
    issuing digital certificates and keeping track of all of them, and adding them
    to the client side, is cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do users not verify each other''s identity?**'
  prefs: []
  type: TYPE_NORMAL
- en: Often, while we do trading in real life, we usually verify the identity of the
    other person ourselves or we bring in an authority to verify the identity. This
    idea can be applied to DApps as well. Users can verify each other's identity manually
    before performing trade with each other. This idea works for specific kinds of
    DApps, that is, for DApps in which people trade with each other. For example,
    if a DApp is a decentralized social network, then obviously a profile cannot be
    verified by this means. But if the DApp is for people to buy/sell something, then
    before making a payment, the buyer and seller can both verify each other's identity.
    Although this idea may seem fine while doing trading, when you think practically,
    it becomes very difficult because you may not want to do identity verification
    every time you trade and everyone not knows how to do identity verification. For
    example, if the DApp is a cab-booking app, then you will obviously not wantÂ to
    perform identity verification before booking a cab every time. But if you trade
    sometimes and you know how to verify identity, then it's fine to follow this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these issues, the only option we are currently left with is verifying
    user identity manually by an authorized person of the company that provides the
    client. For example, to create a Bitcoin account, we don't need an identification,
    but while withdrawing Bitcoin to flat currency, the exchanges ask for proof of
    identification. Clients can omit the unverified users and not let them use the
    client. And they can keep the client open for users whose identity has been verified
    by them. This solution also ends up with minor issues; that is, if you switch
    the client, you will not find the same set of users to interact with because different
    clients have different sets of verified users. Due to this, all users may decide
    to use a particular client only, thus creating a monopoly among clients. But this
    isn't a major issue because if the client fails to properly verify users, then
    users can easily move to another client without losing their critical data, as
    they are stored as decentralized.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of verifying user identity in applications is to make it difficult
    for users toÂ escape after performing some sort of fraudulent activity, preventing
    users with a fraud/criminal background from using the application, and providing
    theÂ means for other users in the network to believe a user to be whom the user
    is claiming to be. It doesn't matter what procedure is used to verify user identity;
    theyÂ are always ways for users to represent themselves to be someone else. It
    doesn't matter whether we use digital identities or scanned documents for verification
    because both can be stolen and reused. What's important is just to make it difficult
    for users to represent themselves to be someone else and also collect enough data
    to track a user and prove that the user has done a fraudulent activity.
  prefs: []
  type: TYPE_NORMAL
- en: User accounts in DApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications need user accounts' functionality. Data associated with an
    account should be modifiable by the account owner only. DApps simply cannot have
    the same username- and password-based account functionality as doÂ centralized
    applications because passwords cannot prove that the data change for an account
    has been requested by the owner.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few ways to implement user accounts in DApps. But the most
    popular way is using a public-private key pair to represent an account. The hash
    of the public key is the unique identifier of the account. To make a change to
    the account's data, the user needs to sign the change using his/herÂ private key.
    We need to assume that users will store their private keys safely. If users lose
    their private keys, then they lose access to their account forever.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the centralized apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DApp shouldn't depend on centralized apps because of a single point of failure.
    But in some cases, there is no other option. For example, if a DApp wants to read
    a football score, then where will it get the data from? Although a DApp can depend
    on another DApp, why will FIFA create a DApp? FIFA will not create a DApp just
    because other DApps want the data. This is because a DApp to provide scores is
    of no benefit as it will ultimately be controlled by FIFA completely.
  prefs: []
  type: TYPE_NORMAL
- en: So in some cases, a DApp needs to fetch data from a centralized application.
    But the major problem is how the DApp knows that the data fetched from a domain
    is not tampered by a middle service/man and is the actual response. Well, there
    are various ways to resolve this depending on the DApp architecture. For example,
    in Ethereum, for the smart contracts to access centralized APIs, they can use
    the Oraclize service as a middleman as smart contracts cannot make direct HTTP
    requests. Oraclize provides a TLSNotary proof for the data it fetches for the
    smart contract from centralized services.
  prefs: []
  type: TYPE_NORMAL
- en: Internal currency in DApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a centralized application to sustain for a long time, the owner of the app
    needs to make a profit in order to keep it running. DApps don't have an owner,
    but still, like any other centralized app, the nodes of a DApp need hardware and
    network resources to keep it running. So the nodes of a DApp need something useful
    in return to keep the DApp running. That's where internal currency comes into
    play. Most DApps have a built-in internal currency, or we can say that most successful
    DApps have a built-in internal currency.
  prefs: []
  type: TYPE_NORMAL
- en: The consensus protocol is what decides how much currency a node receives. Depending
    on the consensus protocol, only certain kinds of nodes earn currency. We can also
    say that the nodes that contribute to keeping the DApp secure and running are
    the ones that earn currency. Nodes that only read data are not rewarded with anything.
    For example, in Bitcoin, only miners earn Bitcoins for successfully mining blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest question is since this is a digital currency, why would someone
    value it? Well, according to economics, anything that has demand and whose supply
    is insufficient will have value.
  prefs: []
  type: TYPE_NORMAL
- en: Making users pay to use the DApp using the internal currency solves the demand
    problem. As more and more users use the DApp, the demand also increases and, therefore,
    the value of the internal currency increases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a fixed amount of currency that can be produced makes the currency scarce,
    giving it a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: The currency is supplied over time instead of supplying all the currency at
    a go. This is done so that new nodes that enter the network to keep it secure
    and running also earn the currency.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of internal currency in DApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only demerit of having internal currency in DApps is that the DApps are
    not free for use anymore. This is one of the places where centralized applications
    get the upper hand as centralized applications can be monetized using ads, providing
    premium APIs for third-party apps, and so and can be made free for users.
  prefs: []
  type: TYPE_NORMAL
- en: In DApps, we cannot integrate ads because there is no one to check the advertising
    standards; the clients may not display ads because there is no benefit for them
    in displaying ads.
  prefs: []
  type: TYPE_NORMAL
- en: What are permissioned DApps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been learning about DApps, which are completely open and
    permissionless; that is, anyone can participate without establishing an identity.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, permissioned DApps are not open for everyone to participate.
    Permissioned DApps inherit all properties of permissionless DApps, except that
    you need permission to participate in the network. Permission systems vary between
    permissioned DApps.
  prefs: []
  type: TYPE_NORMAL
- en: To join a permissioned DApp, you need permission, so consensus protocols of
    permissionless DApps may not work very well in permissioned DApps; therefore,
    they have different consensus protocols than permissionless DApps. Permissioned
    DApps don't have internal currency.
  prefs: []
  type: TYPE_NORMAL
- en: Popular DApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some high-level knowledge about what DApps are and how they
    are different from centralized apps, let's explore some of the popular and useful
    DApps. While exploring these DApps, we will explore them at a level that is enough
    to understand how they work and tackle various issues instead of diving too deep.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin is a decentralized currency. Bitcoin is the most popular DApp and its
    success is what showed how powerful DApps can be and encouraged people to build
    other DApps.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into further details about how Bitcoin works and why people and
    the government consider it to be a currency, we need to learn what ledgers and
    blockchains are.
  prefs: []
  type: TYPE_NORMAL
- en: What is a ledger?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ledger is basically a list of transactions. A database is different from a
    ledger. In a ledger, we can only append new transactions, whereas in a database,
    we can append, modify, and delete transactions. A database can be used to implement
    a ledger.
  prefs: []
  type: TYPE_NORMAL
- en: What is blockchain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A blockchain is a data structure used to create a decentralized ledger. A blockchain
    is composed of blocks in a serialized manner. A block contains a set of transactions,
    a hash of the previous block, timestamp (indicating when the block was created),
    block reward, block number, and so on. Every block contains a hash of the previous
    block, thus creating a chain of blocks linked with each other. Every node in the
    network holds a copy of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-work, proof-of-stake, and so on are various consensus protocols used
    to keep the blockchain secure. Depending on the consensus protocol, the blocks
    are created and added to the blockchain differently. In proof-of-work, blocks
    are created by a procedure called mining, which keeps the blockchain safe. In
    the proof-of-work protocol, mining involves solving complex puzzles. We will learn
    more about blockchain and its consensus protocols later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain in the Bitcoin network holds Bitcoin transactions. Bitcoins are
    supplied to the network by rewarding new Bitcoins to the nodes that successfully
    mine blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage of blockchain data structure is that it automates auditing
    and makes an application transparent yet secure. It can prevent fraud and corruption.
    It can be used to solve many other problems depending on how you implement and
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Is Bitcoin legal?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, Bitcoin is not an internal currency; rather, it's a decentralized
    currency. Internal currencies are mostly legal because they are an asset and their
    use is obvious.
  prefs: []
  type: TYPE_NORMAL
- en: The main question is whether currency-only DApps are legal or not. The straight
    answer is that it's legal in many countries. Very few countries have made it illegal
    and most are yet to decide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few reasons why some countries have made it illegal and most are
    yet to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the identity issue in DApps, user accounts don't have any identity associated
    with them in Bitcoin; therefore, it can be used for money laundering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These virtual currencies are very volatile, so there is a higher risk of people
    losing money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is really easy to evade taxes when using virtual currencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why would someone use Bitcoin?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bitcoin network is used to only send/receive Bitcoins and nothing else.
    So you must be wondering why there would be demand for Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons why people use Bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage of using Bitcoin is that it makes sending and receiving
    payments anywhere in the world easy and fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online payment transaction fees are expensive compared to Bitcoin transaction
    fees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hackers can steal your payment information from merchants, but in the case of
    Bitcoin, stealing Bitcoin addresses is completely useless because for a transaction
    to be valid, it must be signed with its associated private key, which the user
    doesn't need to share with anyone to make a payment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is a decentralized platform that allows us to run DApps on top of it.
    These DApps are written using smart contracts. One or more smart contracts can
    form a DApp together. An Ethereum smart contract is a program that runs on Ethereum.
    A smart contract runs exactly as programmed without any possibility of downtime,
    censorship, fraud, and third-party interference.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using Ethereum to run smart contracts is that it makes
    it easy for smart contracts to interact with each other. Also, you don't have
    to worry about integrating consensus protocol and other things; instead, you just
    need to write the application logic. Obviously, you cannot build any kind of DApp
    using Ethereum; you can build only those kinds of DApps whose features are supported
    by Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has an internal currency called ether. To deploy smart contracts or
    execute functions of the smart contracts, you need ether.
  prefs: []
  type: TYPE_NORMAL
- en: This book is dedicated to building DApps using Ethereum. Throughout this book,
    you will learn every bit of Ethereum in depth.
  prefs: []
  type: TYPE_NORMAL
- en: The Hyperledger project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperledger is a project dedicated to building technologies to build permissioned
    DApps. Hyperledger fabric (or simply fabric) is an implementation of the Hyperledger
    project. Other implementations include Intel Sawtooth and R3 Corda.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric is a permissioned decentralized platform that allows us to run permissioned
    DApps (called chaincodes) on top of it. We need to deploy our own instance of
    fabric and then deploy our permissioned DApps on top of it. Every node in the
    network runs an instance of fabric. Fabric is a plug-and-play system where you
    can easily plug and play various consensus protocols and features.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger uses the blockchain data structure. Hyperledger-based blockchains
    can currently choose to have no consensus protocols (that is, the **NoOps** protocol)
    or else use the **PBFT** (**Practical Byzantine Fault Tolerance**) consensus protocol.
    It has a special node called certificate authority, which controls who can join
    the network and what they can do.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IPFS** (**InterPlanetary File System**) is a decentralized filesystem. IPFS
    uses **DHT** (**distributed hash table**) and Merkle **DAG** (**directed acyclic
    graph**) data structures. It uses a protocol similar to BitTorrent to decide how
    to move data around the network. One of the advanced features of IPFS is that
    it supports file versioning. To achieve file versioning, it uses data structures
    similar to Git.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it called a decentralized filesystem, it doesn't adhere to a major
    property of a filesystem; that is, when we store something in a filesystem, it
    is guaranteed to be there until deleted. But IPFS doesn't work that way. Every
    node doesn't hold all files; it stores the files it needs. Therefore, if a file
    is less popular, then obviously many nodes won't have it; therefore, there is
    a huge chance of the file disappearing from the network. Due to this, many people
    prefer to call IPFS a decentralized peer-to-peer file-sharing application. Or
    else, you can think of IPFS as BitTorrent, which is completely decentralized;
    that is, it doesn't have a tracker and has some advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at an overview of how IPFS works. When we store a file in IPFS, it's
    split into chunks < 256 KB and hashes of each of these chunks are generated. Nodes
    in the network hold the IPFS files they need and their hashes in a hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of IPFS files: blob, list, tree, and commit. A blob represents
    a chunk of an actual file that''s stored in IPFS. A list represents a complete
    file as it holds the list of blobs and other lists. As lists can hold other lists,
    it helps in data compression over the network. A tree represents a directory as
    it holds a list of blobs, lists, other trees, and commits. And a commit file represents
    a snapshot in the version history of any other file. As lists, trees, and commits
    have links to other IPFS files, they form a Merkle DAG.'
  prefs: []
  type: TYPE_NORMAL
- en: So when we want to download a file from the network, we just need the hash of
    the IPFS list file. Or if we want to download a directory, then we just need the
    hash of the IPFS tree file.
  prefs: []
  type: TYPE_NORMAL
- en: As every file is identified by a hash, the names are not easy to remember. If
    we update a file, then we need to share a new hash with everyone that wants to
    download that file. To tackle this issue, IPFS uses the IPNS feature, which allows
    IPFS files to be pointed using self-certified names or human-friendly names.
  prefs: []
  type: TYPE_NORMAL
- en: Filecoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major reason that is stopping IPFS from becoming a decentralized filesystem
    is that nodes only store the files they need. Filecoin is a decentralized filesystem
    similar to IPFS with an internal currency to incentivize nodes to store files,
    thus increasing file availability and making it more like a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes in the network will earn Filecoins to rent disk space, and to store/retrieve
    files, you need to spend Filecoins.
  prefs: []
  type: TYPE_NORMAL
- en: Along with IPFS technologies, Filecoin uses the blockchain data structure and
    the proof-of- retrievability consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this, Filecoin is still under development, so many things
    are still unclear.
  prefs: []
  type: TYPE_NORMAL
- en: Namecoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namecoin is a decentralized key-value database. It has an internal currency
    too, called Namecoins. Namecoin uses the blockchain data structure and the proof-of-work
    consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In Namecoin, you can store key-value pairs of data. To register a key-value
    pair, you need to spend Namecoins. Once you register, you need to update it once
    in every 35,999 blocks; otherwise, the value associated with the key will expire.
    To update, you need Namecoins as well. There is no need to renew the keys; that
    is, you don't need to spend any Namecoins to keep the key after you have registered
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Namecoin has a namespace feature that allows users to organize different kinds
    of keys. Anyone can create namespaces or use existing ones to organize keys.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most popular namespaces are `a` (application specific data), `d`
    (domain name specifications), `ds` (secure domain name), `id` (identity), `is`
    (secure identity), `p` (product), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: .bit domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access a website, a browser first finds the IP address associated with the
    domain. These domain name and IP address mappings are stored in DNS servers, which
    are controlled by large companies and governments. Therefore, domain names are
    prone to censorship. Governments and companies usually block domain names if the
    website is doing something illegal or making loss for them or due to some other
    reason.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, there was a need for a decentralized domain name database. As Namecoin
    stores key-value data just like DNS servers, Namecoin can be used to implement
    a decentralized DNS, and this is what it has already been used for. The d and
    ds namespaces contain keys ending with `.bit`, representing `.bit` domain names.
    Technically, a namespace doesn't have any naming convention for the keys but all
    the nodes and clients of Namecoin agree to this naming convention. If we try to
    store invalid keys in `d` and `ds` namespaces, then clients will filter invalid
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: A browser that supports `.bit` domains needs to look up in the Namecoin's `d`
    and `ds` namespace to find the IP address associated with the `.bit` domain.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `d` and `ds` namespaces is that `ds` stores domains
    that support TLS and `d` stores the ones that don't support TLS. We have made
    DNS decentralized; similarly, we can also make the issuing of TLS certificates
    decentralized.
  prefs: []
  type: TYPE_NORMAL
- en: This is how TLS works in Namecoin. Users create self-signed certificates and
    store the certificate hash in Namecoin. When a client that supports TLS for `.bit`
    domains tries to access a secured `.bit` domain, it will match the hash of the
    certificate returned by the server with the hash stored in Namecoin, and if they
    match, then they proceed with further communication with the server.
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized DNS formed using Namecoin is the first solution to the Zooko
    triangle. The Zooko triangle defines applications that have three properties,
    that is, decentralized, identity, and secure. Digital identity is used not only
    to represent a person, but it can also represent a domain, company, or something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Dash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dash is a decentralized currency similar to Bitcoin. Dash uses the blockchain
    data structure and the proof-of-work consensus protocol. Dash solves some of the
    major issues that are caused by Bitcoin. Here are some issues related to Bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions take a few minutes to complete, and in today's world, we need transactions
    to complete instantly. This is because theÂ mining difficulty in the Bitcoin network
    is adjusted in such a way that a block gets created once in an average of every
    10 minutes. We will learn more about mining later on in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although accounts don't have an identity associated with them, trading Bitcoins
    for real currency on an exchange or buying stuff with Bitcoins is traceable; therefore,
    these exchanges or merchants can reveal your identity to governments or other
    authorities. If you are running your own node to send/receive transactions, then
    your ISP can see the Bitcoin address and trace the owner using the IP address
    because broadcasted messages in the Bitcoin network are not encrypted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dash aims to solve these problems by making transactions settle almost instantly
    and making it impossible to identify the real person behind an account. It also
    prevents your ISP from tracking you.
  prefs: []
  type: TYPE_NORMAL
- en: In the Bitcoin network, there are two kinds of nodes, that is, miners and ordinary
    nodes. But in Dash, there are three kinds of nodes, that is, miners, masternodes,
    and ordinary nodes. Masternodes areÂ what makes Dash so special.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized governance and budgeting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To host a masternode, you need to have 1,000 Dashes and a static IP address.
    In the Dash network, both masternodes and miners earn Dashes. When a block is
    mined, 45% reward goes to the miner, 45% goes to the masternodes, and 10% is reserved
    for the budget system.
  prefs: []
  type: TYPE_NORMAL
- en: Masternodes enable decentralized governance and budgeting. Due to the decentralized
    governance and budgeting system, Dash is called a DAO because that's exactly what
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: Masternodes in the network act like shareholders; that is, they have rights
    to take decisions regarding where the 10% Dash goes. This 10% Dash is usually
    used to funds other projects. Each masternode is given the ability to use one
    vote to approve a project.
  prefs: []
  type: TYPE_NORMAL
- en: Discussions on project proposals happen out of the network. But the voting happens
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Masternodes can provide a possible solution to verify user identity in DApps;
    that is, masternodes can democratically select a node to verify user identity.
    The person or business behind this node can manually verify user documents. A
    part of this reward can also go to this node. If the node doesn't provide good
    service, then the masternodes can vote for a different node. This can be a fine
    solution to the decentralized identity issue.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of just approving or rejecting a proposal, masternodes also form a service
    layer that provides various services. The reason that masternodes provide services
    is that the more services they provide, the more feature-rich the network becomes,
    thus increasing users and transactions, which increases prices for Dash currency
    and the block reward also gets high, therefore helping masternodes earn more profit.
  prefs: []
  type: TYPE_NORMAL
- en: Masternodes provide services such as PrivateSend (a coin-mixing service that
    provides anonymity), InstantSend (a service that provides almost instant transactions),
    DAPI (a service that provides a decentralized API so that users don't need to
    run a node), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: At a given time, only 10 masternodes are selected. The selection algorithm uses
    the current block hash to select the masternodes. Then, we request a service from
    them. The response that's received from the majority of nodes is said to be the
    correct one. This is how consensus is achieved for services provided by the masternodes.
  prefs: []
  type: TYPE_NORMAL
- en: The proof-of-service consensus protocol is used to make sure that the masternodes
    are online, are responding, and have their blockchain up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: BigChainDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BigChainDB allows you to deploy your own permissioned or permissionless decentralized
    database. It uses the blockchain data structure along with various other database-specific
    data structures. BigChainDB, at the time of writing this, is still under development,
    so many things are not clear yet.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides many other features, such as rich permissions, querying, linear
    scaling, and native support for multi-assets and the federation consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBazaar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenBazaar is a decentralized e-commerce platform. You can buy or sell goods
    using OpenBazaar. Users are not anonymous in the OpenBazaar network as their IP
    address is recorded. A node can be a buyer, seller, or a moderator.
  prefs: []
  type: TYPE_NORMAL
- en: It uses a Kademlia-style distributed hash table data structure. A seller must
    host a node and keep it running in order to make the items visible in the network.
  prefs: []
  type: TYPE_NORMAL
- en: It prevents account spam by using the proof-of-work consensus protocol. It prevents
    ratings and reviews spam using proof-of-burn, CHECKLOCKTIMEVERIFY, and security
    deposit consensus protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Buyers and sellers trade using Bitcoins. A buyer can add a moderator while making
    a purchase. The moderator is responsible for resolving a dispute if anything happens
    between the buyer and the seller. Anyone can be a moderator in the network. Moderators
    earn commission by resolving disputes.
  prefs: []
  type: TYPE_NORMAL
- en: Ripple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ripple is decentralized remittance platform. It lets us transfer fiat currencies,
    digital currencies, and commodities. It uses the blockchain data structure and
    has its own consensus protocol. In ripple docs, you will not find the term blocks
    and blockchain; they use the term ledger instead.
  prefs: []
  type: TYPE_NORMAL
- en: In ripple, money and commodity transfer happens via a trust chain in a manner
    similar to how it happens in a hawala network. In ripple, there are two kinds
    of nodes, that is, gateways and regular nodes. Gateways support deposit and withdrawal
    of one or more currencies and/or commodities. To become a gateway in a ripple
    network, you need permission as gateways to form a trust chain. Gateways are usually
    registered financial institutions, exchanges, merchants, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Every user and gateway has an account address. Every user needs to add a list
    of gateways they trust by adding the gateway addresses to the trust list. There
    is no consensus to find whom to trust; it all depends on the user, and the user
    takes the risk of trusting a gateway. Even gateways can add the list of gateways
    they trust.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of how user X living in India can send 500 USD to user
    Y living in the USA. Assuming that there is a gateway XX in India, which takes
    cash (physical cash or card payments on their website) and gives you only the
    INR balance on ripple, X will visit the XX office or website and deposit 30,000
    INR and then XX will broadcast a transaction saying I owe X 30,000 INR. Now assume
    that there is a gateway YY in the USA, which allows only USD transactions and
    Y trusts YY gateway. Now, say, gateways XX and YY don't trust each other. As X
    and Y don't trust a common gateway, XX and YY don't trust each other, and finally,
    XX and YY don't support the same currency. Therefore, for X to send money to Y,
    he needs to find intermediary gateways to form a trust chain. Assume there is
    another gateway, ZZ, that is trusted by both XX and YY and it supports USD and
    INR. So now X can send a transaction by transferring 50,000 INR from XX to ZZ
    and it gets converted to USD by ZZ and then ZZ sends the money to YY, asking YY
    to give the money to Y. Now instead of X owing Y $500, YY owes $500 to Y, ZZ owes
    $500 to YY, and XX owes 30,000 INR to ZZ. But it's all fine because they trust
    each other, whereas earlier, X and Y didn't trust each other. But XX, YY, and
    ZZ can transfer the money outside of ripple whenever they want to, or else a reverse
    transaction will deduct this value.
  prefs: []
  type: TYPE_NORMAL
- en: Ripple also has an internal currency called XRP (or ripples). Every transaction
    sent to the network costs some ripples. As XRP is the ripple's native currency,
    it can be sent to anyone in the network without trust. XRP can also be used while
    forming a trust chain. Remember that every gateway has its own currency exchange
    rate. XRP isn't generated by a mining process; instead, there are total of 100
    billion XRPs generated in the beginning and owned by the ripple company itself.
    XRP is supplied manually depending on various factors.
  prefs: []
  type: TYPE_NORMAL
- en: All the transactions are recorded in the decentralized ledger, which forms an
    immutable history. Consensus is required to make sure that all nodes have the
    same ledger at a given point of time. In ripple, there is a third kind of node
    called validators, which are part of the consensus protocol. Validators are responsible
    for validating transactions. Anyone can become a validator. But other nodes keep
    a list of validators that can be actually trusted. This list is known as UNL (unique
    node list). A validator also has a UNL; that is, the validators it trusts as validators
    also want to reach a consensus. Currently, ripple decides the list of validators
    that can be trusted, but if the network thinks that validators selected by ripple
    are not trustworthy, then they can modify the list in their node software.
  prefs: []
  type: TYPE_NORMAL
- en: You can form a ledger by taking the previous ledger and applying all the transactions
    that have happened since then. So to agree on the current ledger, nodes must agree
    on the previous ledger and the set of transactions that have happened since then.
    After a new ledger is created, a node (both regular nodes and validators) starts
    a timer (of a few seconds, approximately 5 seconds) and collects the new transactions
    that arrived during the creation of the previous ledger. When the timer expires,
    it takes those transactions that are valid according to at least 80% of the UNLs
    and forms the next ledger. Validators broadcast a proposal (a set of transactions
    they think are valid to form the next ledger) to the network. Validators can broadcast
    proposals for the same ledger multiple times with a different set of transactions
    if they decide to change the list of valid transactions depending on proposals
    from their UNLs and other factors. So you only need to wait 5-10 seconds for your
    transaction to be confirmed by the network.
  prefs: []
  type: TYPE_NORMAL
- en: Some people wonder whether this can lead to many different versions of the ledger
    since each node may have a different UNL. As long as there is a minimal degree
    of inter-connectivity between UNLs, a consensus will rapidly be reached. This
    is primarily because every honest node's primary goal is to achieve a consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what DApps are and got an an overview of how they
    work. We looked at some of the challenges faced by DApps and the various solutions
    to these issues. Finally, we saw some of the popular DApps and had an overview
    of what makes them special and how they work. Now you shouldÂ be comfortable explaining
    what a DApp is and how it works.
  prefs: []
  type: TYPE_NORMAL
