["```\ngetArgs() [][]byte\n\ngetStringArgs() []string\n\ngetArgsSlice() ([]byte, error)\n\ngetTxID() string\n\ninvokeChaincode(chaincodeName string, args [][]byte, channel string) \npb.Response\n\ngetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error)\n\ngetStateByPartialCompositeKey(objectType string, keys []string) (StateQueryIteratorInterface, error)\n\ncreateCompositeKey(objectType string, attributes []string) (string, error)\n\nsplitCompositeKey(compositeKey string) (string, []string, error)\n\ngetCreator() ([]byte, error)\n\ngetTransient() (map[string][]byte, error)\n\ngetBinding() ([]byte, error)\n\ngetSignedProposal() (*pb.SignedProposal, error)\n\ngetTxTimestamp() (*timestamp.Timestamp, error)\n```", "```\nimport (\n  \"bytes\"\n  \"encoding/json\"\n  \"fmt\"\n  \"strconv\"\n  \"time\"\n  \"github.com/hyperledger/fabric/core/chaincode/shim\"\n  \"github.com/hyperledger/fabric/protos/peer\"\n)\n```", "```\n// Chaincode implementation\ntype EducationChaincode struct {\n\n}\n\n// receiver/student struct\ntype Receiver struct {\n  ObjectType string `json:\"docType\"` //docType is used to distinguish the various types of objects in state database\n  Receiver_id string `json:\"receiver_id\"`\n  Receiver_name string `json:\"receiver_name\"`\n  Upload_org string `json:\"upload_org\"`\n}\n\n// certificate data struct\ntype Certificate struct {\n  ObjectType string `json:\"docType\"` //docType is used to distinguish the various types of objects in state database\n  Cert_id string `json:\"cert_id\"`\n  Cert_no string `json:\"cert_no\"`\n  Cert_name string `json:\"cert_name\"`\n  Cert_receiver string `json:\"cert_receiver\"` // student name\n  Cert_receiver_id string `json:\"cert_receiver_id\"` // student id\n  Cert_issuer string `json:\"cert_issuer\"` // org name\n  Cert_industry string `json:\"cert_industry\"`\n  Cert_create_time string `json:\"cert_create_time\"`\n  Cert_update_time string `json:\"cert_update_time\"`\n  Cert_remark string `json:\"cert_remark\"`\n  Cert_url_image string `json:\"cert_url_image\"`\n  Cert_status string `json:\"cert_status\"`\n}\n```", "```\n// main - Start execution\nfunc main() {\n  err := shim.Start(new(EducationChaincode))\n  if err != nil {\n    fmt.Printf(\"Error starting Xebest Trace chaincode: %s\", err)\n  }\n}\n```", "```\n// Init initializes chaincode\nfunc (t *EducationChaincode) Init(stub shim.ChaincodeStubInterface) peer.Response {\n  return shim.Success(nil)\n}\n```", "```\n// Invoke - Invoking user transactions\nfunc (t *EducationChaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response {\n  function, args := stub.GetFunctionAndParameters()\n  fmt.Println(\"invoke is running \" + function)\n\n  // Handle different functions\n  if function == \"insertReceiver\" { //create a new Receiver or student\n    return t.insertReceiver(stub, args)\n  } else if function == \"queryReceiverById\" { // query a receiver by id, stupid name - -!\n    return t.queryReceiverById(stub,args)\n  } else if function == \"insertCertificate\" { //insert a cert\n    return t.insertCertificate(stub, args)\n  } else if function == \"queryCertificateById\" { // query a certificate\n    return t.queryCertificateById(stub, args)\n  } else if function == \"getRecordHistory\"{ //query hisitory of one key for the record\n    return t.getRecordHistory(stub,args)\n  } else if function == \"queryAllCertificates\"{ // query all of all students\n    return t.queryAllCertificates(stub,args)\n  } else if function == \"approveCertificate\" { // change status\n    return t.approveCertificate(stub,args) \n  }else if function == \"deleteRecord\" { // delete student or certificate\n    return t.deleteRecord(stub, args)\n  }\n\n  fmt.Println(\"invoke did not find func: \" + function) //error\n  return shim.Error(\"Received unknown function invocation\")\n}\n```", "```\n// initReceiver - insert a new Receiver into chaincode state\nfunc (t *EducationChaincode) insertReceiver(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n  var err error\n\n  if len(args) != 3 {\n    return shim.Error(\"Incorrect number of arguments. Expecting 3\")\n  }\n\n  fmt.Println(\"start insert receiver\")\n\n  receiver_id := args[0]\n  receiver_name := args[1]\n  upload_org := args[2]\n\n  // Check if the receiver already exists with the id\n  receiverAsBytes, err := stub.GetState(receiver_id)\n  if err != nil {\n    return shim.Error(\"Failed to get receiver: \" + err.Error())\n  } else if receiverAsBytes != nil {\n    fmt.Println(\"This receiver already exists: \" + receiver_id)\n    return shim.Error(\"This receiver already exists: \" + receiver_id)\n  }\n\n  // Create receiver object and marshal to JSON \n  objectType := \"receiver\"\n  receiver := &Receiver{objectType, receiver_id, receiver_name,upload_org}\n  receiverJSONasBytes, err := json.Marshal(receiver)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  fmt.Println(\"receiver: \")\n  fmt.Println(receiver)\n  // Save the receiver to ledger state\n  err = stub.PutState(receiver_id, receiverJSONasBytes)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  // receiver saved and indexed. Return success\n  fmt.Println(\"End init receiver\")\n  return shim.Success(nil)\n\n}\n```", "```\n// queryReceiverById - read data for the given receiver from the chaincode state\nfunc (t *EducationChaincode) queryReceiverById(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n  var recev_id, jsonResp string\n  var err error\n\n  if len(args) != 1 {\n    return shim.Error(\"Incorrect number of arguments. Expecting receiver_id to query\")\n  }\n\n  recev_id = args[0]\n  //Read the Receiver from the chaincode state\n  valAsbytes, err := stub.GetState(recev_id) \n  if err != nil {\n    jsonResp = \"{\\\"Error\\\":\\\"Failed to get state for \" + recev_id + \"\\\"}\"\n    return shim.Error(jsonResp)\n  } else if valAsbytes == nil {\n    jsonResp = \"{\\\"Error\\\":\\\"receiver does not exist: \" + recev_id + \"\\\"}\"\n    return shim.Error(jsonResp)\n  } \n  return shim.Success(valAsbytes)\n}\n```", "```\n// insertCertificate - insert a new certificate information into the ledger state\nfunc (t *EducationChaincode) insertCertificate(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n\n  if len(args) != 11 {\n    return shim.Error(\"Incorrect number of arguments. expecting 11 args\")\n  }\n\n  cert_id := args[0]\n  cert_no := args[1]\n  cert_name := args[2] \n  cert_receiver_id := args[3]\n  cert_issuer := args[4]\n  cert_industry := args[5]\n  cert_create_time := args[6]\n  cert_update_time := args[7]\n  cert_remark := args[8]\n  cert_url_image := args[9]\n  cert_status := args[10]\n\n  // check if receiver exists\n  ReceAsBytes, err := stub.GetState(cert_receiver_id)\n  if err != nil {\n    return shim.Error(\"Failed to get Receiver:\" + cert_receiver_id + \",\" + err.Error())\n  } else if ReceAsBytes == nil {\n    fmt.Println(\"Receiver does not exist with id: \" + cert_receiver_id )\n    return shim.Error(\"Receiver does not exist with id: \" + cert_receiver_id )\n  }\n\n  //Fetch receiver name from the state\n  receiver := &Receiver{}\n  err = json.Unmarshal([]byte(ReceAsBytes), &receiver)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n  cert_receiver :=receiver.Receiver_name;\n  fmt.Println(\"cert_receiver: \"+cert_receiver)\n\n  objectType := \"certificate\"\n  certificate := &Certificate{objectType,cert_id,cert_no,cert_name,cert_receiver,cert_receiver_id,cert_issuer,cert_industry,cert_create_time,cert_update_time,cert_remark,cert_url_image,cert_status}\n  certificateJSONasBytes, err := json.Marshal(certificate)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  // insert the certificate into the ledger\n  err = stub.PutState(cert_id, certificateJSONasBytes)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  // certificate saved - Return success \n  return shim.Success(nil)\n}\n```", "```\n// queryCertificateById - read a certificate by given id from the ledger state\nfunc (t *EducationChaincode) queryCertificateById(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n  var cert_id, jsonResp string\n  var err error\n\n  if len(args) != 1 {\n    return shim.Error(\"Incorrect number of arguments. Expecting id of the certificate to query\")\n  }\n\n  cert_id = args[0]\n  //Read the certificate from chaincode state\n  valAsbytes, err := stub.GetState(cert_id) \n  if err != nil {\n    jsonResp = \"{\\\"Error\\\":\\\"Failed to get state for \" + cert_id + \"\\\"}\"\n    return shim.Error(jsonResp)\n  } else if valAsbytes == nil {\n    jsonResp = \"{\\\"Error\\\":\\\"certificate does not exist: \" + cert_id + \"\\\"}\"\n    return shim.Error(jsonResp)\n  }\n\n  return shim.Success(valAsbytes)\n}\n```", "```\n// approveCertificate - approve the certificate by authority\nfunc (t *EducationChaincode) approveCertificate(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n\n  var err error\n  // check args\n  if len(args) != 3 {\n    return shim.Error(\"Incorrect number of arguments. Expecting 3\")\n  }\n  if len(args[0]) <= 0 {\n    return shim.Error(\"1st argument must be a non-empty string\")\n  }\n  if len(args[1]) <= 0 {\n    return shim.Error(\"2nd argument must be a non-empty string\")\n  }\n  if len(args[2]) <= 0 {\n    return shim.Error(\"3rd argument must be a non-empty string\")\n  }\n\n  cert_id := args[0]\n  status := args[1]\n  update_time := args[2]\n\n  //Read certificate details from the ledger\n  valAsbytes, err := stub.GetState(cert_id) \n    if err != nil {\n      return shim.Error(err.Error())\n    } else if valAsbytes == nil {\n      return shim.Error(\"certificate not exist\")\n    }\n\n  certificate := &Certificate{}\n  err = json.Unmarshal([]byte(valAsbytes), &certificate)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n  certificate.Cert_status = status\n  certificate.Cert_update_time = update_time\n\n  valAsbytes, err = json.Marshal(certificate)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n  //Update the certificate in the ledger\n  err = stub.PutState(cert_id, valAsbytes)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  return shim.Success(nil)\n}\n```", "```\n// queryAllCertificates - Query all certificates from the ledger state\nfunc (t *EducationChaincode) queryAllCertificates(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n\n  queryString := \"{\\\"selector\\\":{\\\"docType\\\":\\\"certificate\\\"}}\"\n\n  queryResults, err := getQueryResultForQueryString(stub, queryString)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n  return shim.Success(queryResults)\n}\n```", "```\n// getRecordHistory - Fetches the historical state transitions for a given key of a record\nfunc (t *EducationChaincode) getRecordHistory(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n\n  if len(args) < 1 {\n    return shim.Error(\"Incorrect number of arguments. Expecting an id of Receiver or Certificate\")\n  }\n\n  recordKey := args[0]\n\n  fmt.Printf(\"Fetching history for record: %s\\n\", recordKey)\n\n  resultsIterator, err := stub.GetHistoryForKey(recordKey)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n  defer resultsIterator.Close()\n\n  // buffer is a JSON array containing historic values for the key/value pair\n  var buffer bytes.Buffer\n  buffer.WriteString(\"[\")\n\n  bArrayMemberAlreadyWritten := false\n  for resultsIterator.HasNext() {\n    response, err := resultsIterator.Next()\n    if err != nil {\n      return shim.Error(err.Error())\n    }\n    // Add a comma before array members, suppress it for the first array member\n    if bArrayMemberAlreadyWritten == true {\n      buffer.WriteString(\",\")\n    }\n    buffer.WriteString(\"{\\\"TxId\\\":\")\n    buffer.WriteString(\"\\\"\")\n    buffer.WriteString(response.TxId)\n    buffer.WriteString(\"\\\"\")\n\n    buffer.WriteString(\", \\\"Value\\\":\")\n    // if it was a delete operation on given key, then we need to set the\n    //corresponding value null. Else, we will write the response.Value\n    //as-is (as the Value itself a JSON goods)\n    if response.IsDelete {\n      buffer.WriteString(\"null\")\n    } else {\n      buffer.WriteString(string(response.Value))\n    }\n\n    buffer.WriteString(\", \\\"Timestamp\\\":\")\n    buffer.WriteString(\"\\\"\")\n    buffer.WriteString(time.Unix(response.Timestamp.Seconds, int64(response.Timestamp.Nanos)).String())\n    buffer.WriteString(\"\\\"\")\n\n    buffer.WriteString(\", \\\"IsDelete\\\":\")\n    buffer.WriteString(\"\\\"\")\n    buffer.WriteString(strconv.FormatBool(response.IsDelete))\n    buffer.WriteString(\"\\\"\")\n\n    buffer.WriteString(\"}\")\n    bArrayMemberAlreadyWritten = true\n  }\n  buffer.WriteString(\"]\")\n\n  fmt.Printf(\"Result of getHistoryForRecord :\\n%s\\n\", buffer.String())\n\n  return shim.Success(buffer.Bytes())\n}\n```", "```\n// getQueryResultForQueryString executes the passed in query string.\n// Result set is built and returned as a byte array containing the JSON results.\n\nfunc getQueryResultForQueryString(stub shim.ChaincodeStubInterface, queryString string) ([]byte, error) {\n\n  fmt.Printf(\"getQueryResultForQueryString queryString:\\n%s\\n\", queryString)\n\n  resultsIterator, err := stub.GetQueryResult(queryString)\n  if err != nil {\n    return nil, err\n  }\n  defer resultsIterator.Close()\n\n  // buffer is a JSON array containing QueryRecords\n  var buffer bytes.Buffer\n  buffer.WriteString(\"[\")\n\n  bArrayMemberAlreadyWritten := false\n  for resultsIterator.HasNext() {\n    queryResponse, err := resultsIterator.Next()\n    if err != nil {\n      return nil, err\n    }\n    // Add a comma before array members, suppress it for the first array member\n    if bArrayMemberAlreadyWritten == true {\n      buffer.WriteString(\",\")\n    }\n    buffer.WriteString(string(queryResponse.Value))\n    bArrayMemberAlreadyWritten = true\n  }\n  buffer.WriteString(\"]\")\n\n  fmt.Printf(\"getQueryResultForQueryString queryResult:\\n%s\\n\", buffer.String())\n\n  return buffer.Bytes(), nil\n}\n```", "```\n// deleteRecord - Mark the record deleted by given key\n\nfunc (t *EducationChaincode) deleteRecord(stub shim.ChaincodeStubInterface, args []string) peer.Response {\n\n  if len(args) != 1{\n    return shim.Error(\"Incorrect number of arguments. Expecting 1\")\n  }\n\n  id := args[0]\n  err := stub.DelState(id)\n  if err != nil {\n    return shim.Error(err.Error())\n  }\n\n  return shim.Success(nil)\n}\n```", "```\nconst shim = require('fabric-shim');\nconst Chaincode = class {\n    async Init(stub) {\n        return shim.success();\n    }\n    async Invoke(stub) {\n        let ret = stub.getFunctionAndParameters();\n        let method = this[ret.fcn];\n        console.log(\"Inside invoke. Calling method: \" + ret.fcn);\n        if (!method) {\n            shim.error(Buffer.from('Received unknown function ' + ret.fcn + ' invocation'));\n        }\n        try {\n            let payload = await method(stub, ret.params);\n            return shim.success(payload);\n        } catch (err) {\n            console.log(err);\n            return shim.error(err);\n        }\n    }\n\n    //Method to save or update a user review to a product\n\n    async insertReceiver(stub, args) {\n        console.log(\"inside insertReceiver: \" + JSON.stringify(args));\n        if (args.length != 3) {\n            throw 'Incorrect number of arguments. Expecting ID,Name and Org.';\n        }\n        var receiver = {};\n                             receiver.ObjectType = \"receiver\";\n        receiver.Receiver_id = args[0];\n        receiver.Receiver_name = args[1];\n        receiver.Upload_org = args[2];\n        await stub.putState(receiver.Receiver_id, Buffer.from(JSON.stringify(receiver)));\n    }//End of method\n}\n\nshim.start(new Chaincode());\n```", "```\n{\n  \"name\": \"education\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Chaincode implemented in node.js\",\n  \"engines\": {\n    \"node\": \">=8.9.0\",\n    \"npm\": \">=5.5.0\"\n  }, \n  \"scripts\": { \n    \"start\" : \"node education.js\"\n  },\n  \"engine-strict\": true,\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": { \n    \"fabric-shim\": \"~1.3.0\"\n  } \n}\n```", "```\nvar testEventValue []byte\n\ntestEventValue=[]byte(\"Certificate \"+cert_id+\" status is changed to \"+status)\n\nstub.SetEvent(\"testEvent\",testEventValue)\n```", "```\n{\n  \"requests\":[\n  {\n    \"eventType\":\"chaincodeEvent\",\n    \"callbackURL\": \"--- call back webhook url---\",\n    \"callbackTlsCerts\":{\n      \"caCert\":\" -- mandatory field which is the callback server's CA certificate in PEM format. It will be verified by REST proxy\",\n      \"clientCert\": \"--Optional field which refers to the REST proxy certificate should use during callback --\",\n      \"keyPassword\": \"--clientCert's encrypted private key in base64 encoded\"\n    },\n    \"expires\": \"1m\",\n    \"channel\": \"channeleducation\",\n    \"chaincode\": \"cceducation\",\n    \"eventName\": \"testEvent\"\n  }\n  ]\n}\n```", "```\n{\n\n    \"request\":{\n\n    \"subid\": \"---subscription id received---\"\n  }\n\n}\n```", "```\nD:\\Anand\\OBP\\chaincode\\testing\\go>go test -run Education\n Inside TestEducation\n invoke is running insertReceiver\n start insert receiver\n receiver:\n &{receiver std1231 Anand Y Blockchain}\n End init receiver\n Result insertReceiver:\n {200 [] {} [] 0}\n invoke is running queryReceiverById\n Result queryReceiverById:\n &{receiver std1231 Anand Y Blockchain}\n invoke is running insertCertificate\n cert_receiver: Anand Y\n {200 [] {} [] 0}\n Result insertCertificate:\n {200 [] {} [] 0}\n invoke is running queryCertificateById\n Result queryCertificateById:\n &{certificate cert123 12345 ORU Blockchain Certificate Anand Y std1231 ORU IT 06/04/2019 06/04/2019 Blockchain course completed Active}\n invoke is running approveCertificate\n {200 [] {} [] 0}\n Result approveCertificate:\n {200 [] {} [] 0}\n invoke is running queryCertificateById\n Result queryCertificateById:\n &{certificate cert123 12345 ORU Blockchain Certificate Anand Y std1231 ORU IT 06/04/2019 06/04/2019 10:41:50 Blockchain course completed Approved}\n PASS\n ok _/D_/Anand/OBP/chaincode/testing/go 3.921s\n```", "```\n{\n\"channel\":<channel name>,\n\"chaincode\":<chaincode name>,\n\"method\": <method name>,\n\"args\":[<arguments separated by comma>]\n}\n```"]