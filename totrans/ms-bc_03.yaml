- en: Chapter 3. Cryptography and Technical Foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the concepts, theory, and practical
    aspects of cryptography. More focus will be given to aspects that are specifically
    relevant in the context of the blockchain technology. Moreover, concepts from
    financial markets will also be discussed in order to provide a basis for the material
    covered in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You will also be introduced to the practical implementations of cryptographic
    algorithms so that you can experience the cryptographic functions practically.
    For this, the **OpenSSL** command line is used.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the theoretical foundations, the installation of OpenSSL is
    discussed in the following section so that you can do some practical work as you
    read through the theoretical material.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu Linux distribution, OpenSSL is usually already available; however,
    it can be installed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the upcoming sections, first, the theoretical foundation will be discussed
    and then relevant practical experiments will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography is the science of making information secure in the presence of
    adversaries. It provides a means of secure communication in the presence of adversaries
    with assumed limitless resources. Ciphers are used to encrypt data so that if
    intercepted by an adversary, the data is meaningless to them without decryption,
    which requires the secret key.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is generally used to provide a confidentiality service. On its
    own, it cannot be considered a complete solution but serve as a crucial building
    block within a larger security system to address a security problem.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography provides various security services, such as **Confidentiality,
    Integrity, Authentication**, (Entity Authentication and Data origin authentication)
    and **non-repudiation**. Additionally, accountability is also required in various
    security systems.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing cryptography further, there are some mathematical terms and
    concepts that need to be explained first in order to fully understand the material
    provided later in this chapter. The next section introduces these concepts. It
    should be noted that this section is intended as a basic introduction. An explanation
    with proofs and relevant background for all these terms will require rather involved
    mathematics, which is beyond the scope of this book. More details on these topics
    can be found in any standard number theory, algebra, or cryptography text book.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the subject of cryptography is based on mathematics, this section will introduce
    some basic concepts that will help you understand the concepts later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A set is a collection of distinct objects, for example, *X= {1, 2, 3, 4, 5}*.
  prefs: []
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A group is a commutative set with one operation that combines two elements of
    the set. The group operation is closed and associated with an identity element
    defined. Additionally, each element in the set has an inverse. Closure (closed)
    means that if, for example, elements A and B are in the set, then the resultant
    element after performing operation on the elements is also in the set. Associative
    means that the grouping of elements does not affect the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A field is a set that contains both additive and multiplicative groups. More
    precisely, all elements in the set form an additive and multiplicative group.
    It satisfies specific axioms for addition and multiplication. For all group operations,
    the distributive law is also applied. The law dictates that the same sum or product
    will be produced even if any terms or factors are reordered.
  prefs: []
  type: TYPE_NORMAL
- en: A finite field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A finite field is a field with a finite set of elements. Also known as Galois
    fields, these structures are of particular importance in cryptography as they
    can be used to produce accurate and error-free results of arithmetic operations.
    For example, prime finite fields are used in elliptic curve cryptography to construct
    discrete logarithm problem.
  prefs: []
  type: TYPE_NORMAL
- en: Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the number of elements in a field. It is also known as the cardinality
    of the field.
  prefs: []
  type: TYPE_NORMAL
- en: Prime fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a finite field with a prime number of elements. It has specific rules
    for addition and multiplication, and each nonzero element in the field has an
    inverse. Addition and multiplication operations are performed modulo *p*.
  prefs: []
  type: TYPE_NORMAL
- en: Ring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If more than one operation can be defined over an abelian group, that group
    becomes a ring. There are also certain properties that need to be satisfied. A
    ring must have closure and associative and distributive properties.
  prefs: []
  type: TYPE_NORMAL
- en: A cyclic group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A cyclic group is a type of group that can be generated by a single element
    called the group generator. In other words, if the group operation is repeatedly
    applied to a particular element in the group, then all elements in the group can
    be generated.
  prefs: []
  type: TYPE_NORMAL
- en: An abelian group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abelian group is formed when the operation on the elements of a set is commutative.
    Commutative law basically means that changing the order of the elements does not
    affect the result of the operation, for example, *A X B = B X A*.
  prefs: []
  type: TYPE_NORMAL
- en: Modular arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also known as clock arithmetic, numbers in modular arithmetic wrap around when
    they reach a certain fixed number. This fixed number is a positive number called
    modulus and all operations are performed with regard to this fixed number. In
    an analogy to a clock, there are number from 1 to 12\. When it reaches 12, the
    number 1 starts again. In other words, this arithmetic deals with the remainders
    after the division operation. For example, 50 mod 11 is 6 because 50 / 11 leaves
    a remainder of 6.
  prefs: []
  type: TYPE_NORMAL
- en: This completes a basic introduction to some mathematical concepts; in the next
    section, you will be introduced to cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed earlier, cryptography provides various security services, and these
    security services are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Confidentiality is the assurance that information is only available to authorized
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrity is the assurance that information is modifiable only by authorized
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication provides assurance about the identity of an entity or the validity
    of a message. There are two types of authentications, discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Entity authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Entity authentication is the assurance that an entity is currently involved
    and active in a communication session. Traditionally, users are issued a username
    and password, which are used to gain access to the platforms they are using. This
    is called single factor authentication as there is only one factor, namely *something
    you know*, that is, the password and username. This type of authentication is
    not very secure due to various reasons, such as password leakage; therefore, additional
    factors are now commonly used to provide better security. The use of additional
    techniques for user identification is known as multifactor authentication or two-factor
    authentication if only two methods are used. If more than two factors are used
    for authentication, that is called multifactor authentication. Various factors
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first factor is something you have, such as a hardware token or smart card.
    In this case, a user can use a hardware token in addition to login credentials
    to gain access to a system. This provides protection by requiring two factors
    of authentication. A user who has access to the hardware token and knows the log-on
    credentials will be able to access the system. Both factors should be available
    in order to gain access to the system, thus making this method a two-factor authentication
    mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second factor is something you are, which uses biometric features in order
    to identify the user. In this method, a user uses fingerprint, retina, iris, or
    hand geometry to provide an additional factor for authentication. This way, it
    can be ensured that a user was indeed present during the authentication mechanism
    as biometric features are unique to an individual. However, careful implementation
    is required in order to ensure a high level of security as some research has suggested
    that biometric systems can be circumvented in certain scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data origin authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also known as message authentication, this is an assurance that the source of
    information is verified. Data origin authentication implies data integrity because
    if a source is corroborated, then data must not have been altered. Various methods,
    such as **Message Authentication Codes** (**MACs**) and digital signatures are
    most commonly used. These terms will be explained in detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Non-repudiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-repudiation is the assurance that an entity cannot deny a previous commitment
    or action by providing unforgeable evidence. It is a security service that provides
    unforgeable evidence that a particular action has occurred. This property is very
    necessary in disputable situations whereby an entity has denied actions performed,
    for example, placing an order on an e-commerce system. This service produces cryptographic
    evidence in electronic transactions so that in case of disputes, it can be used
    as a confirmation of an action. Non-repudiation has been an active research area
    for many years. Disputes in electronic transactions are a common issue and there
    is a need to address them in order to increase the confidence level of consumers
    in the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-repudiation protocol usually runs in a communication network and is
    used to provide evidence that an action has been taken by an entity (originator
    or recipient) on the network. In this context, there are two communication models
    that can be used to transfer messages from originator *A* to recipient *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: Message is sent directly from originator *A* to recipient *B*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Message is sent to a delivery agent from originator *A*, which then delivers
    the message to recipient *B*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main requirements of a non-repudiation protocol are fairness, effectiveness,
    and timeliness. In many scenarios, there are multiple participants involved in
    a transaction as opposed to only two parties. For example, in electronic trading
    systems, there can be many entities, such as clearing agents, brokers, and traders
    that can be involved in a single transaction. In this case, two-party non-repudiation
    protocols are not appropriate. To address this problem **Multi-party nonrepudiation
    protocols** (**MPNR**) has been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Accountability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accountability is the assurance that actions affecting security can be traced
    to the responsible party. This is usually provided by logging and audit mechanisms
    in systems where a detailed audit is required due to the nature of the business,
    for example, in electronic trading systems. Detailed logs are vital to trace an
    entity's actions, for example, when a trade is placed in an audit record with
    the date and time stamp and the entity's identity is generated and saved in the
    log file. This log file can optionally be encrypted and can be part of the database
    or a standalone ASCII text log file on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptographic primitives are the basic building blocks of a security protocol
    or system. In the following section, you are introduced to cryptographic algorithms
    that are essential for the building of secure protocols and systems. A **security
    protocol** is a set of steps taken in order to achieve required security goals
    by utilizing appropriate security mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Various types of security protocols are in use, such as **authentication protocols**,
    **non-repudiation protocols**, and **key management protocols**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic cryptography model is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cryptographic primitives](img/B05975_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A model showing the generic encryption and decryption model
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, **P**, **E**, **C**, and **D** represents Plain text,
    Encryption, Cipher text, and Decryption, respectively. Also, based on the model
    shown earlier, it is worth explaining various concepts such as entity, sender,
    receiver, adversary, key, and a channel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: It is either a person or a system that sends, receives, or performs
    operations on data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sender**: Sender is an entity that transmits the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver**: Receiver is an entity that takes delivery of the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adversary**: This is an entity that tries to circumvent the security service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key**: A key is some data that is used to encrypt or decrypt data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: Channel provides a medium of communication between entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography is mainly divided into two categories, namely symmetric and asymmetric
    cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symmetric cryptography refers to a type of cryptography whereby the key that
    is used to encrypt the data is the same for decrypting the data, and thus it is
    also known as a shared key cryptography. The key must be established or agreed
    on before the data exchange between the communicating parties. This is the reason
    it is also called **secret key cryptography**.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of symmetric ciphers, stream ciphers and block ciphers.
    **Data Encryption Standard** (**DES**) and **Advanced Encryption Standard** (**AES**)
    are common examples of block ciphers, whereas RC4 and A5 are commonly used stream
    ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: Stream ciphers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These ciphers are encryption algorithms that apply encryption algorithms on
    a bit-by-bit basis to plain text using a key stream. There are two types of stream
    ciphers: synchronous and asynchronous. Synchronous stream ciphers are ones where
    key stream is dependent only on the key, whereas asynchronous stream ciphers have
    a key stream that is also dependent on the encrypted data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In stream ciphers, encryption and decryption are basically the same function
    because they are simple modulo 2 additions or XOR operation. The key requirement
    in stream ciphers is the security and randomness of key streams. Various techniques
    have been developed to generate random numbers, and it''s vital that all key generators
    be cryptographically secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stream ciphers](img/B05975_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Operation of a stream cipher
  prefs: []
  type: TYPE_NORMAL
- en: Block ciphers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are encryption algorithms that break up a text to be encrypted (plain
    text) into blocks of fixed length and apply encryption block by block. Block ciphers
    are usually built using a design strategy known as Fiestel cipher. Recent block
    ciphers, such as AES (Rijndael) have been built using a combination of substitution
    and permutation called **substitution-permutation network** (**SPN**).
  prefs: []
  type: TYPE_NORMAL
- en: Fiestel ciphers are based on the Fiestel network, which is a structure developed
    by *Horst Fiestel*. This structure is based on the idea of combining multiple
    rounds of repeated operations to achieve desirable cryptographic properties knows
    as confusion and diffusion. Fiestel networks operate by dividing data into two
    blocks (left and right) and process these blocks via keyed round functions.
  prefs: []
  type: TYPE_NORMAL
- en: Confusion makes the relationship between the encrypted text and plaintext complex.
    This is achieved by substitution in practice. For example, 'A' in plain text is
    replaced by 'X' in encrypted text. In modern cryptographic algorithms, substitution
    is performed using lookup tables called S-boxes. The diffusion property spreads
    the plain text statistically over the encrypted data, which ensures that even
    if a single bit is changed in the input text, it results in changing at least
    half (on average) of the bits in the cipher text. Confusion is required to make
    finding the encryption key very difficult even if many encrypted and decrypted
    data pairs are created using the same key. In practice, this is achieved by transposition
    or permutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key advantage of using Fiestel cipher is that encryption and decryption operations
    are almost identical and only require a reversal of the encryption process in
    order to achieve decryption. DES is a prime example of Fiestel-based ciphers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Block ciphers](img/B05975_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simplified operation of a block cipher
  prefs: []
  type: TYPE_NORMAL
- en: Various modes of operation for block ciphers are **Electronic Code Book** (**ECB**),
    **Cipher block chaining** (**CBC**), **Output Feedback Mode** (**OFB**), or **Counter
    mode** (**CTR**). These modes are used to specify the way in which an encryption
    function would be applied to the plain text. These modes will be explained later
    in this section, but the first four categories of block cipher encryption modes
    are introduced here.
  prefs: []
  type: TYPE_NORMAL
- en: Block encryption mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this mode, plaintext is divided into blocks of fixed length depending on
    the type of cipher used and then the encryption function is applied on each block.
  prefs: []
  type: TYPE_NORMAL
- en: Keystream generation modes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this mode, the encryption function generates a keystream that is then XORed
    with the plaintext stream in order to achieve encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Message authentication modes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this mode, a message authentication code is computed as a result of an encryption
    function. MAC is basically a cryptographic checksum that provides an integrity
    service. The most common method to generate MAC using block ciphers is CBC-MAC,
    where some part of the last block of the chain is used as a MAC.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hashes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hash functions are basically used to compress a message to a fixed length digest.
    In this mode, block ciphers are used as a compression function to produce a hash
    of plain text.
  prefs: []
  type: TYPE_NORMAL
- en: The most common block encryption modes are discussed briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic code book
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a basic mode of operation in which the encrypted data is produced as
    a result of applying the encryption algorithm one by one separately to each block
    of plain text. This is the simplest mode but should not be used in practice as
    it is insecure and can reveal information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic code book](img/B05975_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Electronic code book mode for block ciphers
  prefs: []
  type: TYPE_NORMAL
- en: Cipher block chaining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this mode, each block of plain text is XORed with the previous encrypted
    block. The CBC mode uses initialization vector IV to encrypt the first block.
    It is recommended that IV be randomly chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cipher block chaining](img/B05975_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cipher block chaining mode
  prefs: []
  type: TYPE_NORMAL
- en: Counter mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The CTR mode effectively uses a block cipher as a stream cipher. In this case,
    a unique nonce is supplied that is concatenated with the counter value in order
    to produce a **key stream**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counter mode](img/B05975_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Counter mode
  prefs: []
  type: TYPE_NORMAL
- en: There are other modes, such as **Cipher Feedback mode** (**CFB**), **Galois
    Counter mode** (**GCM**), and Output Feedback mode, which are also used in various
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will be introduced to the design and mechanism
    of a currently dominant block cipher know as AES. First, some history will be
    presented with regard to Data Encryption Standard (DES) that led to the development
    of a new AES standard.
  prefs: []
  type: TYPE_NORMAL
- en: Data Encryption Standard (DES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DES was introduced by the US **National Institute of Standards and Technology**
    (**NIST**) as a standard algorithm for encryption and was in main use during 1980s
    and 1990s, but it has been not proven to be very resistant against brute force
    attacks, due to advances in technology and cryptography research. Especially in
    July 1998, **Electronic Frontier Foundation** (**EFF**) broke DES using a special
    purpose machine. DES uses a key of only 56 bits, which has raised some concerns.
    This problem was addressed with the introduction of **Triple DES** (**3DES**),
    which proposed the usage of a 168-bit key using three 56-bit keys and the same
    number of executions of the DES algorithm, thus making brute force attacks almost
    impossible. But other limitations, such as slow performance and 64-bit block size,
    are not desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Encryption Standard (AES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2001, after an open competition, an encryption algorithm named Rijndael that
    was invented by cryptographers *Joan Daemen* and *Vincent Rijmen* was standardized
    as AES with minor modifications by NIST in 2001\. So far, no attack has been found
    against AES that is better than the brute force method. Original Rijndael allows
    different key and block sizes of 128-bit, 192-bit, and 256-bits, but in the AES
    standard, only a 128-bit block size is allowed. However, key sizes of 128-bit,
    192-bit, and 256-bit are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: AES steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During the AES Algorithm processing, a 4 by 4 array of bytes knows as *state*
    is modified using multiple rounds. Full encryption requires 10 to 14 rounds depending
    on the size of the key. The following table shows the key sizes and the required
    number of rounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AES steps](img/B05975_03_56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the state is initialized with the input to the cipher, four operations
    are performed in four stages in order to encrypt the input. These stages are `AddRoundKey`,
    `SubBytes`, `ShiftRows`, and `MixColumns`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `AddRoundKey` step, the state array is XORed with a subkey, which is
    derived from the master key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the substitution step where a lookup table (S-box) is used to replace
    all bytes of the state array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step is used to shift each row except the first one in the state array
    to the left in a cyclic and incremental manner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, all bytes are mixed in this step in a linear fashion column-wise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding steps describe one round of AES. In the final round (either 10,
    12, or 14 depending on the key size), stage 4 is replaced with `Addroundkey` to
    ensure that the first three steps cannot be simply inverted back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AES steps](img/B05975_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AES block diagram, showing 1^(st) round, in last round mixing step is not performed
  prefs: []
  type: TYPE_NORMAL
- en: Various cryptocurrency wallets use AES encryption to encrypt locally stored
    data. Especially in bitcoin wallet, AES 256 in the CBC mode is used.
  prefs: []
  type: TYPE_NORMAL
- en: An OpenSSL example of how to encrypt and decrypt using AES
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![An OpenSSL example of how to encrypt and decrypt using AES](img/B05975_03-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `message.bin` is a binary file; sometimes, it is desirable to encode
    this binary file into a text format for compatibility/interoperability reasons.
    The following command can be used to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decrypt an AES-encrypted file, the following commands can be used.
    An example of `message.bin` from a previous example is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Astute readers would have noticed that no initialization vector has been provided
    even though it''s required in all block encryption modes of operation except ECB.
    The reason is that OpenSSL automatically derives the initialization vector from
    the given password. Users can specify the initialization vector using the switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decode from base64, the following commands are used. Take the `message.b64`
    file from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![An OpenSSL example of how to encrypt and decrypt using AES](img/B05975_03_40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many types of ciphers that are supported in OpenSSL; you can explore
    these options based on the examples provided earlier. A list of supported cipher
    types is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An OpenSSL example of how to encrypt and decrypt using AES](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot displaying rich library options available in OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymmetric cryptography refers to a type of cryptography whereby the key that
    is used to encrypt the data is different from the key that is used to decrypt
    the data. Also known as public key cryptography, it uses public and private keys
    in order to encrypt and decrypt data, respectively. Various asymmetric cryptography
    schemes are in use, such as RSA, DSA, and El-Gammal.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of public key cryptography is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asymmetric cryptography](img/B05975_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Encryption decryption using public/private key
  prefs: []
  type: TYPE_NORMAL
- en: The diagram explains how a sender encrypts the data using a recipient's public
    key and is then transmitted over the network to the receiver. Once it reaches
    the receiver, it can be decrypted using the receiver's private key. This way,
    the private key remains on the receiver's side and there is no need to share keys
    in order to perform encryption and decryption, which is the case with symmetric
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another diagram shows how public key cryptography can be used to verify the
    integrity of the received message by the receiver. In this model, the sender signs
    the data using their private key and transmits the message across to the receiver.
    Once the message is received on the receiver''s side, it can be verified for its
    integrity by the sender''s public key. Note that there is no encryption being
    performed in this model. This model is only used for message authentication and
    validation purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asymmetric cryptography](img/B05975_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Model of a public key cryptography signature scheme
  prefs: []
  type: TYPE_NORMAL
- en: Security mechanisms offered by public key cryptosystem include key establishment,
    digital signatures, identification, encryption, and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Key establishment mechanisms are concerned with the design of protocols that
    allow setting up of keys over an insecure channel. Non-repudiation service, a
    very desirable property in many scenarios, can be provided using digital signatures.
    Sometimes, it is important to not only authenticate a user, but to also identify
    the entity involved in a transaction; this can also be achieved by a combination
    of digital signatures and challenge-response protocols. Finally, the encryption
    mechanism to provide confidentiality can also be realized using public key cryptosystems,
    such as RSA, ECC, or El-Gammal.
  prefs: []
  type: TYPE_NORMAL
- en: Public key algorithms are slower in computation as compared to symmetric key
    algorithms. Therefore, they are not commonly used in the encryption of large files
    or the actual data that needs encryption. They are usually used to exchange keys
    for symmetric algorithms and once the keys are established securely, symmetric
    key algorithms can be used to encrypt the data.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography algorithms are based on various underlying mathematical
    problems. There are three main families of asymmetric algorithms that are described
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Integer factorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These schemes are based on the fact that large integers are very hard to factor.
    RSA is the prime example of this type of algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete logarithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is based on a problem in modular arithmetic that it is easy to calculate
    the result of modulo function but it is computationally infeasible to find the
    exponent of the generator. In other words, it is extremely difficult to find the
    input from the result. This is a one-way function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3^(2 )mod 10 = 9*'
  prefs: []
  type: TYPE_NORMAL
- en: Now given 9 finding 2, the exponent of the generator 3 is very hard. This hard
    problem is commonly used in **Diffie-Hellman** key exchange and digital signature
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is based on the discrete logarithm problem discussed earlier, but in the
    context of elliptic curves. Elliptic curve is an algebraic cubic curve over a
    field, which can be defined by an equation shown here. The curve is non-singular,
    which means that it has no cusps or self-intersections. It has two variables *a,
    b*, along with a point of infinity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Elliptic curves](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *a*, *b* are integers that can have various values and are elements of
    the field on which the elliptic curve is defined. Elliptic curves can be defined
    over reals, rational numbers, complex numbers, or finite fields. For cryptographic
    purposes, elliptic curve over prime finite fields is used instead of real numbers.
    Additionally, the prime should be greater than 3\. Different curves can be generated
    by varying the value of *a*, *b.*
  prefs: []
  type: TYPE_NORMAL
- en: Mostly prominently used cryptosystems based on elliptic curves are **Elliptic
    Curve Digital Signatures Algorithm** (**ECDSA**) and **Elliptic Curve Diffie-Hellman**
    (**ECDH**) key exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand public key cryptography, the first concept that needs
    to be looked at is the idea of public and private keys.
  prefs: []
  type: TYPE_NORMAL
- en: A private key, as the names suggests, is basically a randomly generated number
    that is kept secret and held privately by the users. Private key needs to be protected
    and no unauthorized access should be granted to that key; otherwise, the whole
    scheme of public key cryptography will be jeopardized as this is the key that
    is used to decrypt messages. Private keys can be of various lengths depending
    upon the type and class of algorithms used. For example, in RSA, typically, a
    key of 1024-bit or 2048-bits is used. 1024-bit key size is no longer considered
    secure and at least 2048 bit is recommended to be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: A public key is the public part of the private-public key pair. A public key
    is available publicly and published by the private key owner. Anyone who would
    then like to send the publisher of the public key an encrypted message can do
    so by encrypting the message using the published public key and sending it to
    the holder of the private key. No one else would be able to decrypt the message
    because the corresponding private key is held securely by the intended recipient.
    Once the public key encrypted message is received, the recipient can decrypt the
    message using the private key. There are a few concerns regarding public keys,
    such as authenticity and identification of the publisher of the public keys.
  prefs: []
  type: TYPE_NORMAL
- en: RSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A description of RSA is discussed here. RSA was invented in 1977 by *Ron Rivest*,
    *Adi Shamir*, and *Leonard Adelman*, hence the name RSA. This is based on the
    integer factorization problem, where the multiplication of two large prime numbers
    is easy but difficult to factor it back to the two original numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The crux of the work in the RSA algorithm is during the key generation process.
    An RSA key pair is generated by performing the steps described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modulus generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Select *p* and *q* very large primes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply *p* and *q* , *n=p.q* to generate modulus *n*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate co-prime:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume a number called *e*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should satisfy certain conditions, that is, it should be greater than 1 and
    less than *(p-1) (q-1)*. In other words, e must be such a number that no number
    other than 1 can be divided into *e* and *(p-1) (q-1)*. This is called co-prime,
    that is, *e* is the co-prime of *(p-1)(q-1)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate public key:'
  prefs: []
  type: TYPE_NORMAL
- en: Modulus generated in step 1 and e generated in step 2 is pair that, together,
    is a public key. This part is the public part that can be shared with anyone;
    however, *p* and *q* need to be kept secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate private key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Private key called d here and is calculated from *p*, *q* and *e*. Private
    key is basically the inverse of e modulo *(p-1)(q-1)*. In the equation form, it
    is this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ed = 1 mod(p-1)(q-1)*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Usually, an extended Euclidean algorithm is used to calculate *d*; this algorithm
    takes *p*, *q* and *e* and calculates *d*. The key idea in this scheme is that
    anyone who knows *p* and *q* can calculate private key *d* easily, by applying
    the extended Euclidean algorithm, but someone who doesn't know the value of *p*
    and *q* cannot generate *d*. This also implies that *p* and *q* should be large
    enough for the modulus *n* to become very difficult (computationally infeasible)
    to factor.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and decryption using RSA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RSA uses the following equation to produce cipher text:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C = P^e mod n*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that plain text *P* is raised to *e* number of times and then reduced
    to modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption in RSA is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P = C^d mod n*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the receiver who has a public key pair (*n*, *e*) can decipher
    the data by raising *C* to the value of the private key *d* and reducing to modulo
    *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ECC is based on the discrete logarithm problem that is based on elliptic curves
    over finite fields (Galois fields). The main benefit of ECC over other types of
    public key algorithms is that it needs a smaller key size while providing the
    same level of security as, for example, RSA. Two notable schemes that originate
    from ECC are **Elliptic Curve Diffie-Hellman** (**ECDH**) for key exchange and
    **Elliptic Curve Digital Signature Algorithm** (**ECDSA**) for digital signatures.
    It can also be used for encryption but is not usually used for this purpose in
    practice; instead, key exchange and digital signatures are more commonly used.
    As ECC needs less space to operate, it is becoming very popular on embedded platforms
    or in systems where storage resources are limited. As a comparison, the same level
    of security can be achieved in ECC by only using 256-bit operands as compared
    to 3072-bits in RSA.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics behind ECC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand ECC, a basic introduction to the underlying mathematics
    is necessary. Elliptic curve is basically a type of polynomial equation known
    as weierstrass equation that generates a curve over a finite field. The most commonly
    used field is where all arithmetic operations are performed modulo *a* prime *p*.
    Elliptic curve groups consist of points on the curve over a finite field.
  prefs: []
  type: TYPE_NORMAL
- en: 'An elliptic curve can be defined as an equation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematics behind ECC](img/image_03_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *A* and *B* belong to a finite field *Zp* or *FP* (prime finite field)
    along with a special value called point of infinity. Point of infinity ![Mathematics
    behind ECC](img/image_03_019.jpg) is used to provide identity operations for points
    on the curve.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a condition also needs to be met that ensures that the equation
    mentioned earlier has no repeated roots. This means that the curve is non-singular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The condition is described here in the equation, which is a standard requirement
    that needs to be met. More precisely, this ensures that the curve is nonsingular:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematics behind ECC](img/image_03_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A real number representation of elliptic curve can be visualized as shown in
    the following graph. This is a graph of equation over real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematics behind ECC](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The actual curves used in elliptic curve cryptography are over finite prime
    fields, but here, they are shown over real number as it becomes easier to visualize
    the operations when graphed over *R*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematics behind ECC](img/image_03_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Elliptic curve over reals, a = -3 and b = 3
  prefs: []
  type: TYPE_NORMAL
- en: In order to construct the discrete logarithm problem based on elliptic curves,
    a large enough cyclic group is required. First, the group elements are identified
    as a set of points that satisfy the earlier equation. After this, group operations
    need to be defined on these points.
  prefs: []
  type: TYPE_NORMAL
- en: Group operations on elliptic curves are point addition and point doubling. Point
    addition is a process where two different points are added and point doubling
    means that the same point is added to itself. Both of these operations can be
    visualized as shown in the following diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Point addition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Point addition is shown in the following diagram. This is a geometric representation
    of point addition on elliptic curves. In this method, a line is drawn through
    the curve that intersects the curve at two points shown below *P* and *Q*, which
    yields a third point between the curve and the line. This point is mirrored as
    *P+Q*, which represent the result of addition as *R*. This is shown as *P+Q* in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Point addition visualized over R
  prefs: []
  type: TYPE_NORMAL
- en: 'Group operation denoted by sign *+* for addition yields the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: P + Q = R
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, two points are added in order to compute the coordinates of the
    third point on the curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'More precisely, this means that coordinates are added as shown in the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(*x1, y1) + (x2, y2) = (x3, y3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation of point addition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_025-1.jpg)![Point addition](img/image_03_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*S* in the preceding equation depicts the line going through *P* and *Q*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of point addition shown here is produced using Certicom''s online
    calculator. This example shows the addition and solutions for the equation over
    finite field *F[23]*. This is in contrast to the example shown earlier, which
    is over real numbers and only shows the curve but no solutions to the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example of point addition using Certicom's online calculator tool
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, the graph on the left-hand side shows the points that satisfy
    the equation shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are 27 solutions to the equation shown earlier over a finite field *F[23]*.
    *P* and *Q* are chosen to be added to produce the point *R*. Calculations are
    shown on the right-hand side, which calculates the third point *R*. Note that
    here, *l  *is used to depict the line going through *P* and *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: As an example to show how the equation is satisfied by the points shown in the
    graph, a point (*x, y*) is picked up where *x = 3* and *y = 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these values in the equation shows that the equation is satisfied indeed.
    This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point addition](img/image_03_031.jpg)![Point addition](img/image_03_032.jpg)![Point
    addition](img/image_03_033.jpg)![Point addition](img/image_03_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next section will introduce the concept of point doubling, which is another
    operation that can be performed on elliptic curves.
  prefs: []
  type: TYPE_NORMAL
- en: Point doubling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The other group operation on elliptic curves is called point  doubling and
    is described in the following diagram. This is a process where *P* is added into
    itself. In this method, a tangent line is drawn through the curve, as shown in
    the following graph. The second point  is obtained, which is at the intersection
    of the tangent line drawn and the curve. This point is then mirrored to yield
    the result, which is shown as *2P = P + P*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point doubling](img/image_03_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graph representing point doubling over real numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of point doubling, the equation becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point doubling](img/image_03_025-2.jpg)![Point doubling](img/image_03_026.jpg)![Point
    doubling](img/image_03_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *S* is the slope of tangent (tangent line) going through *P*. It is the
    line on top shown in the preceding figure. In the preceding example, the curve
    is plotted over reals as a simple example and no solution to the equation is shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown here, which shows the solutions and point doubling of elliptic
    curve over finite field *F[23]*. The graph on the left-hand side shows the points
    that satisfy the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point doubling](img/image_03_030.jpg)![Point doubling](img/image_03_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example of point doubling using certicom's online calculator tool
  prefs: []
  type: TYPE_NORMAL
- en: As shown earlier, on the right-hand side, a calculation is shown that finds
    the *R* after *P* is added into itself (point doubling). There is no *Q* as here,
    the same point *P* is used for doubling. Note that in the calculation, *l *is
    used to depict the tangent line going through *P*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, an introduction to the discrete logarithm problem will
    be presented.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete logarithm problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The discrete logarithm problem in ECC is based on the idea that under certain
    conditions, all points on an elliptic curve form a cyclic group. On an elliptic
    curve, the public key is a random multiple of the generator point, whereas the
    private key is a randomly chosen integer used to generate the multiple. In other
    words, a private key is a randomly chosen integer, whereas the public key is a
    point on the curve. The discrete logarithm problem is used to find the private
    key (an integer) where that integer falls within all points on the elliptic curve.
    An upcoming equation shows this precisely. Consider an elliptic curve *E*, with
    two elements *P* and *T*. The discrete logarithmic problem is to find the integer
    d, where *1 <= d <= #E*, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P + P + . . . +P = d P = T*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *T* is the public key (point on the curve) and d is the private key. In
    other words, public key is a random multiple of generator, whereas the private
    key is the integer that is used to generate the multiple. *#E* represents the
    order of the elliptic curve, which basically means the number of points that are
    present in the cyclic group of the elliptic curve. A cyclic group is formed by
    a combination of points on the elliptic curve and point at infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key pair is linked with specific domain parameters of an elliptic curve.
    Domain parameters include a field size, field representation, two elements from
    the field *a* and *b*, two field elements *Xg* and *Yg*, order n of point *G*
    that is calculated as *G=(Xg, Yg)* and the co-factor *h = #E(Fq)/n*. A practical
    example using OpenSSL will be described later in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various parameters that are recommended and standardized to use as
    curves with ECC. You are shown an example of SECP256K1 specifications here. This
    is the specification that has been used in bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discrete logarithm problem](img/image_03_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Specification of SECP256K1 taken from http://www.secg.org/sec2-v2.pdf
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of all these values in the sextuple is given here.
  prefs: []
  type: TYPE_NORMAL
- en: '*P* is the prime *p* that specifies the size of the finite field.'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* and *b* are the coefficients of the elliptic curve equation.'
  prefs: []
  type: TYPE_NORMAL
- en: '*G* is the base point that generates the required subgroup, also known as generator.
    Base point can be represented in either compressed or uncompressed form. There
    is no need to store all points on the curve in practical implementations. The
    compressed generator works because points on the curve can be identified by using
    only the *x* coordinate and the least significant bit of the *y* coordinate.'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* is the order of the subgroup.'
  prefs: []
  type: TYPE_NORMAL
- en: '*h* is the cofactor of the subgroup.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, an example using OpenSSL is shown to help you understand
    the practical aspects of RSA.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, it is shown how RSA public and private key pairs can
    be generated using OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: How to generate public and private key pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, it is shown how the RSA private key can be generated using OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: Private key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the command, a file named `privatekey.pem` is produced, which
    contains the generated private key. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Generate public key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the private key is mathematically linked to the public key, it is possible
    to generate or derive the public key out of the private key. Taking the example
    of the preceding private key, the public key can be generated as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Public key can be viewed using a file reader or any text viewer, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to see more details about the various components, such as modulus,
    prime numbers that are used in the process, exponents and coefficients of the
    generated private key, the following command can be used (the complete output
    is not shown as it is too large):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the public key can be explored using the following commands. Public
    and Private keys are base64-encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the public key can be shared openly and anyone who wants to send us a message
    can use the public key to encrypt the message and send it to us. We can then use
    the corresponding private key to decrypt the file.
  prefs: []
  type: TYPE_NORMAL
- en: How to encrypt and decrypt using RSA with OpenSSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First in the section, an example will presented, which demonstrates how encryption
    can be performed using RSA.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Taking the private key generated in the earlier example, the command to encrypt
    a text file `message.txt` can be constructed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a file named `message.rsa`, which is in a binary format.
    If we open `message.rsa` in the nano editor, it will show some garbage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encryption](img/image_03_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: message.rsa showing garbage data
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to decrypt the RSA-encrypted file, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if the file is read using cat, decrypted plain text can be seen, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ECC using OpenSSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenSSL provides a very rich library of functions to perform elliptic curve
    cryptography. The following section shows how to practically use ECC functions
    in OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: ECC private and public key pair
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, first, an example is presented that demonstrates the creation
    of a private key using ECC functions available in the OpenSSL library.
  prefs: []
  type: TYPE_NORMAL
- en: Private key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECC is based on domain parameters defined by various standards. We can see
    the list of all available standards'' defined and recommended curves available
    in OpenSSL using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As this produces a long output, the complete output is not shown and truncated
    in between. In the following example, SECP256k1 is used to demonstrate ECC usage.
  prefs: []
  type: TYPE_NORMAL
- en: Private key generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The file named `ec-privatekey.pem` now contains the EC private key that is generated
    based on the SECP256K1 curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate a public key out of a private key, issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the file produces the following output, displaying the generated public
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now the `ec-pubkey.pem` file contains the public key derived out of `ec-privatekey.pem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private key can be further explored using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the public key can be explored further with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to generate a file with the required parameters-in this
    case, `SECP256K1`-and then explore it further to understand the underlying parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The file now contains all `SECP256K1` parameters and can be analyzed using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows the prime number used and values of `A` and `B`
    the with generator, order, and cofactor of the `SECP256K1` curve domain parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There is another category of cryptographic primitives that is known as hash
    functions. Hash functions are not used to encrypt; data instead, they produce
    a fixed length digest of text.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This taxonomy of cryptographic primitives can be visualized as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cryptographic primitives](img/B05975_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cryptographic primitives
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash functions are used to create fixed length digests of arbitrarily long input
    strings. Hash functions are keyless and provide the data integrity service. They
    are usually built using iterated and dedicated hash function construction techniques.
    Various families of hash functions are available, such as MD, SHA1, SHA-2, SHA-3,
    RIPEMD, and Whirlpool. Hash functions are commonly used in digital signatures
    and message authentication codes, such as HMACs. They have three security properties,
    namely pre-image resistance, second pre-image resistance, and collision resistance.
    These properties are explained later in the section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash functions** are typically used to provide data integrity services. These
    can be used as one-way functions and to construct other cryptographic primitives,
    such as MACs and digital signatures. Some applications used hash functions as
    a means of generating **pseudo random numbers** (**PRNGs**). Hash functions do
    not require a key. There are two practical and three security properties of hash
    functions that must be met depending on the level of requirements of integrity.'
  prefs: []
  type: TYPE_NORMAL
- en: Compression of arbitrary messages into fixed length digest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property is concerned with the fact that a hash function must be able to
    take a long input text of any length and output a fixed length compressed message.
    Hash functions produce a compressed output in various bit sizes, usually between
    128-bits and 512-bits.
  prefs: []
  type: TYPE_NORMAL
- en: Easy to compute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hash functions are efficient and fast one-way functions. The requirement is
    that they be very quick to compute regardless of the message size. The efficiency
    may decrease if the message is too big but the function should still be fast enough
    for practical use.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, security properties of hash functions are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-image resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider an equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(x) = y*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *h* is the hash function, *x* is the input, and *y* is the hash. The first
    security property requires that *y* cannot be reverse computed to *x*. *x* is
    considered a *pre-image* of *y*, hence the name pre-image resistance. This is
    also called one-way property.
  prefs: []
  type: TYPE_NORMAL
- en: Second pre-image resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property requires that given *x* and *h(x)* , it is almost impossible to
    find any other message *m* , where *m != x* and *hash of m = hash of x*. *h(m)
    = h(x)*. This property is also known as weak collision resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Collision resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property requires that two different input messages should not hash to
    the same output. In other words, *h(x) != h(z)*. This property is also known as
    strong collision resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions, due to their very nature, will always have some collisions,
    and that is where two different messages hash to the same output, but they should
    be computationally infeasible to find. A concept known as **avalanche effect**
    is desirable in all hash functions. Avalanche effect specifies that a small change,
    even a single character change in the input text, will result in a totally different
    hash output.
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are usually designed by following iterated hash functions approach.
    In this method, the input message is compressed in multiple rounds on a block-by-block
    basis to produce the compressed output. A popular type of iterated hash function
    is Merkle-Damgard construction. This construction is based on the idea of dividing
    the input data into equal sizes of blocks and then feeding them through the compression
    functions in an iterative manner. The collision resistance of the property of
    compression functions ensures that the hash output is also collision-resistant.
    Compression functions can be built using block ciphers. In addition to Merkle-Damgard,
    there are various other constructions of compression functions proposed by researchers,
    for example, *Miyaguchi-Preneel* and *Davies-Meyer*.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple hash function categories. You will be introduced to these
    categories in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Message Digest (MD)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Message Digest functions were very popular in early 1990s. MD4 and MD5 are members
    of this category. Both MD functions are found to be insecure and not recommended
    for use any more. MD5 is a 128-bit hash function that was commonly used for file
    integrity checks.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Hash Algorithms (SHAs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SHA-0**: This is a 160-bit function introduced by NIST in 1993.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHA-1**: SHA-1 was introduced later by NIST as a replacement of SHA-0\. This
    is also a 160-bit hash function. SHA-1 is used commonly in SSL and TLS implementations.
    It should be noted that SHA-1 is now considered insecure and is being deprecated
    by certificate authorities. Its usage is now discouraged in any new implementations.
    **SHA-2**: This category includes four functions defined by the number of bits
    of the hash: SHA-224, SHA-256, SHA-384 and SHA-512.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHA-3**: This is the latest family of SHA functions. SHA3-224, SHA3-256,
    SHA3-384 and SHA3-512 are members of this family. SHA3 is a NIST-standardized
    version of Keccak. Keccak uses a new approach called *sponge construction* instead
    of the commonly used Merkle-Damgard transformation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RIPEMD**: RIPEMD is the acronym for *RACE Integrity Primitives Evaluation
    Message Digest*. It is based on the design ideas used to build MD4\. There are
    multiple versions of RIPEMD, including 128-bit, 160-bit, 256-bit, and 320-bit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Whirlpool**: This is based on a modified version of Rijndael cipher known
    as W. It uses the Miyaguchi-Preneel compression function, which is a type of one-way
    function used for the compression of two fixed length inputs into a single fixed
    length output. It is a single block length compression function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Hash Algorithms (SHAs)](img/B05975_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Three security properties of hash functions
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions have many practical applications ranging from simple file integrity
    checks and password storage to be used in cryptographic protocols and algorithms.
    They are used in hash tables, distributed hash tables, bloom filters, virus finger
    printing, peer-to-peer P2P file sharing, and many other applications.
  prefs: []
  type: TYPE_NORMAL
- en: In blockchain, hash functions play a very vital role. Especially, the proof
    of work function uses SHA-256 twice in order to verify the computational effort
    spent by miners. RIPEMD 160 is used to produce bitcoin addresses. This will be
    discussed in more detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Design of Secure Hash Algorithms (SHA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following section, you will be introduced to the design of SHA-256 and
    SHA-3\. Both of these are used in bitcoin and Ethereum, respectively. Ethereum
    doesn't use NIST Standard SHA-3 but Keccak, which is the original algorithm presented
    to NIST. NIST, after some modifications such as increase in the number of rounds
    and simpler message padding, standardized Keccak as SHA-3.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SHA-256 has the input message size < 2^64-bits. Block size is 512-bits and has
    a word size of 32-bits. Output is 256-bit digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compression function processes a 512-bit message block and a 256-bit intermediate
    hash value. There are two main components of this function: compression function
    and a message schedule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-processing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding of the message, which is used to make the length of a block to 512-bits
    if it is smaller than the required block size of 512-bits.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing the message into message blocks that ensure that the message and its
    padding is divided into equal blocks of 512-bits.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up the initial hash value, which is the eight 32-bit words obtained
    by taking the first 32-bits of the fractional parts of the square roots of the
    first eight prime numbers. These initial values are randomly chosen in order to
    initialize the process and gives a level of confidence that no backdoor exists
    in the algorithm.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hash computation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message block is processed in a sequence and requires 64 rounds to compute
    the full hash output. Each round uses slightly different constants to ensure that
    no two rounds are the same.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: First, the message schedule is prepared.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, eight working variables are initialized.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the intermediate hash value is calculated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the message is processed and the output hash is produced:![SHA-256](img/B05975_03_20.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: one round of SHA 256 compression function
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding diagram, *a*, *b*, *c*, *d*, *e*, *f*, *g*, and *h* are the
    registers. **Maj** and **Ch** are applied bitwise. ![SHA-256](img/image_03_048.jpg) performs
    bitwise rotation. Round constants are **W[j]** and **K[j]** , which are added
    *mod 2^32*.
  prefs: []
  type: TYPE_NORMAL
- en: Design of SHA3 (Keccak)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The structure of SHA-3 is very different from the usual SHA-1 and SHA-2\. The
    key idea behind SHA-3 is based on un-keyed permutations as opposed to other usual
    hash functions' constructions that used keyed permutations. Keccak also does not
    make use of the Merkle-Damgard transformation that is commonly used to handle
    arbitrary length input messages in hash functions. A newer approach called sponge
    and squeeze construction is used in Keccak, which is basically a random permutation
    model. Different variants of SHA3 have been standardized, such as SHA3-224, SHA3-256,
    SHA3-384, SHA3-512, SHAKE128, and SHAKE256\. SHAKE128 and SHAKE256 are extendable
    output functions that are also standardized by `NIST.XOF` functions that allow
    the output to be extended to any desired length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the sponge and squeeze model that is the basis
    of SHA3 or Keccak. As an analogy to sponge, first, the data is absorbed into the
    sponge after applying padding, where it is then changed into a subset of permutation
    state using XOR and then the output is squeezed out of the sponge function that
    represents the transformed state. Rate is the input block size of a sponge function,
    whereas capacity determines the generic security level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design of SHA3 (Keccak)](img/B05975_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SHA-3 absorbing and squeezing function in SHA3
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL example of hash functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following command will produce a hash of 256-bits of Hello messages using
    the SHA256 algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that even a small change in the text, such as changing the case of *H*,
    results in a big change in the output hash. This is known as *avalanche effect*,
    as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both outputs are completely different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Message Authentication codes (MACs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MACs are sometimes called keyed hash functions and can be used to provide message
    integrity and authentication. In others words, they are used to provide data origin
    authentication. These are symmetric cryptographic primitives using a shared key
    between the sender and the receiver. MACs can be constructed using block ciphers
    or hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: MACs using block ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this approach, block ciphers are used in the **Cipher block chaining mode**
    (**CBC mode**) in order to generate a MAC. Any block cipher-for example, AES in
    the CBC mode-can be used. The MAC of the message is in fact the output of the
    last round of the CBC operation. The length of the MAC output is the same as the
    block length of the block cipher used to generate MAC. MACs are verified simply
    by computing the MAC of the message and comparing it with the received MAC. If
    they are the same, then the message integrity is confirmed; otherwise, the message
    is considered altered. It should also be noted that MACs work like digital signatures,
    but they cannot provide the nonrepudiation service due to their symmetric nature.
  prefs: []
  type: TYPE_NORMAL
- en: HMACs (hash-based MACs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to the hash function, they produce a fixed length output and take an
    arbitrarily long message as the input. In this scheme, the sender signs a message
    using MAC and the receiver verifies it using the shared key. The key is hashed
    with the message using either of the two methods known as secret prefix or the
    secret suffix method. In the first method, the key is concatenated with the message,
    that is, the key comes first and the message comes after, whereas in the latter
    method, the key comes after the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secret prefix: M = MACk(x) = h(k||x)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secret suffix: M=MACk(x) = h(x||k)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are pros and cons of both methods. Some attacks on both schemes have
    been discovered. There are HMAC constructions schemes that use various techniques,
    such as **ipad** and **opad** (inner padding and outer padding) proposed by researchers
    that are considered secure with some assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HMACs (hash-based MACs)](img/B05975_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Operation of a MAC function
  prefs: []
  type: TYPE_NORMAL
- en: Merkle trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of Merkle tree was introduced by *Ralph Merkle*. A visualization
    of Merkle tree is shown here, which makes it easy to understand. Merkle trees
    allow secure and efficient verification of large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a binary tree in which first, the inputs are placed at the leaves (node
    with no children), and then values of pairs of child nodes are hashed together
    in order to produce a value for the parent node (internal node) until a single
    hash value known as Merkle root is achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merkle trees](img/B05975_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: Patricia trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to understand Patricia trees, first, you will be introduced to the
    concept of a **trie**. A trie or a digital tree is an ordered tree data structure
    used to store a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical Algorithm to Retrieve Information Coded in Alphanumeric** (**Patricia**),
    also known as Radix tree, is a compact representation of a trie in which a node
    that is the only child of a parent is merged with its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merkle-Patricia tree**, based on the definitions of Patricia and Merkle,
    is a tree that has a root node that contains the hash value of the entire data
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed hash tables (DHTs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hash table is a data structure that is used to map keys to values. Internally,
    a hash function is used to calculate an index into an array of buckets, from which
    the required value can be found. Buckets have records stored in them using a hash
    key and are organized in a particular order.
  prefs: []
  type: TYPE_NORMAL
- en: With the definition provided earlier in mind, one can think of the distributed
    hash table as a data structure where data is spread across various nodes and nodes
    are equivalent to buckets in a peer-to-peer to network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visually shows how a DHT works. The example shows that
    data is passed through a hash function, which results in generating a compact
    key. This key is then linked with the data (values) on the peer-to-peer network.
    When users on the network request the data (via the filename), the filename can
    be hashed again to produce the same key and any node on the network can then be
    requested to find the corresponding data. DHTs provides decentralization, fault
    tolerance, and scalability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributed hash tables (DHTs)](img/B05975_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Distributed hash tables
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Digital signatures provide a means of associating a message with an entity
    from which the message has been originated. Digital signatures are used to provide
    data origin authentication and nonrepudiation. They are calculated in two steps.
    High-level steps of an RSA digital signature scheme is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the hash value of the data packet. This will provide the data integrity
    guarantee as hash can be computed at the receiver's end again and matched with
    the original hash to check whether the data has been modified in transit. Technically,
    message signing can work without hashing the data first, but is not considered
    secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step signs the hash value with the signer's private key. As only
    the singer has the private key, the authenticity of the signature and the signed
    data is ensured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital signatures have some important properties, such as authenticity, unforgeability,
    and nonreusability. Authenticity means that the digital signatures are verifiable
    by a receiving party. The unforgeability property ensures that only the sender
    of the message is able to use the signing functionality using the private key.
    In other words, no one else should be able to produce the signed message that
    has been produced by the legitimate sender. Non reusability means that the digital
    signature cannot be separated from a message and used for another message again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation of a generic digital signature function is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Digital signatures](img/B05975_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Digital signing (left) and verification process (right) (Example of RSA digital
    signatures)
  prefs: []
  type: TYPE_NORMAL
- en: If a sender wants to send an authenticated message to a receiver, there are
    two methods that can be used. These two approaches to use digital signatures with
    encryption are introduced here.
  prefs: []
  type: TYPE_NORMAL
- en: Sign then encrypt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this approach, the sender digitally signs the data using the private key,
    appends the signature to the data, and then encrypts the data and the digital
    signature using the receiver's public key. This is considered a more secure scheme
    as compared to the encrypt then sign scheme described next.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt then sign
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this approach, the sender encrypts the data using the receiver's public key
    and then digitally signs the encrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, a digital certificate that contains the digital signature is issued
    by a **certificate authority** (**CA**) that associates a public key with an identity.
  prefs: []
  type: TYPE_NORMAL
- en: Various schemes, such as RSA, Digital Signature Algorithm, and Elliptic Curve
    Digital Signature Algorithm-based digital signature schemes are used in practice.
    RSA is the most commonly used; however, with the traction of elliptic curve cryptography,
    ECDSA-based schemes are also becoming quite popular.
  prefs: []
  type: TYPE_NORMAL
- en: The ECDSA scheme is described in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic Curve Digital signature algorithm (ECDSA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to sign and verify using the ECDSA scheme, the first key pair needs
    to be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define an elliptic curve *E*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With modulus *P*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Coefficients *a* and *b*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generator point *A* that forms a cyclic group of prime order *q.*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An integer *d* is chosen randomly so that *0 < d < q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate public key *B* so that *B = d A.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Public key is the sextuple of the form shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Kpb = (p,a,b,q,A,B)
  prefs: []
  type: TYPE_NORMAL
- en: 'Private key is randomly chosen *d* in Step 2:'
  prefs: []
  type: TYPE_NORMAL
- en: Kpr = d
  prefs: []
  type: TYPE_NORMAL
- en: Now the signature can be generated using the private and public key.
  prefs: []
  type: TYPE_NORMAL
- en: First, an ephemeral key *Ke* is chosen, where *0 < Ke < q*. It should be ensured
    that *Ke* is truly random, and no two signatures have the same key; otherwise,
    the private key can be calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another value *R* is calculated using *R = Ke A*, that is, by multiplying *A*
    (the generator point) and the random ephemeral key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a variable *r* with the *x* coordinate value of point *R*. *r = xR.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signature can be calculated as follows:![Elliptic Curve Digital signature
    algorithm (ECDSA)](img/B05975_02-1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, *m* is the message for which the signature is being computed and *h(m)*
    is the hash of the message *m*.
  prefs: []
  type: TYPE_NORMAL
- en: Signature verification is carried out by following this process.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary value w is calculated as *w = s^(-1)mod q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auxiliary value *u1 = w. h(m) mod q.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auxiliary value *u2 = w. r mod q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate Point *P*, *P = u1A + u2B.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verification is carried out as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*r*, *s* is accepted as a valid signature if x-coordinate of the point *P*
    calculated in Step 4 has the same value as the signature parameter *r mod q*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'that is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Xp = r mod q means valid signature*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Xp != r mod q means invalid signature*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Various practical examples are shown here, which shows how the RSA digital signature
    can be generated, used, and verified using OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: How to generate a digital signature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to generate a hash of the message file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Both hash generation and signing can be done in a single step, as shown here.
    Note that `privatekey.pem` is generated in the steps provided previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s display the directory showing relevant files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![How to generate a digital signature](img/B05975_03_55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to verify the signature, the following operation can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if some other signature file that is not valid is used, the verification
    will fail, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now you are introduced to an example that shows how OpenSSL can be used to perform
    ECDSA-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA using OpenSSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the private key is generated using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the public key is generated out of the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose a file named `testsign.txt` needs to be signed and verified. This
    can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to generate a signature using a private key for the
    `testsign.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the command for verification can be run as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A certificate can also be generated using the private key generated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The certificate can be explored using the command below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![ECDSA using OpenSSL](img/image_03_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: X509 certificate that uses ECDSA algorithm with SHA-256
  prefs: []
  type: TYPE_NORMAL
- en: There are other topics in cryptography that are presented here due to their
    relevance to blockchain or potential use in future blockchain ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, public key cryptosystems, such as RSA, are multiplicative homomorphic
    or additive homomorphic, such as Paillier cryptosystem, and are called **partially
    homomorphic** systems. Additive PHEs are suitable for e-voting and banking applications.
    Until recently, there has been no system that supported both operations, but in
    2009, a **fully homomorphic** system was discovered by *Craig Gentry*. As these
    schemes allow the processing of encrypted data without the need for decryption,
    they have many different possible applications, especially in scenarios where
    privacy is required to be maintained but data is also required to be processed
    by potentially untrusted parties, for example, cloud computing and online search
    engines. Recent development in homomorphic encryption has been very promising
    and researchers are actively working to make it efficient and more practical.
    This is of particular interest in the blockchain technology, as described later
    in the book, because it can solve the problem of confidentiality and privacy in
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Signcryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Signcryption is a public key cryptography primitive that provides all the functions
    of the digital signature and encryption. It was invented by *Yuliang Zheng* and
    is now an ISO standard ISO/IEC 29150:2011\. Traditionally, signature then encrypt
    or encrypt then sign schemes are used to provide unforgeability, authentication,
    and nonrepudiation, but with Signcryption, all services of digital signatures
    and encryption are provided with cost less than that of sign then encrypt schemes.
  prefs: []
  type: TYPE_NORMAL
- en: This is **Cost (signature & encryption) << Cost (signature) + Cost (Encryption)** in
    a single logical step.
  prefs: []
  type: TYPE_NORMAL
- en: Zero knowledge proofs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zero knowledge proofs were introduced by *GoldWasser*, *Micali*, and *Rackoff*.
    These proofs are used to prove the validity of an assertion without revealing
    any information whatsoever about the assertion. There are three properties of
    ZKPs that are required, namely completeness, soundness, and zero-knowledge property.
  prefs: []
  type: TYPE_NORMAL
- en: Completeness ensures that if a certain assertion is true, then the verifier
    will be convinced of this claim by the prover. The soundness property makes sure
    that if an assertion is false, then no dishonest prover can convince the verifier
    otherwise. Zero-knowledge property, as the name implies, is the key property of
    zero knowledge proofs whereby it is ensured that absolutely nothing is revealed
    about the assertion except whether it is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Zero knowledge proofs have sparked a special interest among researchers in the
    blockchain space due to its privacy properties that are very much desirable in
    financial and many other fields, such as law and medicine. A recent example of
    the successful implementation of the zero knowledge proof mechanism is the Zcash
    crypto currency. In Zcash, a specific type of zero knowledge proof, known as **zero-knowledge
    Succinct Non-interactive Argument of Knowledge** (**ZK-Snark**), is implemented.
    This will be discussed in detail in [Chapter 5](ch05.html "Chapter 5. Alternative
    Coins"), *Alternative Coins*.
  prefs: []
  type: TYPE_NORMAL
- en: Blind signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blind signatures were introduced by *David Chaum* in 1982 and are based on public
    key digital signature schemes, such as RSA. The key idea behind blind signatures
    is to get the message signed by the signer without actually revealing the message.
    This is achieved by disguising or blinding the message before signing it, hence
    the name blind signatures. This blind signature can then be verified against the
    original message just like a normal digital signature. Blind signatures were introduced
    as a mechanism to allow the development of digital cash schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding schemes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other than cryptographic primitives, binary to text encoding schemes are also
    used in various scenarios. The most common usage is to convert binary data into
    text so that it can be either processed, saved, or transmitted via a protocol
    that does not support the processing of binary data. For example, sometimes, images
    are stored in the database as base64 encoding, which allows a text field to be
    able to store a picture. A commonly used encoding scheme is base64\. Another encoding
    named base58 was popularized by its usage in bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is a vast field and this section has introduced basic concepts
    that are essential to understand cryptography in general and specifically from
    the blockchain and cryptocurrency point of view. In the next section, you are
    introduced to basic financial markets concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming section describes general terminologies about trading, exchanges,
    and trade life cycle. More relevant information will be provided in later chapters
    where specific use cases are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Financial markets and trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Financial markets exist to facilitate the transfers of savings from savers to
    investors. In an economic system, there are two sectors, namely household and
    business. Financial markets, at their core, act as an intermediary between the
    savers and the investors. Basically, there are three types of markets, namely
    money markets, credit markets, and capital markets. Money markets are short-term
    markets where money is lent to companies or banks to do interbank lending. Foreign
    exchange or FX is another category of money markets where currencies are traded.
    Credit markets consist mostly of retail banks where they borrow money from central
    banks and loan it to companies or households in the form of mortgages or loans.
  prefs: []
  type: TYPE_NORMAL
- en: Capital markets facilitate the buying and selling of financial instruments,
    mainly stocks and bonds. Capital markets can be divided into two types, primary
    and secondary markets. Stocks are issued directly by the companies to investors
    in primary markets, whereas in secondary markets, investors resell their securities
    to investors via stock exchanges. Various electronic trading systems are used
    by exchanges to facilitate the trading of financial instruments.
  prefs: []
  type: TYPE_NORMAL
- en: Trading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A market is a place where traders come to trade. It can ent asset classes.
  prefs: []
  type: TYPE_NORMAL
- en: Trading can be defined as an activity in which traders buy or sell various financial
    instruments to generate profit and hedge risk. Investors, borrowers, hedgers,
    asset exchangers, and gamblers are a few types of traders. Traders have a short
    position when they owe something, for example, if they have sold a contract and
    have a long position when they buy a contract. There are various ways to transact
    trades, such as through brokers or directly on the exchange or over the counter.
    Brokers are agents who arrange trades for their customers. Brokers act on clients'
    behalf to deal at a given price or at the best possible price.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exchanges are usually considered to be a very safe, regulated, and reliable
    place for trading. Recently, electronic trading has gained high popularity as
    compared to traditional floor-based trading. Now traders send orders to a central
    electronic order book from where the orders, prices, and related attributes are
    published to all associated systems using communication networks thus, in essence,
    creating a virtual marketplace. Exchange trades can be performed only by members
    of the exchange. In order to trade without these limitations, the counter parties
    can participate in **OTC** (**Over the Counter**) trading directly.
  prefs: []
  type: TYPE_NORMAL
- en: Orders and order properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Orders are instructions to trade and are the main building blocks of a trading
    system. They have the following general attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The instrument name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direction (buy or sell).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type of the order that represents various conditions, for example, limit
    orders and stop orders, an example of which is 1500 Royal Bank of Scotland ordinary
    shares for GBP £15.50.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Orders are traded on the basis of bid prices and offer prices. Traders show
    their intention to buy or sell by attaching bid and offer prices to their orders.
    The price at which a trader will buy is known as the bid price. The price at which
    a trader is willing to sell is known as the offer price.
  prefs: []
  type: TYPE_NORMAL
- en: Order management and routing systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Order routing systems routes and deliver orders to various destinations depending
    on the business logic. Customers use them to send orders to their brokers, who
    then send these orders to dealers, clearing houses, and exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of orders; the two most common ones are markets orders
    and limit orders. A market order is an instruction to trade at the best price
    currently available in the market, and these orders get filled immediately at
    spot prices. On the other hand, a limit order is an instruction to trade at the
    best price available but only if it is not lower than the limit price set by the
    trader. This can also be higher depending on the direction of the order, either
    sell or buy. All these orders are managed in an order book, which is a list of
    orders maintained by an exchange, and records the intention of buying or selling
    by the traders.
  prefs: []
  type: TYPE_NORMAL
- en: A position is a commitment to sell or buy an amount of financial instruments,
    such as securities, currencies, or commodities for a given price. The contracts,
    securities, commodities, and currencies that traders buy or sell are commonly
    known as trading instruments and come under the large umbrella of asset classes.
    The most common classes are real assets, financial assets, derivative contracts,
    and insurance contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Components of a trade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A trade ticket is the combination of all details related to a trade. However,
    there is some variation depending on the type of the instrument and asset class,
    but generally, all instruments have the attributes discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The underlying instrument**'
  prefs: []
  type: TYPE_NORMAL
- en: The underlying instrument is the basis of the trade. It can be a currency, a
    bond, interest rate, commodity, or equities.
  prefs: []
  type: TYPE_NORMAL
- en: General attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This includes general identification information and basic features associated
    with every trade. Common attributes include a unique ID, instrument name, type,
    status, trade date, and time.
  prefs: []
  type: TYPE_NORMAL
- en: Economic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are features related to the value of the trade, for example, buy or sell
    value, ticker, exchange, price, and quantity.
  prefs: []
  type: TYPE_NORMAL
- en: Sales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sales refers to the sales-characteristic-related details, such as the name of
    the sales person, and is just an information field, usually without any impact
    on the trade life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Counterparty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Counterparty is an important component of a trade as it shows the other side
    of the trade and is required to settle the trade successfully. Usual attributes
    include counterparty name, address, payment type, any reference IDs, settlement
    date, and delivery type.
  prefs: []
  type: TYPE_NORMAL
- en: Trade life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A general trade life cycle includes various stages from order placement to
    execution and then settlement. This life cycle is described step by step as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre-execution**: An order is placed at this stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution and booking**: When the order is matched and executed, it converts
    into a trade. At this stage, the contract between counter parties is matured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confirmation**: This is where both counter parties agree to particulars of
    the trade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post booking**: This stage is concerned with various scrutiny and verification
    processes to ascertain the correctness of the trade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settlement**: This is the most vital part during trade and at this stage,
    the trade is final.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overnight (end of day processing)**: End of day processes include report
    generation, profit and loss calculations, and various risk calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the mentioned processes, many people and business functions are involved.
    Most commonly, these functions are divided into functions such as front office,
    middle office, and back office.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, you are introduced to some concepts that are essential
    in order to understand the strict and necessary rules and regulations that govern
    the financial industry. Some concepts are described here and in later chapters
    when specific use cases are discussed, and these ideas will help you understand
    the scenarios described.
  prefs: []
  type: TYPE_NORMAL
- en: Order anticipators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Order anticipators try to make profit before other traders can carry out trading.
    This is based on the anticipation where a trader knows how trading activities
    of other trades will affect prices. Frontrunners, sentiment-oriented technical
    traders, and squeezers are some examples of order anticipators.
  prefs: []
  type: TYPE_NORMAL
- en: Market manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Market manipulation is strictly illegal in the UK and other countries. Fraudulent
    traders can spread false information in the market, which can result in price
    movements thus making illegal profits. Usually, manipulative market conduct is
    trade-based and it includes generalized and time-specific manipulations. Actions
    that can create an artificial shortage of stock, impression of false activity,
    and price manipulation to gain criminal benefit are included in this category.
  prefs: []
  type: TYPE_NORMAL
- en: Both of the terms discussed earlier are relevant to financial crime. and there
    is a possibility of developing blockchain-based systems that can thwart market
    abuse. This will be discussed in detail in later chapters, where specific use
    cases will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aimed at introducing concepts of cryptography and financial markets
    in order to provide background information for you to be able to understand the
    material provided in later chapters. First, you were introduced to the basics
    of cryptography, and then various schemes such as symmetric and asymmetric ciphers
    were introduced. Practical examples using OpenSSL command line were shown so that
    you could experiment with various commands and experience various cryptographic
    functions firsthand. Also, some mathematical background was provided at the beginning
    of the chapter and where necessary, especially with the elliptic curve cryptography.
    All cryptography concepts presented in this chapter are related to the blockchain
    technology and are implemented or have been proposed to be implemented in various
    blockchains, cryptocurrencies, and relevant ecosystems. Moreover, you were given
    a quick introduction to the financial industry as it sets the scene for various
    examples that will be discussed in relation to the distributed ledger technology
    later in the book. As cryptography and finance are vast subjects, the material
    covered in his chapter is aimed to be introductory in nature (with some exceptions)
    and specific topics will be expanded upon in more detail, where relevant and required,
    in the next chapters.
  prefs: []
  type: TYPE_NORMAL
