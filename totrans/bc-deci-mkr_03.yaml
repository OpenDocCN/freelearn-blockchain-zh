- en: A Technical Dive into Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because digital ubiquity raises more and more concern for decision-makers to
    be able to thrive and adapt their businesses to emerging trends and shifts in
    consumption habits, new technologies have to be well apprehended. Blockchain,
    as a matter of fact, is a new enabler that must be understood properly when considering
    an innovation strategy for your company.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there are different types of blockchain but the general idea behind
    them is the same. Mainly, they aim to solve trust issues between strangers willing
    to exchange value in the digital world. Secondly, even though we can distinguish
    several kinds of blockchain such as public or semi-private infrastructures (more
    on that in [Chapter 9](e768d501-bd11-4725-96d3-4898bdf5e063.xhtml), *Infrastructures
    and Cloud-Based Solutions*), they all integrate similar components.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will discover how the network empowers the blockchain,
    how hashes allow transactions and information to be secured, how digital identities
    are managed, and how game theory and economics enable responsible behavior. We
    will also have a look at the original problem that blockchain was the answer to
    and eventually discover what kind of consensus protocol can be implemented to
    achieve mass coordination within the network. Each component will be described
    as a sole instrument but we shall adopt a holistic view when we combine them all
    together. Therefore, one section can appear unclear when read separately but,
    by the end of this chapter, you should appreciate the functioning of the whole
    infrastructure and the role of each feature that come together to form a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enliven the blockchain with the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography and hash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing digital identities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Byzantine Generals Problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incentive mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving consensus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No network, no blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A blockchain's most important component is the network—which is the community
    empowering it. The role of the community is to ensure that the truth is correctly
    recorded in the shared database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an overview of a blockchain layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb00ce4-f2c6-415b-ba9a-f5dd4d477830.png)'
  prefs: []
  type: TYPE_IMG
- en: To understand this in a better way, let's look at a metaphorical example.
  prefs: []
  type: TYPE_NORMAL
- en: Truth in the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a US Open final is happening next weekend between Roger Federer and
    Rafael Nadal. Being a big fan of Roger Federer and being sure he will win the
    game, Alice bets $10 on the betting website Betwin. On the other hand, Bob, who
    is an experienced gambler, thinks that Rafael Nadal will win. Bob decides to place
    a $10 bet on the Betwin platform on Rafael Nadal's victory.
  prefs: []
  type: TYPE_NORMAL
- en: Because Betwin is a private company, its objective is to maximize its profit.
    To do so, the company could tell Alice that Rafael Nadal won the game and tell
    Bob that Roger Federer won the game. In this manner, Betwin could hold both bets
    without having to pay either Alice or Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why is this method preposterous for Betwin?*'
  prefs: []
  type: TYPE_NORMAL
- en: The evident explanation is that Alice and Bob will not only believe Betwin to
    know the result of the game. They will check press releases, have a look at internet
    news, or ask their friends. And unless Betwin can make the press, the internet
    news, and Alice and Bob's friends announce the result that suits them best, their
    method will not work. In short, Alice and Bob do not trust only one third party,
    but instead, rely on the network to know the truth. And until there is no proof
    that Betwin controls the network, Alice and Bob will always know the truth.
  prefs: []
  type: TYPE_NORMAL
- en: In a blockchain, the information that the majority of the community agrees on
    as being true is recorded on the database that is shared among all members.
  prefs: []
  type: TYPE_NORMAL
- en: The information added to the database is also checked with previous information
    already registered. In our example, Novak Djokovic cannot win the US Open final
    because there is information in the database stating that he already lost the
    previous round.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to look at the various key roles within a blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Participants in the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, the network is a very important feature in a blockchain—it has to
    be decentralized enough to be sure that the majority is not controlled by a single
    entity. It has to be heterogeneous enough so that the truth is represented by
    the majority. To achieve decentralization and heterogeneity, data must be distributed
    across the community. It should be distributed to anyone who wants to participate
    with no condition or barriers, forming a network of computers interacting with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: The network layer of a blockchain is also known as a peer-to-peer network.
  prefs: []
  type: TYPE_NORMAL
- en: In a centralized system, devices such as phones or computers access information
    to a central server that is owned by one entity. In a decentralized system supported
    by a peer-to-peer network, all of the devices, including the servers, interact
    and communicate with each other independently. These devices are called **nodes**.
    Each node can share information with any other node, without relying on a central
    server. Examples of such networks are the infamous file-sharing applications,
    BitTorrent, uTorrent and eMule, enabling users to download from and share data.
    When you are a participant of a peer-to-peer network, you act both as a provider
    and a consumer of files retrieved through other nodes. These are the kind of networks
    that enable decentralization within a blockchain. No entity is proprietary of
    the data nor has the exclusive right to read or modify the database.
  prefs: []
  type: TYPE_NORMAL
- en: The story of Napster is a revealing example of the weaknesses showed in a centralized
    system, especially in terms of control. Napster was a music file-sharing application
    that was shut down in 2001 after a long legal action undertook by record companies
    complaining about a violation of copyrights. Although Napster worked upon a peer-to-peer
    network, it centrally maintained a directory of all users and files. This configuration
    allowed the US district court to cease Napster's activity once the injunction
    was issued. The seizure would probably not have happened if the application relied
    on a true decentralized peer-to-peer network where the directories were stored
    by each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a blockchain, there are several roles given to the participants of the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The users**: They utilize the application running on top of the blockchain.
    They do not own any data from that blockchain; they solely use the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The nodes**: These computers store the database on their memory and make
    it available for anyone to see the history of transactions or information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The miners**: These computers run the software enabling the validation of
    blocks and transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In certain blockchains, such as the one underpinning Bitcoin, anybody can become
    a miner, a node, or just a user. These kinds of blockchains are called public
    (or permissionless) as opposed to private (or permissioned) blockchains in which
    the roles are predefined for every participant. We will explore these differences
    further in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will not technically describe how these nodes are connected but we will remember
    that, in a distributed system (in the end, that is what a blockchain is), the
    computers talk to each other to exchange information efficiently. Geolocation
    and power of the computers are variables that are taken into consideration when
    making the computers talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node (and each miner) holds an identical copy of the blockchain. New miners
    and nodes download the entire history to the peers they are connected to if they
    want to be part of that network. The size of a blockchain can be pretty memory-consuming:
    at the time of writing this book, if you want to become a node of the Bitcoin
    blockchain, you must download a 223 GB file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The responsibility of the miner is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a new block with new transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the correct answer to the mathematical problem (the nonce) to validate
    the block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread it across the network for everyone to see and check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the blockchain to evolve, transactions need to occur continuously and get
    compiled in blocks by the miners who calculate the resulting hash before adding
    the block to the chain.
  prefs: []
  type: TYPE_NORMAL
- en: But how do the miners ensure that the suggested block does not include fake
    transactions? And how do they add it to the chain?
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about cryptography and hash functions in the first chapter where
    we defined what it was:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a mathematical function where, knowing the output, it is almost impossible
    to find the correct input. But knowing the input of the function, it is very easy
    to find the correct output. This is made possible because a hash function always
    returns the same output for the same input.
  prefs: []
  type: TYPE_NORMAL
- en: A hash is a result of a mathematical function that is a transformation applied
    to an input that generates an output. *Y = f(x)* is a mathematical function where
    *x* is the input and *Y* is the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematical terms, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Knowing Y, it is almost impossible to find x. But knowing x, it is very easy
    to find Y."*'
  prefs: []
  type: TYPE_NORMAL
- en: The hash function is essential to make information and transactions secured
    along the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basic properties around a hash function that we have seen in [Chapter
    1](c15da2bc-7e16-4fbe-9e6b-c76ea35ea5fb.xhtml), *Basics of Blockchains and the
    Illustration of Village Beta*:'
  prefs: []
  type: TYPE_NORMAL
- en: It is deterministic, meaning that it is always the same output for the same
    input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a defined range, meaning that any size of input can be injected in the
    function but it will always be the same length output. In other words, no matter
    the length of the input, the function will always return a fixed number of characters
    (in [Chapter 1](https://cdp.packtpub.com/blockchain_for_decision_makers/wp-admin/post.php?post=25&action=edit#post_24), *Basics
    of Blockchains and the Illustration of Village Beta*, the output length was 64
    characters all the time because we were using the hash function, SHA-256).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But these properties are not enough to secure a transaction or a piece of information.
    There are other cryptographic properties surrounding hash functions used in a
    blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: It is **change-sensitive**, meaning that if one character of the input is modified,
    the output will totally be different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is **non-invertible**, meaning that it should not be possible to determine
    efficiently the input of a given output, just like a padlock is not supposed to
    be deciphered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is **collision-resistant**. A collision happens in a hash function when two
    different inputs generate the same output. Since inputs can have any length but
    outputs are fixed-length, obviously, there will be collisions. In other words,
    there is a finite number of possible outputs for an infinite number of inputs.
    Collision resistance means that finding two different inputs for the same output
    should not be possible using smart algorithms or strategy but only by trying every
    possibility. This is what we call **brute-force**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you have to remember for this section is that the hash value of an input
    can be used as the reference of that input. The hash value is the digital fingerprint
    of the input data, which can be a document, a transaction, or any kind of information.
    We can inject any file into the hash function and use the hash value to refer
    to it, hence uniquely identifying the document, the transaction, or the information.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A blockchain can also be defined as a sequence of blocks containing data that
    are chained together. There are two types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block information (also called metadata)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The transaction section is built by gathering all of the transactions that
    happened in a certain period of time and gathered in the block. If I send you
    one Bitcoin, this transaction will be part of the transaction section. Three fields
    are consistently active:'
  prefs: []
  type: TYPE_NORMAL
- en: The recipient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When I send you one Bitcoin using the Bitcoin blockchain, the transaction is
    composed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The recipient is your account (your Bitcoin address).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender is my account (my Bitcoin address).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount is 1 Bitcoin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a Bitcoin address is `3QSuhbsJUZJRgYX965CwMHgsdaU8KuTg4H`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the transactions are filled in the block, the block is hashed with
    the appropriate function (that is, the mining process occurs), which will return
    the **hash value of this block**, hence, of all transactions contained in the
    block. If one transaction of this block is modified afterward, the hash will change
    dramatically (the change-sensitive property) and the block would not be secured
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, depending on the blockchain, the validation span and the number of
    transactions of the block vary. For Bitcoin, one block is validated approximately
    every 10 minutes and contains several transactions fluctuating around 1,500 as
    of June 2019\. This period is defined regarding the size limit of a block, that
    is, the number of transactions it can handle in one block. It is rather the size
    of the transactions that matter than the volume. That is why Bitcoin has an average
    block limit of 1,500 transactions—because it can sometimes handle more transactions
    and sometimes fewer. Transactions can become more complex if there are several
    senders or several recipients in one transaction. To put it in perspective, the
    Bitcoin blockchain handles 1 MB blocks, whereas the Bitcoin Cash blockchain handles
    8 MB blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin Cash was created in August 2017 by a section of the Bitcoin community
    to overcome Bitcoin's scalability issues through the extension of block size.
    Just like Bitcoin, it is a cryptocurrency and a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the block information part, also called metadata.
    These pieces of information refer to the block itself and not to the transactions.
    If we think back to the example of [Chapter 1](https://cdp.packtpub.com/blockchain_for_decision_makers/wp-admin/post.php?post=25&action=edit#post_24), *Basics
    of Blockchains and the Illustration of Village Beta*, they refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The previous hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nonce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous hash is the reference number found when validating the previous
    block. For the first block of a blockchain, it is 0 or any value that the network
    agrees on. Remember that hashes are what allow blocks to be chained together,
    hence making the whole chain tamper-proof. To do so, every block contains the
    hash of the previous block.
  prefs: []
  type: TYPE_NORMAL
- en: The timestamp is the time and date when the block is validated by the network.
  prefs: []
  type: TYPE_NORMAL
- en: The nonce is the variable to find when solving the mathematical problem to validate
    a block. When the miners are receiving new transactions, they run a complex mathematical
    problem to find the appropriate nonce that returns a correct hash.
  prefs: []
  type: TYPE_NORMAL
- en: Once the hash is found, the transactions are validated and the block is stored
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, a block is a container of all of the transactions that happened
    over a defined timespan that are hashed to return a digital fingerprint of all
    of these transactions. The following diagram is the mining process followed by
    the miners of the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e7d57cd-89a0-475b-9a9e-3f3782b69841.png)'
  prefs: []
  type: TYPE_IMG
- en: When building a block, the miners trigger a mining process using the hash of
    the previous block, the hash of all of the transactions, and the timestamp. The
    mining process ends when one of the miners finds the correct nonce that returns
    a valid hash (usually a number starting with a predefined number of zeros), which
    is tied to the block and will serve as the previous hash for the next block.
  prefs: []
  type: TYPE_NORMAL
- en: Creating identities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, to use a service online, you must create an account with
    the organization that provides the service. If you want to use a social media
    application or create a bank account, you need to provide information on yourself
    for the organization to grant you access. This is the centralized model: identities
    are stored and managed on one central organization''s servers. This is totally
    incompatible with the concept of blockchain that promotes decentralization to
    achieve mass-coordination without a central entity.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we create identities that are not controlled by any third party in
    that kind of ecosystem?
  prefs: []
  type: TYPE_NORMAL
- en: Securing identities using blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a blockchain, the person who sends the digital value and the person who receives
    it must be accurately determined.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography allows us to achieve just that, thanks to asymmetric encryption.
    Both asymmetric and symmetric methods basically achieve security through cryptography
    when sending a message or funds to someone, as well as being used to manage identities
    in a decentralized manner. Before explaining what asymmetric encryption is, which
    is used in most blockchains, we should explain what symmetric encryption is.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the symmetric method, everyone has only one key to encrypt or decrypt
    a specific message. If I want to send you the message *Hello*, I will follow this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: I encrypt the message *Hello* that becomes, say, *Jrmmp.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I send you my encrypted key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You decrypt the message using my key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key is generated through an algorithm that allows someone who possesses
    the key to encrypt and decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: But there is one important risk that exists using this encryption method. Since
    you need to send the recipient your key to allow him/her to read your messages
    (the process is called the handshake), a malicious person could intercept the
    key and use it afterward to decrypt your messages.
  prefs: []
  type: TYPE_NORMAL
- en: The asymmetric encryption, on the other hand, overcomes this problem. With this
    method, instead of one key, there are two keys, a public and a private key. The
    public key is communicated to anybody who wants to send you messages or digital
    value. The private key, on the contrary, is known by you and only you. It should
    never be disclosed to anyone else.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I want to send you the message *Hello*, we would follow this process:'
  prefs: []
  type: TYPE_NORMAL
- en: I retrieve your public key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I encrypt the message *Hello* using your public key and send it to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You decrypt the message using your private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a hacker intercepts the encrypted message I sent you, he/she won't be able
    to decrypt it because he/she doesn't possess the private key, which is the only
    key allowing the decryption of the message. In short, the public key is used to
    encrypt a message, and the private key to decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two principles to remember with the asymmetric encryption''s key
    pair—private key/public key; and they are the same as we''ve seen with the hash
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: One private key when hashed always gives the same public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowing the public key, it is impossible to find the private key (except with
    brute-force: by trying a lot of private keys).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-forcing a one-character password is relatively simple—64 combinations
    (a,b…A, B…1, 2…). But when it comes to the Bitcoin blockchain, whose private keys
    are 51 characters long, the probability reaches 64^51 possibilities. It would
    take years to brute-force a private key on the Bitcoin blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: This asymmetric encryption allows you to digitally sign any kind of information,
    message or transaction. Otherwise, how would you prove in the digital world that
    you are the author of a specific message or the owner of a specific account?
  prefs: []
  type: TYPE_NORMAL
- en: Encryption with the private key is used to prove authenticity. If you encrypt
    your message with your own private key, then anyone can decrypt it with your public
    key, which proves that you originated the message since it could only have been
    encrypted with your private key.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, your public key is your digital identity since it identifies
    statements and information made by you in the digital world. The private key is
    a kind of password to prove that you own your public key, that is, your digital
    identity.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we achieve decentralized identity management. Usually, the public
    key refers to the address of the account. Also, you don't have to link your real
    identity with your digital identity. Just by generating a new key pair, you would
    end up with a new digital identity. Keep in mind that this does not provide you
    with full anonymity because some information or statements sent with your digital
    identity may tie you with your real identity. That is why the Bitcoin blockchain
    is not entirely anonymous but rather pseudonymous.
  prefs: []
  type: TYPE_NORMAL
- en: The Byzantine Generals Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following chapters, we will start addressing more business-oriented topics.
    Until then, I should provide you with some context on the whys and wherefores
    of blockchain and go back to where it all started, with the Byzantine Generals
    Problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Byzantine Generals Problem is a real-life analogy for computer science
    that was expressed and partly answered in 1982 by Leslie Lamport, a famous American
    scientist and Turing Award winner, who raised the following question: *how can
    you achieve a consensus in the presence of traitors or faults?* Translated to
    the computer science world, this means: *how can you achieve consensus in a distributed
    system where some computers may be malfunctioning or give conflicting information?* This
    is how the issue came to be illustrated and known as the Byzantine Generals Problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an illustration of the Byzantine Generals Problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f82d06d-24a0-468e-a806-224e51042694.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: L.Lamport, R.Shostak and M.Pease, The Byzantine Generals problem, ACM
    Transactions on Programming Languages and Systems, Vol. 4, No. 3, July 1982'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explanation—multiple byzantine generals surrounding a city must coordinate
    their attack to take the city. To coordinate themselves, they use messengers to
    indicate to each other which decision they took: attack or retreat. Since this
    situation happens under war circumstances, some generals could be traitors and
    some messengers could be captured or die trying to send the news.'
  prefs: []
  type: TYPE_NORMAL
- en: If we draw a comparison with blockchain, the generals are the miners and the
    messengers are the communication links between them. Several researchers have
    concluded that the generals can't agree on a strategy if one third or more are
    traitors.
  prefs: []
  type: TYPE_NORMAL
- en: '*So how does blockchain solve it?*'
  prefs: []
  type: TYPE_NORMAL
- en: One instrument was introduced into the blockchain to make consensus work: **incentives**.
    A blockchain usually includes incentives for the miners who validate the transactions.
    In [Chapter 1](https://cdp.packtpub.com/blockchain_for_decision_makers/wp-admin/post.php?post=25&action=edit#post_24), *Basics
    of Blockchains and the Illustration of Village Beta*, the villager who validated
    the transactions was rewarded with 5 Villagecoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a blockchain, this is how a consensus is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the miners start constructing their local block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A random miner solves the mathematical problem of the block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The random miner sends his/her block to the other miners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other miners receive the block of the random miner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other miners check that the result found by the random miner is correct
    and that the previous hash points to the previous block's hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is valid, they cancel the block they were building and add to the copy
    of their blockchain the new block sent by the random miner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The random miner is rewarded with an incentive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the process repeats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a dishonest miner solved the mathematical problem and incorporated an invalid
    transaction in its block, the other miners would reject it because it contains
    an invalid transaction (the hash would totally be different). This miner would
    have to discard his/her block and, therefore, will not be able to receive any
    incentive. Let's look at how incentives work in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Offering incentives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, incentives ensure that miners continue working for the network responsibly
    (in other words, consensually validate correct transactions). The work provided
    by the miners is rewarded by the cryptocurrency underlying the blockchain. By
    implementing rewards, people are encouraged to join the community and become miners,
    who, as a result, contribute to broadening the network. And the more miners there
    are, the larger the network and the more secured are the transactions because
    the less chance there is for the blockchain to be controlled by one party or individual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the rewards are usually decreasing exponentially over time because
    a blockchain often starts with few miners before enjoying a network effect and
    attracting more miners. Joining a blockchain early as a miner ensures you to gain
    more cryptocurrency even though it is not worth much at the beginning. But as
    more miners are joining the network and as more users are using the service, the
    cryptocurrency itself starts gaining consideration, hence, value. In this manner,
    rewards for miners usually decline over time following a predefined algorithm
    as more members join the network. For Bitcoin, for example, the original block
    reward was 50 Bitcoin, planned to halve every 210,000 blocks. As of June 2019,
    the block rewards are 12.5 BTC and total supply is set to 21 million BTC, the
    last unit of which should be allocated in 2140. What is important to remember
    as a decision-maker is that incentivization is an important component of a blockchain
    because it answers the following question: what are the interests for a miner
    to continue to validate the transactions happening in the network? Put differently,
    what is the motivation of the validators to keep ensuring the truth within the
    registry?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the consensus protocol mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated before, for the miners to validate a block and, hence, the transactions, they
    have to solve a mathematical problem. To solve it, there is a need for a specific
    resource. In Bitcoin, the resource is computing power. The more computing power
    a miner has, the faster he/she can solve the mathematical problem, therefore the
    faster he/she completes a block and the more likely he/she will receive Bitcoins
    as a reward. This mining process is called proof-of-work and is inherent to Bitcoin.
    It is a protocol that all of the miners of the Bitcoin blockchain should follow
    to demonstrate that they have done an appropriate work for validating the transactions.
    This ensures a selection process in which every miner uses computational power
    to find the correct nonce that will return a hash starting with a predefined number
    of zeros. Of course, not all miners have the same computing power, so it is not
    fairly random.
  prefs: []
  type: TYPE_NORMAL
- en: The computing power of a machine is measured by the number of guesses per second.
  prefs: []
  type: TYPE_NORMAL
- en: The most powerful miners will have more chances to solve the problem compared
    to sole computers with less computing power. However, even if one owns 10% of
    the computing power of the entire network and the 90% remaining are provided by
    thousands of other miners, one will still have a 1 in 10 chance of finding the
    correct answer. This is how randomness ensures that no one can control the validation
    of the blocks and, hence, the blockchain. This also means that if one miner, or
    one organization of miners, came to control 51% or more of the computing power
    of the network, they would be the first to solve the problem in 51% of the cases.
    In other words, they would be able, in 51% of the cases, to validate or modify
    the transactions at their will.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important issue behind the proof-of-work protocol that, as a decision-maker,
    you should be aware of—it is a very energy-consuming process that leverages questions
    on its sustainability. Since it takes a tremendous amount of computing power to
    find the proper hash of the block and since there are a lot of miners in the network,
    the consumption of electricity for validating the transactions on the Bitcoin
    blockchain has become a worldwide concern to the point that it has exceeded the
    consumption of electricity of Switzerland ([https://www.bbc.com/news/technology-48853230](https://www.bbc.com/news/technology-48853230)).
    The following diagram shows Bitcoin''s energy consumption as of June 2019:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f0f203-0004-4d03-8fad-0cf868b68b36.png)'
  prefs: []
  type: TYPE_IMG
- en: Source: [https://digiconomist.net](https://digiconomist.net)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, other protocols can replace the energy-consuming proof-of-work. One
    of the most well known is proof-of-stake, which is being implemented in the Ethereum
    blockchain. But more on that in the next chapter, [Chapter 3](b58a1e54-07e5-4b7a-8202-b5a7064ce976.xhtml),
    *Ethereum and Smart Contracts*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All in all, a blockchain is the combination of several instruments that come
    together to provide an infrastructure to exchange digital value and assert the
    truth without the need of a central entity.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed throughout this chapter, a blockchain is composed of a network
    of users, nodes, and miners that respectively send/receive, store, and validate
    transactions. Cryptography (and more specifically hash functions) is used in this
    configuration to create an output (a hash) that refers to any kind of digital
    information, for example, to refer to a batch of transactions. Blocks cluster
    these transactions and include metadata associated with the block itself such
    as the previous hash, the timestamp, and the nonce. Public and private keys provide
    a way to efficiently manage identities in the digital world and more specifically
    in the network. In a blockchain, there is also an incentive mechanism where the
    underlying cryptocurrency is used as a reward to motivate miners to work for the
    common good and keep ensuring the truth across the blockchain. Finally, a consensus
    protocol comes in to enable the miners to validate the transactions continuously
    and properly.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you hopefully understand how a blockchain works and what intrinsic
    principles it combines to ensure security, transparency, and immutability. So
    far, we have covered the most important characteristics. The better you appreciate
    them, the easier it will be for you to grasp the main social and economic challenges
    surrounding blockchain and eventually help you to identify the relevance of a
    blockchain for a specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Ethereum and smart contracts.
  prefs: []
  type: TYPE_NORMAL
