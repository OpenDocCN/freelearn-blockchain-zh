["```\n$ cd $GOPATH/src/trade-finance-logistics/network\n$ ./trade.sh up -d true  \n```", "```\n$ docker exec -it chaincode bash \n$ cd trade_workflow_v1 \n$ go build \n```", "```\n$ CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=tw:0 ./trade_workflow_v1  \n```", "```\n$ docker exec -it cli bash \n$ peer chaincode install -p chaincodedev/chaincode/trade_workflow_v1 -n tw -v 0\n```", "```\n$ peer chaincode instantiate -n tw -v 0 -c '{\"Args\":[\"init\",\"LumberInc\",\"LumberBank\",\"100000\",\"WoodenToys\",\"ToyBank\",\"200000\",\"UniversalFreight\",\"ForestryDepartment\"]}' -C tradechannel \n```", "```\n$ peer chaincode invoke -n tw -c '{\"Args\":[\"requestTrade\", \"trade-12\", \"50000\", \"Wood for Toys\"]}' -C tradechannel\n```", "```\n$ peer chaincode invoke -n tw -c '{\"Args\":[\"getTradeStatus\", \"trade-12\"]}' -C tradechannel\n```", "```\ntype Chaincode interface { \n    Init(stub ChaincodeStubInterface) pb.Response \n    Invoke(stub ChaincodeStubInterface) pb.Response \n} \n```", "```\n$GOPATH/src/trade-finance-logistics/chaincode/src/github.com/trade_workflow_v1\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n    \"strconv\"\n    \"strings\"\n    \"encoding/json\"\n    \"github.com/hyperledger/fabric/core/chaincode/shim\"\n    \"github.com/hyperledger/fabric/core/chaincode/lib/cid\"\n    pb \"github.com/hyperledger/fabric/protos/peer\"\n)\n```", "```\ntype TradeWorkflowChaincode struct {\n    testMode bool\n}\n```", "```\n// TradeWorkflowChaincode implementation\nfunc (t *TradeWorkflowChaincode) Init(stub SHIM.ChaincodeStubInterface)         pb.Response {\n    fmt.Println(\"Initializing Trade Workflow\")\n    return shim.Success(nil)\n}\n```", "```\n// Creates a Response object with the Success status and with argument of a 'payload' to return\n// if there is no value to return, the argument 'payload' should be set to 'nil'\nfunc shim.Success(payload []byte)\n\n// creates a Response object with the Error status and with an argument of a message of the error\nfunc shim.Error(msg string)\n```", "```\n_, args := stub.GetFunctionAndParameters()\nvar err error\n\n// Upgrade Mode 1: leave ledger state as it was\nif len(args) == 0 {\n  return shim.Success(nil)\n}\n\n// Upgrade mode 2: change all the names and account balances\nif len(args) != 8 {\n err = errors.New(fmt.Sprintf(\"Incorrect number of arguments. Expecting 8: {\" +\n             \"Exporter, \" +\n             \"Exporter's Bank, \" +\n             \"Exporter's Account Balance, \" +\n             \"Importer, \" +\n             \"Importer's Bank, \" +\n             \"Importer's Account Balance, \" +\n             \"Carrier, \" +\n             \"Regulatory Authority\" +\n             \"}. Found %d\", len(args)))\n  return shim.Error(err.Error())\n}\n```", "```\n// Type checks\n_, err = strconv.Atoi(string(args[2]))\nif err != nil {\n    fmt.Printf(\"Exporter's account balance must be an integer. Found %s\\n\", args[2])\n    return shim.Error(err.Error())\n}\n_, err = strconv.Atoi(string(args[5]))\nif err != nil {\n    fmt.Printf(\"Importer's account balance must be an integer. Found %s\\n\", args[5])\n    return shim.Error(err.Error())\n}\n\n// Map participant identities to their roles on the ledger\nroleKeys := []string{ expKey, ebKey, expBalKey, impKey, ibKey, impBalKey, carKey, raKey }\nfor i, roleKey := range roleKeys {\n    err = stub.PutState(roleKey, []byte(args[i]))\n    if err != nil {\n        fmt.Errorf(\"Error recording key %s: %s\\n\", roleKey, err.Error())\n```", "```\n        return shim.Error(err.Error())\n    }\n}\n```", "```\nfunc (t *TradeWorkflowChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {\n    fmt.Println(\"TradeWorkflow Invoke\")\n}\n```", "```\n// Returns the first argument as the function name and the rest of the arguments as parameters in a string array.\n// The client must pass only arguments of the type string.\nfunc GetFunctionAndParameters() (string, []string)\n\n// Returns all arguments as a single string array.\n// The client must pass only arguments of the type string.\nfunc GetStringArgs() []string\n\n// Returns the arguments as an array of byte arrays.\nfunc GetArgs() [][]byte\n\n// Returns the arguments as a single byte array.\nfunc GetArgsSlice() ([]byte, error)\n```", "```\n    function, args := stub.GetFunctionAndParameters()\n\n    if function == \"requestTrade\" {\n        // Importer requests a trade\n        return t.requestTrade(stub, creatorOrg, creatorCertIssuer, args)\n    } else if function == \"acceptTrade\" {\n        // Exporter accepts a trade\n        return t.acceptTrade(stub, creatorOrg, creatorCertIssuer, args)\n    } else if function == \"requestLC\" {\n        // Importer requests an L/C\n        return t.requestLC(stub, creatorOrg, creatorCertIssuer, args)\n    } else if function == \"issueLC\" {\n        // Importer's Bank issues an L/C\n        return t.issueLC(stub, creatorOrg, creatorCertIssuer, args)\n    } else if function == \"acceptLC\" {\n  ...\n\n  return shim.Error(\"Invalid invoke function name\")\n```", "```\nfabric-ca-client register --id.name user1 --id.secret pwd1 --id.type user --id.affiliation ImporterOrgMSP --id.attrs 'importer=true:ecert'\n```", "```\nfabric-ca-client register --id.name user1 --id.secret pwd1 --id.type user --id.affiliation ImporterOrgMSP --id.attrs 'importer=true:ecert,hf.Affiliation=ImporterOrgMSP:ecert'\n```", "```\nfabric-ca-client enroll -u http://user1:pwd1@localhost:7054 --enrollment.attrs \"importer,email:opt\"\n```", "```\n// Returns the ID associated with the invoking identity. \n// This ID is unique within the MSP (Fabric CA) which issued the identity, however, it is not guaranteed to be unique across all MSPs of the network. \nfunc GetID() (string, error) \n\n// Returns the unique ID of the MSP associated with the identity that submitted the transaction. \n// The combination of the MSPID and of the identity ID are guaranteed to be unique across the network. \nfunc GetMSPID() (string, error) \n\n// Returns the value of the ecert attribute named `attrName`. \n// If the ecert has the attribute, the `found` returns true and the `value` returns the value of the attribute. \n// If the ecert does not have the attribute, `found` returns false and `value` returns empty string. \nfunc GetAttributeValue(attrName string) (value string, found bool, err error) \n\n// The function verifies that the ecert has the attribute named `attrName` and that the attribute value equals to `attrValue`. \n// The function returns nil if there is a match, else, it returns error. \nfunc AssertAttributeValue(attrName, attrValue string) error \n\n// Returns the X509 identity certificate. \n// The certificate is an instance of a type Certificate from the library \"crypto/x509\". \nfunc GetX509Certificate() (*x509.Certificate, error)  \n```", "```\nimport ( \n   \"fmt\" \n   \"github.com/hyperledger/fabric/core/chaincode/shim\" \n   \"github.com/hyperledger/fabric/core/chaincode/lib/cid\" \n   \"crypto/x509\" \n) \n\nfunc getTxCreatorInfo(stub shim.ChaincodeStubInterface) (string, string, error) { \n   var mspid string \n   var err error \n   var cert *x509.Certificate \n\n   mspid, err = cid.GetMSPID(stub) \n   if err != nil { \n         fmt.Printf(\"Error getting MSP identity: %sn\", err.Error()) \n         return \"\", \"\", err \n   } \n\n   cert, err = cid.GetX509Certificate(stub) \n   if err != nil { \n         fmt.Printf(\"Error getting client certificate: %sn\", err.Error()) \n         return \"\", \"\", err \n   } \n\n   return mspid, cert.Issuer.CommonName, nil \n}\n```", "```\nfunc authenticateExportingEntityOrg(mspID string, certCN string) bool {\n    return (mspID == \"ExportingEntityOrgMSP\") && (certCN == \"ca.exportingentityorg.trade.com\")\n}\nfunc authenticateExporterOrg(mspID string, certCN string) bool {\nreturn (mspID == \"ExporterOrgMSP\") && (certCN == \"ca.exporterorg.trade.com\")\n}\nfunc authenticateImporterOrg(mspID string, certCN string) bool {\n    return (mspID == \"ImporterOrgMSP\") && (certCN == \"ca.importerorg.trade.com\")\n}\nfunc authenticateCarrierOrg(mspID string, certCN string) bool {\n    return (mspID == \"CarrierOrgMSP\") && (certCN == \"ca.carrierorg.trade.com\")\n}\nfunc authenticateRegulatorOrg(mspID string, certCN string) bool {\n    return (mspID == \"RegulatorOrgMSP\") && (certCN == \"ca.regulatororg.trade.com\")\n}\n```", "```\ncreatorOrg, creatorCertIssuer, err = getTxCreatorInfo(stub)\nif !authenticateImporterOrg(creatorOrg, creatorCertIssuer) {\n    return shim.Error(\"Caller not a member of Importer Org. Access denied.\")\n}\n```", "```\ntype TradeAgreement struct { \n   Amount                    int               `json:\"amount\"` \n   DescriptionOfGoods        string            `json:\"descriptionOfGoods\"` \n   Status                    string            `json:\"status\"` \n   Payment                   int               `json:\"payment\"` \n} \n\ntype LetterOfCredit struct { \n   Id                        string            `json:\"id\"` \n   ExpirationDate            string            `json:\"expirationDate\"` \n   Beneficiary               string            `json:\"beneficiary\"` \n   Amount                    int               `json:\"amount\"` \n   Documents                 []string          `json:\"documents\"` \n   Status                    string            `json:\"status\"` \n} \n\ntype ExportLicense struct { \n   Id                        string            `json:\"id\"` \n   ExpirationDate            string            `json:\"expirationDate\"` \n   Exporter                  string            `json:\"exporter\"` \n   Carrier                   string            `json:\"carrier\"` \n   DescriptionOfGoods        string            `json:\"descriptionOfGoods\"` \n   Approver                  string            `json:\"approver\"` \n   Status                    string            `json:\"status\"` \n} \n\ntype BillOfLading struct { \n   Id                        string            `json:\"id\"` \n   ExpirationDate            string            `json:\"expirationDate\"` \n   Exporter                  string            `json:\"exporter\"` \n   Carrier                   string            `json:\"carrier\"` \n   DescriptionOfGoods        string            `json:\"descriptionOfGoods\"` \n   Amount                    int               `json:\"amount\"` \n   Beneficiary               string            `json:\"beneficiary\"` \n   SourcePort                string            `json:\"sourcePort\"` \n   DestinationPort           string            `json:\"destinationPort\"` \n}  \n```", "```\n// Returns the value of the `key` from the Worldstate. \n// If the key does not exist in the Worldstate the function returns (nil, nil). \n// The function does not read data from the WriteSet and hence uncommitted values modified by PutState are not returned. \nfunc GetState(key string) ([]byte, error) \n\n// Records the specified `key` and `value` into the WriteSet. \n// The function does not affect the ledger until the transaction is committed into the ledger. \nfunc PutState(key string, value []byte) error \n\n// Marks the the specified `key` as deleted in the WriteSet. \n// The key will be marked as deleted and removed from Worldstate once the transaction is committed into the ledger. \nfunc DelState(key string) error\n```", "```\nfunc (t *TradeWorkflowChaincode) requestTrade(stub shim.ChaincodeStubInterface, creatorOrg string, creatorCertIssuer string, args []string) pb.Response { \n   var tradeKey string \n   var tradeAgreement *TradeAgreement \n   var tradeAgreementBytes []byte \n   var amount int \n   var err error \n\n   // Access control: Only an Importer Org member can invoke this transaction \n   if !t.testMode && !authenticateImporterOrg(creatorOrg, creatorCertIssuer) { \n         return shim.Error(\"Caller not a member of Importer Org. Access denied.\") \n   } \n\n   if len(args) != 3 { \n         err = errors.New(fmt.Sprintf(\"Incorrect number of arguments. Expecting 3: {ID, Amount, Description of Goods}. Found %d\", len(args))) \n         return shim.Error(err.Error()) \n   } \n\n   amount, err = strconv.Atoi(string(args[1])) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n\n   tradeAgreement = &TradeAgreement{amount, args[2], REQUESTED, 0} \n   tradeAgreementBytes, err = json.Marshal(tradeAgreement) \n   if err != nil { \n         return shim.Error(\"Error marshaling trade agreement structure\") \n   } \n\n   // Write the state to the ledger \n   tradeKey, err = getTradeKey(stub, args[0]) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n   err = stub.PutState(tradeKey, tradeAgreementBytes) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n   fmt.Printf(\"Trade %s request recorded\", args[0]) \n\n   return shim.Success(nil) \n}  \n```", "```\nfunc (t *TradeWorkflowChaincode) acceptTrade(stub shim.ChaincodeStubInterface, creatorOrg string, creatorCertIssuer string, args []string) pb.Response { \n   var tradeKey string \n   var tradeAgreement *TradeAgreement \n   var tradeAgreementBytes []byte \n   var err error \n\n   // Access control: Only an Exporting Entity Org member can invoke this transaction \n   if !t.testMode && !authenticateExportingEntityOrg(creatorOrg, creatorCertIssuer) { \n         return shim.Error(\"Caller not a member of Exporting Entity Org. Access denied.\") \n   } \n\n   if len(args) != 1 { \n         err = errors.New(fmt.Sprintf(\"Incorrect number of arguments. Expecting 1: {ID}. Found %d\", len(args))) \n         return shim.Error(err.Error()) \n   } \n\n   // Get the state from the ledger \n   tradeKey, err = getTradeKey(stub, args[0]) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n   tradeAgreementBytes, err = stub.GetState(tradeKey) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n\n   if len(tradeAgreementBytes) == 0 { \n         err = errors.New(fmt.Sprintf(\"No record found for trade ID %s\", args[0])) \n         return shim.Error(err.Error()) \n   } \n\n   // Unmarshal the JSON \n   err = json.Unmarshal(tradeAgreementBytes, &tradeAgreement) \n   if err != nil { \n         return shim.Error(err.Error()) \n   } \n\n   if tradeAgreement.Status == ACCEPTED { \n         fmt.Printf(\"Trade %s already accepted\", args[0]) \n   } else { \n         tradeAgreement.Status = ACCEPTED \n         tradeAgreementBytes, err = json.Marshal(tradeAgreement) \n         if err != nil { \n               return shim.Error(\"Error marshaling trade agreement structure\") \n         } \n         // Write the state to the ledger \n         err = stub.PutState(tradeKey, tradeAgreementBytes) \n         if err != nil { \n               return shim.Error(err.Error()) \n         } \n   } \n   fmt.Printf(\"Trade %s acceptance recordedn\", args[0]) \n\n   return shim.Success(nil) \n}  \n```", "```\nfunc main() { \n   twc := new(TradeWorkflowChaincode) \n   twc.testMode = false \n   err := shim.Start(twc) \n   if err != nil { \n         fmt.Printf(\"Error starting Trade Workflow chaincode: %s\", err) \n   } \n} \n```", "```\n func TestFname(*testing.T)\n```", "```\n func checkInit(t *testing.T, stub *shim.MockStub, args [][]byte) { \n   res := stub.MockInit(\"1\", args) \n   if res.Status != shim.OK { \n         fmt.Println(\"Init failed\", string(res.Message)) \n         t.FailNow() \n   } \n} \n```", "```\nfunc getInitArguments() [][]byte { \n   return [][]byte{[]byte(\"init\"), \n               []byte(\"LumberInc\"), \n               []byte(\"LumberBank\"), \n               []byte(\"100000\"), \n               []byte(\"WoodenToys\"), \n               []byte(\"ToyBank\"), \n               []byte(\"200000\"),\n```", "```\n               []byte(\"UniversalFreight\"), \n               []byte(\"ForestryDepartment\")} \n} \n```", "```\nfunc TestTradeWorkflow_Init(t *testing.T) { \n   scc := new(TradeWorkflowChaincode) \n   scc.testMode = true \n   stub := shim.NewMockStub(\"Trade Workflow\", scc) \n\n   // Init \n   checkInit(t, stub, getInitArguments()) \n\n   checkState(t, stub, \"Exporter\", EXPORTER) \n   checkState(t, stub, \"ExportersBank\", EXPBANK) \n   checkState(t, stub, \"ExportersAccountBalance\", strconv.Itoa(EXPBALANCE)) \n   checkState(t, stub, \"Importer\", IMPORTER) \n   checkState(t, stub, \"ImportersBank\", IMPBANK) \n   checkState(t, stub, \"ImportersAccountBalance\", strconv.Itoa(IMPBALANCE)) \n   checkState(t, stub, \"Carrier\", CARRIER) \n   checkState(t, stub, \"RegulatoryAuthority\", REGAUTH) \n}\n```", "```\nfunc checkState(t *testing.T, stub *shim.MockStub, name string, value string) { \n  bytes := stub.State[name] \n  if bytes == nil { \n    fmt.Println(\"State\", name, \"failed to get value\") \n    t.FailNow() \n  } \n  if string(bytes) != value {\n    fmt.Println(\"State value\", name, \"was\", string(bytes), \"and not\", value, \"as expected\")\n    t.FailNow()\n  }\n} \n```", "```\nfunc TestTradeWorkflow_Agreement(t *testing.T) { \n   scc := new(TradeWorkflowChaincode) \n   scc.testMode = true \n   stub := shim.NewMockStub(\"Trade Workflow\", scc) \n\n   // Init \n   checkInit(t, stub, getInitArguments()) \n\n   // Invoke 'requestTrade' \n   tradeID := \"2ks89j9\" \n   amount := 50000 \n   descGoods := \"Wood for Toys\" \n   checkInvoke(t, stub, [][]byte{[]byte(\"requestTrade\"), []byte(tradeID), []byte(strconv.Itoa(amount)), []byte(descGoods)}) \n\n   tradeAgreement := &TradeAgreement{amount, descGoods, REQUESTED, 0} \n   tradeAgreementBytes, _ := json.Marshal(tradeAgreement) \n   tradeKey, _ := stub.CreateCompositeKey(\"Trade\", []string{tradeID}) \n   checkState(t, stub, tradeKey, string(tradeAgreementBytes)) \n   ... \n}\n```", "```\nfunc checkInvoke(t *testing.T, stub *shim.MockStub, args [][]byte) { \n   res := stub.MockInvoke(\"1\", args) \n   if res.Status != shim.OK { \n         fmt.Println(\"Invoke\", args, \"failed\", string(res.Message)) \n         t.FailNow() \n   } \n}\n```", "```\n$ cd $GOPATH/src/trade-finance-logistics/chaincode/src/github.com/trade_workflow_v1 \n$ go test \n```", "```\nInitializing Trade Workflow \nExporter: LumberInc \nExporter's Bank: LumberBank \nExporter's Account Balance: 100000 \nImporter: WoodenToys \nImporter's Bank: ToyBank \nImporter's Account Balance: 200000 \nCarrier: UniversalFreight \nRegulatory Authority: ForestryDepartment \n... \nAmount paid thus far for trade 2ks89j9 = 25000; total required = 50000 \nPayment request for trade 2ks89j9 recorded \nTradeWorkflow Invoke \nTradeWorkflow Invoke \nQuery Response:{\"Balance\":\"150000\"} \nTradeWorkflow Invoke \nQuery Response:{\"Balance\":\"150000\"} \nPASS \nok       trade-finance-logistics/chaincode/src/github.com/trade_workflow_v1      0.036s \n```", "```\n// The function creates a key by combining the attributes into a single string. \n// The arguments must be valid utf8 strings and must not contain U+0000 (nil byte) and U+10FFFF charactres. \nfunc CreateCompositeKey(objectType string, attributes []string) (string, error) \n\n// The function splits the compositeKey into attributes from which the key was formed. \n// This function is useful for extracting attributes from keys returned by range queries. \nfunc SplitCompositeKey(compositeKey string) (string, []string, error) \n```", "```\nfunc getTradeKey(stub shim.ChaincodeStubInterface, tradeID string) (string, error) { \n   tradeKey, err := stub.CreateCompositeKey(\"Trade\", []string{tradeID}) \n   if err != nil { \n         return \"\", err \n   } else { \n         return tradeKey, nil \n   } \n}\n```", "```\n // Returns an iterator over all keys between the startKey (inclusive) and endKey (exclusive). \n// To query from start or end of the range, the startKey and endKey can be an empty. \nfunc GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) \n\n// Returns an iterator over all composite keys whose prefix matches the given partial composite key. \n// Same rules as for arguments of CreateCompositeKey function apply. \nfunc GetStateByPartialCompositeKey(objectType string, keys []string) (StateQueryIteratorInterface, error) \n```", "```\nstartKey, err = getTradeKey(stub, \"1\") \nendKey, err = getTradeKey(stub, \"100\") \n\nkeysIterator, err := stub.GetStateByRange(startKey, endKey) \nif err != nil { \n    return shim.Error(fmt.Printf(\"Error accessing state: %s\", err)) \n} \n\ndefer keysIterator.Close() \n\nvar keys []string \nfor keysIterator.HasNext() { \n    key, _, err := keysIterator.Next() \n    if err != nil { \n        return shim.Error(fmt.Printf(\"keys operation failed. Error accessing state: %s\", err)) \n    } \n    keys = append(keys, key) \n}\n```", "```\nfunc GetQueryResult(query string) (StateQueryIteratorInterface, error)\n```", "```\n// CouchDB query definition\nqueryString :=\n`{\n    \"selector\": {\n            \"status\": \"ACCEPTED\"\n            \"payment\": {\n                    \"$gt\": 1000\n            }\n    }\n}`\n\nfmt.Printf(\"queryString:\\n%s\\n\", queryString)\n\n// Invoke query\nresultsIterator, err := stub.GetQueryResult(queryString)\nif err != nil {\n    return nil, err\n}\ndefer resultsIterator.Close()\n\nvar buffer bytes.Buffer\nbuffer.WriteString(\"[\")\n\n// Iterate through all returned assets\nbArrayMemberAlreadyWritten := false\nfor resultsIterator.HasNext() {\n    queryResponse, err := resultsIterator.Next()\n    if err != nil {\n        return nil, err\n    }\n    if bArrayMemberAlreadyWritten == true {\n        buffer.WriteString(\",\")\n    }\n    buffer.WriteString(\"{\\\"Key\\\":\")\n    buffer.WriteString(\"\\\"\")\n    buffer.WriteString(queryResponse.Key)\n    buffer.WriteString(\"\\\"\")\n\n    buffer.WriteString(\", \\\"Record\\\":\")\n    buffer.WriteString(string(queryResponse.Value))\n    buffer.WriteString(\"}\")\n    bArrayMemberAlreadyWritten = true\n}\nbuffer.WriteString(\"]\")\n\nfmt.Printf(\"queryResult:\\n%s\\n\", buffer.String())\n```", "```\n { \n  \"index\": { \n    \"fields\": [ \n      \"status\", \n      \"payment\" \n    ] \n  }, \n  \"name\": \"index_sp\", \n  \"type\": \"json\" \n}  \n```", "```\n{\n  \"rwset\": {\n    \"reads\": [\n      {\n        \"key\": \"key1\",\n        \"version\": {\n          \"block_num\": {\n            \"low\": 9546,\n            \"high\": 0,\n            \"unsigned\": true\n          },\n          \"tx_num\": {\n            \"low\": 0,\n            \"high\": 0,\n            \"unsigned\": true\n          }\n        }\n      }\n    ],\n    \"range_queries_info\": [],\n    \"writes\": [\n      {\n        \"key\": \"key1\",\n        \"is_delete\": false,\n        \"value\": \"value1\"\n      },\n      {\n        \"key\": \"key2\",\n        \"is_delete\": true\n      }\n    ]\n  }\n}\n```", "```\nCRITICAL | ERROR | WARNING | NOTICE | INFO | DEBUG \n```", "```\npeer node start --logging-level=error  \n```", "```\n peer node start --logging-level=chaincode=error:main=info\n```", "```\npeer0.org1.example.com:\n    environment:\n        - CORE_LOGGING_LEVEL=error\n```", "```\nlogging:\n    level: info\n```", "```\n chaincode: \n   logging: \n         level:  error \n         shim:   warning  \n```", "```\n// Creates a new logging object. \nfunc NewLogger(name string) *ChaincodeLogger \n\n// Converts a case-insensitive string representing a logging level into an element of LoggingLevel enumeration type. \n// This function is used to convert constants of standard GO logging levels (i.e. CRITICAL, ERROR, WARNING, NOTICE, INFO or DEBUG) into the shim's enumeration LoggingLevel type (i.e. LogDebug, LogInfo, LogNotice, LogWarning, LogError, LogCritical). \nfunc LogLevel(levelString string) (LoggingLevel, error) \n\n// Sets the logging level of the logging object. \nfunc (c *ChaincodeLogger) SetLevel(level LoggingLevel) \n\n// Returns true if the logging object will generate logs at the given level. \nfunc (c *ChaincodeLogger) IsEnabledFor(level LoggingLevel) bool \n```", "```\nfunc (c *ChaincodeLogger) Debug(args ...interface{}) \nfunc (c *ChaincodeLogger) Debugf(format string, args ...interface{}) \nfunc (c *ChaincodeLogger) Info(args ...interface{}) \nfunc (c *ChaincodeLogger) Infof(format string, args ...interface{}) \nfunc (c *ChaincodeLogger) Notice(args ...interface{}) \nfunc (c *ChaincodeLogger) Noticef(format string, args ...interface{}) \nfunc (c *ChaincodeLogger) Warning(args ...interface{}) \nfunc (c *ChaincodeLogger) Warningf(format string, args ...interface{}) \nfunc (c *ChaincodeLogger) Error(args ...interface{}) \nfunc (c *ChaincodeLogger) Errorf(format string, args ...interface{}) \nfunc (c *ChaincodeLogger) Critical(args ...interface{}) \nfunc (c *ChaincodeLogger) Criticalf(format string, args ...interface{}) \n```", "```\n[timestamp] [logger name] [severity level] printed arguments \n```", "```\nvar logger = shim.NewLogger(\"tradeWorkflow\") \nlogger.SetLevel(shim.LogDebug) \n\n_, args := stub.GetFunctionAndParameters() \nlogger.Debugf(\"Function: %s(%s)\", \"requestTrade\", strings.Join(args, \",\")) \n\nif !authenticateImporterOrg(creatorOrg, creatorCertIssuer) { \n   logger.Info(\"Caller not a member of Importer Org. Access denied:\", creatorOrg, creatorCertIssuer) \n} \n```", "```\nlogLevel, _ := shim.LogLevel(os.Getenv(\"TW_SHIM_LOGGING_LEVEL\"))\nshim.SetLoggingLevel(logLevel)\n```", "```\npeer0.org1.example.com: \n   environment: \n         - CORE_VM_DOCKER_ATTACHSTDOUT=true \n```", "```\n // Returns an unique Id of the transaction proposal. \nfunc GetTxID() string \n\n// Returns an Id of the channel the transaction proposal was sent to. \nfunc GetChannelID() string \n\n// Calls an Invoke function on a specified chaincode, in the context of the current transaction. \n// If the invoked chaincode is on the same channel, the ReadSet and WriteSet will be added into the same transaction. \n// If the invoked chaincode is on a different channel, the invocation can be used only as a query. \nfunc InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response \n\n// Returns a list of historical states, timestamps and transactions ids. \nfunc GetHistoryForKey(key string) (HistoryQueryIteratorInterface, error) \n\n// Returns the identity of the user submitting the transaction proposal. \nfunc GetCreator() ([]byte, error) \n\n// Returns a map of fields containing cryptographic material which may be used to implement custom privacy layer in the chaincode. \nfunc GetTransient() (map[string][]byte, error) \n\n// Returns data which can be used to enforce a link between application data and the transaction proposal. \nfunc GetBinding() ([]byte, error) \n\n// Returns data produced by peer decorators which modified the chaincode input. \nfunc GetDecorations() map[string][]byte \n\n// Returns data elements of a transaction proposal. \nfunc GetSignedProposal() (*pb.SignedProposal, error) \n\n// Returns a timestamp of the transaction creation by the client. The timestamp is consistent across all endorsers. \nfunc GetTxTimestamp() (*timestamp.Timestamp, error) \n\n// Sets an event attached to the transaction proposal response. This event will be be included in the block and ledger. \nfunc SetEvent(name string, payload []byte) error  \n```"]