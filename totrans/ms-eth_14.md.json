["```\ngit clone https://github.com/merlox/dapp\n```", "```\nmv dapp/ social-media-dapp/\n```", "```\ngit config remote.origin.url https://<YOUR-USERNAME>:<YOUR-PASSWORD>@github.com/<YOUR-USERNAME>/social-media-dapp\n```", "```\nnpm i -S style-loader css-loader\n```", "```\n{\n    test: /\\.css$/,\n    exclude: /node_modules/,\n    use: [\n        { loader: 'style-loader' },\n        { loader: 'css-loader' }\n    ]\n}\n```", "```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\n```", "```\nclass Main extends React.Component {\n    constructor() {\n        super()\n\n        this.state = {\n            content: [{\n                author: '0x211824098yf7320417812j1002341342342341234',\n                message: 'This is a test',\n                hashtags: ['test', 'dapp', 'blockchain'],\n                time: new Date().toLocaleDateString(),\n            }, {\n                author: '0x211824098yf7320417812j1002341342342341234',\n                message: 'This is another test',\n                hashtags: ['sample', 'dapp', 'Ethereum'],\n                time: new Date().toLocaleDateString(),\n            }],\n            topHashtags: ['dapp', 'Ethereum', 'blockchain', 'technology', 'design'],\n            followedHashtags: ['electronics', 'design', 'robots', 'futurology', 'manufacturing'],\n            displaySubscribe: false,\n            displaySubscribeId: '',\n        }\n    }\n```", "```\n    render() {\n        return (\n            <div className=\"main-container\">\n            </div>\n        )\n    }\n}\n\nReactDOM.render(<Main />, document.querySelector('#root'))\n```", "```\ngenerateHashtags(hashtag, index) {\n    let timeout\n    return (\n        <span onMouseEnter={() => {\n            clearTimeout(timeout)\n            this.setState({\n                displaySubscribe: true,\n                displaySubscribeId: `subscribe-${hashtag}-${index}`,\n            })\n        }} onMouseLeave={() => {\n            timeout = setTimeout(() => {\n                this.setState({\n                    displaySubscribe: false,\n                    displaySubscribeId: '',\n                })\n            }, 2e3)\n        }}>\n            <a className=\"hashtag\" href=\"#\">#{hashtag}</a>\n            <span className=\"spacer\"></span>\n            <button ref={`subscribe-${hashtag}-${index}`} className={this.state.displaySubscribe && this.state.displaySubscribeId == `subscribe-${hashtag}-${index}` ? '' : 'hidden'} type=\"button\">Subscribe</button>\n            <span className=\"spacer\"></span>\n        </span>\n    )\n}\n```", "```\nrender() {\n    let contentBlock = this.state.content.map((element, index) => (\n        <div key={index} className=\"content\">\n            <div className=\"content-address\">{element.author}</div>\n            <div className=\"content-message\">{element.message}</div>\n            <div className=\"content-hashtags\">{element.hashtags.map((hashtag, i) => (\n                <span key={i}>\n                    {this.generateHashtags(hashtag, index)}\n                </span>\n            ))}\n            </div>\n            <div className=\"content-time\">{element.time}</div>\n        </div>\n    ))\n```", "```\nlet hashtagBlock = this.state.topHashtags.map((hashtag, index) => (\n    <div key={index}>\n        {this.generateHashtags(hashtag, index)}\n    </div>\n))\nlet followedHashtags = this.state.followedHashtags.map((hashtag, index) => (\n    <div key={index}>\n        {this.generateHashtags(hashtag, index)}\n    </div>\n))\n```", "```\n    return (\n        <div className=\"main-container\">\n            <div className=\"hashtag-block\">\n                <h3>Top hashtags</h3>\n                <div className=\"hashtag-container\">{hashtagBlock}</div>\n                <h3>Followed hashtags</h3>\n                <div className=\"hashtag-container\">{followedHashtags}</div>\n            </div>\n            <div className=\"content-block\">\n                <div className=\"input-container\">\n                    <textarea placeholder=\"Publish content...\"></textarea>\n                    <input type=\"text\" placeholder=\"Hashtags separated by commas...\"/>\n                    <button type=\"button\">Publish</button>\n                </div>\n\n                <div className=\"content-container\">\n                    {contentBlock}\n                </div>\n            </div>\n        </div>\n    )\n}\n```", "```\nbody {\n    margin: 0;\n    background-color: whitesmoke;\n    font-family: sans-serif;\n}\n\nbutton {\n    background-color: rgb(201, 47, 47);\n    color: white;\n    border-radius: 15px;\n    border: none;\n    cursor: pointer;\n}\n\nbutton:hover {\n    background-color: rgb(131, 0, 0);\n}\n```", "```\n.hidden {\n    display: none;\n}\n\n.spacer {\n    margin-right: 5px;\n}\n```", "```\n.main-container {\n    display: grid;\n    grid-template-columns: 30% 70%;\n    margin: auto;\n    width: 50%;\n    grid-column-gap: 10px;\n}\n\n.input-container {\n    margin-bottom: 10px;\n    padding: 30px;\n    display: grid;\n    grid-template-columns: 80% 1fr;\n    grid-template-rows: 70% 30%;\n    grid-gap: 10px;\n}\n```", "```\n.input-container textarea {\n    padding: 10px;\n    border-radius: 10px;\n    font-size: 11pt;\n    font-family: sans-serif;\n    border: 1px solid grey;\n    grid-column: 1 / 3;\n}\n\n.input-container input {\n    padding: 10px;\n    border-radius: 10px;\n    font-size: 11pt;\n    font-family: sans-serif;\n    border: 1px solid grey;\n}\n```", "```\n.content {\n    background-color: white;\n    border: 1px solid grey;\n    margin-bottom: 10px;\n    padding: 30px;\n    box-shadow: 4px 4px 0px 0 #cecece;\n}\n.content-address {\n    color: grey;\n    margin-bottom: 5px;\n}\n.content-message {\n    font-size: 16pt;\n    margin-bottom: 5px;\n}\n.content-hashtags {\n    margin-bottom: 5px;\n}\n.content-time {\n    color: grey;\n    font-size: 12pt;\n}\n```", "```\n.hashtag-block {\n    text-align: center;\n}\n\n.hashtag-container {\n    line-height: 30px;\n}\n\n.hashtag {\n    font-size: 15pt;\n}\n```", "```\n// This is a social media smart contract that allows people to publish strings of text in short formats with a focus on hashtags so that they can follow, read and be in touch with the latest content regarding those hashtags. There will be a mapping of the top hashtags. A struct for each piece of content with the date, author, content and array of hashtags. We want to avoid focusing on specific users that's why user accounts will be anonymous where addresses will the be the only identifiers.\n\npragma solidity ^0.5.5;\n\ncontract SocialMedia {}\n```", "```\nstruct Content {\n    uint256 id;\n    address author;\n    uint256 date;\n    string content;\n    bytes32[] hashtags;\n}\n\nevent ContentAdded(uint256 indexed id, address indexed author, uint256 indexed date, string content, bytes32[] hashtags);\n```", "```\nmapping(address => bytes32[]) public subscribedHashtags;\nmapping(bytes32 => uint256) public hashtagScore; // The number of times this hashtag has been used, used to sort the top hashtags\nmapping(bytes32 => Content[]) public contentByHashtag;\nmapping(uint256 => Content) public contentById;\nmapping(bytes32 => bool) public doesHashtagExist;\nmapping(address => bool) public doesUserExist;\naddress[] public users;\nContent[] public contents;\nbytes32[] public hashtags;\nuint256 public latestContentId;\n```", "```\nfunction addContent(string memory _content, bytes32[] memory _hashtags) public {}\nfunction subscribeToHashtag(bytes32 _hashtag) public {}\nfunction unsubscribeToHashtag(bytes32 _hashtag) public {}\nfunction getTopHashtags(uint256 _amount) public view returns(bytes32[] memory) {}\nfunction getFollowedHashtags() public view returns(bytes32[] memory) {}\nfunction getContentIdsByHashtag(bytes32 _hashtag, uint256 _amount) public view returns(uint256[] memory) {}\nfunction getContentById(uint256 _id) public view returns(uint256, address, uint256, string memory, bytes32[] memory) {}\nfunction sortHashtagsByScore() public view returns(bytes32[] memory) {}\nfunction checkExistingSubscription(bytes32 _hashtag) public view returns(bool) {}\n```", "```\n/// @notice To add new content to the social media dApp. If no hashtags are sent, the content is added to the #general hashtag list.\n/// @param _content The string of content\n/// @param _hashtags The hashtags used for that piece of content\nfunction addContent(string memory _content, bytes32[] memory _hashtags) public {}\n\n/// @notice To subscribe to a hashtag if you didn't do so already\n/// @param _hashtag The hashtag name\nfunction subscribeToHashtag(bytes32 _hashtag) public {}\n\n/// @notice To unsubscribe to a hashtag if you are subscribed otherwise it won't do nothing\n/// @param _hashtag The hashtag name\nfunction unsubscribeToHashtag(bytes32 _hashtag) public {}\n```", "```\n/// @notice To get the top hashtags\n/// @param _amount How many top hashtags to get in order, for instance the top 20 hashtags\n/// @return bytes32[] Returns the names of the hashtags\nfunction getTopHashtags(uint256 _amount) public view returns(bytes32[] memory) {}\n\n/// @notice To get the followed hashtag names for this msg.sender\n/// @return bytes32[] The hashtags followed by this user\nfunction getFollowedHashtags() public view returns(bytes32[] memory) {}\n```", "```\n/// @notice To get the contents for a particular hashtag. It returns the ids because we can't return arrays of strings and we can't return structs so the user has to manually make a new request for each piece of content using the function below.\n/// @param _hashtag The hashtag from which get content\n/// @param _amount The quantity of contents to get for instance, 50 pieces of content for that hashtag\n/// @return uint256[] Returns the ids of the contents so that you can get each piece independently with a new request since you can't return arrays of strings\nfunction getContentIdsByHashtag(bytes32 _hashtag, uint256 _amount) public view returns(uint256[] memory) {}\n\n/// @notice Returns the data for a particular content id\n/// @param _id The id of the content\n/// @return Returns the id, author, date, content and hashtags for that piece of content\nfunction getContentById(uint256 _id) public view returns(uint256, address, uint256, string memory, bytes32[] memory) {}\n```", "```\n/// @notice Sorts the hashtags given their hashtag score\n/// @return bytes32[] Returns the sorted array of hashtags\nfunction sortHashtagsByScore() public view returns(bytes32[] memory) {}\n\n/// @notice To check if the use is already subscribed to a hashtag\n/// @return bool If you are subscribed to that hashtag or not\nfunction checkExistingSubscription(bytes32 _hashtag) public view returns(bool) {}\n```", "```\n/// @notice To add new content to the social media dApp. If no hashtags are sent, the content is added to the #general hashtag list.\n/// @param _content The string of content\n/// @param _hashtags The hashtags used for that piece of content\nfunction addContent(string memory _content, bytes32[] memory _hashtags) public {\n    require(bytes(_content).length > 0, 'The content cannot be empty');\n    Content memory newContent = Content(latestContentId, msg.sender, now, _content, _hashtags);\n    // If the user didn't specify any hashtags add the content to the #general hashtag\n```", "```\n    if(_hashtags.length == 0) {\n        contentByHashtag['general'].push(newContent);\n        hashtagScore['general']++;\n        if(!doesHashtagExist['general']) {\n            hashtags.push('general');\n            doesHashtagExist['general'] = true;\n        }\n    } else {\n        for(uint256 i = 0; i < _hashtags.length; i++) {\n            contentByHashtag[_hashtags[i]].push(newContent);\n            hashtagScore[_hashtags[i]]++;\n            if(!doesHashtagExist[_hashtags[i]]) {\n                hashtags.push(_hashtags[i]);\n                doesHashtagExist[_hashtags[i]] = true;\n            }\n        }\n    }\n```", "```\n    hashtags = sortHashtagsByScore();\n    contentById[latestContentId] = newContent;\n    contents.push(newContent);\n    if(!doesUserExist[msg.sender]) {\n        users.push(msg.sender);\n        doesUserExist[msg.sender] = true;\n    }\n    emit ContentAdded(latestContentId, msg.sender, now, _content, _hashtags);\n    latestContentId++;\n}\n```", "```\n/// @notice To subscribe to a hashtag if you didn't do so already\n/// @param _hashtag The hashtag name\nfunction subscribeToHashtag(bytes32 _hashtag) public {\n    if(!checkExistingSubscription(_hashtag)) {\n        subscribedHashtags[msg.sender].push(_hashtag);\n        hashtagScore[_hashtag]++;\n        hashtags = sortHashtagsByScore();\n    }\n}\n```", "```\n/// @notice To unsubscribe to a hashtag if you are subscribed otherwise it won't do nothing\n/// @param _hashtag The hashtag name\nfunction unsubscribeToHashtag(bytes32 _hashtag) public {\n    if(checkExistingSubscription(_hashtag)) {\n        for(uint256 i = 0; i < subscribedHashtags[msg.sender].length; i++) {\n            if(subscribedHashtags[msg.sender][i] == _hashtag) {\n                delete subscribedHashtags[msg.sender][i];\n                hashtagScore[_hashtag]--;\n                hashtags = sortHashtagsByScore();\n                break;\n            }\n        }\n    }\n}\n```", "```\n/// @notice To get the top hashtags\n/// @param _amount How many top hashtags to get in order, for instance the top 20 hashtags\n/// @return bytes32[] Returns the names of the hashtags\nfunction getTopHashtags(uint256 _amount) public view returns(bytes32[] memory) {\n    bytes32[] memory result;\n    if(hashtags.length < _amount) {\n        result = new bytes32[](hashtags.length);\n        for(uint256 i = 0; i < hashtags.length; i++) {\n            result[i] = hashtags[i];\n        }\n    } else {\n        result = new bytes32[](_amount);\n        for(uint256 i = 0; i < _amount; i++) {\n            result[i] = hashtags[i];\n        }\n    }\n    return result;\n}\n```", "```\n/// @notice To get the followed hashtag names for this msg.sender\n/// @return bytes32[] The hashtags followed by this user\nfunction getFollowedHashtags() public view returns(bytes32[] memory) {\n    return subscribedHashtags[msg.sender];\n}\n```", "```\n/// @notice To get the contents for a particular hashtag. It returns the ids because we can't return arrays of strings and we can't return structs so the user has to manually make a new request for each piece of content using the function below.\n/// @param _hashtag The hashtag from which get content\n/// @param _amount The quantity of contents to get for instance, 50 pieces of content for that hashtag\n/// @return uint256[] Returns the ids of the contents so that you can get each piece independently with a new request since you can't return arrays of strings\nfunction getContentIdsByHashtag(bytes32 _hashtag, uint256 _amount) public view returns(uint256[] memory) {\n    uint256[] memory ids = new uint256[](_amount);\n    for(uint256 i = 0; i < _amount; i++) {\n        ids[i] = contentByHashtag[_hashtag][i].id;\n    }\n    return ids;\n}\n```", "```\n/// @notice Returns the data for a particular content id\n/// @param _id The id of the content\n/// @return Returns the id, author, date, content and hashtags for that piece of content\nfunction getContentById(uint256 _id) public view returns(uint256, address, uint256, string memory, bytes32[] memory) {\n    Content memory c = contentById[_id];\n    return (c.id, c.author, c.date, c.content, c.hashtags);\n}\n```", "```\n/// @notice Sorts the hashtags given their hashtag score\n/// @return bytes32[] Returns the sorted array of hashtags\nfunction sortHashtagsByScore() public view returns(bytes32[] memory) {\n    bytes32[] memory _hashtags = hashtags;\n    bytes32[] memory sortedHashtags = new bytes32[](hashtags.length);\n    uint256 lastId = 0;\n    for(uint256 i = 0; i < _hashtags.length; i++) {\n        for(uint j = i+1; j < _hashtags.length; j++) {\n            // If it's a buy order, sort from lowest to highest since we want the lowest prices first\n            if(hashtagScore[_hashtags[i]] < hashtagScore[_hashtags[j]]) {\n                bytes32 temporaryhashtag = _hashtags[i];\n                _hashtags[i] = _hashtags[j];\n                _hashtags[j] = temporaryhashtag;\n            }\n        }\n        sortedHashtags[lastId] = _hashtags[i];\n        lastId++;\n    }\n    return sortedHashtags;\n}\n```", "```\n/// @notice To check if the use is already subscribed to a hashtag\n/// @return bool If you are subscribed to that hashtag or not\nfunction checkExistingSubscription(bytes32 _hashtag) public view returns(bool) {\n    for(uint256 i = 0; i < subscribedHashtags[msg.sender].length; i++) {\n        if(subscribedHashtags[msg.sender][i] == _hashtag) return true;\n    }\n    return false;\n}\n```", "```\nimport Web3Js from 'web3'\n```", "```\nclass Main extends React.Component {\n    constructor() {\n        // Previous code omitted for simplicity\n\n        this.setup()\n    }\n\n async setup() {\n window.web3js = new Web3Js(ethereum)\n try {\n await ethereum.enable();\n } catch (error) {\n alert('You must approve this dApp to interact with it, reload it to approve it')\n }\n }\n}\n```", "```\ntruffle compile\n\ntruffle deploy --network ropsten --reset\n```", "```\n\"Unknown network \"ropsten\". See your Truffle configuration file for available networks.\"\n```", "```\nconst HDWalletProvider = require('truffle-hdwallet-provider')\nconst infuraKey = \"https://ropsten.infura.io/v3/8e12dd4433454738a522d9ea7ffcf2cc\"\n\nconst fs = require('fs')\nconst mnemonic = fs.readFileSync(\".secret\").toString().trim()\n\nmodule.exports = {\n  networks: {\n    ropsten: {\n      provider: () => new HDWalletProvider(mnemonic, infuraKey),\n      network_id: 3, // Ropsten's id\n      gas: 5500000, // Ropsten has a lower block limit than mainnet\n      confirmations: 2, // # of confs to wait between deployments. (default: 0)\n      timeoutBlocks: 200, // # of blocks before a deployment times out (minimum/default: 50)\n      skipDryRun: true // Skip dry run before migrations? (default: false for public nets )\n    }\n  }\n}\n```", "```\nconst SocialMedia = artifacts.require(\"./SocialMedia.sol\")\n\nmodule.exports = function(deployer) {\n  deployer.deploy(SocialMedia);\n}\n```", "```\nasync setup() {\n    window.web3js = new Web3Js(ethereum)\n    try {\n        await ethereum.enable();\n    } catch (error) {\n        alert('You must approve this dApp to interact with it, reload it to approve it')\n    }\n const user = (await web3js.eth.getAccounts())[0]\n const contract = new web3js.eth.Contract(ABI.abi, ABI.networks['3'].address, {\n from: user\n })\n await this.setState({contract, user})\n}\n```", "```\nasync setup() {\n    window.web3js = new Web3Js(ethereum)\n    try {\n        await ethereum.enable();\n    } catch (error) {\n        alert('You must approve this dApp to interact with it, reload it to approve it')\n    }\n    const user = (await web3js.eth.getAccounts())[0]\n    window.contract = new web3js.eth.Contract(ABI.abi, ABI.networks['3'].address, {\n        from: user\n    })\n await this.setState({contract, user})\n}\n```", "```\nrender() {\n    return (\n        <div className=\"main-container\">\n            <div className=\"hashtag-block\">\n                <h3>Top hashtags</h3>\n                <div className=\"hashtag-container\">{this.state.topHashtagBlock}</div>\n                <h3>Followed hashtags</h3>\n                <div className=\"hashtag-container\">{this.state.followedHashtagsBlock}</div>\n            </div>\n            <div className=\"content-block\">\n                <div className=\"input-container\">\n                    <textarea ref=\"content\" placeholder=\"Publish content...\"></textarea>\n                    <input ref=\"hashtags\" type=\"text\" placeholder=\"Hashtags separated by commas without the # sign...\"/>\n                    <button onClick={() => {\n                        this.publishContent(this.refs.content.value, this.refs.hashtags.value)\n                    }} type=\"button\">Publish</button>\n                </div>\n\n                <div className=\"content-container\">\n                    {this.state.contentsBlock}\n                </div>\n            </div>\n        </div>\n    )\n}\n```", "```\nasync getContent() {\n    const latestContentId = await this.state.contract.methods.latestContentId().call()\n    const amount = 10\n    const amountPerHashtag = 3\n    let contents = []\n    let counter = amount\n```", "```\n    // If we have subscriptions, get content for those subscriptions 3 pieces per hashtag\n    if(this.state.followedHashtags.length > 0) {\n        for(let i = 0; i < this.state.followedHashtags.length; i++) {\n            // Get 3 contents per hashtag\n            let contentIds = await this.state.contract.methods.getContentIdsByHashtag(this.bytes32(this.state.followedHashtags[i]), 3).call()\n            let counterTwo = amountPerHashtag\n            if(contentIds < amountPerHashtag) counterTwo = contentIds\n            for(let a = counterTwo - 1; a >= 0; a--) {\n                let content = await this.state.contract.methods.getContentById(i).call()\n                content = {\n                    id: content[0],\n                    author: content[1],\n                    time: new Date(parseInt(content[2] + '000')).toLocaleDateString(),\n                    message: content[3],\n                    hashtags: content[4],\n                }\n                content.message = web3js.utils.toUtf8(content.message)\n                content.hashtags = content.hashtags.map(hashtag => web3js.utils.toUtf8(hashtag))\n                contents.push(content)\n            }\n        }\n    }\n```", "```\n    // If we don't have enough content yet, show whats in there\n    if(latestContentId < amount) counter = latestContentId\n    for(let i = counter - 1; i >= 0; i--) {\n        let content = await this.state.contract.methods.getContentById(i).call()\n        content = {\n            id: content[0],\n            author: content[1],\n            time: new Date(parseInt(content[2] + '000')).toLocaleDateString(),\n            message: content[3],\n            hashtags: content[4],\n        }\n        content.message = web3js.utils.toUtf8(content.message)\n        content.hashtags = content.hashtags.map(hashtag => web3js.utils.toUtf8(hashtag))\n        contents.push(content)\n    }\n```", "```\n    let contentsBlock = await Promise.all(contents.map(async (element, index) => (\n        <div key={index} className=\"content\">\n            <div className=\"content-address\">{element.author}</div>\n            <div className=\"content-message\">{element.message}</div>\n            <div className=\"content-hashtags\">{element.hashtags.map((hashtag, i) => (\n                <span key={i}>\n                    <Hashtag\n                        hashtag={hashtag}\n                        contract={this.state.contract}\n                        subscribe={hashtag => this.subscribe(hashtag)}\n                        unsubscribe={hashtag => this.unsubscribe(hashtag)}\n                    />\n                </span>\n            ))}\n            </div>\n            <div className=\"content-time\">{element.time}</div>\n        </div>\n    )))\n\n    this.setState({contentsBlock})\n}\n```", "```\nclass Hashtag extends React.Component {\n constructor(props) {\n        super()\n        this.state = {\n            displaySubscribe: false,\n            displayUnsubscribe: false,\n            checkSubscription: false,\n            isSubscribed: false,\n        }\n }\n```", "```\n componentDidMount() {\n        this.checkExistingSubscription()\n }\n\n bytes32(name) {\n        let nameHex = web3js.utils.toHex(name)\n        for(let i = nameHex.length; i < 66; i++) {\n            nameHex = nameHex + '0'\n        }\n        return nameHex\n }\n\n async checkExistingSubscription() {\n        const isSubscribed = await this.props.contract.methods.checkExistingSubscription(this.bytes32(this.props.hashtag)).call()\n        this.setState({isSubscribed})\n    }\n```", "```\n render() {\n        return (\n            <span onMouseEnter={async () => {\n                if(this.state.checkSubscription) await this.checkExistingSubscription()\n                if(!this.state.isSubscribed) {\n                    this.setState({\n                        displaySubscribe: true,\n                        displayUnsubscribe: false,\n                    })\n                } else {\n                    this.setState({\n                        displaySubscribe: false,\n                        displayUnsubscribe: true,\n                    })\n                }\n            }} onMouseLeave={() => {\n                this.setState({\n                    displaySubscribe: false,\n                    displayUnsubscribe: false,\n                })\n            }}>\n```", "```\n                <a className=\"hashtag\" href=\"#\">#{this.props.hashtag}</a>\n                <span className=\"spacer\"></span>\n                <button onClick={() => {\n                    this.props.subscribe(this.props.hashtag)\n                    this.setState({checkSubscription: true})\n                }} className={this.state.displaySubscribe ? '' : 'hidden'} type=\"button\">Subscribe</button>\n                <button onClick={() => {\n                    this.props.unsubscribe(this.props.hashtag)\n                    this.setState({checkSubscription: true})\n                }} className={this.state.displayUnsubscribe ? '' : 'hidden'} type=\"button\">Unsubscribe</button>\n                <span className=\"spacer\"></span>\n            </span>\n )\n }\n}\n```", "```\nasync getHashtags() {\n    let topHashtagBlock\n    let followedHashtagsBlock\n    const amount = 10\n    const topHashtags = (await contract.methods.getTopHashtags(amount).call()).map(element => web3js.utils.toUtf8(element))\n    const followedHashtags = (await this.state.contract.methods.getFollowedHashtags().call()).map(element => web3js.utils.toUtf8(element))\n```", "```\n    if(topHashtags.length == 0) {\n        topHashtagBlock = 'There are no hashtags yet, come back later!'\n    } else {\n        topHashtagBlock = topHashtags.map((hashtag, index) => (\n            <div key={index}>\n                <Hashtag\n                    hashtag={hashtag}\n                    contract={this.state.contract}\n                    subscribe={hashtag => this.subscribe(hashtag)}\n                    unsubscribe={hashtag => this.unsubscribe(hashtag)}\n                />\n            </div>\n        ))\n    }\n```", "```\n    if(followedHashtags.length == 0) {\n        followedHashtagsBlock = \"You're not following any hashtags yet\"\n    } else {\n        followedHashtagsBlock = followedHashtags.map((hashtag, index) => (\n            <div key={index}>\n                <Hashtag\n                    hashtag={hashtag}\n                    contract={this.state.contract}\n                    subscribe={hashtag => this.subscribe(hashtag)}\n                    unsubscribe={hashtag => this.unsubscribe(hashtag)}\n                />\n            </div>\n        ))\n    }\n    this.setState({topHashtagBlock, followedHashtagsBlock, followedHashtags})\n}\n```", "```\nbytes32(name) {\n    let nameHex = web3js.utils.toHex(name)\n    for(let i = nameHex.length; i < 66; i++) \n    {\n        nameHex = nameHex + '0'\n    }\n    return nameHex\n}\n```", "```\nasync publishContent(message, hashtags) {\n    if(message.length == 0) alert('You must write a message')\n    hashtags = hashtags.trim().replace(/#*/g, '').replace(/,+/g, ',').split(',').map(element => this.bytes32(element.trim()))\n    message = this.bytes32(message)\n    try {\n        await this.state.contract.methods.addContent(message, hashtags).send({\n            from: this.state.user,\n            gas: 8e6\n        })\n    } catch (e) {console.log('Error', e)}\n    await this.getHashtags()\n    await this.getContent()\n}\n```", "```\nasync setup() {\n    window.web3js = new Web3Js(ethereum)\n    try {\n        await ethereum.enable();\n    } catch (error) {\n        alert('You must approve this dApp to interact with it, reload it to approve it')\n    }\n    const user = (await web3js.eth.getAccounts())[0]\n    window.contract = new web3js.eth.Contract(ABI.abi, ABI.networks['3'].address, {\n        from: user\n    })\n    await this.setState({contract, user})\n await this.getHashtags()\n await this.getContent()\n}\n```", "```\nasync subscribe(hashtag) {\n    try {\n        await this.state.contract.methods.subscribeToHashtag(this.bytes32(hashtag)).send({from: this.state.user})\n    } catch(e) { console.log(e) }\n    await this.getHashtags()\n    await this.getContent()\n}\n\nasync unsubscribe(hashtag) {\n    try {\n        await this.state.contract.methods.unsubscribeToHashtag(this.bytes32(hashtag)).send({from: this.state.user})\n    } catch(e) { console.log(e) }\n    await this.getHashtags()\n    await this.getContent()\n}\n```"]