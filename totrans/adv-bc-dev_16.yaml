- en: Scalability and Other Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to provide an introduction to various challenges that need
    to be addressed before blockchains can become a mainstream technology. Even though
    various use cases and proof of concept systems have been developed and the technology
    works well for many of the scenarios, there still is a need to address some fundamental
    limitations that are present in blockchains in order to make this technology more
    adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the list of these issues comes scalability and then privacy. Both
    of these are important limitations to address, especially as blockchains are envisioned
    to be used in privacy-demanding industries too. There are specific requirements
    around confidentiality of transactions in finance, law, and health, whereas scalability
    is generally a concern where blockchains do not meet the adequate performance
    levels expected by the users. These two issues are becoming inhibiting factors
    toward blockchain technology's wider acceptance.
  prefs: []
  type: TYPE_NORMAL
- en: A review of currently proposed and ongoing research in these two specific areas
    will be presented throughout this chapter. In addition to privacy and security,
    other challenges include regulation, integration, adaptability, and security in
    general. Although, in Bitcoin blockchain security is bulletproof and has stood
    the test of time, there still are some caveats that may allow security to be compromised
    to an extent in some subtle scenarios. Also, there are some reasonable security
    concerns in other blockchains, such as Ethereum, regarding smart contracts, denial
    of service attacks, and large attack surface. All of these will be discussed in
    detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This problem has been a focus of intense debate, rigorous research, and media
    attention for the last few years.
  prefs: []
  type: TYPE_NORMAL
- en: This is the single most important problem that could mean the difference between
    wider adaptability of blockchains or limited private use only by consortiums.
    As a result of substantial research in this area, many solutions have been proposed,
    which are discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a theoretical perspective, the general approach toward tackling the scalability
    issue generally revolves around protocol-level enhancements. For example, a commonly
    mentioned solution to Bitcoin scalability is to increase its block size. Other
    proposals include off-chain solutions that offload certain processing to off-chain
    networks, for example, off-chain state networks. Based on the aforementioned solutions,
    generally, the proposals can be divided into two categories: **on-chain solutions**
    that are based on the idea of changing fundamental protocols on which the blockchain
    operates, and **off-chain solutions** that make use of network and processing
    resources off-chain in order to enhance the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to addressing limitations in blockchains has been recently
    proposed by Miller and others in their position paper *On Scaling Decentralized
    Blockchains* available at [https://doi.org/10.1007/978-3-662-53357-4_8](https://doi.org/10.1007/978-3-662-53357-4_8).
    In this paper, it is shown that a blockchain can be divided into various abstract
    layers called **planes**. Each plane is responsible for performing specific functions.
    These include the network plane, consensus plane, storage plane, view plane, and
    side plane. This abstraction allows bottlenecks and limitations to be addressed
    at each plane individually and in a structured manner. A brief overview of each
    layer is given in the following subsections with some references to the Bitcoin
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Network plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the network plane is discussed. A key function of the network plane is
    transaction propagation. It has been identified in the aforementioned paper that
    in Bitcoin, this plane underutilizes the network bandwidth due to the way transaction
    validation is performed by a node before propagation and duplication of transaction
    propagation, first in the transaction broadcast phase, and then after mining in
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this issue was addressed by BIP 152 (*Compact Block
    Relay*, [https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)).
  prefs: []
  type: TYPE_NORMAL
- en: Consensus plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second layer is called the consensus plane. This layer is responsible for
    mining and achieving consensus. Bottlenecks in this layer revolve around limitations
    in PoW algorithms whereby increasing consensus speed and bandwidth results in
    compromising the security of the network due to an increase in the number of forks.
  prefs: []
  type: TYPE_NORMAL
- en: Storage plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The storage plane is the third layer, which stores the ledger. Issues in this
    layer revolve around the need for each node to keep a copy of the entire ledger,
    which leads to certain inefficiencies, such as increased bandwidth and storage
    requirements. Bitcoin has a method available called **pruning**, which allows
    a node to operate without the need to keep the full blockchain in its storage.
    Pruning means that when a Bitcoin node has downloaded the blockchain and validated
    it, it deletes the old data that it has already validated. This saves storage
    space. This functionality has resulted in major improvements from a storage point
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: View plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next on the list is the view plane, which proposes an optimization which is
    based on the proposal that bitcoin miners do not need the full blockchain to operate,
    and a view can be constructed out of the complete ledger as a representation of
    the entire state of the system, which is sufficient for miners to function. Implementation
    of views will eliminate the need for mining nodes to store the full blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the side plane has been proposed by the authors of the aforementioned
    research paper. This plane represents the idea of off-chain transactions whereby
    the concept of payment or transaction channels is used to offload the processing
    of transactions between participants but is still backed by the main Bitcoin blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned model can be used to describe limitations and improvements
    in current blockchain designs in a structured manner. Also, there are several
    general strategies that have been proposed over the last few years which can address
    the limitations in current blockchain designs such as Ethereum and Bitcoin. These
    approaches are also characterized and discussed individually in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Block size increase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most debated proposal for increasing blockchain performance (transaction
    processing throughput). Currently, Bitcoin can process only about three to seven
    transactions per second, which is a major inhibiting factor in adapting the Bitcoin
    blockchain for processing microtransactions. Block size in Bitcoin is hardcoded
    to be 1 MB, but if the block size is increased, it can hold more transactions
    and can result in faster confirmation time. There are several **Bitcoin Improvement
    Proposals** (**BIPs**) made in favor of block size increase. These include BIP
    100, BIP 101, BIP 102, BIP 103, and BIP 109.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent account of historic references and discussion is available at [https://en.bitcoin.it/wiki/Block_size_limit_controversy](https://en.bitcoin.it/wiki/Block_size_limit_controversy).
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, the block size is not limited by hardcoding; instead, it is controlled
    by a gas limit. In theory, there is no limit on the size of a block in Ethereum
    because it's dependent on the amount of gas, which can increase over time. This
    is possible because miners are allowed to increase the gas limit for subsequent
    blocks if the limit has been reached in the previous block. Bitcoin SegWit has
    addressed this issue by separating witness data from transaction data which resulted
    in more space for transactions. Other proposals for Bitcoin include Bitcoin Unlimited,
    Bitcoin XT and Bitcoin Cash. Readers can refer back to [Chapter 8](0534fad3-2928-4d0f-8d31-8aabd658dadb.xhtml),
    *Introducing Bitcoin*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.bitcoinunlimited.info](https://www.bitcoinunlimited.info)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bitcoinxt.software](https://bitcoinxt.software)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.bitcoincash.org](https://www.bitcoincash.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block interval reduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another proposal is to reduce the time between each block generation. The time
    between blocks can be decreased to achieve faster finalization of blocks but may
    result in less security due to the increased number of forks. Ethereum has achieved
    a block time of approximately 14 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: This is a significant improvement from the Bitcoin blockchain, which takes 10
    minutes to generate a new block. In Ethereum, the issue of high orphaned blocks
    resulting from smaller times between blocks is mitigated by using the **Greedy
    Heaviest Observed Subtree** (**GHOST**) protocol whereby orphaned blocks (uncles)
    are also included in determining the valid chain. Once Ethereum moves to **Proof
    of Stake** (**PoS**), this will become irrelevant as no mining will be required
    and almost immediate finality of transactions can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Invertible Bloom Lookup Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another approach that has been proposed to reduce the amount of data
    required to be transferred between the Bitcoin nodes. **Invertible Bloom Lookup
    Tables** (**IBLTs**) were originally proposed by Gavin Andresen, and the key attraction
    in this approach is that it does not result in a hard fork of Bitcoin if implemented.
    The key idea is based on the fact that there is no need to transfer all transactions
    between nodes; instead, only those that are not already available in the transaction
    pool of the syncing node are transferred. This allows quicker transaction pool
    synchronization between nodes, thus increasing the overall scalability and speed
    of the Bitcoin network.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharding is not a new technique and has been used in distributed databases for
    scalability such as MongoDB and MySQL. The key idea behind sharding is to split
    up the tasks into multiple chunks that are then processed by multiple nodes. This
    results in improved throughput and reduced storage requirements. In blockchains,
    a similar scheme is employed whereby the state of the network is partitioned into
    multiple shards. The state usually includes balances, code, nonce, and storage.
    Shards are loosely coupled partitions of a blockchain that run on the same network.
    There are a few challenges related to inter-shard communication and consensus
    on the history of each shard. This is an open area for research.
  prefs: []
  type: TYPE_NORMAL
- en: State channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another approach proposed for speeding up the transaction on a blockchain
    network. The basic idea is to use side channels for state updating and processing
    transactions off the main chain; once the state is finalized, it is written back
    to the main chain, thus offloading the time-consuming operations from the main
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'State channels work by performing the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a part of the blockchain state is locked under a smart contract, ensuring
    the agreement and business logic between participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now off-chain transaction processing and interaction is started between the
    participants that update the state only between themselves for now. In this step,
    almost any number of transactions can be performed without requiring the blockchain
    and this is what makes the process fast and a best candidate for solving blockchain
    scalability issues. However, it could be argued that this is not a real on-blockchain
    solution such as, for example, sharding, but the end result is a faster, lighter,
    and robust network which can prove very useful in micropayment networks, IoT networks,
    and many other applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the final state is achieved, the state channel is closed and the final
    state is written back to the main blockchain. At this stage, the locked part of
    the blockchain is also unlocked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28a27f20-0c80-40f2-9e26-e076a2f286b3.png)'
  prefs: []
  type: TYPE_IMG
- en: State channels
  prefs: []
  type: TYPE_NORMAL
- en: This technique has been used in the Bitcoin lightning network and Ethereum's
    Raiden.
  prefs: []
  type: TYPE_NORMAL
- en: Private blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private blockchains are inherently fast because no real decentralization is
    required and participants on the network do not need to mine; instead, they can
    only validate transactions. This can be considered as a workaround to the scalability
    issue in public blockchains; however, this is not the solution to the scalability
    problem. Also, it should be noted that private blockchains are only suitable in
    specific areas and setups such as enterprise environments where all participants
    are known.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using **Proof of Work** (**PoW**), PoS algorithm based blockchains
    are fundamentally faster. PoS was explained in greater detail in [Chapter 10](1e7e53b5-c84c-4dd2-8c0b-3ee9cd6acf24.xhtml),
    *Alternative Coins*.
  prefs: []
  type: TYPE_NORMAL
- en: Sidechains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sidechains can improve scalability indirectly by allowing many sidechains to
    run along with the main blockchain while allowing usage of perhaps comparatively
    less secure and faster sidechains to perform transactions but still pegged with
    the main blockchain. The core idea of sidechains is called a two-way peg, which
    allows transfer of coins from a parent chain to a sidechain and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Subchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a relatively new technique recently proposed by Peter R. Rizun which
    is based on the idea of weak blocks that are created in layers until a strong
    block is found. Weak blocks can be defined as those blocks that have not been
    able to be mined by meeting the standard network difficulty criteria but have
    done enough work to meet another weaker difficulty target. Miners can build subchains
    by layering weak blocks on top of each other unless a block is found that meets
    the standard difficulty target.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the subchain is closed and becomes the strong block. Advantages
    of this approach include reduced waiting time for the first verification of a
    transaction. This technique also results in a reduced chance of orphaning blocks
    and speeds up transaction processing. This is also an indirect way of addressing
    the scalability issue. Subchains do not require any soft fork or hard fork to
    implement but need acceptance by the community.
  prefs: []
  type: TYPE_NORMAL
- en: The subchains research paper is available at [https://www.ledgerjournal.org/ojs/index.php/ledger/article/view/40](https://www.ledgerjournal.org/ojs/index.php/ledger/article/view/40).
  prefs: []
  type: TYPE_NORMAL
- en: Tree chains (trees)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are also other proposals to increase Bitcoin scalability, such as tree
    chains that change the blockchain layout from a linearly sequential model to a
    tree. This tree is basically a binary tree which descends from the main Bitcoin
    chain. This approach is similar to sidechain implementation, eliminating the need
    for major protocol change or block size increase. It allows improved transaction
    throughput. In this scheme, the blockchains themselves are fragmented and distributed
    across the network in order to achieve scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, mining is not required to validate the blocks on the tree chains;
    instead, users can independently verify the block header. However, this idea is
    not ready for production yet and further research is required in order to make
    it practical.
  prefs: []
  type: TYPE_NORMAL
- en: The original idea was proposed in the research paper [https://eprint.iacr.org/2016/545.pdf](https://eprint.iacr.org/2016/545.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the aforementioned general techniques, some Bitcoin-specific
    improvements have also been proposed by Christian Decker ([https://scholar.google.ch/citations?user=ZaeGlZIAAAAJ&hl=en](https://scholar.google.ch/citations?user=ZaeGlZIAAAAJ&hl=en))
    in his book *On the Scalability and Security of Bitcoin*. This proposal is based
    on the idea of speeding up propagation time as the current information propagation
    mechanism results in blockchain forks. These techniques include minimization of
    verification, pipelining of block propagation, and connectivity increase. These
    changes do not require fundamental protocol-level changes; instead, these changes
    can be implemented independently in the Bitcoin node software.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to verification minimization, it has been noted that the block
    verification process is contributing toward propagation delay. The reason behind
    this is that a node takes a long time to verify the uniqueness of the block and
    transactions within the block. It has been suggested that a node can send the
    inventory message as soon as the initial PoW and block validation checks are completed.
    This way, propagation can be improved by just performing the first *difficulty
    check* and not waiting for transaction validation to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Block propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the preceding proposal, pipelining of block propagation has also
    been suggested, which is based on the idea of anticipating the availability of
    a block. In this scheme, the availability of a block is already announced without
    waiting for actual block availability, thus reducing the round-trip time between
    nodes. Finally, the problem of long distances between transaction originator and
    nodes also contributes toward the slowdown of block propagation. It has been shown
    in the research conducted by Christian Decker that connectivity increase can reduce
    propagation delay of blocks and transactions. This is possible because, if at
    any one time the Bitcoin node is connected to many other nodes, it will result
    in reducing the distance between nodes and can speed up information propagation
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: An elegant solution to scalability issues will most likely be a combination
    of some or all of the aforementioned general approaches. A number of initiatives
    taken in order to address scalability and security issues in blockchains are now
    almost ready for implementation or already implemented. For example, Bitcoin **Segregated
    Witness** (**SegWit**) is a proposal that can help massively with scalability
    and only needs a soft fork in order for it to be implemented. The key idea behind
    so-called *SegWit* is to separate signature data from the transactions, which
    resolves the transaction malleability issue and allows block size increase, thus
    resulting in increased throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin-NG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another proposal, Bitcoin-NG, which is based on the idea of microblocks and
    leader election, has gained some attention recently. The core idea is to split
    blocks into two types, namely leader blocks (also called key blocks) and microblocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leader blocks**: These are responsible for PoW whereas microblocks contain
    actual transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micro blocks**: These do not require any PoW and are generated by the elected
    leader every block-generation cycle. This block-generation cycle is initiated
    by a leader block. The only requirement is to sign the microblocks with the elected
    leader''s private key. The microblocks can be generated at a very high speed by
    the elected leader (miner), thus resulting in increased performance and transaction
    speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, an Ethereum mauve paper written by Vitalik Buterin has been
    presented at Ethereum Devcon2 in Shanghai; it describes the vision of a scalable
    Ethereum. The mauve proposal is based on a combination of sharding and implementation
    of PoS algorithm. Certain goals such as efficiency gain via PoS, maximally fast
    block time, economic finality, scalability, cross-shard communication, and censorship
    resistance have been identified in the paper.
  prefs: []
  type: TYPE_NORMAL
- en: Mauve paper is available at [https://docs.google.com/document/d/1maFT3cpHvwn29gLvtY4WcQiI6kRbN_nbCf3JlgR3m_8/edit#](https://docs.google.com/document/d/1maFT3cpHvwn29gLvtY4WcQiI6kRbN_nbCf3JlgR3m_8/edit#).
  prefs: []
  type: TYPE_NORMAL
- en: Plasma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another recent scalability proposal is **Plasma**, which has been proposed by
    Joseph Poon and Vitalik Buterin. This proposal describes the idea of running smart
    contracts on root blockchain (Ethereum MainNet) and have child blockchains that
    perform high number of transactions to feedback small amounts of commitments to
    the parent chain. In this scheme, blockchains are arranged in a tree hierarchy
    with mining performed only on the root (main) blockchain which feeds the proofs
    of security down to child chains. This is also called a Layer-2 system, like state
    channels also operate on Layer 2, and not on the main chain.
  prefs: []
  type: TYPE_NORMAL
- en: The research paper is available at [http://plasma.io](http://plasma.io).
  prefs: []
  type: TYPE_NORMAL
- en: Privacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Privacy of transactions is a much-desired property of blockchains. However,
    due to its very nature, especially in public blockchains, everything is transparent,
    thus inhibiting its usage in various industries where privacy is of paramount
    importance, such as finance, health, and many others. There are different proposals
    made to address the privacy issue and some progress has already been made. Several
    techniques, such as **Indistinguishability Obfuscation** (**IO**), usage of homomorphic
    encryption, ZKPs, and ring signatures.
  prefs: []
  type: TYPE_NORMAL
- en: All these techniques have their merits and demerits and are discussed in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Indistinguishability Obfuscation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This cryptographic technique may serve as a silver bullet to all privacy and
    confidentiality issues in blockchains but the technology is not yet ready for
    production deployments. IO allows for code obfuscation, which is a very ripe research
    topic in cryptography and, if applied to blockchains, can serve as an unbreakable
    obfuscation mechanism that will turn smart contracts into a black box.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea behind IO is what's called by researchers a *multilinear jigsaw
    puzzle*, which basically obfuscates program code by mixing it with random elements,
    and if the program is run as intended, it will produce expected output but any
    other way of executing would render the program look random and garbage. This
    idea was first proposed by Shai and others in their research paper *Candidate
    Indistinguishability Obfuscation and Functional Encryption for all circuits*.
  prefs: []
  type: TYPE_NORMAL
- en: This research paper is available at [https://doi.org/10.1109/FOCS.2013.13](https://doi.org/10.1109/FOCS.2013.13).
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of encryption allows operations to be performed on encrypted data.
    Imagine a scenario where the data is sent to a cloud server for processing. The
    server processes it and returns the output without knowing anything about the
    data that it has processed. This is also an area ripe for research and fully homomorphic
    encryption that allows all operations on encrypted data is still not fully deployable
    in production; however, major progress in this field has already been made. Once
    implemented on blockchains, it can allow processing on ciphertext which will allow
    privacy and confidentiality of transactions inherently. For example, the data
    stored on the blockchain can be encrypted using homomorphic encryption and computations
    can be performed on that data without the need for decryption, thus providing
    privacy service on blockchains. This concept has also been implemented in a project
    named *Enigma* which is available online at ([https://www.media.mit.edu/projects/enigma/overview/](https://www.media.mit.edu/projects/enigma/overview/))
    by MIT's Media Lab. Enigma is a peer-to-peer network which allows multiple parties
    to perform computations on encrypted data without revealing anything about the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Original research is available at [https://crypto.stanford.edu/craig/](https://crypto.stanford.edu/craig/).
  prefs: []
  type: TYPE_NORMAL
- en: Zero-Knowledge Proofs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ZKPs have recently been implemented in Zcash successfully, as seen in [Chapter
    10](1e7e53b5-c84c-4dd2-8c0b-3ee9cd6acf24.xhtml), *Alternative Coins*. More specifically,
    **SNARK** (short for **Succinct Non-Interactive Argument of Knowledge**) have
    been implemented in order to ensure privacy on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The same idea can be implemented in Ethereum and other blockchains also. Integrating
    Zcash on Ethereum is already a very active research project being run by the Ethereum
    R&D team and the Zcash Company.
  prefs: []
  type: TYPE_NORMAL
- en: The original research paper is available at [https://eprint.iacr.org/2013/879.pdf](https://eprint.iacr.org/2013/879.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Another excellent paper is here [http://chriseth.github.io/notes/articles/zksnarks/zksnarks.pdf](http://chriseth.github.io/notes/articles/zksnarks/zksnarks.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: There is a recent addition to the family of ZKPs called **Zero-Knowledge Succinct
    Transparent Argument of Knowledge** (**ZK-STARKs**) which is an improvement on
    ZK-SNARKs in the sense that ZK-STARKs consume a lot less bandwidth and storage
    as compared to ZK-SNARKs. Also, they do not require the initial, somewhat controversial,
    trusted setup that is required for ZK-SNARKs. Moreover, ZK-STARKs are much quicker
    than ZK-SNARKs as they do not make use of elliptic curves and rely on hashes.
  prefs: []
  type: TYPE_NORMAL
- en: The original research paper for ZK-STARKs is available here [https://eprint.iacr.org/2018/046.pdf](https://eprint.iacr.org/2018/046.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: State channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Privacy using state channels is also possible, simply due to the fact that all
    transactions are run off-chain and the main blockchain does not see the transaction
    at all except for the final state output, thus ensuring privacy and confidentiality.
  prefs: []
  type: TYPE_NORMAL
- en: Secure multiparty computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of secure multiparty computation is not new and is based on the
    notion that data is split into multiple partitions between participating parties
    under a secret sharing mechanism which then does the actual processing on the
    data without the need of the reconstructing data on a single machine. The output
    produced after processing is also shared between the parties.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of hardware to provide confidentiality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trusted computing platforms can be used to provide a mechanism by which confidentiality
    of transaction can be achieved on a blockchain, for example, by using Intel **Software
    Guard Extension** (**SGX**), which allows code to be run in a hardware-protected
    environment called an **enclave**. Once the code runs successfully in the isolated
    enclave, it can produce a proof called a **quote** that is attestable by Intel's
    cloud servers. However, it is a concern that trusting Intel will result in some
    level of centralization and is not in line with the true spirit of blockchain
    technology. Nevertheless, this solution has its merits and, in reality, many platforms
    already use Intel chips anyway, therefore trusting Intel may be acceptable by
    some in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: If this technology is applied on smart contracts then, once a node has executed
    the smart contract, it can produce the quote as a proof of correct and successful
    execution and other nodes will only have to verify it. This idea can be further
    extended by using any **Trusted Execution Environment** (**TEE**) which can provide
    the same functionality as an enclave and is available even on mobile devices with
    **Near Field Communication** (**NFC**) and a secure element.
  prefs: []
  type: TYPE_NORMAL
- en: CoinJoin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoinJoin is a technique which is used to anonymize the bitcoin transactions
    by mixing them interactively. The idea is based on forming a single transaction
    from multiple entities without causing any change in inputs and outputs. It removes
    the direct link between senders and receivers, which means that a single address
    can no longer be associated with transactions, which could lead to the identification
    of the users. CoinJoin needs cooperation between multiple parties that are willing
    to create a single transaction by mixing payments. Therefore, it should be noted
    that, if any single participant in the CoinJoin scheme does not keep up with the
    commitment made to cooperate for creating a single transaction by not signing
    the transactions as required, then it can result in a denial of service attack.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, there is no need for a single trusted third party. This concept
    is different from mixing a service which acts as a trusted third party or intermediary
    between the bitcoin users and allows shuffling of transactions. This shuffling
    of transactions results in the prevention of tracing and the linking of payments
    to a particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Confidential transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Confidential transactions make use of Pedersen commitments in order to provide
    confidentiality. Commitment schemes allow a user to commit to some value while
    keeping it secret with the capability of revealing it later. Two properties that
    need to be satisfied in order to design a commitment scheme are binding and hiding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binding** makes sure that the committer is unable to change the chosen value
    once committed, whereas the **hiding** property ensures that any adversary is
    unable to find the original value to which the committer made a commitment. Pedersen
    commitments also allow addition operations and preserve commutative property on
    the commitments, which makes it specifically useful for providing confidentiality
    in bitcoin transactions. In other words, it supports homomorphic encryption of
    values. Using commitment schemes allows the hiding of payment values in a bitcoin
    transaction. This concept is already implemented in the Elements Project ([h](https://elementsproject.org/)[t](https://elementsproject.org/)[t](https://elementsproject.org/)[p](https://elementsproject.org/)[s](https://elementsproject.org/)[://e](https://elementsproject.org/)[l](https://elementsproject.org/)[e](https://elementsproject.org/)[m](https://elementsproject.org/)[e](https://elementsproject.org/)[n](https://elementsproject.org/)[t](https://elementsproject.org/)[s](https://elementsproject.org/)[p](https://elementsproject.org/)[r](https://elementsproject.org/)[o](https://elementsproject.org/)[j](https://elementsproject.org/)[e](https://elementsproject.org/)[c](https://elementsproject.org/)[t](https://elementsproject.org/)[.](https://elementsproject.org/)[o](https://elementsproject.org/)[r](https://elementsproject.org/)[g](https://elementsproject.org/)[/](https://elementsproject.org/)).'
  prefs: []
  type: TYPE_NORMAL
- en: MimbleWimble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MimbleWimble scheme was proposed somewhat mysteriously on the Bitcoin IRC
    channel and since then has gained a lot of popularity. MimbleWimble extends the
    idea of confidential transactions and CoinJoin, which allows aggregation of transactions
    without requiring any interactivity. However, it does not support the use of Bitcoin
    scripting language along with various other features of standard Bitcoin protocol.
    This makes it incompatible with existing Bitcoin protocol. Therefore, it can either
    be implemented as a sidechain to Bitcoin or on its own as an alternative cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme can address privacy and scalability issues both at once. The blocks
    created using the MimbleWimble technique do not contain transactions as in traditional
    Bitcoin blockchains; instead, these blocks are composed of three lists: an input
    list, output list, and something called **excesses** which are lists of signatures
    and differences between outputs and inputs. The input list basically references
    to the old outputs, and the output list contains confidential transactions outputs.
    These blocks are verifiable by nodes by using signatures, inputs, and outputs
    to ensure the legitimacy of the block. In contrast to Bitcoin, MimbleWimble transaction
    outputs only contain pubkeys, and the difference between old and new outputs is
    signed by all participants involved in the transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though blockchains are generally secure and make use of asymmetric and
    symmetric cryptography as required throughout the blockchain network, there still
    are few caveats that can result in compromising the security of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few examples of transaction malleability, eclipse attacks, and the
    possibility of double spending in bitcoin that, in certain scenarios, have been
    shown to work by various researchers. Transaction malleability opens up the possibility
    of double withdrawal or deposit by allowing a hacker to change a transaction's
    unique ID before the Bitcoin network can confirm it, resulting in a scenario where
    it would seem that transactions did not occur. BIP 62 is one of the proposals
    along with SegWit that have suggested solutions to solve this issue. It should
    be noted that this is a problem only in the case of unconfirmed transactions,
    that is, scenarios where operational processes rely on unconfirmed transactions.
    In the case of normal applications that only rely on confirmed transactions, this
    is not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Information eclipse attacks in Bitcoin can result in double spending. The idea
    behind eclipse attacks is that the Bitcoin node is tricked into connecting only
    with the attacker node IPs. This opens up the possibility of a 51 % attack by
    the attacker. This has been addressed to some extent in Bitcoin client v0.10.1.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently, a lot of work has been started in smart contract security and, especially,
    formal verification of smart contracts is being discussed and researched. This
    was all triggered especially due to the infamous DAO hack.
  prefs: []
  type: TYPE_NORMAL
- en: Formal verification is a process of verifying a computer program to ensure that
    it satisfies certain formal statements. This is now a new concept and there are
    a number of tools available for other languages that achieve this; for example,
    Frama-C ([https://frama-c.com](https://frama-c.com)) is available for analyzing
    C programs. The key idea behind formal verification is to convert the source program
    into a set of statements that is understandable by the automated provers.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, Why3 ([http://why3.lri.fr](http://why3.lri.fr)) is commonly
    used, and a formal verifier for Solidity also makes use of that. An experimental
    but operational verifier is available in browser Solidity already.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract security is of paramount importance now, and many other initiatives
    have also been taken in order to devise methods that can analyze Solidity programs
    and find bugs. A recent and seminal example is Oyente, which is a tool built by
    researchers and has been introduced in their paper *Making Smart Contracts Smarter*.
  prefs: []
  type: TYPE_NORMAL
- en: Oyente is available at [https://github.com/melonproject/oyente](https://github.com/melonproject/oyente).
  prefs: []
  type: TYPE_NORMAL
- en: Several security bugs in smart contracts have been discovered and analyzed in
    this paper. These include transaction ordering dependence, timestamp dependence,
    mishandled exceptions such as call stack depth limit exploitation, and reentrance
    vulnerability. The transaction ordering dependency bug basically exploits the
    scenarios where the perceived state of a contract might not be what the state
    of the contract changes to after execution.
  prefs: []
  type: TYPE_NORMAL
- en: This weakness is a type of race condition. It is also called frontloading and
    is possible due to the fact that the order of transactions within a block can
    be manipulated. As all transactions first appear in the memory pool, the transactions
    there can be monitored before they are included in the block. This allows a transaction
    to be submitted before another transaction, thus leading to controlling the behavior
    of a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp dependency bugs are possible in scenarios where the timestamp of the
    block is used as a source of some decision-making within the contract, but timestamps
    can be manipulated by the miners. Call stack depth limit is another bug that can
    be exploited due to the fact that the maximum call stack depth of EVM is 1,024
    frames. If the stack depth is reached while the contract is executing then, in
    certain scenarios, the send or call instruction can fail, resulting in non-payment
    of funds. The call stack depth bug was addressed in the EIP 50 hard fork [https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md).
  prefs: []
  type: TYPE_NORMAL
- en: The reentrancy bug was exploited in the DAO attack to siphon out millions of
    dollars into a child DAO. The reentrancy bug basically means that a function can
    be called repeatedly before the previous (first) invocation of the functions has
    completed. This is particularly unsafe in Ether withdrawal functions in Solidity
    smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the aforementioned bugs, there are several other problems that
    should be kept in mind while writing contracts. These bugs include that fact that
    if sending funds to another contract, handle it carefully because send can fail
    and even if throw is used as a *catch-all* mechanism, it will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Other standard software bugs such as integer overflow and underflow are also
    quite significant and any use of integer variables should be carefully implemented
    in Solidity. For example, a simple program where uint8 is used to parse through
    elements of an array with more than 255 elements can result in an endless loop.
    This occurs because uint8 is limited to 256 numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, two examples of contract verification will be shown
    using Remix IDE, Why3 and Oyente respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Formal verification and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security analysis of Solidity code is now available as a feature in the solidity
    online IDE called Remix. The code is analyzed for vulnerabilities and reported
    in the Analysis tab of the remix IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cb8ca56-c325-4fa3-8a45-9e0c27601189.png)'
  prefs: []
  type: TYPE_IMG
- en: Remix IDE analysis options
  prefs: []
  type: TYPE_NORMAL
- en: A sample output of the same contract with reentrancy bug is shown in the bottom
    of the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: This tool analyzes several categories of vulnerabilities including, security,
    gas, and economy. As shown in the preceding screenshot the analysis tool has successfully
    detected the reentrancy bug, details of which are shown at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Why3 can also be used for formally analyzing Solidity code.
  prefs: []
  type: TYPE_NORMAL
- en: Why3 is available at [http://why3.lri.fr/try/](http://why3.lri.fr/try/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a simple Solidity code that defines the `z` variable
    as the maximum limit of `uint` is shown. When this code runs, it will result in
    returning `0`, because `uint z` will overrun and start again from `0`. This can
    also be verified using Why3, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b624d92-c7b5-45b4-9382-07a6a72290e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Solidity online compiler with formal verification
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from Solidity to Why3 compliant code used to be available in Solidity
    online compiler but it is no longer available. Therefore, the following example
    is only for completeness purposes and to shed light on an important class of bugs
    which can go undetected with traditional tools. In this example, integer overflow
    is shown as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows that Why3 successfully checks and reports integer
    overflow errors. This tool is under heavy development but is still quite useful.
    Also, this tool or any other similar tool is not a silver bullet. Even formal
    verification generally should not be considered a panacea because specifications
    in the first place should be defined appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277c5f14-affe-4886-b674-b5cf66b9a6a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Why3
  prefs: []
  type: TYPE_NORMAL
- en: Oyente tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, Oyente is available as a Docker image for easy testing and installation.
    It is available at [https://github.com/melonproject/oyente](https://github.com/melonproject/oyente)
    and can be downloaded and tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a simple contract taken from Solidity documentation
    that contains a reentrancy bug has been tested and it is shown that Oyente successfully
    analyzes the code and finds the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e670b04a-17e6-48ef-9589-2ad28c0326ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Contract with reentrancy bug, source: solidity documentation'
  prefs: []
  type: TYPE_NORMAL
- en: This sample code contains a reentrancy bug which basically means that if a contract
    is interacting with another contract or transferring Ether, it is effectively
    handing over the control to that other contract. This allows the called contract
    to call back into the function of the contract from which it has been called without
    waiting for completion. For example, this bug can allow calling back into the
    withdraw function shown in the preceding example again and again, resulting in
    getting Ethers multiple times. This is possible because the share value is not
    set to `0` until the end of the function, which means that any later invocations
    will be successful, resulting in withdrawing again and again.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown of Oyente running to analyze the contract shown here and
    as can be seen in the following output, the analysis has successfully found the
    reentrancy bug. The bug is proposed to be handled by a combination of the Checks-Effects-Interactions
    pattern described in the solidity documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02eedb31-5853-4824-810f-d8bd11aeeff8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oyente tool detecting solidity bugs
  prefs: []
  type: TYPE_NORMAL
- en: Oyente is also available in analysis tools for smart contacts at [https://oyente.melon.fund](https://oyente.melon.fund/).
    A sample output is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: With this example, we conclude our introduction to security and analysis tools
    for solidity. This is a very rich area of research and more and more tools are
    expected to be available with time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87d28e52-66c2-4dbe-ad3e-9a17bfe77592.png)'
  prefs: []
  type: TYPE_IMG
- en: Oyente analysis
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, readers have been introduced to the security, confidentiality,
    and privacy aspects of blockchain technology. Privacy was discussed, which is
    another major inhibiting factor in adapting public blockchains for various industries.
    Next, smart contract security, which is a very hot topic currently, was discussed.
    It is a deep and extensive subject but a brief introduction on various aspects
    has been given, which should serve as a solid ground for further research in this
    area.
  prefs: []
  type: TYPE_NORMAL
- en: For example, formal verification on its own is a vast area for research. Furthermore,
    examples of formal verification have also been provided to give readers an idea
    of what tools are available. It should be noted that the tools mentioned earlier
    are under heavy development and lack various desirable features. Also, documentation
    is quite scarce; therefore, readers are encouraged to keep an eye on developments,
    especially around formal verification and developments related to the Ethereum
    mauve paper, as it is going to develop rapidly very soon. The field of blockchain
    security and especially smart contract security is so ripe now that a whole book
    can be written on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: There are many experts and researchers in academia and the commercial sector
    exploring this area and soon there will be many automated tools available for
    the verification of smart contracts. There is an online tool available already
    at [https://securify.ch](https://securify.ch) which analyses smart contract code
    to find security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
