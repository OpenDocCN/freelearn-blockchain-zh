- en: Mastering Smart Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通智能合约
- en: 'In this chapter, you''ll be taken on a journey across several interesting frameworks
    to design secure, scalable, and fast smart contracts that are gas-optimized so
    that people don''t pay too much Ether per transaction. We are going to create
    a **copyright marketplace smart contract** that stores licenses that people create
    for their content that''s identified by a unique ID, all on the blockchain. Then,
    you''ll explore the EVM in depth in order to understand how it actually works
    in the backend when you deploy and interact with a smart contract. Next, we''ll
    talk about upgradable and scalable smart contracts for the next generation. And,
    finally, we''ll cover gas- and data-efficient smart contracts and security analysis
    with audits. In this chapter, we''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将被带上一段旅程，穿越几个有趣的框架，以设计安全、可扩展和快速的智能合约，这些智能合约被优化以减少Gas，从而使人们不必为每笔交易支付太多以太币。我们将创建一个**版权市场智能合约**，该合约存储人们为其内容创建的许可证，这些内容由唯一的ID标识，并且全部存储在区块链上。然后，您将深入探讨EVM，以了解在部署和与智能合约交互时，它在后台实际运行的方式。接下来，我们将讨论下一代可升级和可扩展的智能合约。最后，我们将涵盖Gas和数据高效的智能合约以及安全分析。在本章中，我们将涵盖以下主题：
- en: Getting up to speed
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应速度
- en: The EVM in depth
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解EVM
- en: Upgradable and scalable smart contracts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可升级和可扩展的智能合约
- en: Gas- and data-efficient smart contracts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gas和数据高效的智能合约
- en: Smart contract security analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约安全分析
- en: Getting up to speed
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应速度
- en: If you want to become an expert when it comes to smart contracts, you have to
    start with a simple project to refresh your skills. We're going to create a copyright
    marketplace smart contract to upload legal documents to the blockchain that guarantee
    that some piece of content is protected by copyright law and cannot be copied.
    Without further ado, let's get right to it!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要成为智能合约方面的专家，你必须从一个简单的项目开始，以更新你的技能。我们将创建一个版权市场智能合约，将合法文件上传到区块链，以确保某些内容受版权法保护，不能被复制。言归正传，让我们开始吧！
- en: Planning the marketplace idea
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划市场构想
- en: 'Here is the way copyright law works in simple terms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是版权法的简单工作方式：
- en: You register a piece of content that could be a document, text, an image, a
    video, or any kind of creation that you did by yourself with a unique identifier,
    publicly so that people can confirm your authority.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你要注册一篇内容，可能是文件、文本、图片、视频或者你自己制作的任何一种创作，通过一个唯一的标识符公开注册，这样其他人可以确认你的权威性。
- en: The people that want to use your content for whatever reasons have to consult
    your copyright terms and obey them to avoid legal problems, because we don't want
    people stealing your work for their own benefit.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论出于什么原因，想要使用你的内容的人都必须咨询您的版权条款并遵守它们，以避免法律问题，因为我们不希望人们为了自己的利益而窃取你的作品。
- en: A copyrighted register shouldn't be modified, so we'll avoid creating functions
    that allow people to modify their copyrighted data; so, we'll only allow them
    to add or remove copyrights.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 版权注册不应该被修改，所以我们会避免创建允许人们修改其版权数据的功能；因此，我们只允许他们添加或删除版权。
- en: 'We need a smart contract that lives on the blockchain that people can access
    easily. This contract will have the following functions to manage copyright registers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个生存在区块链上的智能合约，人们可以轻松访问。该合约将具有以下功能来管理版权注册：
- en: A function to add new copyrighted content with a unique identifier that you
    create by hashing the content. In this case, we want to limit the copyrighted
    content to just text, since it's expensive to upload other types of content on
    the blockchain. This function will receive the address of the owner of the content,
    their name, their email address, the hashed ID of the content, a URL containing
    the article or document to register, and the terms of use that others must obey
    when using this particular piece of content.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个根据哈希值创建新的带有唯一标识符的版权内容的函数。在这种情况下，我们只想限制版权内容为文本，因为在区块链上上传其他类型的内容是昂贵的。该函数将接收内容所有者的地址、姓名、电子邮件地址、内容的哈希ID、包含要注册的文章或文档的URL，以及他人在使用该特定内容时必须遵守的使用条款。
- en: A function to get content based on a hash.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个根据哈希值获取内容的函数。
- en: A function to delete copyrighted content if you're the owner.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于删除版权内容的函数，如果你是所有者。
- en: A function to extract the funds locked in this smart contract. It often happens
    that people send Ether to the wrong address, which ends up in a smart contract
    like this. We want to be able to extract the funds locked away so that they are
    not lost forever if this happens. It can also be used as a donation address for
    showing the appreciation for the work done.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the code in Solidity
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we''ll use Truffle to deploy and run our smart contract. When
    dealing with larger projects, it''s always worth the initial effort that''s invested
    in setting up a framework such as Truffle with all the required dependencies,
    because it saves us a lot of time in the long run while improving the development
    experience. Here are the steps for setting up our project with Truffle, since
    it''s the first time we''re mentioning it in this book. Later on, we''ll assume
    that you know how to set up a project in Truffle, although we''ll remind you plenty
    of times when needed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Let's start right away by creating a new folder called `copyright`**:**
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b264df7-8c04-4f50-8378-97f3c330f5a6.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Inside that folder, run the `truffle init` command. If you don''t have Truffle,
    install it with `npm i -g truffle` or `sudo npm i -g truffle`. You can get `npm`
    by installing Node.js from their website, [nodejs.org](http://nodejs.org). The
    following screenshot shows what the process is:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07b94f8a-e1b3-4e38-9bf2-244e43d7e322.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can open the project with your preferred code editor, in my case,
    Atom:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/205bf315-6fbd-45e7-ab53-b670587b762f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file inside `contracts` with the name `Copyright.sol`. Create
    the basic code structure of every Solidity smart contract:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The order of every smart contract is simple. First, we define the events, the
    variables, the modifiers, the fallback function, the constructor, and, finally,
    the functions. So, let''s define our events:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This event logs the `counter`, `hashId`, `contentUrl`, the address of the owner,
    the timestamp, email, and terms of use for that content. We can now define the
    `struct` that contains those variables. Our goal is to store information in a
    way that is as accessible as possible, so a struct is the best way to organize
    copyrighted content with mapping:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The mapping will associate each hash to the content object that stores all
    the relevant information about the copyrighted content. Here''s the reason behind
    each of those members inside the struct:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`counter`: We need a simple way to keep track of how many copyrighted elements
    are added to the blockchain, because it provides us with a simple way to look
    up the latest content using the registry of events.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashId`: The `keccak256` string of the text content that we''ll associate
    with this object. Because we can''t use strings as the key of the mapping, we
    have to use a `bytes32` type of variable. This causes the problem that we can''t
    store the entire `keccack256` string because it''s 64 characters long, and `bytes32`
    variables are limited to 32 hexadecimal characters. What we''re going to do to
    overcome this limitation is to cut the resulting hash in half to only store the
    first half, which is exactly 32 bytes. This significantly reduces the hash security,
    but it''s good enough given that we won''t generate astronomically high copyrighted
    elements.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashId`：我们将与此对象关联的文本内容的`keccak256`字符串。因为我们不能将字符串用作映射的键，所以我们必须使用`bytes32`类型的变量。这导致了我们无法存储整个`keccack256`字符串的问题，因为它有64个字符长，而`bytes32`变量限制为32个十六进制字符。为了克服这个限制，我们将做的是将结果哈希值截断一半，仅存储前半部分，即正好32个字节。这显着降低了哈希安全性，但考虑到我们不会生成天文数字般的高版权元素，这已经足够了。'
- en: '`contentUrl`: A web URL that contains the original document to be copyrighted.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentUrl`：包含原始文档的 Web URL，用于版权登记。'
- en: '`owner`: The content owner''s address, which is essential to guarantee the
    person''s property.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`：内容所有者的地址，这对确保个人财产至关重要。'
- en: '`timestamp`: A fixed timestamp for when the content was copyrighted. Great
    to set up expiry dates to invalidate outdated elements.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`：内容版权的固定时间戳。非常适合设置到期日期以使过时元素失效。'
- en: '`email`: A valid email to provide users with a simple system to contact the
    owner of that particular content.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：有效的电子邮件，提供给用户一个简单的联系方式，以联系特定内容的所有者。'
- en: '`termsOfUse`: A short piece of text explaining how the content must be treated:
    what you can do with it as an external individual, when you can use it, and so
    on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`termsOfUse`：简短的文本，解释了如何处理内容：外部个人可以做什么，何时可以使用等等。'
- en: 'You can add your own elements to the `struct` if you wish to create a different
    type of copyright registry marketplace. It''s about personal preference. Finally,
    I''ve added an `owner` variable that we''ll use later for extracting funds that
    could end up locked in this contract. Now, we can continue with the functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望创建不同类型的版权注册市场，可以向`struct`中添加自己的元素。这取决于个人偏好。最后，我添加了一个`owner`变量，我们稍后将用于提取可能被锁定在合同中的资金。现在，我们可以继续进行功能：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `constructor` variable will be used for setting up the owner address. The
    `addContent` function takes four parameters instead of the seven required for
    the struct since we can generate the others dynamically. This is important to
    simplify things and help people upload their copyright easier. First, it checks
    that the most important parameters are set because we need them no matter what.
    This means that the terms of use are optional for the simple reason that people
    can choose to not restrict the use of their content, meaning open content with
    their ownership.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor`变量将用于设置所有者地址。`addContent`函数需要四个参数，而不是结构所需的七个，因为我们可以动态生成其他参数。这对于简化事务并帮助人们更轻松地上传其版权非常重要。首先，它检查是否设置了最重要的参数，因为无论如何我们都需要它们。这意味着使用条款是可选的，简单地因为人们可以选择不限制其内容的使用，这意味着使用其所有权的开放内容。'
- en: We generate the `newContent` object, we increase the counter, and add that content
    to the mapping of `copyrightsById` to finally emit the registration event. This
    is the most important function and it has to be as optimized as soon as possible
    to avoid reaching gas limits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成`newContent`对象，增加计数器，并将该内容添加到`copyrightsById`映射中，最后发出注册事件。这是最重要的功能，必须尽快进行优化，以避免达到气体限制。
- en: Note that we don't need a function to get the content by hash because the `copyrightsById`
    mapping is `public`, therefore it has a getter function automatically created
    for retrieving each struct element.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要一个根据哈希获取内容的函数，因为`copyrightsById`映射是`public`的，因此它会自动为检索每个结构元素创建一个getter函数。
- en: 'Let''s continue with the function to delete copyrights and to extract funds:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续完成删除版权和提取资金的功能：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `deleteCopyrightedByHash` function takes the half `keccak256` hash of existing
    copyrights and deletes them if you're the owner of that particular content. The
    `extractFunds` function is an optional function that I like to add, because I
    usually see smart contracts with Ether inside that they got by mistake because
    someone didn't realize that they were sending real money to the contract address,
    so it's stuck in there forever. This function makes the extraction of funds possible
    so that you can retrieve the money if that ends up happening.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteCopyrightedByHash`函数获取现有版权的一半`keccak256`哈希，并在您是特定内容的所有者时将其删除。`extractFunds`函数是一个可选函数，我喜欢添加这个函数，因为我通常看到智能合约中包含了以太币，这是由于某人不小心将真钱发送到合约地址，所以它一直停留在那里。此函数使提取资金成为可能，以便如果发生这种情况，您可以检索资金。'
- en: That's the entire contract! You can compile it with Truffle using `truffle compile`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个合同！您可以使用`truffle compile`来编译它。
- en: 'You can check the updated code on my GitHub: [https://github.com/merlox/copyright-marketplace](https://github.com/merlox/copyright-marketplace).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我的GitHub上查看更新后的代码：[https://github.com/merlox/copyright-marketplace](https://github.com/merlox/copyright-marketplace).
- en: Deploying your smart contract with Truffle
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Truffle部署您的智能合约
- en: 'Deploying smart contracts with Truffle is not a straightforward process: you
    must go through a few different files to modify the expected behavior of Truffle.
    You see, Truffle needs to know where to deploy your contracts, the constructor
    parameters, and the deployment order, among other things; therefore it''s necessary
    that you configure all the moving parts to be able to deploy your contract continuously.
    Once set up, you''ll be able to re-deploy new versions with just a command since
    Truffle will know exactly what you need to get done, how, and where.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Truffle部署智能合约并不是一个直截了当的过程：您必须通过几个不同的文件来修改Truffle的预期行为。您会发现，Truffle需要知道在哪里部署您的合约、构造函数参数和部署顺序，以及其他事项；因此，有必要配置所有运动部分以连续部署您的合约。设置完成后，只需一条命令，您就可以重新部署新版本，因为Truffle将确切知道您需要完成什么任务，如何完成，以及在哪里完成。
- en: 'We will deploy our contract using the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤部署我们的合约：
- en: First, you must compile your contract with `truffle compile` since you can only
    deploy compiled code to the blockchain. Open the `truffle-config.js` file from
    your project folder. That's the file where the deployment configuration is set
    up.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须使用`truffle compile`编译您的合约，因为您只能将编译代码部署到区块链上。打开项目文件夹中的`truffle-config.js`文件。这是设置部署配置的文件。
- en: 'If you read the comments, you''ll see that Truffle uses INFURA for a quick
    and effective connection to the blockchain and that you need to uncomment lines
    1 to 5 to update your information. For instance, the commented code shown here
    must be uncommented:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您阅读评论，您会发现Truffle使用INFURA进行快速有效地连接到区块链，您需要取消注释1到5行以更新您的信息。例如，此处显示的注释代码必须取消注释：
- en: '![](img/0681d055-8f14-478d-b864-a2229d3e467f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0681d055-8f14-478d-b864-a2229d3e467f.png)'
- en: 'Doing this will mean that it will look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将意味着看起来像下面这样：
- en: '![](img/b93cff75-88d8-4287-bded-46cef3374582.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b93cff75-88d8-4287-bded-46cef3374582.png)'
- en: This essentially uncomments your INFURA and mnemonic variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这实质上是取消注释了您的INFURA和助记词变量。
- en: 'Get your INFURA key by registering on [https://infura.io](https://infura.io)
    to get unlimited access to high quality servers with blockchains installed after
    creating a project:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册[https://infura.io](https://infura.io)获取您的INFURA密钥，以便在创建项目后，可以无限制访问安装了区块链的高质量服务器：
- en: '![](img/97bb0e91-5b1c-4522-90b2-328f9d30d069.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97bb0e91-5b1c-4522-90b2-328f9d30d069.png)'
- en: 'The ENDPOINT is where your INFURA key is. Simply click on the Copy icon next
    to it so that you have something similar to this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ENDPOINT是您的INFURA密钥所在的地方。只需单击旁边的复制图标，这样您就会得到类似以下内容：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Strip the copied string down to just the part after the website name, since
    that''s what Truffle uses when configuring the deployment network key:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消复制字符串，只保留网站名称后的部分，因为这是Truffle在配置部署网络密钥时使用的内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, paste that into your `infuraKey` variable inside `truffle-config.js` so
    that you''re able to deploy your smart contract on `ropsten`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将其粘贴到`truffle-config.js`中的`infuraKey`变量中，以便您能够在`ropsten`上部署您的智能合约：
- en: '![](img/a36dfa0b-d07d-49a1-9258-539db776cd3f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a36dfa0b-d07d-49a1-9258-539db776cd3f.png)'
- en: 'What you need now is to give Truffle your mnemonic phrase, so that it''s able
    to deploy the smart contract on `ropsten` with your address. To do so, create
    a file called `.secret` at the topmost level of your project containing the mnemonic.
    Here is an example:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您需要给 Truffle 提供您的助记词短语，以便它能够使用您的地址在`ropsten`上部署智能合约。为此，请在项目的最顶层创建一个名为`.secret`的文件，其中包含助记词。以下是一个示例：
- en: '![](img/d3c6bd5a-4e35-4469-abe1-f721d682756f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3c6bd5a-4e35-4469-abe1-f721d682756f.png)'
- en: 'Inside `.secret`, write down your mnemonic without any additional information:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.secret`中，仅写下您的助记词，不要添加任何其他信息：
- en: '![](img/6f6bbe48-9ad9-417a-9c8f-f149ba2df23d.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f6bbe48-9ad9-417a-9c8f-f149ba2df23d.png)'
- en: 'Then, go back to your `truffle-config.js` file and uncomment the section about
    `ropsten`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，返回到您的`truffle-config.js`文件，并取消对`ropsten`部分的注释：
- en: '![](img/10b326fd-3184-4bed-930d-3b4eabd946dd.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10b326fd-3184-4bed-930d-3b4eabd946dd.png)'
- en: 'Then, install `truffle-hdwallet-provider` with the following command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装`truffle-hdwallet-provider`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Be sure to be in your project folder when installing it, since it will install
    in the current location. Finally, execute the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装它时，请确保您在项目文件夹中，因为它将在当前位置安装。最后，执行以下操作：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Your contract will be deployed in a few minutes, depending on the network.
    You can then play and test the smart contract. Make sure to hash the copyrighted
    content with `keccak256` by using this tool: [https://emn178.github.io/online-tools/keccak_256.html](https://emn178.github.io/online-tools/keccak_256.html).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您的合约将在几分钟内部署完成，具体时间取决于网络情况。然后，您可以玩耍并测试智能合约。确保使用此工具对受版权保护的内容进行`keccak256`哈希处理：[https://emn178.github.io/online-tools/keccak_256.html](https://emn178.github.io/online-tools/keccak_256.html)。
- en: 'After getting `keccak256`, cut it in half and generate the hexadecimal code.
    If you have MetaMask, you can do that from your browser, since you''ll have web3.js
    available on all websites. These are the steps to convert a specific string of
    text into the hexadecimal version within your browser:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 获得`keccak256`后，将其切成一半并生成十六进制代码。如果您有 MetaMask，则可以在浏览器中执行此操作，因为您将在所有网站上都可以使用 web3.js。以下是将特定文本字符串转换为其十六进制版本的步骤：
- en: Open the developer tools on your browser.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器上打开开发者工具。
- en: Go to the Console tab where you can execute JavaScript code.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您可以执行 JavaScript 代码的 Console 标签。
- en: Type `web3` to see if web3 is available.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`web3`以查看 web3 是否可用。
- en: 'If so, take your half `keccak256` resulting code and generate the hexadecimal
    version with `web3.toHex(''your-hash'')`, as shown in the following example:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，请取一半的`keccak256`结果代码，并使用`web3.toHex('your-hash')`生成十六进制版本，如下例所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can then use that hexadecimal string to add a new copyright element to your
    smart contract as `hashId`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用该十六进制字符串将新的版权元素添加到智能合约中，作为`hashId`。
- en: The EVM in depth
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 EVM
- en: The **Ethereum Virtual Machine (EVM)** is one of the least understood parts
    of the entire Ethereum ecosystem. It could be because the complexity that this
    virtual machine contains is confusing even to the best developers. In any case,
    your goal as an Ethereum expert is to become great at all things related to Ethereum
    development, so it's a must that you understand the intricacies of this powerful
    virtual machine so that you can extract its full potential at all times.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊虚拟机（EVM）**是整个以太坊生态系统中最不被理解的部分之一。这可能是因为即使对于最优秀的开发者来说，这个虚拟机包含的复杂性也令人困惑。无论如何，作为以太坊专家，您的目标是成为与以太坊开发相关的所有事物的专家，因此您必须理解这台强大的虚拟机的复杂性，以便随时发挥其全部潜力。'
- en: Explaining the EVM
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 EVM
- en: 'The EVM is a virtual machine where smart contracts and transactions get executed.
    Think of VirtualBox or VMware with the Ethereum operating system. They are emulations
    of a physical computer, in order to create a clean environment where applications
    can communicate with the CPU. This type of virtual machine processes transactions,
    blocks, and smart contracts uniformly for all users. It keeps hundreds of computers
    connected, so it''s very important to have enough security to protect each node
    from potential attacks. Some of the security systems that are implemented are
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: EVM是一个虚拟机，用于执行智能合约和交易。将以太坊操作系统与VirtualBox或VMware类比。它们是物理计算机的仿真，以创建一个应用程序可以与CPU通信的清洁环境。这种虚拟机为所有用户统一处理交易、区块和智能合约。它保持数百台计算机连接，因此有足够的安全性来保护每个节点免受潜在攻击是非常重要的。一些已实施的安全系统如下：
- en: '**Gas**: Every transaction must be paid before being executed to avoid abusive
    behaviors where some nodes send unlimited transactions without any intention of
    paying them.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gas**：每笔交易在执行之前必须付费，以避免某些节点发送无限交易而没有意图支付它们的滥用行为。'
- en: '**Peer-to-peer communication**: Nodes can only communicate via messages by
    sending and receiving data, which means that they can''t access each other''s
    data.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点通信**：节点只能通过发送和接收数据的消息进行通信，这意味着它们无法访问彼此的数据。'
- en: '**Deterministic**: This means that the initial state will always produce the
    same results. For instance, adding two numbers will result in the same exact result
    if they are the same. This is important to make consensus possible because it
    allows others to verify that the transactions are indeed valid; otherwise, it
    would be impossible to verify transactions and consensus would be limited given
    that the same state results in different calculations.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**：这意味着初始状态总是会产生相同的结果。例如，如果两个数字相加结果相同，那么无论它们是什么，都会得到完全相同的结果。这对于实现共识是很重要的，因为它允许他人验证交易确实有效；否则，要验证交易并取得共识将是不可能的，因为相同的状态导致不同的计算。'
- en: '**Sandboxed execution**: Since this is a virtual machine, smart contracts using
    it can''t have access to the outside computer making all the transactions possible.
    Only smart contracts can interact with each other with a limited scope.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒执行**：由于这是一个虚拟机，使用它的智能合同不能访问外部计算机，使所有交易都成为可能。只有智能合同才能以有限的范围相互交互。'
- en: To fully understand how the EVM works, we have to go deeper into the assembly
    language that keeps this system together. Ideally, we could understand bytecode
    language, which is what computers process, but because we can't, we've created
    an abstraction for each process in a language called **assembly** that can be
    easily translated to bytecode for processors to compute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解EVM的工作原理，我们必须深入研究保持系统一体的汇编语言。理想情况下，我们可以理解字节码语言，这是计算机处理的内容，但由于我们无法理解，我们已经为每个过程创建了一种称为**汇编语言**的语言，它可以轻松转换为处理器计算的字节码。
- en: Operation of smart contracts in the EVM
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EVM中智能合同的操作
- en: Smart contracts are fascinating because they are able to keep many nodes connected
    in a single system that understands how they should make decisions and agree on
    the results. They work on top of a stack-based virtual machine that you could
    think of as an array that keeps track of the variables stored in memory. It provides
    you with a set of small functions to manipulate that stack. To understand how
    smart contracts operate in the EVM, we'll have to follow them to see how they
    are being transformed by the virtual machine until they become executable bytecode.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合同非常吸引人，因为它们能够在一个能够理解它们应该如何做出决策并就结果达成一致的单一系统中保持许多节点连接。它们在一个基于堆栈的虚拟机上运行，您可以将其视为一个数组，用于跟踪存储在内存中的变量。它为您提供了一组小函数来操作该堆栈。要了解智能合同在EVM中的操作方式，我们必须跟踪它们，以了解它们如何被虚拟机转换为可执行的字节码。
- en: 'For instance, take a simple contract such as this one:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的合同，比如这个：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'How does a compiler such as `solc` convert that code into something that the
    EVM can understand so that the computer can process it? Let''s try to analyze
    it with that specific compiler. Install `solc` by executing the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器（比如`solc`）是如何将代码转换为EVM可以理解的东西，以便计算机可以处理它的呢？让我们尝试用特定的编译器进行分析。通过执行以下命令安装`solc`：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you compile the contract to bytecode and analyze the process that the bytecode
    is taking, you will get the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将合同编译为字节码并分析字节码所采取的过程，您将得到以下结果：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You''ll see a few interesting things about the EVM''s behavior. First off,
    you''ll get a file with the `.bin` termination, such as `Example_sol_Example.bin`,
    which is the binary file containing the compiled bytecode of the smart contract:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到有关EVM行为的一些有趣的事情。首先，您会得到一个带有`.bin`结尾的文件，例如`Example_sol_Example.bin`，这是包含智能合同已编译字节码的二进制文件：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To understand all that bytecode and see what the EVM is really doing, we have
    to split each instruction accordingly. `6080604052` is just the initialization
    of the smart contract. It''s always the same for every contract. Then, we have
    the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解所有那个字节码并看看EVM真正在做什么，我们必须根据每个指令拆分它。`6080604052`只是智能合同的初始化。每个合同都是一样的。然后，我们有以下内容：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The number 60 is a specific instruction, known as `PUSH`, that essentially
    moves the number `3` to the memory stack. The stack is just an empty array that
    can get or delete values from its array. Our stack looks like this after the `PUSH`
    3 instruction:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following instruction adds a zero to the stack:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This results in `stack: [0, 3]`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have `55`, which is a `STORE` instruction that writes `uint256` permanently
    to storage, the blockchain. We need to add the number 3 to the stack before we
    can write it into storage. What we did here is essentially the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is equivalent to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember that all smart contracts start with `6080604052`, as you saw in the
    complete bytecode. Our smart contract contains just a `uint256` assignment, so
    it follows that bytecode with `6003600055`. What we finally have is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The rest is irrelevant, since it contains information about the sender and the
    contract. There are about 100 opcodes, and many different techniques are used
    in the EVM to translate smart contract code to bytecode so that it can be published
    to the blockchain efficiently.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Now, you understand what happens under the hood when you write a smart contract,
    compile it, and deploy it to the network. The rest is up to the nodes that run
    their own specific implementation of the Ethereum protocol, so they decide which
    blocks to take and which ones to ignore. The EVM is a complex virtual environment
    that processes transactions and bytecode from smart contracts to achieve a global
    consensus that benefits everybody.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Upgradable and scalable smart contracts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ethereum blockchain is immutable, which means that you can't modify its
    past actions. Once an action is confirmed by the majority of the miners, that
    action stays there forever. The same restrictions apply to smart contracts. However,
    we, as Ethereum experts, are able to overcome the issue of deploying unscalable
    code that ends up being vulnerable because we understand that there are different
    development techniques where we create scalable code. The idea is to deploy smart
    contracts so that they are ready to scale in the future with a set of different,
    interchangeable contracts. Knowing how to create smart contracts that scale and
    can be improved in the future is an essential skill that any top Ethereum expert
    must possess, so don't miss out on it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Upgradable smart contracts
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Upgradable smart contracts** are the next step when it comes to creating
    advanced smart contracts for big industries that keep evolving and require new
    functionalities unexpectedly. They can be used in all kinds of projects, but I
    recommend that you use them only for those that may require upgrades in the future
    or for those that want to secure their data for future projections. Not every
    smart contract needs to have upgradable functionalities, although tokens and the
    likes will benefit heavily from upgradable code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create an upgradable smart contract that is made up of three parts and
    two smaller smart contracts. Here''s how it will look:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/953fbe37-68a7-4bd3-bcf9-e65bec40eb96.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: There are many ways to make upgradable smart contracts—you can even create your
    own! So, be patient when it comes to understanding this kind of technology, because
    it can seem confusing in the beginning.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a contract upgradable, we need three pieces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**The proxy contract**: This is the initial contract—the main contract that
    users always use to interact with the code. Think of this one as the same old
    smart contract that you use to make function calls but that, instead of executing
    the logic inside here, gets executed in the upgradable smart contract.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The upgradable contract**: This one is where all the logic takes place. This
    contract can be upgraded, which means that it can be removed and you can deploy
    a newer version with the same name and new functions. Users won''t interact with
    this contract directly since the address changes every time it gets upgraded.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The storage contract**: Because we don''t want to lose our state variables
    and all the user information every time we upgrade a contract, we will store all
    the variables, mappings, and data in this storage contract. It will have only
    variables and setter functions to update those variables. It won''t have any logic
    or functions besides those.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To upgrade a contract while keeping the same address, what will happen is this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Users will send a transaction to the proxy contract, for instance, `execute
    function buyTokens()`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proxy contract will send that, find the `buyTokens()` function inside the
    upgradable contract, and execute it.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The upgradable contract will process the logic to buy tokens and it will store
    all the changes inside the storage contract, for instance, by calling a function
    named **`setTokens()`**, which increases the number of tokens of user A to 40.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The storage contract executes **`setTokens()`** and updates the tokens variables
    to `tokens = 40;` for user A.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's essentially the workflow of how the logic operates. In essence, we will
    always use the same contract address, but the logic will change. We will also
    keep the same information without deleting it because it's valuable information
    that could be very hard to re-insert.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand the concept behind all these contracts, I'll show you
    a pseudocode version of the code that each smart contract has. We'll use the token
    analogy, where a user wants to buy tokens in an upgradable contract.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the proxy contract would look like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is what the upgradable contract would look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, finally, here''s what the storage contract would look like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Those three contracts working together are the core concept behind upgradable
    smart contracts, where instead of updating the entire codebase, we break the different
    roles into changeable parts that can be modified in the future. Let's take a deeper
    look at how they are all implemented, one by one.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个合同一起工作是可升级智能合同背后的核心概念，而不是更新整个代码库，我们将不同的角色分成可以在将来修改的可变部分。让我们深入了解它们是如何一个接一个地实现的。
- en: Storage smart contracts
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储智能合同
- en: The storage smart contract is the simplest of the three, since it just contains
    variables and functions to update those variables. We don't need getters, because
    these are public variables that already have getter functions created by default
    for being public.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 存储智能合同是这三个智能合同中最简单的，因为它只包含变量和函数来更新这些变量。我们不需要getter，因为这些都是public变量，已经默认创建了getter函数来获取public变量。
- en: 'We''ll create a simple storage smart contract that contains one `uint` variable
    for demonstration purposes. You''ll then be able to add more variables as you
    need. This contract is quite simple, since it just contains one variable:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的存储智能合同，其中包含一个`uint`变量，以演示目的。然后，你可以根据需要添加更多变量。该合同非常简单，因为它只包含一个变量：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we have a variable called `myNumber` and a setter function called
    `setMyNumber` that updates that variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有一个名为`myNumber`的变量和一个名为`setMyNumber`的setter函数来更新该变量。
- en: You may want to introduce access logic to only allow specific users to update
    certain variables. For now, it's enough that you understand how it looks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望引入访问逻辑，只允许特定用户更新某些变量。目前，只要你理解它的外观就足够了。
- en: Upgradable smart contracts
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可升级智能合同
- en: 'The upgradable smart contract is the most interesting one. It will execute
    all the logic and will interact with the storage contract whenever it has to update
    some variable data. Let''s take a look at the code to see how it works. We''ll
    later see how to upgrade it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可升级智能合同是最有趣的。它将执行所有逻辑，并在需要更新一些变量数据时与存储合同交互。让我们看看代码，看它是如何工作的。稍后我们将看到如何对其进行升级：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This upgradable contract is in the same file as the `Storage` smart contract.
    This is important at the beginning because we need access to that contract for
    deployment purposes. Alternatively, you could use the `import` keyword.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可升级合同与`Storage`智能合同在同一个文件中。这一点很重要，因为在部署时我们需要访问该合同。或者，你也可以使用`import`关键字。
- en: As you can see, I've declared the `Upgradable` smart contract with a variable
    called `storageContract`, which keeps track of the storage contract's address,
    since we will update the state variables there. In the constructor, we set the
    storage contract's address, since this contract will keep the same storage until
    it's updated. Then, I added a function called `buyTokens()` as an example to show
    you how it would look in a real-world example; right now, it doesn't do anything
    besides updating the storage by calling `setMyNumber()` from the `Storage` contract.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我用一个名为`storageContract`的变量声明了`Upgradable`智能合同，它跟踪存储合同的地址，因为我们将在那里更新状态变量。在构造函数中，我们设置了存储合同的地址，因为该合同将一直保留相同的存储，直到更新为止。然后，我添加了一个名为`buyTokens()`的函数作为示例，向你展示它在现实世界中是什么样子的；目前它除了通过调用`Storage`合同中的`setMyNumber()`更新存储外不会执行任何操作。
- en: If you were to create a real implementation, you'd add all your desired logic.
    I don't want to show you a real, completed version of this upgradable contract
    because the many functions would distract you from understanding how an upgradable
    smart contract works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要创建一个真正的实现，你将添加所有你期望的逻辑。我不想向你展示一个真正完整的可升级合同版本，因为其中许多函数会让你无法理解可升级智能合同是如何工作的。
- en: It shows that you execute all your logic and then, at the end of the file, you
    update your storage variables by calling the storage contract.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了你执行所有逻辑，然后在文件末尾，通过调用存储合同更新存储变量。
- en: 'To upgrade this contract, follow these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级这个合同，请按照以下步骤操作：
- en: Deploy a new version of this contract with your updated functions. You can add
    new functions, update old ones, or even delete some.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署这个合同的新版本，其中包含了更新后的函数。你可以添加新的函数，更新旧的函数，甚至删除一些。
- en: When deploying the contract, use the storage address in your constructor, since
    you need to access that contract for variable keeping.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署合同时，在你的构造函数中使用存储地址，因为你需要访问该合同来保持变量。
- en: Finally, in the proxy contract, execute a function called `upgradeUpgradableContract()`,
    which will redirect all the function calls to the newer version of your upgradable
    smart contract.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在代理合约中，执行一个名为`upgradeUpgradableContract()`的函数，它将把所有的函数调用重定向到你的可升级智能合约的新版本。
- en: Notice how you can deploy this contract while keeping the same storage contract,
    thus preserving your data safely and so that it is ready to use like nothing happened
    in the next version of your upgradable contract. Alternatively, you can deploy
    a new storage contract and then a new upgradable contract pointing to that new
    storage. That way, you have clean storage if you don't want to keep the old data.
    Nevertheless, you'll still have access to the old data, since the contract will
    permanently live on the blockchain just by pointing to the old storage address
    when creating a new upgradable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以部署这个合约，同时保留相同的存储合约，这样您的数据就可以安全地保留，并且在下一个可升级合约版本中准备好像什么都没有发生一样使用。或者，您可以部署一个新的存储合约，然后部署一个指向该新存储的新可升级合约。这样，如果您不想保留旧数据，您就会有一个干净的存储。然而，您仍然可以访问旧数据，因为合约将永久地存在于区块链上，只要在创建新的可升级合约时指向旧存储地址即可。
- en: Proxy smart contracts
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理智能合约
- en: This is the most important piece because this contract will never change. We
    don't want it to change, because we want to keep the same Ethereum address while
    updating the underlying logic. This contract will redirect all the calls to the
    upgradable contract and will have several variables to register the current upgradable
    contract's address and a list of past contracts for those that don't want to update
    to the new code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的部分，因为这个合约将永远不会改变。我们不希望它改变，因为我们希望保留相同的以太坊地址，同时更新底层逻辑。这个合约将把所有的调用重定向到可升级合约，并且有几个变量用于注册当前可升级合约的地址和不想更新到新代码的过去合约列表。
- en: Remember that upgrading to a new version is always optional. If your users decide
    that they want to keep using the old smart contracts, they will simply send all
    their transactions to the old upgradable contract directly without executing the
    proxy contract. You could stop them from doing so by destroying the old upgradable
    smart contract with the `selfdestruct()` function, but I don't recommend it, since
    it makes your contract worthless, and it could be usable in the future.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，升级到新版本始终是可选的。如果您的用户决定要继续使用旧的智能合约，他们可以直接将所有的交易发送到旧的可升级合约而不执行代理合约。您可以通过使用
    `selfdestruct()` 函数销毁旧的可升级智能合约来阻止他们这样做，但我不建议这样做，因为这将使您的合约变得毫无价值，并且可能在未来可用。
- en: 'Here''s how the proxy contract looks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代理合约的样子：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the most complex contract because it has to do quite a few things. First
    off, we set up `storageAddress`, `upgradableAddress`, and `owner`. Those are the
    variables that the contract will use to understand where to redirect all the calls.
    We don't actually need to keep track of the storage address or the owner, but
    it's good practice, since it makes things understandable and gives you more options.
    Note that the `delegatecall()` function can't update the storage of the upgradable
    contract, so we set up an external storage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最复杂的合约，因为它需要做一些事情。首先，我们设置了 `storageAddress`、`upgradableAddress` 和 `owner`。这些是合约将用来理解在哪里重定向所有调用的变量。实际上，我们并不需要跟踪存储地址或所有者，但这是一个良好的做法，因为它使事情更容易理解，并提供更多的选择。请注意，`delegatecall()`
    函数无法更新可升级合约的存储，所以我们设置了一个外部存储。
- en: 'Then, we have two address arrays: `listStorage` and `listUpgradable`. These
    arrays will contain the current and older versions of those storage and upgradable
    contracts since we want to have access to old logic in case we needed to do so
    with those addresses. I''ve added an `onlyOwner` modifier because we only want
    to allow contract updates from the owner.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个地址数组：`listStorage` 和 `listUpgradable`。这些数组将包含当前和旧版本的存储和可升级合约，因为我们希望在需要时能够访问旧的逻辑。我添加了一个
    `onlyOwner` 修饰符，因为我们只希望允许所有者进行合约更新。
- en: 'After that, we have the constructor. It is used to deploy a new storage and
    upgradable smart contract right away. You could deploy them separately, but it''s
    just easier and cleaner to do it from the proxy''s constructor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有构造函数。它被用来立即部署一个新的存储和可升级智能合约。您可以分别部署它们，但从代理的构造函数中这样做更简单和干净：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, there''s the fallback function, which is marked as external. This is
    the most important function, since it''s the one that will receive all the function
    calls and will redirect them to the right function from the upgradable smart contract.
    It works by using the `delegatecall()` function. It''s a low-level function that
    receives a `bytes` parameter to indicate which function to call from the other
    contract with the parameter values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个标记为外部的回退函数。这是最重要的函数，因为它是将接收所有函数调用并将其重定向到可升级智能合约的正确函数的函数。它通过使用`delegatecall()`函数工作。这是一个接收`bytes`参数以指示使用参数值从其他合同调用哪个函数的低级函数：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we have the functions that are required to upgrade the storage and
    logic contracts whenever the owner decides to do so. They work by keeping track
    of previous versions in the arrays so that users can access older versions if
    they want to do so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有必要在所有者决定升级存储和逻辑合同时，升级存储和逻辑合同所需的函数。它们通过在数组中跟踪先前的版本来工作，以便用户如果希望如此，则可以访问旧版本：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To understand how the mechanism of communicating with the logic contract works,
    check out this function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解与逻辑合同通信的机制如何工作，请查看此函数：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, this takes the address of the contract to call, which in this case is
    the upgradable contract address, and then the data with the information to transmit.
    The `msg.data` parameter is a special variable that contains the function to call
    with the parameter values. Here's where you'd write the function name to call.
    For instance, let's say that you want to execute the `buyTokens(uint256 _number)`
    function, with the `_number` parameter being `12`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这需要调用合同的地址，本例中为可升级合同地址，然后是包含要传输信息的数据。`msg.data`参数是一个特殊变量，其中包含要调用的带参数值的函数。在这里，您将编写要调用的函数名称。例如，假设您想执行`buyTokens(uint256
    _number)`函数，其中`_number`参数为`12`。
- en: 'In a normal contract, you''d simply create a contract instance and call the
    function by name while sending the parameter values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通合同中，您只需创建合同实例，并按名称调用函数，同时发送参数值：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But we can't do that when we don't know the function name beforehand. Remember
    that we're dealing with a contract that may have new functions in the future,
    and we also want to have access to those functions from the same proxy contract.
    For that reason, we use `msg.data`. That variable contains a hexadecimal bytes
    string with the function name and the parameters. Let's see how to format it properly
    so that Solidity understands which function we want to call.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们事先不知道函数名称时，我们无法这样做。请记住，我们正在处理可能在将来具有新函数的合同，并且我们还希望从同一代理合同中访问这些函数。因此，我们使用`msg.data`。该变量包含一个十六进制字节字符串，其中包含函数名称和参数。让我们看看如何正确格式化它，以便
    Solidity 理解我们要调用哪个函数。
- en: 'First, we need the function name, and then we need the parameters encoded.
    Because Solidity works with hexadecimal values, we need to write it in hexadecimal
    form using the function signature. The function signature is a short way to reference
    functions by a short hexadecimal value instead of their string names. If you go
    to [https://remix.ethereum.org](https://remix.ethereum.org), you can quickly see
    the function signature of each of your functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要函数名称，然后我们需要编码的参数。因为 Solidity 使用十六进制值，所以我们需要用函数签名以十六进制形式写入它。函数签名是通过短的十六进制值而不是它们的字符串名称来引用函数的一种简短方式。如果您转到[https://remix.ethereum.org](https://remix.ethereum.org)，您可以快速看到每个函数的函数签名：
- en: '![](img/40a35747-e6f0-43f9-81b6-cc56ecce72d6.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40a35747-e6f0-43f9-81b6-cc56ecce72d6.png)'
- en: 'As you can see, I''ve copied my contract on Remix. Now, to get the function
    signature in a hexadecimal form of the `setMyNumberStorage()` function, you have
    to go to the compile tab while selecting your contract:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我已经在 Remix 上复制了我的合同。现在，要以十六进制形式获取`setMyNumberStorage()`函数的函数签名，您必须在选择您的合同时转到编译选项卡：
- en: '![](img/c97dc487-11f7-4d92-af1e-41dc1146209c.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c97dc487-11f7-4d92-af1e-41dc1146209c.png)'
- en: 'Then, you can click on Details for more information:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以点击“详情”以获取更多信息：
- en: '![](img/8084c651-204f-4d4f-8e24-a453845d2f8f.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8084c651-204f-4d4f-8e24-a453845d2f8f.png)'
- en: 'If you scroll down, you''ll see the section with the function hashes of your
    contract:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下滚动，您将看到合同的功能哈希部分：
- en: '![](img/06255bbe-301b-46aa-ab9c-18656f8752da.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06255bbe-301b-46aa-ab9c-18656f8752da.png)'
- en: 'The function hash for `setMyNumberStorage()` is `009be4e6`; that''s the function''s
    signature. Great! We have the first part of our `msg.data` object: `0x009be4e6`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to encode the parameters of the function. Let''s say that I want
    to set a number of `16` when calling the function. You can do it manually by converting
    that number into its hexadecimal form with web3\. If you have MetaMask installed,
    you can open your browser''s developer tools to interact with `web3.js`. In the
    console, you can simply type `web3.toHex(16)` and you''ll receive the hexadecimal
    version of 16:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e8684fa-05a2-48ea-af5a-0dc446d040cc.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Note that `web3.toHex()` only works for version 0.20 of web3, which is the one
    being used by MetaMask at the moment. The syntax is different in web3 1.0, so
    if MetaMask updates its version of web3, you can read how to do hexadecimal conversion
    in the official web3 1.0 docs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to add 62 zeroes in front of 10, since `0x10` is our number
    to get the encoded version of that parameter. Here''s an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That would be 16 encoded hexadecimally. We just need to add the function signature
    in front of that to complete our `msg.data` object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s about it! That long string of hexadecimal numbers says: *Call the function
    setMyNumberStorage(12)*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to where we left it, the `.delegatecall(msg.data)` function can
    now be executed properly with the converted value of our function call. You may
    be asking yourself: *But why complicate things so much, how will users do all
    that conversion work?*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The truth is that people using your smart contract or dApp won''t do all the
    conversion. You''ll simple write the conversion logic in your decentralized application,
    and the function names will be converted automatically in a few lines with web3,
    as you saw already. Alternatively, you can deploy your contract on Remix and get
    the entire encoded function call with just one button:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/686a99c0-4ecd-41de-83e0-6072bd1b0909.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'When you deploy a contract, you can see a box where you can interact with your
    deployed contract. If you click the arrow that I''ve marked, you''ll see the expanded
    version of the function call that shows you the toolbox icon, which you can click
    to get `setMyNumberStorage(16)` converted directly into hexadecimal form:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s a simple trick to make the conversion when using your contracts with
    Remix. With that hexadecimal number, you can go to MetaMask and paste it inside
    the data field. First, open MetaMask and click on SEND:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc869e8c-850b-446f-bb47-9e63a97f5b40.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Then, paste your code into the data field by scrolling down:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72f8dde7-2186-4ef2-9638-2e25df506488.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: After confirming the transaction, you'll see that your function has been successfully
    delegated and that you've made the execution from the proxy contract.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our fallback function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can see that the `delegatecall` function returns two values: a boolean
    for whether the delegation was successful and a bytes parameter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`delegatecall`函数返回两个值：一个布尔值，用于指示委托是否成功，以及一个字节参数。
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We simply capture them and require that the delegation is successful. Otherwise,
    it will revert the transaction and not make any changes. This is important, because
    the `delegatecall` function doesn't care if the delegation was successful or not;
    it will simply inform you to let you take the decision, since it's a low-level
    function that can be used in many advanced situations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是捕获它们并要求委派成功。否则，它将撤销交易并不做任何更改。这很重要，因为`delegatecall`函数不关心委派是否成功；它只会通知您让您做出决定，因为它是一个低级函数，可在许多高级情况下使用。
- en: Another interesting property of `delegatecall()` is that `msg.sender` of the
    receiving contract will be your Ethereum address instead of the proxy contract's
    address. This is important because otherwise, your address would simply be different
    in the upgradable contract. You don't want that in many cases, where the user
    address is important for some logic.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegatecall()` 的另一个有趣属性是，接收合约的`msg.sender`将是您的以太坊地址，而不是代理合约的地址。这很重要，否则，在可升级合约中，您的地址将会不同。在许多情况下，用户地址对于某些逻辑很重要，你不希望出现这种情况。'
- en: 'Finally, we have these two functions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有这两个函数：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: They are simply used to update a smart contract. Whenever you deploy a new version
    of `Upgradable` or `Storage`, you'll have to execute the corresponding function
    to let the proxy contract know which one is the active one so that it can delegate
    all the function calls to the right version of the contract.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它们只是用于更新智能合约。每当部署新版本的`Upgradable`或`Storage`时，您都必须执行相应的函数，以使代理合约知道哪个是活动的版本，以便它可以将所有函数调用委托给合约的正确版本。
- en: Scalable smart contracts
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展的智能合约。
- en: Usually, smart contracts are strictly limited by blockchain's processing capacity,
    since hundreds of thousands of nodes have to be connected to each other to execute
    the same transactions. This is a major problem when we're dealing with popular
    applications that exceed blockchain's capacity. To overcome this issue, there
    are different scaling solutions that you can implement in your smart contracts
    so that many more users are able to run your decentralized applications without
    performance issues.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，智能合约严格受到区块链处理能力的限制，因为数十万个节点必须相互连接以执行相同的交易。当我们处理超出区块链容量的热门应用程序时，这是一个重大问题。为了解决这个问题，有不同的扩展解决方案，您可以在智能合约中实施，以便许多更多的用户能够运行您的去中心化应用程序而无性能问题。
- en: 'To understand the scaling solution that you''re going to learn, it''s important
    to understand the process that takes place when using a smart contract:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解您将要学习的扩展解决方案，了解使用智能合约时发生的过程很重要：
- en: First, the user generates a transaction for a specific smart contract either
    by running a decentralized application that interfaces with that contract or by
    executing the smart contract directly with their own Ethereum node
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，用户通过运行一个与该合约交互的去中心化应用程序或直接使用他们自己的以太坊节点执行智能合约，为特定智能合约生成一个交易。
- en: The transaction is received by the miners so that they can include it into the
    next block and execute the bytecode
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矿工接收交易，以便将其包含到下一个区块中并执行字节码。
- en: When they confirm it, the transaction gets permanently added to the longest
    chain
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他们确认时，交易将永久添加到最长的链中。
- en: We can't speed up the process of confirming transactions by miners since the
    consensus scheme used by Ethereum requires that each node verifies each transaction
    until they all become valid.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法加快矿工确认交易的过程，因为以太坊使用的共识方案要求每个节点验证每个交易，直到它们都变为有效为止。
- en: What we can do instead is use a protocol known as **state channels**. It consists
    of commitment schemes that generate valid transactions off-chain as long as a
    group of people agree on those transactions. For instance, think about a card
    game such as blackjack. If you're not familiar with it, it consists of receiving
    one card per turn for each player and betting chips on getting the largest sum
    of combined cards. The one with a combined sum of 21, or the next largest number,
    wins. If you exceed 21, you lose.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In essence, state channels are like blackjack games, where users can play an
    endless number of games while keeping a score of chips that you can exchange for
    real money when you finish. It's a great scaling system because you can run many
    transactions off-chain directly peer-to-peer without waiting for the blockchain
    to process each one of them. You simply bundle the result together and push one
    big transaction to the blockchain when you end the game.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: So, you're processing hundreds of transactions in real time until you end the
    game, when you have to send 1 transaction. Instead of waiting about 20 seconds
    per transaction for 100 transactions, you just wait 20 seconds once, while saving
    gas. Therefore, you end up with a much faster and scalable system where many more
    players can use your dApp with much better performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using state channels for scalable smart contracts
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll guide you through a simple example project so that you can see state channels
    in action. They use commitment schemes, which are just encrypted transactions
    that you can't change to commit to your actions before revealing the result when
    the players decide to show their cards.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The smart contract will be the entry and exit point of the state channel. What
    happens in-between is outside of the blockchain''s control, although we''ll define
    what goes inside each encrypted message so that we can verify it when ending.
    These are the steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Each player that participates in the game must open the state channel by calling
    a function in the smart contract to define who they are. When they do that, they
    must send some Ether to the smart contract as an escrow. Those funds will be used
    for distributing the rewards when the game ends.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the hash with the variables that you want to commit. These hashes will
    contain the encrypted participation of each player. So, they exchange messages
    back and forth directly by first committing to their bet, then revealing their
    result and updating the variables and balances.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When they decide to end the game, they go back to the smart contract to upload
    their latest signed hash so that the smart contract can read it to send the corresponding
    Ether to each one.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create the smart contract with the entry and exit functions. The rest
    will be done off-chain. As usual, here''s the contract''s structure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The constructor will be the entry, since we want to deploy a new instance of
    the contract per game. The `exitStateChannel()` function will check the latest
    signed hash and will send the corresponding Ether to each player. Notice how the
    constructor is payable given that we want to receive the escrow funds when starting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some variables that we''ll need. In this case, we''ll create a simple
    guessing game where each player has to set a number from 1 to 10 and the other
    has to guess that number to win. So, player 1 wins when player 2 makes a guess
    different from theirs. They also bet Ether every guessing game; the winner takes
    double his bet as long as both have enough funds for those bets:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need to set up those variables for each player:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the constructor will initialize the address and escrow for the
    first player, while the `setupPlayerTwo()` function will do the same for the second
    player. That's all we need for opening the state channel between 2 players. Before
    creating the `exitStateChannel()` function that will end the game while closing
    the channel and distributing funds, I want to clarify what kind of elements compose
    each hashed message and how the game will be played off-chain.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In this guessing game, we have two players who have two different escrows in
    which they make bets every game about a specific number that they select. If the
    number is the same for both, the second player wins; otherwise, the first player
    wins. And they get double the number of Ether invested as long as they both have
    enough funds.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, player 1 will create an encrypted object containing the following
    values to start a game:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**Number selected**: This must be between 1 and 10.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amount of Ether bet for the game**: The other player must have enough funds
    to pay double what you invest. For instance, player 1 has 10 Ether while player
    2 has 4\. Player 1 won''t be able to bet more than 4 Ether given that, if he wins,
    the second player will have to pay all his Ether to him. We will leave this option
    open so that they can invest as much as they want and if the bet exceeds the balance
    of the player, he simply gets all the funds, even if it''s less than the bet.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game sequence**: A counter that increases every game to identify the order
    of each game.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: A unique timestamp for each player to understand when the bet
    was made.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A nonce**: A random 10-digit number to keep each message unique. This is
    not mandatory, but it helps when trying to understand the order of events of the
    game.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example: the first player starts the game after opening the state
    channel by creating the smart contract with another player, who set up their escrow
    within the smart contract. He then creates the following data that will be encrypted:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Number selected**: 9'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amount of Ether to bet**: He has 10 Ether in escrow, so he''ll bet 4 Ether
    for this game'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game sequence**: 1'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: 1549378379'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonce**: 2948372910'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'He then encrypts that information with the `keccak256` algorithm using a dApp:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，他使用 dApp 用 `keccak256` 算法加密该信息：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'He gets this resulting hash:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 他得到了这个结果的哈希值：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that this is just an example where the real `keccak256` would be different.
    He then signs that hash with the Ethereum account used in the state channel smart
    contract. He can do so with web3.js since it''s the fastest way to sign hashes
    off-chain in combination with MetaMask:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是一个示例，真正的 `keccak256` 将会不同。然后，他使用在状态通道智能合约中使用的以太坊账户对该哈希进行签名。他可以使用 web3.js
    进行此操作，因为它是与 MetaMask 结合使用在链下最快的签署哈希的方式：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After that, the encrypted hash will be signed to later confirm that he indeed
    chose those parameters with his account. The other player will take the same steps
    to generate an encrypted signed hash with his bet.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，加密的哈希将被签名，以后确认他确实选择了那些参数与他的账户。另一个玩家将采取相同的步骤生成加密签名的哈希与他的赌注。
- en: When the two hashes are generated, they will use a decentralized application
    running some kind of communication system, such as a server or email, to exchange
    those hashes and reveal their bets. They will be able to verify those hashes at
    any point, since you can quickly verify that the information encrypted is valid
    once you know the valid contents of it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成两个哈希时，他们将使用运行某种通信系统的去中心化应用，例如服务器或电子邮件，来交换这些哈希并揭示他们的赌注。他们可以随时验证这些哈希，因为一旦知道了加密信息的有效内容，就可以快速验证该信息是否有效。
- en: Each new message will have an increased sequence number, a random nonce, and
    a new timestamp that must be larger than the previous one. All those checks can
    be done in a dApp that implements the state channel contract.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新消息都会有一个增加的序列号、一个随机的随机数和一个新的时间戳，该时间戳必须大于上一个时间戳。所有这些检查都可以在实现状态通道合约的 dApp 中完成。
- en: When they decide to end the game, they will upload their latest message to the
    smart contract for it to distribute the updated balances from the escrow that
    they configured when opening the channel. Here's how the game will be closed in
    the smart contract with the `exitStateChannel()` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们决定结束游戏时，他们将上传他们的最新消息到智能合约，以便从在打开通道时配置的托管中分发更新后的余额。以下是如何在智能合约中使用 `exitStateChannel()`
    函数关闭游戏。
- en: 'First, we set up the variables required for our game to keep track of the balances:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置游戏所需的变量以跟踪余额：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we create the setup functions, which in this case are the constructor
    and `setupPlayerTwo()`, whose job is to store users'' initial data:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建设置函数，这种情况下是构造函数和 `setupPlayerTwo()`，它的作用是存储用户的初始数据：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we add the most important function: the function to end the game and
    exit the state channel by choosing a victorious player based on the last state:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加最重要的函数：根据最后的状态选择获胜玩家并结束游戏的函数：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When we have that many parameters for a function, it's great practice to separate
    each one in a new line. First off, we check that the address hasn't been set up,
    since we want to set up each message individually. Then, we regenerate the encrypted,
    signed hash message to verify that the parameters that were passed are valid.
    To verify if `keccak256` is valid, we only have to generate it again with the
    supposedly used parameters and check if the resulting hash is exactly the same
    as the one given.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有这么多参数的函数时，将每个参数分开放在新行中是很好的实践。首先，我们检查地址是否已设置，因为我们希望单独设置每个消息。然后，我们重新生成加密的、签名的哈希消息以验证传递的参数是否有效。要验证
    `keccak256` 是否有效，我们只需再次使用假定使用的参数生成它，并检查结果哈希是否与给定的哈希完全相同。
- en: After that, we use assembly to get r, v, and s, which are the three variables
    that are used to sign a message with your Ethereum account. We use it to get the
    address of the signer to verify that it comes from the right person. Then, we
    set up the balance, bet, and call of that player in the state variables. We do
    that to later distribute the funds when the second player executes the exit function
    with his parameters. Finally, after both have set up their resulting messages,
    we execute the Ether transfers with the `transfer()` function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用汇编语言获取 r、v 和 s，这三个变量用于使用您的以太坊账户对消息进行签名。我们用它来获取签名者的地址以验证消息来自正确的人。然后，我们在状态变量中设置该玩家的余额、赌注和调用。我们这样做是为了在第二个玩家使用他的参数执行退出函数时稍后分发资金。最后，在两者都设置好他们的结果消息后，我们使用
    `transfer()` 函数执行以太币转账。
- en: It seems complicated, but all we did was check that the signed message is valid,
    then check that the signature of the message is valid, and finally update the
    variables to distribute the funds when the other player verifies his exit message
    with this function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: This smart contract is just a demonstration. It has some important issues, such
    as the fact that one player could decide not to publish his message to exit the
    channel to avoid losing Ether. For that, we would need to add some kind of conflict
    resolution mechanism to distribute the funds if the second player doesn't respond
    after 24 hours. I'll leave that up to you to practice your skills.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: These are the next generation of smart contract, which will power complex decentralized
    applications running for hundreds of thousands of computers simultaneously with
    some centralized logic. In the end, it's about making sure we leverage the trustless
    nature of the blockchain to create applications that can benefit users without
    external entities intervening in the process. Continue reading to learn more about
    efficient smart contracts that use the minimum amount of resources for the greatest
    results.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Gas and data-efficient smart contracts
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s imperative to make smart contracts that not only handle transactions
    in a transparent and secure manner, but that are actually using the blockchain
    resources as efficiently as possible. For this reason, we''ll explore how to make
    gas- and data-efficient code for Ethereum. In this section, we''re going to cover
    the following topics:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Making gas-efficient smart contracts
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making data-efficient smart contracts
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making gas-efficient smart contracts
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m sure you''ve seen several smart contracts containing lots of functions
    that feel like they are consuming too much gas to operate: functions such as those
    that manage lots of state variables or those that have several different contracts
    operating at the same time.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Even though the blockchain requires gas be paid for every single transaction,
    it's in our best interest to create smart contracts that consume as few resources
    as possible so that transaction costs get reduced drastically for our users.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we do that?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that every small operation has an opcode associate in the EVM.
    Whenever you use an opcode, you''re paying gas because miners have to process
    your transaction. Here''s a list of the most common opcodes and their gas costs:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD` and `SUB`: Adding or subtracting two numbers. It costs 3 gas every time
    you add or subtract a number.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUL` and `DIV`: Multiplying or dividing numbers. This costs 5 gas per operation.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND`, `OR`, and `XOR`: Logic operations for comparing booleans. This costs
    3 gas per operation.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LT`, `GT`, `SLT`, `SGT`, and `EQ`: Logic operations for comparing numbers.
    This costs 3 gas per operation.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POP`: It''s an EVM stack operation to remove elements from the stack machine.
    It takes 2 gas for every `POP` operation.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUSH`, `DUP`, or `SWAP`: To add elements to the stack machine. This uses 3
    gas.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MLOAD` and `MSTORE`: To add data to the EVM''s memory. This uses 3 gas per
    operation.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JUMP`: To jump to another place in the assembly code. This takes 8 gas.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JUMPI`: A conditional jump. This takes 10 gas per operation.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLOAD`: Another stack operation that adds an element to the stack. This takes
    200 gas per operation.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SSTORE`: Stores information into the blockchain directly. This takes anywhere
    between 5,000 to 20,000 gas every operation.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BALANCE`: To get the balance of an Ethereum account or contract. This uses
    400 gas per operation.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATE`: To deploy a new smart contract or account. We need 32,000 gas to
    create a new smart contract.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, storing information in the state variables uses `SSTORE`, which
    costs up to 20k gas. That is very expensive and it's a place to optimize your
    code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main optimization techniques that we''ll explore and then explore
    with a real-world example to check the real gas costs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**The order of comparison operators**: The order of `&&` and `||` comparison
    operators, where the first condition is always checked, while the second may not
    be checked. For instance, if the second part of an if statement has a much higher
    probability of being true than the other, it''s better to put the second part
    first, since in an `OR` statement, it will save gas because it won''t spend unnecessary
    computations in checking the other parameters. The same thing is true of `AND`:
    you want to put the first part as the one most likely to be false because if the
    first part is false, the compiler won''t check the second one and you''ll save
    gas, given that every operator has a gas cost.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `for` **and** `while` **loops that use state variables**: When you
    have a loop that uses an external variable, you want it to use memory variables,
    since they are way cheaper than using storage.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inaccessible** `if...else` **statements**: There are situations where a conditional
    `if...else` won''t ever execute the other part. In those cases, it''s important
    to remove duplicate, redundant, and unreachable code that would consume gas every
    time it''s executed.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit the size of the variables**: The number after each variable type defines
    its capacity, so a variable with a smaller capacity consumes less gas for the
    simple reason that it won''t need as much blockchain storage: for instance, `uint8`
    instead of `uint256` for smaller variables.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t use libraries when possible**: Every time you make a library or an
    external contract call, you''re wasting gas, since you have to create an instance
    of that external contract, which in turn wastes gas. That''s why it''s better
    to combine all the code inside one big smart contract when deploying, instead
    of creating smaller pieces, which is great for development but not so much for
    production.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instead of storing to storage, use memory**: The `memory` keyword after the
    function type tells the compiler to store that information temporarily in the
    local memory instead of writing it to the blockchain.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit balance calls**: Whenever you request the balance of some account,
    you''re spending 400 gas, which can become quite a big number in sizeable contracts.
    Also, remember to store your balance in a memory variable if you''re going to
    request it several times, because once you store it, you won''t have to use the
    opcode CREATE again.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use** `bytes32` **instead of** `string`: String is a much bigger type of
    variable, since it can hold about 1,000 words using all the gas of the transaction.
    It doesn''t have a limit, per se; instead, it''s limited by the gas that you sent.
    The more gas, the bigger the string that you can store. However, it''s always
    best to use bytes32 since it''s much more compact, allowing you to store up to
    32 characters, which is ideal for shorter texts such as names.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some examples that can be optimized using these techniques:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see in the preceding contract, we are running a `for` loop inside
    the `counter()` function, which just increments the `myNumber` state variable
    by the `_counter` times. Do you see where there could be a problem? The main issue
    is that we are writing to the state variable each time the loop runs, which means
    that we are spending from 5k to 20k gas using the `SSTORE` opcode every single
    iteration, because the `myNumber` variable is a state variable.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: When running the function with `_counter = 5`, the transaction cost is 48,180
    gas and with `_counter = 10`, it costs 74,625 gas. As you can see, the cost quickly
    increased by about 26k gas, which is exactly what we expected from the `SSTORE`
    opcode given that we ran it five more times.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the contract, we simply have to create a new local variable that uses
    memory instead of storage:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the transaction cost went from 27,331 to 27,681, which is merely
    350 gas. As you can see, it's a huge improvement that will save people at least
    double the money in thousands of transactions. It makes sense to create gas-optimized
    contracts. This example can be further improved by changing `uint256` to `uint8`
    or the equivalent in order to store smaller variables.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This function runs a set of conditional statements with different conditions.
    In the first case, where `if (conditionOne && conditionTwo)`, we can improve the
    code by putting the condition most likely to be false first because it will save
    gas by not doing unnecessary checks to the second condition. The `&&` operator
    will not consider the second condition if the first one is false given that it
    requires both to be true, which makes sense, so it saves gas. Consider the following
    cases where we define the possibilities of each condition:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '`conditionOne` will be true 80% of the time, meaning that after 100 function
    calls, it will be true 80 times'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conditionTwo` will be true 20% of the time, meaning that after 100 function
    calls, it will be true 20 times'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conditionTwo` 在 20% 的情况下为真，这意味着经过100次函数调用后，它将为真20次。'
- en: If we leave the function as it is and we run the function 100 times, we will
    be wasting 3 gas every time the first condition is true but false in the other
    case. Remember that it costs 3 gas to run **AND** (**&&**), **OR** (**||**), and
    **XOR** (**^**). So, after 100 runs, we'll be wasting 80 `&&` checks, because
    the second condition is false in those cases, which means that we'll waste 300
    gas. It doesn't seem much, but it adds up to many different functions and transactions,
    so it's imperative to pay attention to the order of the conditional statements.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持函数不变，并且运行该函数100次，那么每次第一个条件为真但另一种情况为假时，我们将浪费3 gas。请记住，运行 **AND** (**&&**),
    **OR** (**||**), 和 **XOR** (**^**) 操作需要3 gas。所以，经过100次运行后，我们将浪费80次 `&&` 检查，因为在这些情况下第二个条件为假，这意味着我们将浪费300
    gas。这似乎不多，但它会累积到许多不同的函数和交易中，因此务必注意条件语句的顺序。
- en: 'The correct version would be as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的版本应该是如下所示：
- en: '[PRE49]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The same thing happens to the OR || statement, where we want to put the condition
    most likely to be true first, since we only need one to be true. Whenever the
    first condition is true, the compiler will stop checking the remaining conditions
    in that `if` statement to save gas, since it''s not needed. Considering the same
    probabilities from the previous example, where `conditionOne` is true 80% of the
    time and `conditionTwo` is true 20% of the time, we can fix the code to be gas-optimized:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OR || 语句，情况也是一样的，我们希望先放置最有可能为真的条件，因为我们只需要其中一个为真。每当第一个条件为真时，编译器将停止检查该 `if`
    语句中的其余条件以节省 gas，因为这是不需要的。考虑到前面示例中相同的概率，其中 `conditionOne` 80% 的时间为真，而 `conditionTwo`
    20% 的时间为真，我们可以修复代码以优化 gas：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The last conditional statement in the function is this one:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一个条件语句是这样的：
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because the condition inside the if statement will always be true, it doesn''t
    make sense to add the `else` block, since it will never be run. In this case,
    it makes sense to remove that `else` block to save gas when processing the function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 if 语句中的条件将始终为真，所以添加 `else` 块是没有意义的，因为它永远不会运行。在这种情况下，删除该 `else` 块以节省处理函数时的
    gas 是有意义的：
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This kind of check is also important for coverage testing, since this uses tools
    to verify that all parts of the code are being touched at least once to remove
    unnecessary elements.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种检查对于覆盖测试也很重要，因为它使用工具来验证代码的所有部分是否至少被触及一次，以移除不必要的元素。
- en: 'As a final tip for this section, I want you to know a little trick for storing
    information super efficiently: use indexed events as storage. Events have a dedicated
    section in the blockchain that costs way less gas to execute, therefore making
    them super gas efficient. This can be leveraged to store small strings and variables
    that you want to use in your dApps with minimal costs. You can later find each
    event with web3.js because they are indexed, which means that they are searchable
    for that particular parameter. Also, note that you can only have three indexed
    parameters in each event, so you can create several different events that are
    indexed.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一条建议，我想让你了解一种非常高效存储信息的小技巧：使用索引事件作为存储。事件在区块链中有一个专门的部分，执行成本要低得多，因此它们非常节省
    gas。这可以用来存储你想要在你的 dApps 中使用的小字符串和变量，成本最小化。你可以稍后使用 web3.js 找到每个事件，因为它们是被索引的，这意味着它们可被搜索到特定参数。另外，请注意，每个事件只能有三个被索引的参数，因此你可以创建多个不同的被索引的事件。
- en: Remember to go back to the 8-point list we set out before, every time you write
    a contract to guarantee an efficient smart contract process that saves people
    money and reduces the size of the blockchain, which is what we all want, after
    all.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次编写合约时都要回到我们之前列出的8点清单，以确保高效的智能合约流程，节省人们的资金并减少区块链的大小，这正是我们所有人想要的。
- en: As a final tip, you can create `view` and `pure` functions for functionality
    that could be expensive, since `pure` and `view` functions don't consume any gas
    given that they process the calculations locally, so you're using computation
    for free. For instance, if you want to sort an array in Solidity, you'd have to
    spend a lot of gas, since each iteration costs gas, but, if the sorting function
    is `view`, it won't cost you any gas, so you can sort as many arrays as you want
    without spending gas.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Making data-efficient smart contracts
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What I mean by a data-efficient smart contract is just code that is easy to
    read, understand, and manage. State variables are the main component when we talk
    about data efficiency: we want to optimize the maintainability of our code. This
    is not only important for explaining the code from developer to developer, but
    also for customers that will want to investigate what the smart contract code
    is actually doing. Data structures that are properly set up will save people hours
    of headaches and will improve the quality of your code exponentially.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Vyper does a fantastic job in this regard, because you can use custom Unit
    Types that are specifically designed to improve readability. It also uses a minimal
    syntax system inherited from Python that helps with the readability of the code.
    What does a data efficient smart contract look like? Take a look at this example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, each variable has a short comment above it to help you understand
    what it's supposed to do, since it's not uncommon to find confusing variables
    that could be misinterpreted for the wrong reasons. Each name is properly defined
    with concise naming that tries to be as clear as possible about the variable's
    use, just as they provide a clear understanding about when not to use them.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The variable types are the right ones for each variable's purpose, since we
    want to make them gas efficient by maximizing the capabilities of the virtual
    machine without spending unnecessary amounts of gas.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, here''s what a bad contract would look like:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the naming is too simplistic, leaving too much room for confusion. There
    aren''t comments above each variable to help you understand when they should be
    used, for what purpose, and with what limitations. And the variable types could
    be improved: instead of using `string` for the name, it probably makes sense to
    use `bytes32`, since we don''t need such a big type for a short piece of text.
    The same thing is true with `uint256`, where we must consider whether it''s better
    to reduce its size or not.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: In general, we want to provide as much clarification in our contracts as possible.
    To do so, we'll write great descriptions on top of each variable, even when we
    think it's clear enough; we'll use types efficiently to optimize gas costs; and
    we'll name the variables concisely to help upcoming developers understand the
    complexity of the contract code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Many large smart contracts become too big to understand easily, so it's imperative
    for you to optimize for data efficiency, since it's a great preventive security
    measure for detecting dangerous entry points.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: You've just learned how to optimize your smart contracts with simple techniques
    that can save people's Ether by properly understanding opcodes with their costs
    associated, so that you can make better decisions when creating functions that
    will be executed by thousands of others.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract security analysis
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in decentralized applications is a must that has to be carefully dealt
    with, since we are dealing with real money from real people that trust the code
    to be secure enough to keep their funds safely. You can't skip security analysis
    in your code, because otherwise you'll be risking people's money, so it's a huge
    responsibility.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: That's one of the main reasons securing a smart contract can be so costly in
    time and price. Audits, bug bounties, and code analysis are common for ICO smart
    contracts and those that handle real-world funds. They are naturally expensive
    because they require careful consideration of all the moving parts in a smart
    contract.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to secure a smart contract
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at some common checks that you want to go through before
    you deploy a smart contract to the Mainnet:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflows and underflows**: Overflowing a number means exceeding the capacity
    of it, thus resetting its value to start counting from zero again. Conversely,
    underflowing is exceeding the number capacity from the negative side, so when
    you go beyond zero in the `uint` type of variables, the value jumps straight to
    the largest value of that variable. For instance, let''s say that you want to
    store 5,000 in a uint8: could you do it safely? No, because the maximum number
    of a uint8 is 2 ** 8, which is 255 (not 256, since we start at zero), so you''ll
    exceed the capacity of that type several times before storing an unknown value.
    As you know, `uints` can''t be negative, so when you try to store a negative number
    inside them, you''ll underflow them. Pay attention to those situations and have
    checks in places to avoid exceeding the capacity of number types.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Not documenting your code is not a security risk in itself,
    since documentation has more to do with the fact that you''ll save hours by not
    confusing functions that could be misinterpreted. When you do document your code
    properly, you can quickly understand where it could fail, making it easier to
    maintain and more secure when auditing the code. For that reason, I always recommend
    NatSpec documentation, which is a way of describing your functions using some
    common parameters that can easily be understood by compilers and developers.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Re-entrancy attacks**: You''re probably familiar with this attack, which
    consists of taking advantage of the `delegatecall` function to call external contracts
    to update them in malicious manners. This is very dangerous and must be carefully
    analyzed whenever you see a low-level function such as `delegatecall`. You can
    avoid it by restricting access to the most important functions via visibility
    or modifiers.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race conditions**: This type of attack consists of taking advantage of gas
    limitations to run a specific sequence of code repeatedly until you run out of
    gas. It can be prevented by making sure that you reduce state variables before
    increasing them. For instance, for a token contract that increases your balance
    whenever you buy tokens with Ether, it is important to reduce the number of Ether
    that you own before increasing the balance of tokens you own to avoid re-entrance
    situations.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more small security issues that are specific to each individual
    contract. To fix them, you'll have to slowly analyze your smart contract to find
    points where it could lead to potential risks.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you started by getting up to speed to refresh your smart contract
    development skills with a project marketplace of copyrighted content to protect
    users'' content. Then, you explored the depths of the obscure world that is the
    EVM with a solid understanding of how it works internally and how smart contracts
    benefit from this wonderful technology. After that, you learned about one of the
    most powerful skills in Ethereum: developing upgradable and scalable smart contracts
    that can be used for advanced projects so that you can efficiently run large-scale
    applications for big businesses.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned how data and gas flows in smart contracts so that you're able
    to better manage the consumption of the precious resources available within the
    blockchain limitation, ultimately saving people's money and time with higher quality
    contracts. Finally, you've come full circle with security analysis to protect
    your code from malicious hands so that people's funds are completely secure in
    your dApps.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll explore the wonders of advanced decentralized applications
    by challenging your current understanding of how great dApps are created from
    the ground up. You'll see step-by-step the most efficient way to build stronger
    dApps for projects that scale.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
