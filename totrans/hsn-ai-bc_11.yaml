- en: Implementing DIApps*"Blockchain and AI are the binary stars in IT. **They are
    here to help save humanity from an invisible virus."*
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 实施DIApps*"区块链和人工智能是IT领域的双子星。**它们在这里帮助拯救人类免受隐形病毒的侵害。"*
- en: With it being more than 10 years since the advent of blockchain and AI, there
    is now a whole new range of solutions that can be built by combining both technologies.
    By combining these two technologies in a new way, we can address some tough problems.
    In this chapter, we'll propose a better pattern for application development that
    leverages the combination of AI and blockchain. This is a hands-on chapter where
    you will learn more about using blockchain and AI techniques to build a smart
    application that could potentially save us from further outbreaks of COVID-19,
    along with other agents of infection. By the end of this chapter, you will be
    able to identify the benefits of **Decentralized intelligent application** (**DIApp**)
    as you build a sample contact tracing application using the DIApp design pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链和人工智能已经问世超过10年，现在可以通过结合这两项技术构建一系列全新的解决方案。通过以一种新的方式结合这两项技术，我们可以解决一些棘手的问题。在本章中，我们将提出一种更好的应用程序开发模式，利用人工智能和区块链的组合。本章是一个实践性的章节，您将学习如何使用区块链和人工智能技术构建智能应用程序，这些应用程序有可能拯救我们免受COVID-19以及其他传染病的更多爆发的侵害。在本章结束时，您将能够识别**分布式智能应用** (**DIApp**)的好处，并使用DIApp设计模式构建一个样本接触追踪应用程序。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: Evolution of decentralized applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式应用的演进
- en: Building a sample DIApp
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个样本DIApp
- en: Testing the sample DIApp
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试样本DIApp
- en: Deploying the sample DIApp
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署样本DIApp
- en: Retrospecting the sample DIApp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾样本DIApp
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: '**Technical** r**equirements**'
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**技术** **要求**'
- en: 'While following the tutorials in this chapter, please ensure that the following
    software is installed on your system:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章节的教程时，请确保您的系统已安装以下软件：
- en: 'Just (v0.5.11 and above): [https://github.com/casey/just#installation](https://github.com/casey/just#installation)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Just (v0.5.11及以上版本)：[https://github.com/casey/just#installation](https://github.com/casey/just#installation)
- en: 'Python (v3.6.9 and above): [https://www.python.org/downloads/](https://www.python.org/downloads/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python（v3.6.9及以上版本）：[https://www.python.org/downloads/](https://www.python.org/downloads/)
- en: 'Node.js (12.18.2 LTS and above): [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js（12.18.2 LTS及以上版本）：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)
- en: 'Brave browser (v1.5.123 and above): [https://brave.com/download/](https://brave.com/download/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勇敢浏览器（v1.5.123及以上版本）：[https://brave.com/download/](https://brave.com/download/)
- en: 'Jupyter Notebook: [https://jupyter.org/install](https://jupyter.org/install)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter Notebook：[https://jupyter.org/install](https://jupyter.org/install)
- en: With the preceding software dependencies installed, we have tested the code
    on Linux (Ubuntu) and macOS (Mojave) to ensure it works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了上述软件依赖项的情况下，我们已在Linux（Ubuntu）和macOS（Mojave）上测试了代码，以确保其正常运行。
- en: In order to understand and appreciate the content in this chapter, you must
    be familiar with the basic concepts of the DIApp design pattern, as explained
    in [Chapter 7](dce2532d-dc68-42b1-996e-8b5f3336848e.xhtml), *Development Life
    Cycle of a DIApp*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解并欣赏本章节的内容，您必须熟悉DIApp设计模式的基本概念，如[第7章](dce2532d-dc68-42b1-996e-8b5f3336848e.xhtml)中所解释的*DIApp的开发生命周期*。
- en: This chapter also assumes that you are familiar with the basic concepts of blockchains,
    as explained in [Chapter 1](c9fa3dfc-7ac8-45a8-8c00-7dafed9e9389.xhtml), *Getting
    Started with Blockchain*. It is also assumed that you are familiar with the basic
    concepts of AI, as explained in [Chapter 2](8d65a7c4-c90d-42ec-bf01-2d387f52de99.xhtml),
    *Introduction to the AI Landscape*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还假设您熟悉区块链的基本概念，如[第1章](c9fa3dfc-7ac8-45a8-8c00-7dafed9e9389.xhtml)中所解释的，*区块链入门*。同时也假设您熟悉人工智能的基本概念，如[第2章](8d65a7c4-c90d-42ec-bf01-2d387f52de99.xhtml)中所解释的，*人工智能景观简介*。
- en: To appreciate the connection between these two technologies and apply them in
    this chapter, you are also expected to understand the benefits of decentralized
    database technologies, which were articulated, along with examples, in [Chapter
    4](75f3d1ef-59e1-4a7a-975b-114f2b50a6fe.xhtml), *AI and Blockchain-Driven Databases*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这两项技术之间的联系，并在本章中应用它们，您还需要理解分布式数据库技术的好处，在[第4章](75f3d1ef-59e1-4a7a-975b-114f2b50a6fe.xhtml)中已有详细解释，并且附有示例，*AI与区块链驱动数据库*。
- en: '**Evolution of decentralized applications**'
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**分布式应用的演进**'
- en: 'Let''s begin this chapter by quickly refreshing our memory about the current
    state of decentralized applications in a chronological manner. The following diagram
    shows how applications have evolved over the past three decades:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过按照时间顺序迅速回顾去中心化应用的当前状态来开始本章。下图展示了过去三十年中应用程序的演变过程：
- en: '![](img/eabe417c-b3ab-4cc8-9371-9584e8fac5d2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eabe417c-b3ab-4cc8-9371-9584e8fac5d2.png)'
- en: 'Fig 8.1: Evolution of applications since the dawn of the internet'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：自互联网诞生以来应用程序的演变
- en: Here, we can observe three major shifts in the application design pattern. We
    can also observe the three major aspects of how applications evolve over time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到应用程序设计模式发生了三次重大转变。我们还可以观察到应用程序随时间演变的三个主要方面。
- en: We will discuss each in the following sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论每一个。
- en: '**Traditional web applications**'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**传统的 Web 应用程序**'
- en: Although prominent work for the foundation of the internet was laid out in the
    1970s and the 1980s, it was the World Wide Web that made a significant leap in
    how information can be shared easily among nodes in a network. Traditional web
    applications such as blogs, chatrooms, and e-commerce websites emerged since the
    advent of the public internet in the mid-1990s. The majority of internet traffic
    is still driven by such applications, offering information and services to internet
    users.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管互联网的基础工作在1970年代和1980年代已经奠定了，但是正是万维网使得信息如何在网络中的节点之间轻松共享有了显著进步。自公共互联网的问世以来，传统的
    Web 应用程序，如博客、聊天室和电子商务网站，便开始出现在中期的1990年代。大多数互联网流量仍然由这些应用程序驱动，向互联网用户提供信息和服务。
- en: Most of these applications started with a simple web server in the backend.
    Servers were hosted to accept limited client connections across the world but
    easily crashed after reaching the desired threshold. Now, the majority of these
    applications have moved toward an n-tier architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序大多以简单的后端 Web 服务器开始。服务器被托管以接受世界各地的有限客户端连接，但在达到所需阈值后很容易崩溃。现在，这些应用程序大多已经转向了n层架构。
- en: The currently used **n-tier architecture**, also called **multi-tier architecture**
    or **multi-layer architecture**, is used to manage large-scale web applications
    such as e-commerce websites, social media sites, chatrooms, blogging platforms,
    and so on. Dedicated infrastructures are managed on the cloud in order for companies
    to facilitate transactions performed by users. Compared to the primitive version
    of the client-server model, the n-tier model separates the functions into many
    layers (hence the name). This also means that the n-tier model is serving as a
    better version of the client-server model in terms of handling failures and managing
    the liveness of traditional web applications. Companies manage their own infrastructure,
    such as servers, which is needed to provide services to users. Most of the infrastructure
    used by companies can be purchased or rented from cloud providers for a short
    period of time. This means the costs of operating traditional web applications
    are almost fixed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的**n层架构**，也称为**多层架构**或**多层架构**，用于管理诸如电子商务网站、社交媒体网站、聊天室、博客平台等大规模 Web 应用程序。为了便于公司进行用户执行的交易，专用基础设施在云上进行管理。与客户-服务器模型的原始版本相比，n层模型将功能分为许多层（因此得名）。这也意味着在处理传统
    Web 应用程序的故障和管理活跃性方面，n层模型作为客户-服务器模型的更好版本。公司管理自己的基础设施，如服务器，这是向用户提供服务所需的。公司使用的大部分基础设施可以从云提供商那里购买或租用一段时间。这意味着运行传统
    Web 应用程序的成本几乎是固定的。
- en: Now, let's try to understand how decentralized applications have evolved on
    the internet over the past 10 years.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着了解过去十年中互联网上去中心化应用程序的演变。
- en: '**Decentralized applications**'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**去中心化应用程序**'
- en: The foremost characteristic of a decentralized application is the fact that
    it is not controlled by a single entity. Another important characteristic is that
    it facilitates a common bar of entry to use the app. By textbook definition, Napster
    and BitTorrent were some of the earliest decentralized applications that could
    be used to host and share various files of sorts in a peer-to-peer format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用的最主要特征是它不受单一实体的控制。另一个重要特征是它为使用应用程序提供了一个共同的入门标准。按照教科书的定义，Napster 和 BitTorrent
    是一些最早的可以用于以点对点格式托管和共享各种文件的去中心化应用程序。
- en: Some of you might be wondering whether blockchains were used to build these
    apps. It is partially true that these peer-to-peer file sharing protocols used
    the fundamental cryptographic and networking technologies we use in blockchains
    today.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想知道区块链是否被用来构建这些应用程序。部分正确，这些点对点文件共享协议使用了我们今天在区块链中使用的基本加密和网络技术。
- en: At the time of writing, in 2020, we associate decentralized applications mostly
    with business logic running on blockchains such as Bitcoin and Ethereum. We must
    understand that decentralized applications are also a design pattern that existed
    long before the invention of Bitcoin.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，即 2020 年，我们将去中心化应用主要与运行在比特币和以太坊等区块链上的业务逻辑相关联。我们必须了解，去中心化应用也是一种设计模式，早在比特币发明之前就存在了。
- en: Comparing decentralized applications with traditional web applications, we can
    see that decentralized applications run on more than one server or computer. Also,
    such computers are not necessarily owned and operated by a single entity or individual.
    They usually consist of interested parties who are willing to run the software
    for a benefit or an incentive. Hence, it is safe to conclude that most of the
    decentralized applications run on a peer-to-peer network. Unlike traditional web
    applications, these applications do not experience a single point of failure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将去中心化应用与传统 Web 应用进行比较，我们可以看到去中心化应用在多个服务器或计算机上运行。而且，这些计算机不一定由单一实体或个人拥有和操作。它们通常由愿意为了利益或激励而运行软件的相关方组成。因此，可以得出结论，大多数去中心化应用在点对点网络上运行。与传统
    Web 应用不同，这些应用不会遭受单一故障点的影响。
- en: These peer-to-peer networks are defined by a protocol and are usually fault-tolerant
    to protect the users from many attack vectors. Compared to a client-server model,
    it is very difficult to compromise a peer-to-peer network due to its distributed
    topology. Incentivization and penalties in a blockchain protocol make it more
    difficult to compromise the network as the cost of an attack is much higher than
    the returns gained from such an attack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点对点网络由一种协议定义，并且通常具有容错性，以保护用户免受许多攻击向量的影响。与客户端-服务器模型相比，由于其分布式拓扑结构，很难 compromise
    一个点对点网络。在区块链协议中的激励机制和惩罚措施使得 compromise 网络的成本远高于从此类攻击中获得的回报。
- en: Although decentralized applications address the two aforementioned problems,
    the cost of running business and mission-critical applications is challenging
    due to the volatility associated with token prices. At the time of writing, efforts
    are being made to reduce this volatility in terms of signing the transaction on
    behalf of the user or paying the user in advance for the transactional costs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然去中心化应用解决了前述两个问题，但由于与代币价格波动相关的成本，运行业务和关键任务应用的成本仍然具有挑战性。在撰写本文时，正在努力降低这种波动性，以便代表用户签署交易或提前为交易成本支付用户。
- en: So far, we have learned that traditional web applications and centralized services
    offer predictable performance at a fixed cost, whereas decentralized applications
    offer independent services without risking the network, vendor, or user. However,
    we have also learned that, in achieving independence using decentralized applications,
    we invite some degree of uncertainty in terms of fees. Finally, we have also observed
    that users opt for centralized models to achieve performance and security in an
    internal environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到传统 Web 应用和集中式服务以固定成本提供可预测的性能，而去中心化应用则提供独立的服务，而不会 risking 网络、供应商或用户。然而，我们也了解到，通过使用去中心化应用来实现独立性，我们在费用方面引入了一定程度的不确定性。最后，我们还观察到，用户选择集中式模型以在内部环境中实现性能和安全性。
- en: Now, let's try to understand how decentralized intelligent applications are
    evolving on the internet.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试了解互联网上去中心化智能应用是如何发展的。
- en: '**Decentralized intelligent applications**'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**去中心化智能应用**'
- en: Now that business models are leaning toward transparency and efficiency, there
    is a need for a new design pattern that favors a combination of traceability,
    decentralization, and predictability. Decentralized intelligent applications can
    use reliable infrastructure in a peer-to-peer network. This network is composed
    of nodes operated by more than one entity that may have vested interests in serving
    users and growing their businesses. Also, transactions on this kind of network
    are usually confirmed in a very short period of time at significantly lower fees.
    Similar to large public networks, it would be costly to attempt to compromise
    the network due to the deficit between the benefit of the attack and the cost
    of performing an attack.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于商业模式正在倾向于透明和效率，需要一种新的设计模式，有利于追溯性，去中心化和可预测性的组合。去中心化智能应用程序可以在点对点网络中使用可靠的基础设施。这个网络由多个实体运营的节点组成，它们可能对为用户服务和发展他们的业务感兴趣。此类网络上的交易通常会在非常短的时间内确认，而费用显著更低。类似于大型公共网络，由于攻击的利益和执行攻击的成本之间的差值，试图破坏网络将会非常昂贵。
- en: A key differentiator between this pattern and others is the closer integration
    of AI models with the help of decentralized databases. This makes it possible
    to build mission-critical and business-centric applications with traceability
    and insights as first-class features.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模式之间的一个关键区别在于AI模型的更紧密集成，借助去中心化数据库的帮助。这使得可能构建具有可追溯性和洞察力作为一流特性的使命关键和业务中心的应用程序。
- en: Now, let's summarize our analysis of all three models.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结对所有三种模型的分析。
- en: '**Contrast and analysis**'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**对比和分析**'
- en: We can summarize our learning and decide the right design pattern by weighing
    the benefits of each pattern against its trade-offs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过权衡每种模式的优势和权衡，我们可以总结我们的学习并决定正确的设计模式。
- en: In the case of traditional web applications, we may observe better performance
    when using a centralized and dedicated infrastructure. The transactions will achieve
    near-immediate finality at a reasonable and fixed cost for the company developing
    the app. However, this design pattern may lack some security and traceability
    features offered by other design patterns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web应用程序的情况下，当使用集中和专用的基础设施时，我们可能会观察到更好的性能。交易将以合理且固定的成本实现几乎立即的最终性，适用于开发应用程序的公司。然而，这种设计模式可能缺乏其他设计模式提供的一些安全性和可追溯性功能。
- en: In the case of decentralized applications, we may observe reasonable performance
    and traceability at the expense of variable transaction costs. Compared to traditional
    web applications, the speed of transactions may be impacted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在去中心化应用程序的情况下，我们可能会观察到合理的性能和可追溯性，但以可变的交易成本为代价。与传统Web应用程序相比，交易速度可能会受到影响。
- en: In the case of decentralized intelligent applications, we may observe predictable
    costs and near-immediate finality for most of the transactions. Apart from better
    cost, speed, security, and performance, the pattern also provides decentralized
    storage for building privacy-preserving applications that can be used to derive
    actionable insights with ethical usage of AI models on user data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在去中心化智能应用程序的情况下，我们可能会观察到大多数交易的可预测成本和几乎即时的最终性。除了更好的成本，速度，安全性和性能，该模式还为构建保护隐私的应用程序提供了去中心化存储，这些应用程序可以用于在用户数据上以道德方式使用AI模型从中获得可操作洞见。
- en: 'Now that we''ve analyzed the three major patterns, let''s end this section
    with a table summarizing their differences:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经分析了三种主要模式，让我们用一个表格总结它们的区别：
- en: '|  | **Traditional web application (App)** | **Decentralized application (DApp,
    dApp, or Dapp)** | **Decentralized intelligent application (DIApp)** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| | **传统Web应用程序（App）** | **去中心化应用程序（DApp，dApp或Dapp）** | **去中心化智能应用程序（DIApp）**
    |'
- en: '| **Network** | The client-server model is used with n-tier architectures.
    | A distributed network topology is used to allow anyone to join the network.
    | A distributed network topology is used to allow anyone to join the network.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **网络** | 使用客户-服务器模型与n层架构。 | 使用分布式网络拓扑来允许任何人加入网络。 | 使用分布式网络拓扑来允许任何人加入网络。 |'
- en: '| **Security** | Single points of failure are very likely. Data can be hacked
    or leaked due to weak encryption or centralized control over data. | The user
    is the owner of the data. All the data and operations are secured by a unique
    key pair. Limited data can be stored. | Users can store and operate on larger
    sizes of data with the same key pair security in order to own their own data.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **安全** | 单点故障的可能性很高。数据可能会因加密薄弱或数据集中控制而遭到黑客攻击或泄漏。 | 用户是数据的所有者。所有数据和操作都由唯一的密钥对保护。存储的数据量有限。
    | 用户可以使用相同的密钥对安全地存储和操作更大量的数据，以便拥有自己的数据。 |'
- en: '| **Cost** | Fixed costs in managing a dedicated infrastructure throughout
    the year. | The costs of transactions are volatile since the costs depend on the
    price of the native token in the blockchain. | Prices are relatively stable in
    smaller yet decentralized groups of nodes. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 一年内管理专用基础设施的固定成本。 | 交易成本不稳定，因为成本取决于区块链中本地代币的价格。 | 在小型但分散的节点组中，价格相对稳定。
    |'
- en: '| **Transparency** | Apps and data operations are not transparent to the user
    or other stakeholders. | The logic of the app and most of the operations are transparent.
    Private transactions are optionally allowed. | Logic and operations are transparent,
    with options to use privacy without harming security. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **透明度** | 应用程序和数据操作对用户或其他利益相关者不透明。 | 应用程序的逻辑和大部分操作都是透明的。私人交易是可选的。 | 逻辑和操作是透明的，提供了使用隐私而不损害安全性的选项。
    |'
- en: '| **Performance** | A large number of transactions can be processed with immediate
    finality | The throughput is low due to the large distribution of nodes. Finality
    is slower. | Transaction throughputs are higher. Finality is also achieved quickly.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **性能** | 可以处理大量交易并实现即时最终性 | 由于节点的大规模分布，吞吐量较低。最终性较慢。 | 交易吞吐量较高。最终性也能迅速实现。
    |'
- en: '| **Privacy** | Complete privacy and the anonymity of user data is seldom practiced
    by companies while harnessing insights as data is hosted on a centralized or distributed
    database controlled by organizations. | Anonymity is practiced through wallets,
    but data management on blockchain networks is a costly affair. The privacy of
    the user depends on the application''s policies. AI models are not used regularly.
    | DIApps aim to provide complete privacy and anonymity to users while providing
    meaningful and actionable insights using AI in a fair manner, without hampering
    the anonymity of the user. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **隐私** | 公司很少会在利用洞察力时练习完全的用户数据隐私和匿名性，因为数据托管在由组织控制的中心化或分散式数据库上。 | 通过钱包进行匿名处理，但在区块链网络上管理数据是一件昂贵的事情。用户的隐私取决于应用程序的政策。
    AI 模型不经常使用。 | DIApps旨在为用户提供完整的隐私和匿名性，同时以公平的方式利用AI提供有意义且可操作的洞察力，而不会损害用户的匿名性。 |'
- en: The preceding table shows the benefits and drawbacks of different application
    patterns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的表格显示了不同应用程序模式的优缺点。
- en: Now that we have had a quick recap of the evolution of apps, let's build a sample
    DIApp that addresses real-world challenges.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速回顾了应用程序的演变，让我们构建一个解决现实世界挑战的样本 DIApp。
- en: '**Building a sample DIApp**'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**构建样本 DIApp**'
- en: In this section, we will cover the problem statement, find a solution to the
    stated problem, come up with a technical architecture as per the DIApp design
    pattern, and observe how to develop all the deliverables needed to launch the
    DIApp.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将涵盖问题陈述，找到所述问题的解决方案，根据 DIApp 设计模式设计技术架构，并观察如何开发启动 DIApp 所需的所有可交付成果。
- en: Let's begin by understanding the problem statement in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下部分了解问题陈述。
- en: '**Problem statement**'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**问题陈述**'
- en: 'A novel coronavirus that goes by the name of **Severe Acute Respiratory Syndrome
    coronavirus 2** (**SARS-CoV-2**) has created a new pandemic outbreak called **Coronavirus
    Disease 2019** (**COVID-19**). At the time of writing this chapter, the virus
    has infected over 11 million people globally through various modes of transmission,
    tragically taking the lives of more than 500,000 people: a sad page in the history
    books of humanity. Although efforts have been made by local governments to reduce
    these infections, some virus carriers appear to be asymptomatic. This means that
    a person may be carrying the virus without knowing it. Sometimes, the prescribed
    checkups could also fail to recognize the virus in its early stage of incubating
    inside the patient''s body.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为**严重急性呼吸综合症冠状病毒2型**（**SARS-CoV-2**）的新型冠状病毒引发了一场名为**2019冠状病毒病**（**COVID-19**）的新型大流行。在撰写本章节时，该病毒已经通过各种传播方式感染了全球超过1100万人，不幸地夺走了50万人以上的生命：这是人类历史书中的悲伤一页。尽管地方政府已经采取了措施减少这些感染，但一些病毒携带者似乎是无症状的。这意味着一个人可能携带病毒却不知情。有时，规定的检查也可能无法在患者体内孵化的早期阶段识别出病毒。
- en: '**Current challenges**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**当前挑战**'
- en: This virus has introduced humanity to new challenges. Let's take a look at the
    two major challenges that are, at the time of writing, being faced.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种病毒给人类带来了新的挑战。让我们来看看在撰写本章节时所面临的两个主要挑战。
- en: '**Detecting the virus in asymptomatic patients**: As discussed previously,
    the SARS-CoV-2 virus poses a new challenge to medical professionals in terms of
    identifying infections in a human body that fails to show any symptoms. Such people
    may be allowed to continue their daily life, thus risking the wellness of the
    entire community they belong to. This leaves a gaping hole in security checks,
    which may allow asymptomatic people to access public services or interact with
    people who may potentially contract the virus from the patient.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测无症状患者中的病毒**：正如前面讨论的，SARS-CoV-2病毒给医务人员带来了一个新的挑战，即识别人体内没有显示任何症状的感染。这些人可能被允许继续他们的日常生活，从而使他们所属社区的整体健康处于风险之中。这在安全检查中留下了一个巨大的漏洞，可能允许无症状的人接触公共服务或与可能从患者那里感染病毒的人交往。'
- en: '**Tracing the transmission of the virus**: Although it is difficult to detect
    the virus in its early stages for a few people who are asymptomatic, symptoms
    do surface over time. Once they do, and the person tests positive, it is important
    to trace back all the actions of the diagnosed patient in order to contain the
    infection. This is difficult to achieve without an accurate history of the patient''s
    activity over the past couple of weeks. Any efforts to jot it down will need time
    and will remain inaccurate due to human errors.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追踪病毒的传播**：尽管对于一些无症状的人，早期检测病毒是困难的，但随着时间的推移，症状会逐渐显现。一旦出现症状，并且这个人检测为阳性，追踪被诊断患者的所有行动以遏制感染就显得非常重要。在没有患者过去几周活动的准确历史记录的情况下，这是难以实现的。任何记录这些行动的努力都需要时间，并且由于人为错误而保持不准确。'
- en: To contain such infections, medical professionals resort to contact tracing.
    We'll learn more about contact tracing in the following section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遏制这种感染，医务人员采取了联系追踪措施。我们将在下一节中了解更多关于联系追踪的内容。
- en: '**Contact tracing**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**联系追踪**'
- en: Contact tracing is a process of identifying all the people involved in the patient's
    activities over the past few days or weeks since the diagnosis of the infection.
    This is a process carried out by health department officials in coordination with
    law enforcement agencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 联系追踪是一个过程，目的是识别过去几天或几周参与患者活动的所有人，自感染被诊断以来。这是卫生部门官员在与执法机构协调的过程。
- en: 'A generic workflow of contact tracing is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 联系追踪的一般工作流程如下：
- en: The doctor has diagnosed the patient as positive for SARS-CoV-2.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 医生已经诊断该患者为SARS-CoV-2阳性。
- en: A contact tracer is assigned to the case.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个联系追踪员被分配到这个案例。
- en: The contact tracer interacts with the patient to identify the activity of the
    patient.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系追踪员与患者互动以识别患者的活动。
- en: Depending on the jurisdiction/country, the contact tracer is responsible for
    collecting accurate information about the patient's whereabouts for a designated
    number of days or weeks. For example, a patient that tests positive in India might
    be asked to share their activity for the past 14 calendar days.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据司法管辖区/国家的不同，联系追踪员负责收集关于患者过去一定天数或周数的准确信息。例如，在印度，测试阳性的患者可能被要求分享他们过去14天的活动情况。
- en: Based on the input provided by the patient, the contact tracers may verify some
    information.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据患者提供的信息，接触追踪者可能会验证一些信息。
- en: If the information shared by the patient is convincing, more contact tracers
    are hired to identify the first-degree people infected by the patient.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果患者分享的信息令人信服，将聘请更多的接触追踪者来确定受到患者感染的一级人员。
- en: Once this manual search is over, the people who have been contacted are tested
    for the virus.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这种手动搜索结束，被联系到的人将接受病毒测试。
- en: Depending on the jurisdiction, the people who have been contacted may be placed
    under mandatory quarantine for up to 14 days to check whether symptoms develop.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据司法管辖权，被联系到的人可能会被强制隔离14天，以检查是否出现症状。
- en: The quarantined people are tested for the virus periodically.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被隔离的人会定期接受病毒检测。
- en: If there are no signs of the virus, the suspected people are released. However,
    if they test positive, the same process repeats.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有病毒迹象，疑似病人将被释放。但是，如果他们测试呈阳性，同样的过程将重复。
- en: Although you may find this process to be tightly planned and sophisticated,
    most of the steps mentioned here are manually carried out by many countries. Although
    some countries have opted to automate contact tracing with the help of digital
    technologies, they do not consider all the agents of infection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能会觉得这个过程安排得非常紧密和复杂，但许多国家仍然采用手动方式执行这里提到的大部分步骤。尽管一些国家选择利用数字技术自动化接触追踪，但他们并未考虑所有的感染因素。
- en: '**Issues with contact tracing**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接触追踪的问题**'
- en: As we discussed previously, contact tracing is an arduous process. Although
    some countries have successfully been able to automate this process digitally,
    it is very difficult to track infections from non-human sources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，接触追踪是一个艰巨的过程。虽然一些国家已成功地能够通过数字方式自动化这个过程，但是很难跟踪来自非人类来源的感染。
- en: We tend to forget that a significant number of hypotheses claim that the origin
    of the virus leads back to bats, animals that live in forests and rural and urban
    areas. It has also been observed by many researchers that the virus can remain
    on many forms of surfaces for a few hours. Modern supply chains are so advanced
    that goods can be transferred from one point to another in just a matter of hours.
    Unfortunately, this velocity of the supply chain provides a potential window for
    the virus being transmitted from one container to another while the cargo is airborne.
    Such infections not only risk the supply chain of normal goods but could also
    infect a wide range of people who may use these products without effective sanitization.
    Assessing the risks of infection before delivering goods to the public should
    be considered. Similarly, we want to protect our pets and other important species
    of animals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们往往忘记，有大量的假设认为病毒的起源可以追溯到生活在森林、乡村和城市地区的蝙蝠。许多研究人员也观察到，这种病毒可以在许多形式的表面上保留几个小时。现代供应链非常先进，货物可以在几个小时内从一个地方转移到另一个地方。不幸的是，供应链的高速提供了一个潜在窗口，病毒可能在货物在空中运输的时候从一个容器传播到另一个容器。这样的传染不仅危及正常商品的供应链，还可能感染许多使用这些产品但没有进行有效消毒的人群。在向公众交付货物之前评估感染的风险是必须考虑的。同样，我们希望保护我们的宠物和其他重要物种。
- en: Hence, it is imperative to consider monitoring animals and non-living objects
    for infections of the SARS-CoV-2 virus. As such, there is a need for a digital
    contact tracing algorithm that can address the possibility of infections among
    these two agents in the ecosystem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要考虑监测动物和非生物物体是否感染了SARS-CoV-2病毒。因此，需要一种数字接触追踪算法，可以解决这两个生态系统中感染的可能性。
- en: With the need for digital contact tracing for animals and objects clearly established,
    let's try to formulate a solution approach.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字接触追踪对动物和物体的需求得到明确确认，让我们试图制定解决方案的方法。
- en: '**Solution approach**'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: Since we are developing a sample application to track potential infections from
    animals and non-living objects, I would like to name the solution **Decentralized
    Intelligent Contact Tracing for Animals and Objects** (**DICTAO**). As discussed
    in the preceding section, there is a need to track animals and objects. We must
    be able to track down the infection status at a granular level for the sake of
    transparency. A public blockchain with a decentralized and open ledger can offer
    this feature. Similarly, we must understand that the global supply chain is a
    busy world of its own. Manually tracking down all potential contacts is virtually
    impossible. Similarly, it is very difficult to identify potential contacts between
    animals. Hence, there is a need for an automated but intelligent way of identifying
    the potential infections and separating them from the noise. Thus comes the need
    for blockchain and AI in tracing animals and objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个样例应用程序来跟踪动物和非生物对象的潜在感染情况，我想将解决方案命名为**动物和物体的去中心化智能接触追踪**（**DICTAO**）。如前文所述，有必要跟踪动物和物体。为了透明度，我们必须能够在细粒度水平上追踪感染状态。具有分散和开放分类帐的公共区块链可以提供此功能。同样，我们必须理解全球供应链是一个繁忙的世界。手动跟踪所有潜在联系几乎是不可能的。同样，很难确定动物之间的潜在联系。因此，有必要采用自动但智能的方式来识别潜在感染并将其与噪音分离。因此，区块链和人工智能在追踪动物和物体方面的需求就此产生。
- en: In the following sections, we will see how DICTAO can be built.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何构建 DICTAO。
- en: '**Choosing the blockchain technology**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择区块链技术**'
- en: As discussed previously, blockchains are essential in maintaining the transparency
    of the status of animals and objects. Since this is a tutorial to building a sample
    DIApp, I am going to keep the context very simple and accessible to everyone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，区块链对于维护动物和物体状态的透明度至关重要。由于这是一个构建样例 DIApp 的教程，我将保持上下文非常简单和易于理解。
- en: 'The Ethereum network has many testnets for developers to deploy and test their
    applications in a sandboxed test environment. One of the most famous test networks
    is called the **Kovan** testnet. Kovan is a **Proof of Authority** (**PoA**)-based
    Ethereum blockchain network. It is maintained by the Ethereum developer community.
    The Kovan testnet is known for its speed of execution, reliability, and free access
    to test ethers made available through a faucet. You can read more about the Kovan
    testnet here: [https://kovan-testnet.github.io/website/](https://kovan-testnet.github.io/website/).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊网络有许多测试网络供开发人员在沙盒测试环境中部署和测试其应用程序。最著名的测试网络之一称为**Kovan**测试网络。Kovan 是基于**PoA**（权威证明）的以太坊区块链网络。它由以太坊开发者社区维护。Kovan
    测试网络以其执行速度、可靠性和通过 Faucet 提供的免费测试以太币而闻名。您可以在这里阅读有关 Kovan 测试网络的更多信息：[https://kovan-testnet.github.io/website/](https://kovan-testnet.github.io/website/)。
- en: Faucet is a piece of software used by smart contract developers and users to
    acquire testnet tokens for free, without the need for mining them on their local
    PCs. Most of the blockchain testnets have their own respective faucets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Faucet 是供智能合约开发人员和用户免费获取测试网令牌的软件，而无需在本地 PC 上进行挖掘。大多数区块链测试网络都有各自的 Faucet。
- en: 'I have chosen Kovan to only help you understand and get along with blockchains
    as easily as possible. Kovan is a test network, so it is not intended to be used
    for any production-grade Ethereum applications. If you wish to deploy this example
    for a live use case, I recommend that you either use the Ethereum mainnet or prefer
    sidechains such as Matic. If you wish to deploy it live, you can learn more about
    the Matic sidechain here: [https://matic.network/](https://matic.network/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了 Kovan，只是为了帮助您尽可能轻松地理解和适应区块链。Kovan 是一个测试网络，因此不打算用于任何生产级别的以太坊应用程序。如果您希望为实际用例部署此示例，我建议您要么使用以太坊主网，要么偏好于
    Matic 等侧链。如果您希望实时部署它，您可以在这里了解更多关于 Matic 侧链的信息：[https://matic.network/](https://matic.network/)。
- en: '**Choosing a decentralized database**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择去中心化数据库**'
- en: Digital contact tracing often involves collecting data. To enable accuracy and
    provide high-quality predictions, more data could be collected at a high frequency.
    Over time, data can become very large. Such data should not be stored on a blockchain
    directly since it incurs a high cost. Also, storing huge amounts of data can often
    lead to bottleneck issues and may hamper the performance of a blockchain. Hence,
    there is a need to store the activity of the animals or objects in a decentralized
    database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数字接触追踪通常涉及收集数据。为了提高准确性并提供高质量的预测，可以以高频率收集更多的数据。随着时间的推移，数据可能会变得非常庞大。这样的数据不应直接存储在区块链上，因为这会产生高昂的成本。此外，存储大量数据通常会导致瓶颈问题，并可能影响区块链的性能。因此，有必要将动物或物体的活动存储在去中心化数据库中。
- en: I will be using the MóiBit REST API as the decentralized database for this sample
    DIApp. MóiBit offers a developer-friendly API environment, which makes it an easy
    choice.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 MóiBit 的 REST API 作为本示例 DIApp 的去中心化数据库。MóiBit 提供了一个开发者友好的 API 环境，这使得它成为一个容易的选择。
- en: Since MóiBit is an IPFS-based decentralized storage service, each change to
    a new file or an existing file generates a new hash. Similar to blockchains, each
    new hash represents a successful state change. However, updating the data on MóiBit
    will be cheaper and faster compared to blockchains. Since it is driven by hashes,
    the file's integrity is also secured and easily verifiable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MóiBit 是基于 IPFS 的去中心化存储服务，对新文件或现有文件的每一次更改都会生成一个新的哈希。类似于区块链，每个新的哈希代表了一个成功的状态变化。然而，与区块链相比，更新
    MóiBit 上的数据将更加便宜和快速。由于它是由哈希驱动的，文件的完整性也得到了保障，并且易于验证。
- en: To learn more about MóiBit's APIs, visit their documentation at [https://apidocs.moibit.io/](https://apidocs.moibit.io/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 MóiBit API 的更多信息，请访问其文档网站：[https://apidocs.moibit.io/](https://apidocs.moibit.io/)。
- en: '**Choosing an AI technique**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择一种人工智能技术**'
- en: Tracking innumerable objects and animals across an area – even a small one –
    will lead to a humongous quantity of data points. It is virtually impossible to
    perform contact tracing manually on these data points. Due to some low-quality
    data points, the efforts of a manual contact tracer could easily go to waste.
    As the number of positive cases increases, more pressure mounts on the manual
    contact tracers to close a case and move on to the next one. This could also lead
    to inaccurate identification of infections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪一个区域中的无数对象和动物——即使是一个小区域——将导致大量的数据点。在这些数据点上手动执行接触追踪几乎是不可能的。由于一些低质量的数据点，手动接触追踪者的努力很容易就会付诸东流。随着阳性病例数量的增加，手动接触追踪者的压力也会增加，以尽快关闭一个案例并转向下一个案例。这也可能导致感染的不准确识别。
- en: In order to reduce errors and automate the process of cleaning, ordering, grouping,
    and predicting the infections, we can leverage AI techniques.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少错误并自动化清理、排序、分组和预测感染的过程，我们可以利用人工智能技术。
- en: As discussed previously, contract tracing usually involves the process of analyzing
    the activity of the infected person/animal/object. It is safe to assume that snapshotting
    the location data, along with a timestamp of when it occurred, will provide enough
    insights into potential contact cases. Therefore, we will be analyzing geolocation
    data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，合同追踪通常涉及分析感染者/动物/物体的活动过程。可以安全地假设，对位置数据进行快照，以及发生时间戳，将为潜在接触案例提供足够的见解。因此，我们将分析地理位置数据。
- en: We'll use geospatial analysis to identify some anomalies in the data points.
    Specifically, we will be using the **Density-Based Spatial Clustering of Applications
    with Noise** (**DBSCAN**) algorithm to perform geospatial analysis to identify
    potential infections among animals and objects. It is a data clustering algorithm
    used to effectively group data points in a range under a cluster and drop the
    outliers that cannot be reached by other data points.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用地理空间分析来识别数据点中的一些异常情况。具体来说，我们将使用**基于密度的空间聚类算法与噪声**（**DBSCAN**）算法进行地理空间分析，以识别动物和物体之间的潜在感染情况。它是一种数据聚类算法，用于有效地将数据点分组在一个范围内，并且丢弃其他数据点无法到达的异常值。
- en: 'To learn more about the DBSCAN algorithm, consult the following Wikipedia article:
    [https://en.wikipedia.org/wiki/DBSCAN](https://en.wikipedia.org/wiki/DBSCAN).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 DBSCAN 算法的更多信息，请参阅以下维基百科文章：[https://en.wikipedia.org/wiki/DBSCAN](https://en.wikipedia.org/wiki/DBSCAN)。
- en: Now that we have decided what technologies and techniques will be used in the
    sample DIApp, let's try to formalize it in the form of a reference technical architecture
    by borrowing it from the DIApp design pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经决定了示例 DIApp 中将使用的技术和技巧，让我们尝试以 DIApp 设计模式的形式将其形式化为一个参考技术架构。
- en: '**The technical architecture of the sample DIApp**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**示例 DIApp 的技术架构**'
- en: 'In this section, I will be proposing the technical architecture of the sample
    DIApp. Based on the decisions made in the preceding sections, I have compiled
    all the solution components into one diagram, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将提出示例 DIApp 的技术架构。基于前面各节中所做的决策，我将所有解决方案组件编译成一个图表，如下所示：
- en: '![](img/fb964d60-6a4b-4ee4-9918-83c09b8c90f8.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb964d60-6a4b-4ee4-9918-83c09b8c90f8.png)'
- en: 'Fig 8.2: DIApp reference architecture of our sample application'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：我们示例应用的 DIApp 参考架构
- en: 'In the preceding diagram, we have represented all the solution components as
    per the DIApp reference architecture proposed in the DIApp design pattern. Now,
    let''s examine each component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们根据 DIApp 设计模式中提出的 DIApp 参考架构代表了所有解决方案组件。现在，让我们逐个查看每个组件：
- en: '**Sensor**: A sensor is a hardware device attached to the animal or object
    that needs to be tracked in case of infection. Each sensor is identified by a
    unique wallet address that is recognizable on the Ethereum blockchain. Also, it
    is important to note that each sensor gets a dedicated file on MóiBit where the
    location history of the corresponding sensor can be stored.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**传感器**：传感器是附在动物或需要在感染情况下进行跟踪的物体上的硬件设备。每个传感器都由在以太坊区块链上可识别的唯一钱包地址标识。此外，重要的是要注意，每个传感器都会在
    MóiBit 上获得一个专用文件，其中可以存储相应传感器的位置历史。'
- en: An application will run inside the sensor. This application is expected to automatically
    read its location and update the location to its dedicated file on MóiBit. The
    current location of the sensor can be accessed by making a call to a geolocation
    API. In our sample DIApp example, we are using the Google Maps API to retrieve
    the current location of the sensor. When called, the Google Maps Geolocation API
    returns the latitude, longitude, and accuracy of the coordinates back to the sensor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用将在传感器内运行。期望该应用能自动读取其位置并将位置更新到其在 MóiBit 上的专用文件中。传感器的当前位置可以通过调用地理位置 API 访问。在我们的示例
    DIApp 中，我们使用 Google Maps API 来检索传感器的当前位置。当调用时，Google 地图地理位置 API 将经度、纬度和坐标的准确性返回给传感器。
- en: For the sake of simplicity, we will be ignoring the accuracy value returned
    by the Google Maps API and uploading the rest of the data to MóiBit. Since the
    example DIApp is trying to demonstrate the convergence of AI and blockchain technologies,
    optimizations are not given priority in this book. Handling the accuracy of the
    data while predicting infections will take us out of the scope of this book. However,
    I look forward to solving that problem with you offline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将忽略 Google 地图 API 返回的准确性值，并将其余数据上传到 MóiBit。由于示例 DIApp 试图展示 AI 和区块链技术的融合，优化在本书中并不优先考虑。在预测感染时处理数据的准确性将超出本书的范围。然而，我期待与您线下解决这个问题。
- en: Now, once the sensor receives the response from the Google Maps Geolocation
    API, the data is restructured and uploaded to the dedicated location history file
    on MóiBit. We will discuss the design and structure of the client application
    in the *Developing the client code for sensors* section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦传感器收到来自 Google 地图地理位置 API 的响应，数据将被重组并上传到 MóiBit 上的专用位置历史文件中。我们将在 *开发传感器客户端代码*
    部分讨论客户端应用程序的设计和结构。
- en: '**Smart contract in the blockchain**: The significance of the smart contract
    in this sample DIApp is to maintain proof for each location update performed by
    every sensor. Every time a sensor updates its location history on MóiBit, a new
    function call is made to the smart contract to update the **Content Identifier**
    (**CID**) value for the corresponding wallet designated for the sensor. We will
    discuss the design and structure of the smart contract in later sections.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链中的智能合约**：在示例 DIApp 中，智能合约的重要性在于为每个传感器执行的每个位置更新维护证明。每当传感器在 MóiBit 上更新其位置历史时，将向智能合约发出新的函数调用，以更新为传感器指定的相应钱包的**内容标识符（CID）**值。我们将在后面的章节中讨论智能合约的设计和结构。'
- en: '**Contact tracing dashboard**: The contact tracing dashboard is a simple Express-based
    Node.js web application that spawns a local server to host a single HTML file.
    Through the dashboard web page rendered by the Node.js application, users can
    enter the suspected wallet ID. The web application performs basic form validation
    and returns a list of potentially infected wallet IDs, if any. We will discuss
    the design and structure of the contact tracing dashboard in later sections.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**接触追踪仪表板**：接触追踪仪表板是一个简单的基于Express的Node.js web应用程序，它生成一个本地服务器来托管单个HTML文件。通过Node.js应用程序呈现的仪表板网页，用户可以输入疑似的钱包ID。Web应用程序执行基本的表单验证，并返回任何潜在感染的钱包ID列表。我们将在后面的章节讨论接触追踪仪表板的设计和结构。'
- en: '**Contact tracing API**: The user input to track a suspected wallet ID is received
    by the contact tracing API. This is a backend API that also predicts the infected
    IDs in order to return them to the dashboard. We will discuss the design and structure
    of the contact tracing API in later sections.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**接触追踪API**：接触追踪API接收用户跟踪疑似钱包ID的输入。这是一个后端API，也会预测被感染的ID，以便将它们返回给仪表板。我们将在后面的章节讨论接触追踪API的设计和结构。'
- en: '**Developing the smart contract**'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**开发智能合约**'
- en: In this section, we will discuss the design and structure of the smart contract
    used to record the proof each time the location history is updated. As discussed
    in the previous section, we will be using the Ethereum blockchain and therefore
    I will be showing you how to develop the smart contract in the Solidity language.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论用于记录每次位置历史更新的证据的智能合约的设计和结构。如前一节所述，我们将使用以太坊区块链，因此我将向您展示如何用Solidity语言开发智能合约。
- en: If you are not familiar with the Solidity programming language, I suggest that
    you take a look at their website for more technical details, know-how, and documentation: [https://solidity.readthedocs.io/](https://solidity.readthedocs.io/en/v0.6.11/).
    It is important that you understand the semantics of the Solidity programming
    language to understand this section and learn the benefits of a smart contract
    in the proposed DIApp solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Solidity编程语言不熟悉，我建议你查看他们的网站以获取更多技术细节、知识和文档：[https://solidity.readthedocs.io/](https://solidity.readthedocs.io/en/v0.6.11/)。理解Solidity编程语言的语义对于理解本节内容并了解建议DIApp解决方案的智能合约的好处至关重要。
- en: 'Let''s start by identifying the actors. We know that the solution aims to trace
    infections that originate from animals and objects. Hence, we understand that
    a tracking device or sensor is necessary. Let''s assume that each sensor can be
    identified by a unique Ethereum wallet address. Apart from sensors, we also have
    end users such as medical professionals and enforcement teams who may want to
    identify the potentially infected actors from a given animal or object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从识别参与者开始。我们知道解决方案旨在追踪源自动物和物体的感染。因此，我们了解到跟踪设备或传感器是必要的。假设每个传感器都可以通过一个唯一的以太坊钱包地址进行识别。除了传感器，我们还有医疗专业人员和执法团队等最终用户，他们可能希望从给定的动物或物体中识别潜在的感染者：
- en: 'Each time the sensor has a new location to update on MóiBit, it makes the necessary
    update and receives a hash back from MóiBit. We are using that hash and the wallet
    address from the calling sensor to maintain a mapping on the smart contract. Each
    time a new location coordinate is updated by a sensor, the corresponding value
    of the sensor''s wallet address needs to be updated. Hence, we need to define
    a mapping to record any changes that are made to the location history of each
    sensor. We can do this with the following mapping:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当传感器有新的位置在MóiBit上更新时，它就会进行必要的更新，并从MóiBit那里收到一个哈希。我们正在使用该哈希和来自调用传感器的钱包地址在智能合约上维护一个映射。每当传感器更新一个新的位置坐标时，传感器的钱包地址对应的值就需要更新。因此，我们需要定义一个映射来记录对每个传感器位置历史所做的任何更改。我们可以用以下映射来做到这一点：
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding mapping, we can see that the address serves as a unique key
    to an updated string value, which is basically the CID received from MóiBit when
    the location of the corresponding sensor is updated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述映射中，我们可以看到地址作为一个唯一键，对应一个更新的字符串值，这基本上是从MóiBit收到的CID，当对应传感器的位置更新时。
- en: 'Apart from the preceding mapping, we will also need another mapping to track
    all the sensors by their addresses to confirm whether they have ever updated their
    location. We can achieve this by persisting a list of all the wallet addresses
    in the following mapping:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了前面的映射之外，我们还需要另一个映射来通过它们的地址跟踪所有传感器，以确认它们是否曾经更新过它们的位置。我们可以通过在以下映射中持久保存所有钱包地址的列表来实现这一点：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding mapping, we can see that every sensor that has ever updated
    its history will be recorded in this mapping. We will learn more about the reason
    behind this soon.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述映射中，我们可以看到，每个更新了历史记录的传感器都会记录在这个映射中。我们很快就会了解到背后的原因。
- en: 'Finally, we will record the address of each and every sensor that has ever
    updated its history to this smart contract with the following array of wallet
    addresses:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将每个曾经更新过历史记录的传感器的地址记录到以下钱包地址数组中：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding array declaration, designated users can access the list of
    all the addresses that have ever updated their location history in the smart contract.
    Do not confuse the `deviceIDs` array with the `deviceIDExists` mapping. The array
    is used to directly access each and every sensor's wallet address, whereas the
    mapping is used to check whether a sensor has already updated the location history
    before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的数组声明中，指定用户可以访问智能合约中曾经更新过其位置历史记录的所有地址列表。不要将`deviceIDs`数组与`deviceIDExists`映射混淆。该数组用于直接访问每个传感器的钱包地址，而映射用于检查传感器是否已经更新了位置历史记录。
- en: 'Before we move on to the functional aspects of this smart contract, we have
    two more declarations: a modifier and an event.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论这个智能合约的功能方面之前，我们还有两个声明：一个修改器和一个事件。
- en: A modifier is a conditional instruction that must be fulfilled before executing
    a function. If the conditions of a modifier for a function are not satisfied,
    that function call will not happen. In our case, we use a modifier to control
    who can update the location history mapping: `deviceIDToLatestCID`. As you may
    have observed, this mapping needs to be updated with the CIDs pointing to the
    latest location history of a sensor. But we also need to make sure that only the
    sensor can update its own value. Other sensors, users, or developers should not
    be allowed to update the location history of an unknown sensor. This important
    design decision will prevent other rogue actors from corrupting the reputation
    of a good standing sensor on the blockchain.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改器是在执行函数之前必须满足的条件指令。如果函数的修改器条件不满足，则不会发生函数调用。在我们的情况下，我们使用一个修改器来控制谁可以更新位置历史记录映射：`deviceIDToLatestCID`。正如您可能已经观察到的那样，这个映射需要使用指向传感器最新位置历史记录的CID进行更新。但我们还需要确保只有传感器才能更新自己的值。其他传感器、用户或开发人员不应被允许更新未知传感器的位置历史记录。这个重要的设计决定将防止其他恶意行为者破坏区块链上正常传感器的声誉。
- en: 'To achieve this, we can use the following modifier:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们可以使用以下修改器：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the preceding modifier declaration, we can observe that a function with
    the preceding modifier is executed only if the caller is the same as the address
    whose location history is being updated in the blockchain. We will understand
    the implication of this `onlyBy` mapping when we understand how the location is
    updated by the `setLatestCID` function. But before that, let's quickly go through
    one last declaration of an event.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的修改器声明中，我们可以观察到，只有在调用者与正在区块链中更新其位置历史记录的地址相同时，才会执行具有前述修改器的函数。当我们了解到位置是如何通过`setLatestCID`函数更新时，我们将理解这个`onlyBy`映射的含义。但在此之前，让我们快速浏览一下事件的最后声明。
- en: Events are very helpful when working on complex use cases. As a user who may
    be depositing some ethers or other tokens to a wallet, we wait for the transaction
    receipt as confirmation. For confirmation of some logical execution, we can't
    just wait for transaction receipts. There may be other sub-components that may
    have to be triggered, depending on the successful execution of the logic. Events
    come to our rescue here. Events in Solidity are a logging feature that helps non-blockchain
    applications take a cue point and continue with their execution.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理复杂用例时，事件非常有用。作为可能将一些以太币或其他代币存入钱包的用户，我们等待交易收据作为确认。对于某些逻辑执行的确认，我们不能只等待交易收据。可能需要触发其他子组件，具体取决于逻辑的成功执行。这时，事件就派上了用场。Solidity中的事件是一种日志记录功能，它帮助非区块链应用程序找到一个线索点，并继续执行。
- en: 'We''ll declare one event in our smart contract, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的智能合约中声明一个事件，如下所示：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the preceding event declaration, we can see that an event can be emitted
    with the wallet address of a sensor, along with its latest CID. This event is
    emitted every time the mapping is successfully updated with the new CID pointing
    to the latest location history of a sensor on MóiBit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的事件声明中，我们可以看到事件可以与传感器的钱包地址一起被发出，以及它的最新CID。每当映射成功更新为指向MóiBit上传感器最新位置历史的新CID时，就会发出这个事件。
- en: 'We will learn more about the application of this `MappingUpdated` event by
    looking in the `setLatestCID` function body, as shown here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过查看`setLatestCID`函数体来更多了解`MappingUpdated`事件的应用，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the preceding function declaration, `setLatestCID` is a
    setter function that allows each and every sensor to update its own location history
    by passing its wallet address, along with the CID pointing to the latest history
    on MóiBit. The `address` and `string` types are used to define the `deviceID`
    and `latestCID` input parameters. `deviceID` is the wallet address of the sensor,
    which is calling the function, while `latestCID` is the hash pointing to the latest
    history of the corresponding sensor on MóiBit. The `public` keyword defines that
    the function can be called by anyone globally. Thereafter, we see the `onlyBy`
    modifier being used to validate the function call. It takes the same input argument,
    `deviceID`, and checks whether the caller intending to update the location history
    is the sensor itself. If the modifier conditions are validated to be true, the
    remaining function body is executed. Otherwise, the transaction will be reverted.
    Now that we have a fair understanding of the `setLatestCID` function's header,
    let's understand its body.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述函数声明中可以看到，`setLatestCID`是一个setter函数，允许每个传感器通过传递其钱包地址和指向MóiBit上最新历史的CID来更新自己的位置历史。`address`和`string`类型用于定义`deviceID`和`latestCID`输入参数。`deviceID`是调用函数的传感器的钱包地址，而`latestCID`是指向MóiBit上相应传感器最新历史的哈希。`public`关键字定义函数可以被全局任何人调用。然后，我们看到`onlyBy`修饰符被用来验证函数调用。它接受相同的输入参数`deviceID`并检查意图更新位置历史的调用者是否是传感器本身。如果修改器的条件验证为真，剩余的函数体将被执行。否则，交易将被撤销。既然我们对`setLatestCID`函数的标题有了充分的了解，现在让我们了解它的体。
- en: Inside the function's body, we can observe that the `latestCID` value is assigned
    to `deviceID` immediately. Once the mapping is updated, it checks whether the
    sensor had previously updated its location. This is made possible by checking
    the status bit for the corresponding sensor's wallet address in the `deviceIDExists`
    mapping. If no entry exists for the given wallet address, it is added to the `deviceIDExists`
    mapping and the corresponding status bit value is set to 1\. Simultaneously, we
    can also observe that we are appending the `deviceIDs` array to the new array.
    Updating this array under this condition ensures that the wallet address is not
    added to the array again as a duplicate. This means that the `setLatestCID` function
    only appends the wallet address when a new sensor is onboarded to the smart contract.
    Finally, once the location mapping is updated and status bits are managed, the
    `MappingUpdated` event is emitted by the function. You can see that the input
    parameters have been supplied in the parentheses to log the event for corresponding
    values. This summarizes the details of the `setLatestCID` setter function. Now,
    let's take a look at some of the other `getter` functions in the smart contract.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，我们可以观察到`latestCID`的值立即被赋给了`deviceID`。一旦映射被更新，它会检查传感器是否之前更新了它的位置。这是通过检查`deviceIDExists`映射中相应传感器钱包地址的状态位来实现的。如果给定钱包地址没有条目存在，它会被添加到`deviceIDExists`映射中，并且相应的状态位值被设置为1。同时，我们还可以观察到我们正在将`deviceIDs`数组附加到新数组上。在这种条件下更新此数组可以确保钱包地址不会作为重复项再次添加到数组中。这意味着`setLatestCID`函数只在新的传感器上线到智能合约时追加钱包地址。最后，一旦位置映射被更新并且状态位被管理，`MappingUpdated`事件就会被函数发出。你可以看到在括号中提供了输入参数来记录相应值的事件。这总结了`setLatestCID`设置函数的细节。现在，让我们来看一些智能合约中的其他`getter`函数。
- en: Once we set the location history mapping with a new CID for a given sensor,
    we may have to read the mapping in case we need the details of a sensor.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们为给定的传感器使用新的CID设置了位置历史映射，我们可能需要读取映射以获取传感器的详细信息。
- en: 'Hence, we will define a `getter` function to read the latest CID of the sensor
    from the mapping, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将定义一个`getter`函数来从映射中读取传感器的最新CID，如下所示：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `getter` function, `getLatestCID`, reads one input parameter.
    The `deviceID` input parameter represents the wallet address of a sensor, with
    the Solidity type address. Since anyone should be able to read the proof that
    a sensor is updating its location from time to time, we have to make this `getter`
    function accessible globally. This is possible by using the `public` keyword.
    Also, since this is a function that only fetches the data from the blockchain
    and does not intend to make changes, it is also required to use the `view` keyword.
    This ensures that the `getLatestCID` function has read-only powers. Since we want
    anybody to be able to call the function, we do not have modifiers for this function.
    In the function's body, we can only see one line of instructions, and that is
    to return the CID value of the corresponding sensor from the `deviceIDToLatestCID`
    mapping. Since the returned value is a string that has been defined in the mapping,
    the function's header also defines the same. This summarizes the `getter` function, `getLatestCID`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`getter`函数`getLatestCID`读取一个输入参数。`deviceID`输入参数代表传感器的钱包地址，使用Solidity类型address。由于任何人都应该能够查看传感器定期更新其位置的证明，我们必须使这个`getter`函数全局可访问。这可以通过使用`public`关键字实现。另外，由于这是一个仅从区块链获取数据而不打算进行更改的函数，也需要使用`view`关键字。这确保了`getLatestCID`函数具有只读权限。由于我们希望任何人都能调用该函数，因此对于此函数我们没有修饰符。在函数体中，我们只能看到一行指令，即从`deviceIDToLatestCID`映射中返回相应传感器的CID值。由于返回值是在映射中定义的字符串，函数的头部也定义了同样的。这总结了`getter`函数`getLatestCID`。
- en: Now, let's look at the peripheral functions required by the backend scripts.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下后端脚本所需的附属函数。
- en: 'We''ll continue with one more `getter` function, as defined here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续定义另一个`getter`函数，如下所示：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `getDeviceIDsLength` is a getter function that does not take
    any input, but simply returns the current length of the `deviceIDs` array. Since
    we need to call this from a backend program, we have set the visibility of this
    function to `public` too. Similar to our previous function, this function is also
    a read-only function returning an unsigned integer value. Hence, `view` and `uint256`
    are used in the function's header. This summarizes the `getter` function, `getDeviceIDsLength`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`getDeviceIDsLength`是一个不接受任何输入参数，但简单返回`deviceIDs`数组当前长度的`getter`函数。因为我们需要从后端程序调用这个函数，所以我们也将此函数的可见性设置为`public`。与我们之前的函数类似，此函数也是一个只读函数，返回一个无符号整数值。因此，函数头部使用了`view`和`uint256`。这总结了`getter`函数`getDeviceIDsLength`。
- en: 'Now, let''s take a look at the last function in the contract:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看一下合约中的最后一个函数：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can  see, `getIDByIndex` is a `getter` function that returns the wallet
    address by the index value from the `deviceIDs` array. Since it is complicated
    to return composite values in Solidity directly, I have resorted to reading them
    one by one. If you are a sophisticated Solidity developer, you may eliminate this
    function and read the whole array directly at the client side without spending
    too much on gas costs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`getIDByIndex`是一个`getter`函数，根据`deviceIDs`数组的索引值返回钱包地址。由于在Solidity中直接返回复合值比较复杂，我必须逐个读取它们。如果您是一个精通Solidity开发者，您可以消除这个函数，并在客户端直接读取整个数组，而无需花费太多气体成本。
- en: 'The complete Solidity smart contract code is available at the following GitHub
    link: [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Solidity智能合约代码可在以下GitHub链接找到：[https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08)。
- en: Now that we have a way to manage proofs of location updates, let's go ahead
    and develop the client code for sensors, which can make location history updates
    on MóiBit and call this contract.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了管理位置更新证明的方法，让我们继续为传感器开发客户端代码，该代码可以在MóiBit上进行位置历史更新并调用该合约。
- en: '**Developing the client code for sensors**'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**为传感器开发客户端代码**'
- en: In this section, we will discuss the design and structure of the sensor application.
    The application is used to get the current location of the sensor in a periodic
    manner and update the location history to MóiBit. Once the location history is
    successfully updated, the new CID or hash received by MóiBit is used as proof
    that the sensor is in good standing by updating its location in a periodic manner.
    The applications will now call the appropriate blockchain function to maintain
    its reputation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论传感器应用程序的设计和结构。该应用程序用于以周期性的方式获取传感器的当前位置，并将位置历史记录更新到 MóiBit。一旦成功更新了位置历史记录，MóiBit
    收到的新 CID 或哈希值就可以作为证明，表明传感器通过周期性地更新其位置保持在正常状态。应用程序现在将调用适当的区块链功能，以维护其信誉。
- en: 'I have chosen to implement this application in the Python language since it
    is a well-known language for reference implementation across the fields of **AI**,
    the **Internet of Things** (**IoT**), and blockchain. It is important that you
    understand Python in order to make sense of this section. I suggest that you enroll
    yourself in a Packt micro-course to understand the basic concepts of the Python
    language: [https://subscription.packtpub.com/interactive-courses/data/introduction-to-python](https://subscription.packtpub.com/interactive-courses/data/introduction-to-python).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择用 Python 语言实现这个应用程序，因为它是跨 **AI**、**物联网**（**IoT**）和区块链等领域的参考实现中广泛使用的语言。理解
    Python 对于理解本节内容非常重要。我建议您注册一个 Packt 微课程，以了解 Python 语言的基本概念：[https://subscription.packtpub.com/interactive-courses/data/introduction-to-python](https://subscription.packtpub.com/interactive-courses/data/introduction-to-python)。
- en: 'My implementation is a single Python script. First things first, the following
    `import` statements are required to make the necessary calls in the Python script:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我的实现是一个单独的 Python 脚本。首先，以下 `import` 语句是确保 Python 脚本中必要调用的必需语句：
- en: 'Please make sure that you install the third-party libraries mentioned in the
    `import` statements using the `pip install` command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保您使用 `pip install` 命令安装 `import` 语句中提到的第三方库：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are some important variables that I''ll be using throughout the script.
    They are as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个脚本中，我将使用一些重要的变量。它们如下：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding code block, you can observe that `url` is a string variable
    with the URL to Google Maps' Geolocation API. `myobj` is a request object that
    I'll be passing to the Geolocation API during requests. Since the Geolocation
    API is protected by an API key registered by the user, I need to pass it along
    with every request I make to Google Maps' Geolocation API. Inside the `myobj`
    variable, you can observe that `key` is mapped to `API KEY`, which is set inside
    the shell and accessible through `os.environ[‘GMAPS_API_KEY’]`. Basically, it
    fetches the value of the `GMAPS_API_KEY` environment variable and uses it as the
    corresponding value to `key`. We will observe how to set the value for `GMAPS_API_KEY`
    in later sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码块中，您可以看到 `url` 是一个字符串变量，包含了指向 Google Maps 地理位置 API 的 URL。`myobj` 是我在请求期间将传递给地理位置
    API 的请求对象。由于地理位置 API 受到用户注册的 API 密钥保护，我需要在每次请求 Google Maps 地理位置 API 时传递这个密钥。在
    `myobj` 变量中，您可以看到 `key` 映射到 `API KEY`，这个值在 shell 中设置，可以通过 `os.environ['GMAPS_API_KEY']`
    访问。基本上，它获取了 `GMAPS_API_KEY` 环境变量的值，并将其用作 `key` 的对应值。我们将在后续部分看到如何设置 `GMAPS_API_KEY`
    的值。
- en: 'Now, let''s understand some of the common variables I use for MóiBit operations:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下我用于 MóiBit 操作的一些常见变量：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, `conn` is a variable that represents the HTTPS connection that's
    been established between the sensor as a client, and MóiBit as a server. `moibit_url`
    is a string variable that points to the base URL of the MóiBit API. Furthermore,
    `moibit_header_obj` is a JSON object that I need to pass as part of the request
    header. Since the MóiBit API is also protected by an API key and API secret, I
    need to pass these two values in order to authenticate my requests with the MóiBit
    network. These are represented by the `api_key` and `api_secret` fields, respectively.
    Both fields are, again, mapped to the `MOIBIT_API_KEY` and `MOIBIT_API_SECRET` environment
    variables, respectively. `os.environ` fetches the value of the corresponding environment
    variables from the shell.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`conn`是一个变量，表示传感器作为客户端与MóiBit作为服务器之间建立的HTTPS连接。`moibit_url`是一个字符串变量，指向MóiBit
    API的基本URL。此外，`moibit_header_obj`是我需要作为请求头的一部分传递的JSON对象。由于MóiBit API也受API密钥和API密钥的保护，因此我需要传递这两个值以使用MóiBit网络对我的请求进行身份验证。分别将这两个值表示为`api_key`和`api_secret`字段。这两个字段再次分别映射到`MOIBIT_API_KEY`和`MOIBIT_API_SECRET`环境变量，`os.environ`从shell中获取对应环境变量的值。
- en: Finally, the `content-type` field represents the metadata of the request header.
    Since it is a JSON object, we use `"application/json"` as the corresponding value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`content-type`字段表示请求头的元数据。由于它是一个JSON对象，我们使用`"application/json"`作为相应的值。
- en: 'Now, let''s look at the variables related to blockchain interactions within
    the script:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下脚本中与区块链交互相关的变量：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding code block, we can observe that the `blockchain_url` string
    variable points to the URL of the Ethereum Kovan testnet, which is accessible
    via the service provider Infura. Since Infura's API is also protected, we need
    to pass a project ID that's been created under an Infura user account. This is
    observed as we append the string with the value of the `WEB3_INFURA_PROJECT_ID` environment
    variable that we read from the shell using `os.environ`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码块中，我们可以观察到`blockchain_url`字符串变量指向以太坊科文测试网的URL，该网址可通过服务提供商Infura访问。由于Infura的API也是受保护的，因此我们需要传递在Infura用户帐户下创建的项目ID。这是因为我们在字符串末尾添加了`WEB3_INFURA_PROJECT_ID`环境变量的值，我们使用`os.environ`从shell中读取该值。
- en: 'Since we interact with a smart contract on the blockchain, we also have to
    define its corresponding **Contract Application Binary Interface** (**ABI**) in
    our script, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们要与区块链上的智能合约进行交互，因此我们还必须在我们的脚本中定义其相应的**合约应用二进制接口**（**ABI**），如下所示：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do not panic if you do not understand this. This is basically a serialized JSON
    representation of the contract's variables, functions, and input and output specifications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解这个，不要惊慌。这基本上是合约的变量、函数以及输入和输出规范的序列化JSON表示。
- en: If you are not a Solidity smart contract developer, I suggest that you get acquainted
    with ABI by going to [https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是Solidity智能合约开发人员，我建议您通过访问[https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html)来熟悉ABI。
- en: Now that we have defined every variable that's important to the functionality
    of the script, let's go ahead and understand the functionality of the following
    script.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了对脚本功能至关重要的每个变量，让我们继续了解以下脚本的功能。
- en: 'As usual, the entry point to our Python script starts with the `main()` function,
    as defined in the following code extract:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们Python脚本的入口点始于`main()`函数，如下面的代码摘录所定义：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the preceding code block, we can understand that when the `main` function
    is called, it reads the wallet address of the sensor from the `WALLET_ADDRESS` environment
    variable as `Tracking_ID`. Once it identifies its wallet address, the `getGeoCordinates`
    function is called to get the current latitude and longitude. Now that we have
    the current latitude and longitude, the `getCurrentTime` function is called immediately
    to get the current UNIX timestamp at that time. Now, all four variables – `Tracking_ID`,
    `latitude`, `longitude`, and `timestamp` – are expected to be formed as one JSON
    object. Hence, the `Marshal` function is called to marshal the four values into
    one JSON object under the `id`, `latitude`, `longitude`, and `timestamp` fields,
    respectively. The resulting variable, `jsonData`, is now ready to be updated in
    the corresponding location history file dedicated to that sensor on MóiBit. Now,
    the `updateLocationHistory` function is called by passing the wallet address variable, `Tracking_ID`,
    along with `jsonData`. Once the latest location data is updated in MóiBit, the
    function returns the latest CID back to the main function as `latest_cid`. This
    is now used to sign a new transaction on the blockchain via the smart contract.
    Once the transaction is signed and placed in the Ethereum Kovan blockchain, the
    transaction hash is returned as `txnHash`. The same hash is suffixed to an URL
    for preview purposes. The resulting URL can be used to review the status of the
    transaction. This summarizes the `main` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码块中，我们可以了解到当调用`main`函数时，它会从`WALLET_ADDRESS`环境变量中读取传感器的钱包地址作为`Tracking_ID`。一旦确定了其钱包地址，就会调用`getGeoCordinates`函数来获取当前的纬度和经度。现在我们有了当前的纬度和经度，立即调用`getCurrentTime`函数来获取该时刻的当前UNIX时间戳。现在，所有四个变量
    - `Tracking_ID`、`latitude`、`longitude`和`timestamp` - 预计将形成一个JSON对象。因此，调用`Marshal`函数将这四个值分别编组成一个JSON对象，在`id`、`latitude`、`longitude`和`timestamp`字段下。结果变量`jsonData`现在准备好更新到MóiBit上专用于该传感器的相应位置历史文件中。现在，通过传递钱包地址变量`Tracking_ID`和`jsonData`来调用`updateLocationHistory`函数。一旦在MóiBit中更新了最新的位置数据，该函数将最新的CID作为`latest_cid`返回给主函数。现在，这个CID用于通过智能合约在区块链上签署一个新的交易。一旦交易被签署并放置在以太坊科文区块链上，交易哈希将作为`txnHash`返回。相同的哈希被后缀到一个URL上以进行预览。生成的URL可用于查看交易的状态。这总结了`main`函数。
- en: 'Since `main` needs the geocoordinates first, it calls the `getGeoCordinates`
    function, which is defined as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`main`首先需要地理坐标，因此它调用了以下定义的`getGeoCordinates`函数：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the preceding code block, we can see that the `getGeoCordinates` function
    is making a POST API call to the Google Maps Geolocation API, along with the credentials.
    The API response, `res`, is parsed to extract the latitude and longitude. You
    can observe that we are rounding off the decimal degrees of both values to seven
    places. You can also observe that we are ignoring the `accuracy` field since optimizing
    this solution is simply out of the scope of this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码块中，我们可以看到`getGeoCordinates`函数正在向Google Maps地理位置API发送POST API调用，以及凭据一起发送。API响应`res`被解析以提取纬度和经度。您可以观察到我们将两个值的小数度舍入到七位数。您还可以观察到我们忽略了`accuracy`字段，因为优化此解决方案仅仅是本书的范围之外。
- en: 'Once the `main` function receives the `lat` and `long` values, it now captures
    the timestamp instantly by calling the `getCurrentTime` function, which is defined
    as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`main`函数接收到`lat`和`long`值，它现在立即通过调用以下定义的`getCurrentTime`函数来捕获时间戳：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can observe from the preceding code block, the `getCurrentTime` function
    simply captures the UNIX timestamp based on the local time of the sensor and returns
    it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从上述代码块中所看到的那样，`getCurrentTime`函数只是根据传感器的本地时间捕获UNIX时间戳并返回它。
- en: 'Now that we have all the necessary data, the `main` function needs it in a
    presentable format for MóiBit. Hence, it calls the `Marshal` function, which is
    defined as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的数据，`main`函数需要以MóiBit可呈现的格式呈现它。因此，调用以下定义的`Marshal`函数：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the `Marshal` function simply takes the four values and returns
    the marshaled version of the data in JSON format.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`Marshal`函数只是取这四个值并以JSON格式返回数据的编组版本。
- en: 'With the new location data of the sensor ready to be updated, the `updateLocationHistory`
    function is called, which is defined at this link [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/iot-client-code/python/main.py](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/iot-client-code/python/main.py):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好传感器的新位置数据后，将调用 `updateLocationHistory` 函数，该函数在此链接中定义：[https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/iot-client-code/python/main.py](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/iot-client-code/python/main.py)：
- en: As you can see, the `updateLocationHistory` function checks whether a dedicated
    file for the sensor already exists on MóiBit by calling the `checkIfFileExists`
    function. Based on the status value returned by the `checkIfFileExists` function,
    a new file is created if a dedicated file does not exist for the sensor on MóiBit.
    Once created, the JSON marshaled data is uploaded to the newly created file and
    the CID of the file is returned to the main function as `latest_cid`. However,
    if a dedicated file for the sensor already exists on MóiBit, the current location
    history of the sensor is first downloaded, and then the newly marshaled location
    data is appended to it. Once appended, the updated location history is now uploaded
    to MóiBit. As a new update to the file, the CID hash of the file with the new
    location data is returned to `main` as `latest_cid`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`updateLocationHistory` 函数通过调用 `checkIfFileExists` 函数检查 MóiBit 上是否已经存在传感器的专用文件。根据
    `checkIfFileExists` 函数返回的状态值，如果 MóiBit 上不存在传感器的专用文件，则创建一个新文件。创建后，将 JSON 编组数据上传到新创建的文件，并将文件的
    CID 返回到 `main` 函数作为 `latest_cid`。然而，如果 MóiBit 上已经存在传感器的专用文件，则首先下载传感器的当前位置历史记录，然后将新编组的位置数据追加到其中。追加后，更新的位置历史记录现在上传到
    MóiBit。作为文件的新更新，将带有新位置数据的文件的 CID 哈希返回到 `main` 作为 `latest_cid`。
- en: In case of any errors, suitable response error codes are printed, along with
    data from the response body and headers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现任何错误的情况下，会打印适当的响应错误代码，以及响应体和标头中的数据。
- en: 'The `checkIfFileExists` function is defined as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkIfFileExists` 函数定义如下：'
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the `checkIfFileExists` function sweeps across the entire `dictao` folder
    to check whether there is a dedicated file for a sensor. Since the name of the
    file is the same as the wallet address, it is easier to simply pass the wallet
    address of the sensor and check whether a dedicated file exists for the sensor
    on MóiBit. If the wallet address of the calling sensor is `0xABC`, then the dedicated
    file for this sensor on MóiBit would be `0xABC.json`. If a file is found under
    the root folder, `dictao`, of your respective MóiBit developer accounts, it returns
    the Boolean value `True` to the `updateLocationHistory` function. If such a file
    does not exist, it will return `False`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkIfFileExists` 函数遍历整个 `dictao` 文件夹，检查是否有专门用于传感器的文件。由于文件名与钱包地址相同，因此只需传递传感器的钱包地址，然后检查
    MóiBit 上是否存在专门用于传感器的文件即可。如果调用传感器的钱包地址是 `0xABC`，那么此传感器在 MóiBit 上的专用文件将是 `0xABC.json`。如果在您各自的
    MóiBit 开发者帐户的根文件夹 `dictao` 下找到文件，则向 `updateLocationHistory` 函数返回布尔值 `True`。如果不存在这样的文件，则返回
    `False`。'
- en: 'Finally, once the `main` function receives the updated CID hash of the location
    data of the sensor, it needs to maintain the proof of this location update on
    the blockchain. Hence, it calls the `CommitTxn` function, which is defined as
    follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦 `main` 函数接收到传感器位置数据的更新 CID 哈希，就需要在区块链上维护此位置更新的证明。因此，它调用 `CommitTxn` 函数，其定义如下：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From the preceding code block, you can see that the `CommitTxn` function is
    taking the wallet address and the latest cid using `id` and `CID`, respectively.
    The function now creates a new `web3` object connected to one of the Ethereum
    nodes run by Infura. Once connected to the Ethereum Kovan blockchain network,
    it connects to the smart contract deployed on the blockchain by passing the contract
    address. The contract address is also fed into the shell as `PROOF_SMART_CONTRACT_ADDRESS`,
    which can be read by `os.environ`. Using this address, the contract variable is
    initiated and points to the smart contract instance on the blockchain. Now, a
    new transaction is created by using the input data; that is, `id` and `CID`. The
    transaction is created using the `buildTransaction` call that's offered by the
    Python `web3` library. The `chainId` field represents the network ID of the Ethereum
    Kovan blockchain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码块中，您可以看到`CommitTxn`函数正在使用钱包地址和最新的cid，分别使用`id`和`CID`。该函数现在通过连接到由Infura运行的以太坊节点之一的新的`web3`对象与以太坊Kovan区块链网络进行连接。连接到以太坊Kovan区块链网络后，它连接到在区块链上部署的智能合约，通过传递合约地址。合同地址也作为`PROOF_SMART_CONTRACT_ADDRESS`传递到shell中，可以通过`os.environ`读取。使用这个地址，合同变量被初始化，并指向区块链上的智能合约实例。现在，通过使用输入数据`id`和`CID`，创建一个新的交易。通过Python的`web3`库提供的`buildTransaction`调用创建了这个事务。`chainId`字段表示以太坊Kovan区块链的网络ID。
- en: 'To find out more about each parameter passed to this function, I suggest that
    you go through the documentation of how to send raw transactions using `web3.py`
    here: [https://web3py.readthedocs.io/en/stable/web3.eth.account.html#sign-a-contract-transaction](https://web3py.readthedocs.io/en/stable/web3.eth.account.html#sign-a-contract-transaction).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每个参数传递给此函数的更多信息，建议您阅读`web3.py`发送原始交易的文档：[https://web3py.readthedocs.io/en/stable/web3.eth.account.html#sign-a-contract-transaction](https://web3py.readthedocs.io/en/stable/web3.eth.account.html#sign-a-contract-transaction)。
- en: Once the transaction has been built, sent, and verified by the network, a receipt
    is obtained as `tx_receipt`. We wait for this receipt and then send the transaction
    hash back to the `main` function as `tx_hash` for reference purposes. This summarizes
    the `CommitTxn` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易已建立、发送并通过网络验证，将获得一个收据作为`tx_receipt`。我们等待这个收据，然后将交易哈希作为`tx_hash`发回`main`函数以供参考。这总结了`CommitTxn`函数。
- en: Now that the location history data has been updated and proof is available on
    the blockchain, let's learn how to apply AI techniques in order to predict the
    potential infections.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在位置历史数据已更新，并且在区块链上有了证据，让我们学习如何应用AI技术以预测潜在的感染。
- en: '**Training the model**'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**训练模型**'
- en: In this section, I will walk you through all the steps needed to build a contact
    tracing algorithm by leveraging AI techniques. We will go through the common steps
    in training an AI model to predict an outcome or a value. With the help of our
    sample DIApp, we'll understand the 10 common steps taken when training an AI model
    and reapply them to our use case. We will be using Jupyter Notebook to explain
    each step involved.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将带您了解利用AI技术构建接触者追踪算法所需的所有步骤。我们将经历训练AI模型以预测结果或值时的常见步骤。借助我们的样本DIApp，我们将了解训练AI模型时采取的10个常见步骤，并重新应用到我们的用例中。我们将使用Jupyter
    Notebook来解释所涉及的每个步骤。
- en: 'The steps to building our AI-based contact tracing algorithm are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '构建基于AI的接触者追踪算法的步骤如下:'
- en: '**Preparing the training dataset**: As mentioned in the previous section, the
    location history of each sensor is stored in a separate file under MóiBit. Each
    file serves as a subset of the main DataFrame and will be used to identify potential
    infections. The DataFrame of an individual sensor looks as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备训练数据集**: 如前文所述，每个传感器的位置历史存储在MóiBit的单独文件中。每个文件作为主DataFrame的子集，将用于识别潜在的感染。一个单独传感器的DataFrame如下所示：'
- en: '** ![](img/42e31115-bf5d-405d-87a7-729e90bc4400.png)**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '** ![](img/42e31115-bf5d-405d-87a7-729e90bc4400.png)**'
- en: 'Fig 8.3: Location history of an individual sensor captured in Jupyter Notebook
    using the pandas DataFrame view'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '图8.3: 在Jupyter Notebook中使用pandas DataFrame视图捕获的单个传感器的位置历史'
- en: To detect potential infections and cluster the infections in an intelligent
    manner, we are going to use the DBSCAN algorithm.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了智能地检测潜在感染并对感染进行集群化，我们将使用DBSCAN算法。
- en: '**DBSCAN** is a data clustering algorithm that separates high-density data
    points from low-density points. The algorithm was proposed by Martin Ester, Hans-Peter
    Kriegel, Jörg Sander, and Xiaowei Xu in 1996\. Basically, the DBSCAN algorithm
    clusters a group of data points that are close to each other in a certain space
    and ignores the outliers as noise.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**DBSCAN** 是一种数据聚类算法，它将高密度数据点与低密度点分离开来。这个算法是由Martin Ester、Hans-Peter Kriegel、Jörg
    Sander和Xiaowei Xu在1996年提出的。基本上，DBSCAN算法将在某个空间中彼此靠近的一组数据点聚类在一起，并将离群值作为噪音忽略掉。'
- en: In order to understand the location history and its applicability in DBSCAN,
    we generated a training dataset with preset random IDs, a timestamp, and lat-long
    values. It is not easy or safe to assign random values by ourselves. Hence, we
    used the **JSON Generator** tool. JSON Generator allows users to generate JSON
    documents with random values in a customizable manner. This is made possible by
    programming the JSON generator to use specific values for a given field.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解位置历史及其在DBSCAN中的适用性，我们生成了一个具有预设的随机ID、时间戳和纬度-经度值的训练数据集。我们自己指定随机值并不容易也不安全。因此，我们使用了**JSON生成器**工具。JSON生成器允许用户以可定制的方式生成具有随机值的JSON文档。这是通过编程JSON生成器为给定字段使用特定值来实现的。
- en: 'We used the following syntax to generate 100 JSON objects with random values
    for the ID, timestamp, latitude, and longitude:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下语法生成了100个具有随机ID、时间戳、纬度和经度值的JSON对象：
- en: '![](img/785fd3e5-a6c8-4e8c-b3aa-9dde96be2186.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/785fd3e5-a6c8-4e8c-b3aa-9dde96be2186.png)'
- en: 'Fig 8.4: Schema required to generate a training dataset on JSON Generator'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fig 8.4: 生成训练数据集所需的模式在JSON Generator上'
- en: As shown in the preceding screenshot, the schema specifies all four attributes
    desired in the dataset. Since this is a dataset, the `id` attribute has a set
    of dummy wallet addresses. The `timestamp` attribute also has a set of UNIX timestamps
    ranging between 24 hours with at least a 1-hour gap between each other. Finally,
    the `latitude` and `longitude` attributes have also been specified to take any
    value between the specified minimum and maximum values at a precision of seven
    decimal places.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，模式指定了数据集中所需的所有四个属性。由于这是一个数据集，`id`属性具有一组虚拟钱包地址。`timestamp`属性也具有一组UNIX时间戳，范围在24小时内，每个之间都至少间隔1小时。最后，`latitude`和`longitude`属性也已被指定为在指定的最小值和最大值之间以七位小数精度接受任何值。
- en: From the preceding schema, we can generate exactly 100 random JSON objects.
    However, this may not be enough. Hence, I regenerated some more random JSON objects
    to form a training dataset consisting of 1,000 JSON objects. I concatenated the
    100 JSON objects that were generated by the preceding schema repeatedly 10 times.
    The resulting dataset is an array of 1,000 random JSON objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述的模式中，我们可以生成确切的 100 个随机JSON对象。但这可能不够。因此，我重新生成了一些随机JSON对象，形成了由 1,000 个JSON对象组成的训练数据集。我将前述模式生成的100个JSON对象重复10次。得到的数据集是
    1,000 个随机JSON对象的数组。
- en: 'The resulting dataset can be viewed on Jupyter Notebook by executing the `head()`
    function of the `pandas` library, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行`pandas`库的`head()`函数来在Jupyter Notebook上查看得到的数据集，如下所示：
- en: '![](img/a5cb8a90-ff44-4b23-80ee-ab5fab1ef7b1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5cb8a90-ff44-4b23-80ee-ab5fab1ef7b1.png)'
- en: Fig 8.5**:** Output of the df.head() function call on Jupyter Notebook
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Fig 8.5**：** 在Jupyter Notebook上调用df.head()函数的输出
- en: From the preceding screenshot, we can see that a training dataset has been created
    and read on Jupyter Notebook.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，我们可以看到在Jupyter Notebook上已经创建并读取了一个训练数据集。
- en: '**Analyzing the training dataset**: Now that we have created a training dataset
    with random values and loaded it into Jupyter Notebook, we shall analyze it a
    bit further to understand the dataset. This process is called analyzing the training
    dataset. This step helps us understand more about the nature of the data points
    and how they are distributed.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析训练数据集**：现在，我们已经创建了一个具有随机值的训练数据集，并将其加载到了Jupyter Notebook中，我们将对其进行进一步分析，以更好地理解数据集。这个过程被称为分析训练数据集。这一步可以帮助我们更好地了解数据点的性质以及它们的分布情况。'
- en: 'First, we begin the analysis by describing how to get topline information about
    the dataset. We do this by calling the `info` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`info`函数来描述如何获取有关数据集的顶线信息：
- en: '![](img/5c196a9c-570d-44c4-889d-2cfa2252567f.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c196a9c-570d-44c4-889d-2cfa2252567f.png)'
- en: Fig 8.6**:** Output of the df.info() function call on Jupyter Notebook
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Fig 8.6**：** 在Jupyter Notebook上调用df.info()函数的输出
- en: From the preceding screenshot, we can observe that there are 1,001 entries in
    the dataset. The output of the `info` function call also lists all the columns
    in the DataFrame, including their types. It also checks whether there are any
    null values. Since our schema for JSON Generator was very specific, we do not
    have any null values in any rows of the DataFrame.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以观察到数据集中有 1,001 个条目。`info` 函数调用的输出还列出了 DataFrame 中的所有列，包括它们的类型。它还检查是否有任何空值。由于我们为
    JSON 生成器设计的模式非常具体，因此 DataFrame 的任何行中都没有空值。
- en: 'Next, we need to understand the distribution of the data points by tasking
    pandas with describing the dataset using the `describe()` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过使用 `describe()` 函数让 pandas 描述数据集来了解数据点的分布：
- en: '![](img/7d152ae1-0558-4462-8c69-0befbc1c0829.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d152ae1-0558-4462-8c69-0befbc1c0829.png)'
- en: 'Fig 8.7: Output of the df.describe() function call on Jupyter Notebook'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：Jupyter Notebook 上 df.describe() 函数调用的输出
- en: From the preceding screenshot, we can observe the statistical summary of the
    same DataFrame. We can see that `count` represents the total number of non-null
    rows in the training DataFrame, `df. mean` represents the average values of the
    latitude and longitude columns at around 12.973009 and 77.621612, respectively.
    `min` represents the minimum latitude and longitude value ever recorded in the
    DataFrame at 12.879612 and 77.445554, respectively. `max` represents the maximum
    latitude and longitude value ever recorded in the DataFrame at 13.069226 and 77.798141,
    respectively. Although `count`, `mean`, `min`, and `max` highlight the boundaries,
    they do not explain the distribution of data points. However, the distribution
    of the data points can be understood by the `std`, `25%`, `50%`, and `75%` parameters.
    Let's understand what they mean.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以观察到相同 DataFrame 的统计摘要。我们可以看到，`count` 表示训练 DataFrame 中非空行的总数，`df.mean`
    分别表示纬度和经度列的平均值约为 12.973009 和 77.621612。 `min` 分别表示 DataFrame 中记录的纬度和经度的最小值分别为
    12.879612 和 77.445554。 `max` 分别表示 DataFrame 中记录的纬度和经度的最大值分别为 13.069226 和 77.798141。尽管
    `count`、`mean`、`min` 和 `max` 突出了边界，但它们并不解释数据点的分布。但是，数据点的分布可以通过 `std`、`25%`、`50%`
    和 `75%` 参数来理解。让我们了解一下它们的含义。
- en: '`std` numerically represents how far the latitude and longitude values are
    from the mean latitude and longitude value. In this case, the values are 0.054532
    and 0.101059, respectively. The `std` values are so low in our training dataset
    because of the minimum and maximum value range we have entered into our JSON Generator
    schema. Although it looks like all the rows in the DataFrame are close enough,
    each of them is placed kilometers away from one another due to a change or shift
    in one decimal degree as well.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`std` 数值上表示纬度和经度值与平均纬度和经度值的距离有多远。在本例中，这些值分别为 0.054532 和 0.101059。由于我们在 JSON
    生成器模式中输入了最小值和最大值范围，我们的训练数据集中的 `std` 值很低。尽管在 DataFrame 中的所有行看起来都很接近，但由于每个行之间的一次小数度变化或转变，它们彼此之间相隔数公里。'
- en: If the `df` DataFrame were to be sorted, the first 250 columns of the DataFrame
    would have latitude values ranging from 12.879612 to 12.925427\. Similarly, the
    longitude values would be ranging from 77.445554 to 77.535446\. This is represented
    by the resulting parameter, `25%`. The same can be interpreted for the remaining
    parameters – `50%`, `75%`, and `max` – by cascading 250 rows while analyzing.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `df` DataFrame 被排序，DataFrame 的前 250 列将具有从 12.879612 到 12.925427 的纬度值范围。同样，经度值将从
    77.445554 到 77.535446 范围内。这由结果参数 `25%` 表示。通过在分析时级联 250 行，可以解释剩余参数 `50%`、`75%`
    和 `max`。
- en: It is also important to note that the summary is helpful in understanding whether
    the data points are distributed enough.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，摘要有助于了解数据点是否分布均匀。
- en: '**Feature engineering**: Feature engineering usually involves identifying critical
    data points, transforming the data points, and grooming them for a better analysis.
    Since there are no missing values or NaN values in our dataset, we will not be
    performing any featuring engineering on our dataset.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**特征工程**：特征工程通常涉及识别关键数据点，转换数据点，并对其进行整理以进行更好的分析。由于我们的数据集中没有缺失值或 NaN 值，我们将不会对数据集进行任何特征工程。'
- en: '**Exploratory data analysis**: Next, we will try to visually analyze our dataset.
    Since we are dealing with geographic data, it is better to understand the data
    points by plotting them against a real map. We are going to be using the Plotly
    library to plot the lat-long coordinates on a real map. By doing so, we''ll obtain
    the following visualization:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**探索性数据分析**：接下来，我们将尝试对数据集进行可视化分析。由于我们正在处理地理数据，最好通过将它们与真实地图相对比来理解数据点。我们将使用Plotly库在真实地图上绘制纬度-经度坐标。通过这样做，我们将获得以下可视化效果：'
- en: '![](img/ec706f28-a9af-4205-861d-36da131f3065.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec706f28-a9af-4205-861d-36da131f3065.png)'
- en: Fig 8.8**:** Graphical output of the datapoints on Jupyter Notebook using Plotly
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8**：在Jupyter Notebook上使用Plotly绘制数据点的图形输出
- en: From the preceding screenshot, we can see that all the data points are being
    plotted across many areas in Bengaluru city. This is because of the limits we
    have set in our training dataset. As you can see, we have manually set the limitations
    for the latitude and longitude in the JSON Generator schema. Hence, we cannot
    see any other data points beyond the city limits of Bengaluru. While trying out
    this tutorial, you may wish to change it as per your requirements and mention
    a city-specific lat-long range or keep it very wide open in your JSON Generator
    schema.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，我们可以看到所有数据点都被绘制在Bengaluru城市的许多区域。这是因为我们在训练数据集中设置了限制。正如您所看到的，我们在JSON生成器模式中手动设置了纬度和经度的限制。因此，在Bengaluru城市边界之外我们看不到任何其他数据点。在尝试此教程时，您可能希望根据您的要求更改它，并在JSON生成器模式中提到一个特定城市的纬度-经度范围，或者保持非常宽泛。
- en: Apart from plotting the lat-long data on a map, we can also analyze the data
    points using a scatterplot. Under a scatterplot, we plot the lat-long values on
    a two-dimensional graph, with the *x *axis representing the latitude and the *y *axis
    representing the longitude.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在地图上绘制纬度-经度数据外，我们还可以使用散点图来分析数据点。在散点图下，我们将纬度-经度值绘制在一个二维图上，其中*x*轴表示纬度，*y*轴表示经度。
- en: 'Now, let''s take a look at a simpler version of a scatterplot on our training
    dataset:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下在我们的训练数据集上的一个更简单版本的散点图：
- en: '![](img/38be23ca-910f-4412-9712-549b74e26782.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38be23ca-910f-4412-9712-549b74e26782.png)'
- en: 'Fig 8.9: The scatterplot''s output of the datapoints on Jupyter Notebook using
    Seaborn'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：在Jupyter Notebook上使用Seaborn绘制数据点的散点图输出
- en: From the preceding screenshot, we can observe the location history of all 10
    IDs randomly scattered across the geographic space. Each color represents an ID,
    while all the colored dots on the graph represent its corresponding location history.
    You can get more creative by applying more parametric filters and also performing
    analysis using other charts, including, but not limited to, box plot, joint plot,
    heatmap, and so on.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，我们可以观察到在地理空间中随机分布的所有10个ID的位置历史。每种颜色代表一个ID，而图表上的所有彩色点代表其相应的位置历史。您可以通过应用更多参数化过滤器并使用其他图表进行分析（包括但不限于箱形图、联合图、热图等）来变得更有创意。
- en: To find out more about visualizing your training dataset, I recommend that you
    use Seaborn and Plotly. To learn more about Seaborn, visit [https://seaborn.pydata.org/](https://seaborn.pydata.org/).
    To learn more about Plotly, visit [https://plotly.com/](https://plotly.com/).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关可视化您的训练数据集的更多信息，我建议您使用Seaborn和Plotly。要了解有关Seaborn的更多信息，请访问[https://seaborn.pydata.org/](https://seaborn.pydata.org/)。要了解有关Plotly的更多信息，请访问[https://plotly.com/](https://plotly.com/)。
- en: '**Splitting the training dataset**: Most of the time, we split the training
    dataset into two parts. One part is used to train the model, while the other part
    is used to predict the values and compare the predicted values with the actual
    values in the training dataset. Since we are clustering the data and not using
    regression-based models to actually predict a value, there is no need to split
    our training dataset.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练数据集的分割**：大多数情况下，我们将训练数据集分为两部分。一部分用于训练模型，而另一部分用于预测值并将预测值与训练数据集中的实际值进行比较。由于我们正在对数据进行聚类，并且不使用基于回归的模型来实际预测值，因此无需拆分我们的训练数据集。'
- en: '**Selecting the model**: When it comes to performing digital contact tracing
    for animals and objects, one approach is to use clustering algorithms that can
    provide customizations as per the new-found medical data and approaches. Although
    there are many clustering approaches, such as K-means, hierarchical clustering,
    and density-based clustering, we chose density-based clustering in this sample
    application as it is simple to understand and also offers some customizations
    that can be applied for practical use cases.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择模型**：在执行动物和物体的数字接触追踪时，一种方法是使用可以根据新发现的医疗数据和方法进行定制的聚类算法。虽然有许多聚类方法，例如 K-means、层次聚类和基于密度的聚类，但在这个示例应用程序中，我们选择了基于密度的聚类，因为它简单易懂，还提供了一些可应用于实际用例的定制。'
- en: K-means clustering is also easy to understand but it generally does not have
    a strong reputation when it comes to analyzing geocoordinates and spatial data.
    Although hierarchical clustering can help us analyze spatial data, it does not
    offer an easy learning curve like DBSCAN does.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: K-means 聚类也很容易理解，但通常在分析地理坐标和空间数据时声誉不佳。虽然层次聚类可以帮助我们分析空间数据，但不像 DBSCAN 那样提供简单的学习曲线。
- en: We are going to use the DBSCAN algorithm for this, which is available under
    the scikit-learn machine learning library.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 scikit-learn 机器学习库中提供的 DBSCAN 算法。
- en: 'For more information about the features that are available, visit the following
    link: [https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用特征的更多信息，请访问以下链接：[https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html)。
- en: '**Training and fitting**: Now that we have created the training dataset, analyzed
    it, and visualized it, we need to use the training dataset to train our model
    using the DBSCAN algorithm to cluster the data points and identify them distinctly.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练和拟合**：现在我们已经创建了训练数据集，对其进行了分析并可视化了，我们需要使用训练数据集使用 DBSCAN 算法训练我们的模型，以对数据点进行聚类并明确识别它们。'
- en: As per the medical norms accepted by many practitioners globally, it is a popular
    opinion that we can contract coronavirus if people are not maintaining the minimum
    safety distance of at least 6 feet. So, we are assuming the same accepted metric
    for physical distancing and creating our model so that it clusters data points
    that are connected to each other whose distance is less than or equal to 6 feet.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据全球许多从业者接受的医疗规范，普遍认为如果人们不保持至少 6 英尺的最小安全距离，我们可能会感染冠状病毒。因此，我们假设相同的接受度量单位用于身体距离，并创建我们的模型，以便对彼此连接且距离小于或等于
    6 英尺的数据点进行聚类。
- en: 'Based on the criteria we''ve discussed so far, we''ll define the model using
    Jupyter Notebook as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们迄今为止讨论的标准，我们将使用 Jupyter Notebook 定义模型如下：
- en: '![](img/7d48ac4e-5077-4e0d-8aaa-a4c31360b64c.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d48ac4e-5077-4e0d-8aaa-a4c31360b64c.png)'
- en: 'Fig 8.10: Initiating the DBSCAN model with the training dataset'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Fig 8.10：使用训练数据集初始化 DBSCAN 模型
- en: From the preceding screenshot, we can observe that a `model` has been initiated
    based on the DBSCAN algorithm. The inputs given to the DBSCAN algorithm are the
    training dataset, `df`, itself. Along with df, the `epsilon` variable is also
    sent. `Epsilon` is the maximum distance between any two given data points. We
    choose 0.0018288 as the value of the `epsilon` variable since it is the kilometer
    equivalent of 6 feet. This is a crucial parameter while setting up a DBSCAN-based
    model. Along with `epsilon`, the `min_sample` variable is also sent to the DBSCAN
    algorithm to initiate the model. `min_sample` defines the minimum number of data
    points that need to be present within the `epsilon` radius to form a cluster.
    We chose 2 as the value of the `min_sample` variable since it takes a minimum
    of two actors to spread the infection.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，我们可以观察到基于 DBSCAN 算法初始化了一个`model`。输入给 DBSCAN 算法的是训练数据集 `df` 本身。除了 df，还发送了
    `epsilon` 变量。`Epsilon` 是任意两个给定数据点之间的最大距离。我们选择 0.0018288 作为`epsilon` 变量的值，因为它是
    6 英尺的公里等效值。这是设置基于 DBSCAN 的模型时的关键参数。除了`epsilon`，还向 DBSCAN 算法发送了 `min_sample` 变量以初始化模型。`min_sample`
    定义了在`epsilon` 半径内需要存在的最小数据点数以形成一个聚类。我们选择 2 作为 `min_sample` 变量的值，因为传播感染需要至少两个参与者。
- en: Finally, we need to choose the metric function, based on which the distance
    between the data points is calculated. Since we are working on geographic coordinates,
    we chose `haversine` as the metric function to calculate the distance between
    the data points to form the cluster.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要选择度量函数，根据该函数计算数据点之间的距离。由于我们正在处理地理坐标，我们选择`haversine`作为度量函数，以计算数据点之间的距离以形成集群。
- en: 'To find out more about the haversine geographic distance formula, visit the
    following Wikipedia article: [https://en.wikipedia.org/wiki/Haversine_formula](https://en.wikipedia.org/wiki/Haversine_formula).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于haversine地理距离公式的信息，请访问以下维基百科文章：[https://en.wikipedia.org/wiki/Haversine_formula](https://en.wikipedia.org/wiki/Haversine_formula)。
- en: 'Once the model has been initialized, the clusters are formed and assigned to
    the respective data points by us adding the new column, called `cluster`, to the
    training dataset. You can now see that the same DataFrame is updated with one
    more column cluster, as shown in the following screenshot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型被初始化，集群就会形成，并且通过我们向训练数据集添加名为`cluster`的新列将其分配给相应的数据点。现在，您可以看到相同的DataFrame通过增加一个名为cluster的列进行了更新，如下面的屏幕截图所示：
- en: '![](img/c2e38a31-e307-411e-ba4c-4567665cfaed.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2e38a31-e307-411e-ba4c-4567665cfaed.png)'
- en: Fig 8.11**:** Reading the updated contents of the DataFrame with the new column
    cluster by using the df.head() function call on Jupyter Notebook
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11**：**通过在Jupyter Notebook上调用df.head()函数调用读取带有新列集群的DataFrame的更新内容
- en: 'When the clusters are plotted on the graph with the *x* axis representing latitude
    and the *y* axis representing the longitude, this results in the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当集群在图上绘制时，*x*轴代表纬度，*y*轴代表经度，结果如下：
- en: '![](img/dd99de8d-4673-4fa9-80d4-db8a9f7f0a3a.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd99de8d-4673-4fa9-80d4-db8a9f7f0a3a.png)'
- en: 'Fig 8.12: Scatterplotting all the clusters, including noise'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：散点图显示所有集群，包括噪声
- en: From the preceding plotted graph, we can observe that there are 74 normal clusters
    ranging from **cluster-0** to **cluster-73**. It is also important to observe
    that there is one more cluster that goes by the name **cluster--1**, which represents
    all the data points that do not belong to any cluster. Such data points are considered
    **noise** and hence they are irrelevant to our further efforts in contact tracing.
    Noise data points occur if the sensors were attached to animals or objects that
    have likely been isolated and have not interacted with another animal or object
    wearing a sensor.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面绘制的图表中，我们可以观察到有74个正常集群，范围从**cluster-0**到**cluster-73**。还重要的是观察到还有一个名为**cluster--1**的集群，它代表所有不属于任何集群的数据点。这样的数据点被视为**噪声**，因此它们与我们进一步的接触追踪努力无关。如果传感器连接到可能已被隔离并且没有与戴传感器的另一个动物或物体进行交互的动物或物体，则会发生噪声数据点。
- en: It is difficult to analyze the data since there's so much noise in the preceding
    graph, so let's go ahead and remove all the data points in the DataFrame that
    are considered noise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的图中有很多噪声，因此很难分析数据，因此让我们继续删除DataFrame中被视为噪声的所有数据点。
- en: 'We can remove the noise and replot the graph as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以去除噪声并重新绘制图形如下：
- en: '![](img/44450a4f-2eeb-41b9-952e-41199daeba1e.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44450a4f-2eeb-41b9-952e-41199daeba1e.png)'
- en: Fig 8.13**:** Removing the noise cluster before plotting again
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13**：**再次绘制前去除噪声集群
- en: From the preceding screenshot, we can observe that we have dropped all the rows
    that belonged to **cluster -1**.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以观察到我们已经删除了所有属于**cluster -1**的行。
- en: 'The resulting graph is cleaner and can be observed as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表更清晰，可以如下观察：
- en: '![](img/198b97e9-517f-4c75-ab76-39e445feb247.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/198b97e9-517f-4c75-ab76-39e445feb247.png)'
- en: 'Fig 8.14: Replotting the clusters without noise'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：重新绘制没有噪声的集群
- en: From the preceding screenshot, you can observe that the DBSCAN model has been
    successfully initiated with the configured parameters. Now, let's check the accuracy
    of the model.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，您可以观察到DBSCAN模型已成功初始化并配置了参数。现在，让我们检查模型的准确性。
- en: '**Evaluating the model**: Usually, prediction models use logistic regressors
    or classifiers. But in our sample application, we are not predicting any new values;
    we''re simply using machine learning to split the data into smaller, customized
    clusters.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估模型**：通常，预测模型使用逻辑回归器或分类器。但在我们的示例应用程序中，我们不是在预测任何新值；我们只是使用机器学习将数据分割成更小的、定制的集群。'
- en: Now that we have been able to split the dataset into clusters of two or more
    data points, we need to check whether the clustering is working effectively. In
    simpler terms, we need to check the basic correctness of the model. In our case,
    we can perform a basic evaluation by checking whether the model is generating
    any false positives; that is, we need to check whether the model is clustering
    two or more data points whose haversine distance is more than the specified distance.
    If such data points are grouped under one new cluster, we can easily conclude
    that the model has its limitations with false positives. Similarly, we also need
    to check whether the model is prone to false negatives; that is, we need to check
    whether the model is clustering two or more data points whose haversine distance
    is less than the specified valid distance, but the model fails to recognize it
    as a potential infection by not clustering them together. Due to the limited scope
    of this book, we will conclude by making one observation that the current model
    seems to be generating false positives for data points up to 10 meters in haversine
    distance. As far as false negatives are concerned, we have not observed such anomalies
    or limitations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够将数据集分成两个或两个以上数据点的簇，我们需要检查聚类是否有效。 简而言之，我们需要检查模型的基本正确性。 在我们的情况下，我们可以通过检查模型是否生成任何误报来进行基本评估；也就是说，我们需要检查模型是否将两个或两个以上的数据点聚类在一起，这些数据点的
    haversine 距离大于指定距离。 如果这样的数据点被聚合到一个新的簇中，我们可以很容易地得出结论，即模型具有误报的限制。 同样，我们还需要检查模型是否容易产生错失检测；也就是说，我们需要检查模型是否将两个或两个以上的数据点聚类在一起，这些数据点的
    haversine 距离小于指定的有效距离，但模型未能将其识别为潜在的感染。 由于本书的范围有限，我们将通过做一个观察来得出结论，即当前模型似乎会为 haversine
    距离高达 10 米的数据点产生误报。 就错误的遗漏而言，我们没有观察到这样的异常或限制。
- en: '**Tuning the parameters**: There are only three main input parameters that
    are required by the DBSCAN algorithm. They are `epsilon`, `min_sample`, and the
    haversine metric function. Apart from these parameters, you can also add some
    more parameters when you are trying this solution on your system.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**参数调整**：DBSCAN 算法只需要三个主要的输入参数。 它们是 `epsilon`，`min_sample` 和 haversine 度量函数。
    除了这些参数，当您在系统上尝试此解决方案时，还可以添加一些更多的参数。'
- en: 'For more information regarding the other parameters, visit the documentation
    at the following link: [https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其他参数的更多信息，请访问以下链接的文档：[https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html)。
- en: Due to the limited scope of this book, I will not be focusing on the optimization
    of the model since it does a decent job with clustering as-is.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的范围有限，我不会专注于优化模型，因为它在聚类方面工作得相当不错。
- en: '**Predicting infections**:The model is now ready to take live data from MóiBit
    and predict the potential infections by clustering the data points using the preceding
    parameters. Of course, the model will be prone to some false positives for neighboring
    data points of up to 10 meters as it is not fully tuned. It is out of the scope
    of this book to only focus on optimizing the AI component of the sample solution.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预测感染**：现在模型已经准备好从 MóiBit 获取实时数据，并使用先前的参数对数据点进行聚类，以预测潜在的感染情况。 当然，由于模型尚未完全调整，对于相邻数据点的误报率可能高达
    10 米，这超出了本书仅关注优化样本解决方案的范围。 '
- en: 'All the screenshots in this section have been borrowed from Madhusudhan Kumble''s
    Jupyter Notebook. The complete implementation of the notebook is available on
    his GitHub: [https://github.com/madatpython/PRANA/blob/packt/prana_contact_tracing_using_DBSCAN.ipynb](https://github.com/madatpython/PRANA/blob/packt/prana_contact_tracing_using_DBSCAN.ipynb).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有截屏都来自Madhusudhan Kumble的Jupyter笔记本。 笔记本的完整实现可在他的GitHub上找到：[https://github.com/madatpython/PRANA/blob/packt/prana_contact_tracing_using_DBSCAN.ipynb](https://github.com/madatpython/PRANA/blob/packt/prana_contact_tracing_using_DBSCAN.ipynb)。
- en: Now that we understand how to apply the DBSCAN algorithm to our use case and
    we have developed a fair understanding of its limitations, let's incorporate this
    model in the backend API.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将 DBSCAN 算法应用于我们的用例，并且对其局限性有了一定的了解，让我们将这个模型合并到后端 API 中。
- en: '**Developing the backend**'
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**后端开发**'
- en: In this section, we will be discussing the design and structure of the contact
    tracing backend API. The backend API is responsible for performing contact tracing
    by reading a wallet address and returning the wallet addresses of any other potentially
    infected sensors.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Similar to sensor application code, I will be implementing the contact tracing
    backend API in the Python language as it is easier to bridge the language gaps
    between the AI, IoT, and blockchain communities.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we start by noting down all the `import` statements that are necessary
    for proceeding with the API''s development:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Please make sure that you have all the external packages installed through the `pip
    install` command.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop the contact tracing backend API, I will be using the Flask framework.
    You can read more about the Flask web application framework here: [https://flask.palletsprojects.com/en/1.1.x/](https://flask.palletsprojects.com/en/1.1.x/).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'We initiate the API by defining the `flask` web app, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the API is allowing any source on the internet to query the
    API. This is made possible by using `CORS(app)`. Also, I have set the app to debug
    mode to help you get more exposure to the API as you follow these instructions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry point to this API script is made by using the following instruction
    in the script:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For those of you who are not familiar with the Flask framework, this is equivalent
    to the `main` function, which we discussed when we looked at the IoT client code
    for sensors.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other programs, this API is also manifested in a single-file Python
    script. As such, we will have to use a few variables.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at them in the following code block:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can observe from the preceding code block, we are using the same techniques
    as that of a sensor application in order to access the blockchain network and
    access the smart contract through the ABI.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we also reuse the variables needed for interacting with MóiBit:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can observe from the preceding code block, the same variables are used
    to access resources from MóiBit. Unlike the sensor application, the variables
    will be used in this script to read the location history of each sensor and build
    a dataset for further analysis. To summarize, all these variables are used for
    read-only purposes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'When the script is run, it procedurally falls back to the home function defined,
    as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As the name suggests, the `home` function is a handler function used to respond
    to the `GET`-based API requests made to the root of the API. In this case, I am
    returning simple HTML content.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that we send a proper response for any illicit request or invalid
    requests, we have defined the `page_not_found` handler function, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown in the preceding code block, this function returns a string response
    along with an HTTP response code 404 back to the client, which means **file/resource
    not found**.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from illicit or invalid client requests, we also need to cover some of
    the internal errors that may occur. This can be achieved by defining the `internal_server_error`
    function, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As shown in the preceding code block, when an `internal_server_error` function
    is called by the API program, along with an error or an exception, the same will
    be returned to the client, along with the HTTP response code 500, which means
    an internal error occurred on the server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the API by designing the contingent communications,
    let's focus on the main logic of the API program. Our API will respond to requests
    made by web clients at the `/api/v0/get_infections` endpoint. For example, if
    the API is hosted at `example.com`, then the API calls must be sent to the following
    URL: [https://example.com/api/v0/get_infections](https://example.com/api/v0/get_infections).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue with the logic that supports such API calls. Here is the
    code link [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/backend-contact-tracing/server.py](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/backend-contact-tracing/server.py):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: A new app router is now set up for the `/api/v0/get_infections` endpoint. The
    type of API calls accepted by this router has been set to `GET`. This means that
    there is a response from the server being waited on by the web client. `get_infections`
    is the handler function responsible for handling the API calls landing at the
    said endpoint. As you may be able to predict from the code, `get_infections` is
    returning a list of potentially infected wallet addresses back to the web client.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A wallet address is communicated as `ID` in this section as it aligns with the
    design of the backend and that of the dataset.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: When the API receives the wallet address from the web client, it is checked
    for any possible corruption or loss of data. If the received ID is not an empty
    string, then the API makes the next move by retrieving all the wallet addresses
    registered on the smart contract. For each wallet address registered in the smart
    contract, the latest location history CID of each wallet is retrieved from the
    blockchain. Furthermore, each CID is used to retrieve the location history data
    of each registered sensor from MóiBit.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding code can be seen in the following code block:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the preceding code block, you can observe that the `getLatestCID` function
    is used to fetch the latest CIDs of the respective wallet addresses of the sensors,
    once the `get_infections` function retrieves each and every wallet address. The
    CID value read from the mapping in the smart contract is returned to the caller
    function, `get_infections`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `get_infections` handle function contains the CID hashes of the
    corresponding wallet addresses of each and every registered sensor, it is used
    to retrieve the location history data from MóiBit, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: From the preceding code block, you can see that the retrieved `cid` from the
    `getLatestCID` function is passed along to the `getJsonDataFromMoiBit` function.
    This CID is used to retrieve the latest location history data of the corresponding
    sensors.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Now that the data is available for analysis, the AI-based contact tracing algorithm
    we designed in the previous section comes into the picture.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The AI model is incorporated in the following function:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, the `get_infected_ids` function can be called to fetch all the
    potentially infected IDs. When called, this function basically clusters the live
    dataset generated at runtime and checks whether the given ID exists in any of
    the clusters. If the IDs exist in the cluster, all the neighboring IDs are considered
    to be affected by the coronavirus infection. Each neighboring ID in the same cluster
    is appended to an array and the search for the potentially infected IDs continues
    until the function reaches the last cluster. Once the potentially infected IDs
    have been identified, they are returned to the caller function, `get_infections`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**Developing the frontend**'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will discuss the design and structure of the contact tracing
    dashboard web application. In short, let's call it the dashboard. The purpose
    of the dashboard is to help us identify all the potentially infected IDs by entering
    the ID or wallet address of the suspected sensor that may be attached to an animal
    or an object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashboard application is simply composed of two components: an Express
    server that hosts the static files and an `index.html` HTML file that reads the
    input from a user, calls the contact tracing API, and prints all IDs returned
    by the backend API.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashboard web server code is as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can observe from the preceding code block, this is a simple Express-based
    Node.js application that starts a web server locally at port 3000 and starts hosting
    the `index.html` file for users who visit the root of the server. The web server
    also logs all the requests made by the clients.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visit the markup code for the dashboard at [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/frontend-tracking-dashboard/public/index.html](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/blob/master/Chapter08/frontend-tracking-dashboard/public/index.html):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding code block, we can observe that the markup code, `index.html`,
    is hosting a simple form to take the wallet address of the suspected sensor as
    input from the user. The input is confirmed when the user clicks the submit button.
    On clicking the submit button, the JavaScript `getInfectedIDs` function is called.
    Now, the `getInfectedIDs` function is responsible for performing basic form validations
    and alerting the user in case of any faulty inputs. If not, the function is responsible
    for calling the contact tracing backend API to retrieve the list of potentially
    infected sensors. If it receives a non-null response from the API, it populates
    the received IDs or wallet addresses in a table.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码块中，我们可以观察到标记代码`index.html`托管了一个简单的表单，用于从用户那里获取疑似传感器的钱包地址。用户点击提交按钮时，输入将被确认。点击提交按钮时，将调用
    JavaScript 的`getInfectedIDs`函数。`getInfectedIDs`函数负责执行基本表单验证，并在出现任何故障输入时向用户发出警报。如果没有故障输入，则该函数负责调用接触追踪后端
    API 以检索潜在感染传感器的列表。如果它从 API 收到非空响应，则会在表中填入收到的 ID 或钱包地址。
- en: Now, let's go take a look at some of the testing tools available to test our
    sample DIApp.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看可用于测试我们的示例 DIApp 的一些测试工具。
- en: '**Testing the sample DIApp**'
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**测试示例 DIApp**'
- en: Unfortunately, due to the limited scope of this book, we cannot cover too much
    on testing, so I will point you to some relevant resources in this section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于本书的范围有限，我们无法在测试方面涉及太多内容，所以在本节中我将指引您查阅一些相关资源。
- en: '**Testing smart contracts**: Truffle is one of the most renowned toolchains
    for Solidity smart contract development. You can follow the test instructions
    mentioned in their documentation, which are available at the following link: 
    [https://www.trufflesuite.com/docs/truffle/testing/testing-your-contracts](https://www.trufflesuite.com/docs/truffle/testing/testing-your-contracts).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能合约测试**：Truffle 是 Solidity 智能合约开发中最著名的工具链之一。您可以按照其文档中提到的测试说明进行操作，文档链接在这里：[https://www.trufflesuite.com/docs/truffle/testing/testing-your-contracts](https://www.trufflesuite.com/docs/truffle/testing/testing-your-contracts)。'
- en: '**Testing sensor implementation**: The sensor application is implemented using
    basic Python programming skills. You may have already observed that the script
    interacts with the Google Maps Geolocation API,  Ethereum, and MóiBit. Hence,
    I suggest that you heavily test the HTTP client code. I highly encourage you to
    perform unit testing with as many test cases as possible. You can learn all about
    testing basic Python code by viewing the Python documentation that''s available
    at the following link: [https://docs.python-guide.org/writing/tests/](https://docs.python-guide.org/writing/tests/).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器实现测试**：传感器应用是使用基本的 Python 编程技能实现的。您可能已经观察到脚本与 Google 地图地理定位 API、以太坊和 MóiBit
    进行交互。因此，我建议您对 HTTP 客户端代码进行大量测试。我强烈建议您使用尽可能多的测试用例进行单元测试。您可以通过查看以下链接上提供的 Python
    文档来了解有关测试基本 Python 代码的所有信息：[https://docs.python-guide.org/writing/tests/](https://docs.python-guide.org/writing/tests/)。'
- en: '**Testing the AI model for accuracy**: Testing the AI models with **Mean Absolute
    Error** (**MAE**) is pretty simple and straightforward. However, we are not using
    regressors or classifiers in our sample DIApp. Hence, I urge you to play with
    the dataset by adding new data points so that you can manually verify the results.
    You can check whether the model responds with a false positive or false negative
    in such edge cases. This is your opportunity to get fluent with geospatial analysis!
    Finding content for calculating the accuracy of unsupervised clustering algorithms
    is pretty rare in my experience.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试 AI 模型的准确性**：使用**平均绝对误差**（**MAE**）测试 AI 模型非常简单直接。但是，在我们的示例 DIApp 中，我们并未使用回归器或分类器。因此，我建议您通过添加新数据点来对数据集进行调整，以便手动验证结果。您可以检查模型在此类边缘情况下是否会出现假阳性或假阴性。这是您熟悉地理空间分析的机会！根据我的经验，在计算无监督聚类算法的准确性方面，找到相关内容非常少见。'
- en: 'However, there are a few resources that are hidden gems. I recommend that you
    read [https://www.cs.kent.edu/~jin/DM08/ClusterValidation.pdf](https://www.cs.kent.edu/~jin/DM08/ClusterValidation.pdf)
    to understand more about measuring the accuracy of clustering algorithms through
    various approaches. You can also visit the scikit-learn documentation, which highlights
    some aspects of clustering performance: [https://scikit-learn.org/stable/modules/clustering.html#clustering-performance-evaluation](https://scikit-learn.org/stable/modules/clustering.html#clustering-performance-evaluation).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the contact tracing backend API**: Since we have written our API
    using the Flask framework, I highly recommend that you visit the official testing
    documentation of Flask for more information on testing Flask web applications:
    [https://flask.palletsprojects.com/en/1.1.x/testing/](https://flask.palletsprojects.com/en/1.1.x/testing/).
    I suggest that you test each route with more than one test case for each route
    and handler function defined in the script.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing the web dashboard frontend app**: Finally, the frontend web application
    is a simple piece of implementation. As there isn''t much to test on the Node.js
    side, I suggest that you test the inline JavaScript function in `index.html` to
    get better form validation, pagination, and other edge cases that can make the
    UX better while you''re presenting it.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of testing tools and techniques, let's
    deploy the sample DIApp solution.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying the sample DIApp**'
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have been able to explain the problem statement,
    design a solution for addressing the problem, build the solution, and also make
    some recommendations regarding testing. The whole effort will be fruitful if you
    deploy this application on your own. Hence, in the following sections, I will
    be suggesting that you sign up for the appropriate services that are needed to
    deploy this sample DIApp. I will also instruct you to set up your local system
    with another important special piece of configuration management software required
    to run these programs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**Signing up for the Google Maps API**'
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, we use the Google Maps Geolocation API to get the current lat-long
    coordinates of the sensor. Hence, please follow the instructions in the following
    documentation and get yourself an API key: [https://developers.google.com/maps/premium/apikey/geolocation-apikey](https://developers.google.com/maps/premium/apikey/geolocation-apikey).
    Make sure that you do not share your API key with anyone. It is also important
    that you do not disseminate the API key on open source code hosting platforms.
    If your API key is exposed and still valid, someone could exploit this credential,
    and this will surprise you with a fat invoice. If you think that your API key
    may be exposed, you can delete or disable it and regenerate a new one for our
    sample DIApp.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**Signing up for MóiBit**'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, we use the MóiBit decentralized file storage API to store the
    location history data of each sensor. Hence, you are required to sign up for the
    MóiBit API. The signup process for MóiBit is very straightforward. You can sign
    up for MóiBit at the following link: [https://account.moibit.io/#/signup](https://account.moibit.io/#/signup).
    Once you''ve verified your email address and your password, a new API key will
    be generated for you.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Using these credentials, you are expected to create a new folder under the root
    folder. Please create a new folder there and name it `dictao`, as it is hardcoded
    into our current implementation. This makes sure that all the files will be persisted
    in a dedicated folder. This will also help you use MóiBit for other applications
    without any hassle or clutter. Again, make sure that your API key is not visible
    or accessible to the public.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '**Signing up for Infura**'
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use Infura to connect to the Ethereum Kovan blockchain. You need to create
    a new Infura account and create a new project. Once you''ve created a new project,
    you will need to copy the credentials for the project and use them to get dedicated
    access to the blockchain using Infura''s infrastructure. The registration process
    for Infura is also pretty straightforward. You can sign up for an Infura account
    here: [https://infura.io/register](https://infura.io/register).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating your local justfile**'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have already observed, we use a lot of credentials in our sample
    DIApp. To ensure that these credentials are safely managed, I suggest that you
    manage an isolated file on the host that can privately share these credentials
    to the respective processes. To achieve this, we will be using the `just` command.
    You can install the `just` command by following the instructions available on
    GitHub: [https://github.com/casey/just#installation](https://github.com/casey/just#installation).
    Please follow the installation instructions that fit your system the best, and
    make sure that you create a `justfile`, which is untracked by the `git` protocol.
    This is possible by adding the name justfile to the `.gitignore` file.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the necessary fields by replacing the question marks with the appropriate
    credentials for the services you have now signed up for:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Depending on where you write the source code, you may need to change the relative
    paths of the source code files as well. Just make sure that the justfile is in
    the root of a project folder where you manage all the source code for this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Now, your **justfile** is ready to launch the necessary applications, along
    with your credentials.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying smart contracts**'
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Paste the final smart contract code into [https://remix.ethereum.org/](https://remix.ethereum.org/)
    and deploy the contract on the Ethereum Kovan testnet blockchain. If you are not
    very familiar with the Remix IDE or smart contract development, I recommend that
    you follow the instructions provided in the official Remix documentation, which
    is available here: [https://remix-ide.readthedocs.io/en/latest/create_deploy.html](https://remix-ide.readthedocs.io/en/latest/create_deploy.html).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 将最终的智能合约代码粘贴到[https://remix.ethereum.org/](https://remix.ethereum.org/)并在以太坊Kovan测试网区块链上部署合约。如果您对Remix
    IDE或智能合约开发不太熟悉，我建议您按照官方Remix文档提供的说明进行操作，官方Remix文档链接：[https://remix-ide.readthedocs.io/en/latest/create_deploy.html](https://remix-ide.readthedocs.io/en/latest/create_deploy.html)。
- en: '**Deploying client code into sensors**'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**部署客户端代码到传感器**'
- en: 'In this section, I will show you how to deploy the sensor application. You
    can deploy the sensor application by running the `just` command, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何部署传感器应用程序。您可以通过运行以下`just`命令来部署传感器应用程序：
- en: '[PRE33]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the credentials entered by you are valid and under the service quota, your
    client application will run. Also, make sure that the relative path to the Python
    script is updated in the **justfile**.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入的凭据有效并且在服务配额内，您的客户端应用程序将运行。另外，请确保justfile中Python脚本的相对路径已更新。
- en: '**Deploying the backend API**'
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**部署后端API**'
- en: 'In this section, I will help you launch the contact tracing backend API. You
    can deploy the contact tracing backend API by running the `just` command, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将帮助您启动接触追踪后端API。您可以通过运行以下`just`命令来部署接触追踪后端API：
- en: '[PRE34]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the credentials entered by you are valid and under the service quota, your
    backend API will run. Also, make sure that the relative path to the Python script
    is updated in the **justfile**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入的凭据有效并且在服务配额之内，您的后端API将运行。另外，请确保justfile中Python脚本的相对路径已更新。
- en: '**Deploying the web dashboard**'
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**部署Web仪表板**'
- en: 'In this section, I will help you launch the frontend web dashboard, which can
    be used to query the backend for any potential infections. You can deploy the
    web dashboard application by running the `just` command, as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将帮助您启动前端Web仪表板，该仪表板可用于查询任何潜在感染的后端。您可以通过运行以下`just`命令来部署Web仪表板应用程序：
- en: '[PRE35]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the credentials entered by you are valid and under the service quota, your
    dashboard application will run. Also, make sure that the relative path to the
    Node.js script is updated in the **justfile**.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入的凭据有效并且在服务配额内，您的仪表板应用程序将运行。另外，请确保justfile中Node.js脚本的相对路径已更新。
- en: 'If you are confused about the setup process or the code, you can find the complete
    implementation, including the justfile template, at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08).
    Add your credentials in the appropriate fields of the justfile, and you should
    be able to deploy easily. Feel free to raise an issue if you find difficulties
    in understanding the code or running it. You can also propose improvements to
    the branch by forking the repo and creating a pull request with your suggested
    changes.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对设置过程或代码感到困惑，您可以在以下GitHub链接中找到完整的实现，包括justfile模板：[https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-for-Blockchain/tree/master/Chapter08)。在justfile的相应字段中添加您的凭据，然后您应该可以轻松部署。如果您在理解代码或运行代码时遇到困难，请随时提出问题。您还可以通过分叉存储库并创建包含建议更改的拉取请求来提出对分支的改进。
- en: '**Retrospecting the sample DIApp**'
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**回顾样品DIApp**'
- en: In this section, we will try to analyze the pros and cons of the proposed sample
    DIApp.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试分析所提议的样品DIApp的优缺点。
- en: '**Merits of the sample DIApp**'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**样品DIApp的优点**'
- en: 'Here are some of the merits of our proposed sample DIApp solution:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们提议的样品DIApp解决方案的一些优点：
- en: It covers other agents of infection, apart from humans.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涵盖了除人类之外的其他感染源。
- en: It helps in restoring the global economy and normalcy.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于恢复全球经济和正常状态。
- en: It allows insurance companies and organizations to assess supply chain risks.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许保险公司和组织评估供应链风险。
- en: However, there are some limitations in the sample DIApp we must acknowledge
    and understand.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须承认和理解样品DIApp中的一些限制。
- en: '**Limitations of the sample DIApp**'
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**样品DIApp的限制**'
- en: 'Here are some of the limitations in our proposed sample DIApp solution:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The AI algorithm can be prone to some false positives. Optimization will be
    needed.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to a lack of hardware precision, software accuracy, and a better approach
    to computational complexity, the current implementation of the DIApp cannot be
    used in production.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DIApp is unable to trace infections indoors as GPS is unable to identify
    the floor that the sensor is currently placed in. Other alternatives such as Wi-Fi,
    Bluetooth, a manual check-in register, and CCTV image analysis can be considered
    to boost the accuracy of the model.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at some future enhancements.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Future enhancements**'
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I think that the proposed sample DIApp is simply the beginning of a new revolution.
    You can consider making the following enhancements to the code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Better precision with other modes of input, apart from GPS
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better accuracy by optimizing the models to prevent false positives
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better data retention management for preserving privacy
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing beacons to develop a heat map and assessing risks
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can always reach out to me on GitHub by creating new issues for each of
    the suggestions or by participating in existing issue threads.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both AI and blockchain are major technologies that are catalyzing the pace of
    innovation. The combination of these two technologies is expected to redesign
    the whole industrial paradigm. This chapter has articulated how we can empower
    blockchain and its decentralized applications using various AI techniques and
    models. We covered the evolution of applications and contrasted different types.
    We also explained the latest problems caused by the COVID-19 pandemic and discussed
    how to tackle these problems by taking contact tracing as an example use case.
    We covered the problem statement, the solution approach, and the technical architecture
    in order to develop a sample contact tracing application using the DIApp design
    pattern. We also highlighted the tools needed to test each solution component
    and make it more robust. Finally, we explained how to sign up for each of the
    dependent services used by the solution. This chapter has enabled you to develop
    a paradigm of thinking where you combine both AI and blockchain technologies to
    bring about productive and robust applications aimed at the next generation of
    the internet.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: If the DIApp tutorial in this chapter has inspired you, I highly recommend that
    you contribute what you've learned to a live use case called Tracy. Tracy is a
    privacy-preserving mobile application suite that offers many features to citizens,
    businesses, and government authorities so that they can handle the COVID-19 pandemic
    and beyond. To find out more about how you can contribute to Tracy, please join
    the telegram community at, [https://telegram.me/ProjectTracy](https://telegram.me/ProjectTracy).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover some of the potential use cases of building
    DIApps, where blockchain, AI, and decentralized storage can be used to address
    challenging problems.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将覆盖构建 DIApps 的潜在用例，其中区块链、人工智能和分布式存储可用于解决具有挑战性的问题。
