- en: Blockchain - Outside of Currencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital currencies were the first-ever application of blockchain technology,
    arguably without realizing its real potential. With the invention of Bitcoin,
    the concept of blockchain was introduced for the very first time, but it was not
    until 2013 that the true potential of blockchain technology was realized with
    its possible application in many different industries, other than cryptocurrencies.
    Since then many use cases of blockchain technology in various industries have
    been proposed, including but not limited to finance, the Internet of Things, digital
    rights management, government, and law.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, four main industries namely the Internet of Things, government,
    health, and finance, have been selected, with the aid of use cases, for discussion.
  prefs: []
  type: TYPE_NORMAL
- en: In 2010, discussion started regarding BitDNS, a decentralized naming system
    for domains on the internet. Then Namecoin ([https://wiki.namecoin.org/index.php?title=History](https://wiki.namecoin.org/index.php?title=History))
    started in April 2011 with a different vision as compared to Bitcoin whose sole
    purpose is to provision electronic cash. This can be considered first example
    of blockchain usage other than purely cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: After this by 2013, many ideas emerged. Since 2013 this trend is growing exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Internet of Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Internet of Things** (**IoT**) for short has recently gained much traction
    due to its potential for transforming business applications and everyday life.
    IoT can be defined as a network of computationally intelligent physical objects
    (any object such as cars, fridges, industrial sensors, and so on) that are capable
    of connecting to the internet, sensing real-world events or environments, reacting
    to those events, collecting relevant data, and communicating it over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: This simple definition has enormous implications and has led to exciting concepts,
    such as wearables, smart homes, smart grids, smart connected cars, and smart cities,
    that are all based on this basic concept of an IoT device. After dissecting the
    definition of IoT, four functions come to light as being performed by an IoT device.
    These include **sensing**, **reacting**, **collecting**, and **communicating**.
    All these functions are performed by using various components on the IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Sensing is performed by sensors. Reacting or controlling is performed by actuators,
    the collection is a function of various sensors, and communication is performed
    by chips that provide network connectivity. One thing to note is that all these
    components are accessible and controllable via the internet in the IoT. An IoT
    device on its own is perhaps useful to some extent, but if it is part of a broader
    IoT ecosystem, it is more valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical IoT can consist of many physical objects connecting with each other
    and to a centralized cloud server. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6f1262b-4c86-4d17-a817-e1d438db8f7a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A typical IoT network
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: IBM'
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements of IoT are spread across multiple layers, and various reference architectures
    exist that can be used to develop IoT systems. A five-layer model can be used
    to describe IoT, which contains a physical object layer, device layer, network
    layer, services layer, and application layer. Each layer or level is responsible
    for various functions and includes multiple components. These are shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879e7509-93b0-49e8-8336-49d6cbfeaf26.png)'
  prefs: []
  type: TYPE_IMG
- en: IoT five-layer model
  prefs: []
  type: TYPE_NORMAL
- en: Now we will examine each layer in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Physical object layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These include any real-world physical objects. It includes people, animals,
    cars, trees, fridges, trains, factories, homes, and in fact anything that is required
    to be monitored and controlled can be connected to the IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Device layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer contains things that make up the IoT such as sensors, transducers,
    actuators, smartphones, smart devices, and **Radio-Frequency Identification**
    (**RFID**) tags. There can be many categories of sensors such as body sensors,
    home sensors, and environmental sensors based on the type of work they perform.
    This layer is the core of an IoT ecosystem where various sensors are used to sense
    real-world environments. This layer includes sensors that can monitor temperature,
    humidity, liquid flow, chemicals, air, pressure, and much more. Usually, an **Analog
    to Digital Converter** (**ADC**) is required on a device to turn the real-world
    analog signal into a digital signal that a microprocessor can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Actuators in this layer provide the means to enable control of external environments,
    for example, starting a motor or opening a door. These components also require
    digital to analog converters to convert a digital signal into analog. This method
    is especially relevant when control of a mechanical component is required by the
    IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Network layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer is composed of various network devices that are used to provide Internet
    connectivity between devices and to the cloud or servers that are part of the
    IoT ecosystem. These devices can include gateways, routers, hubs, and switches.
    This layer can include two types of communication.
  prefs: []
  type: TYPE_NORMAL
- en: First there is the horizontal means of communication, which includes radio,
    Bluetooth, Wi-Fi, Ethernet, LAN, Zigbee, and PAN and can be used to provide communication
    between IoT devices. Second, we have communication to the next layer, which is
    usually through the internet and provides communication between machines and people
    or other upper layers. The first layer can optionally be included in the device
    layer as it physically is residing on the device layer where devices can communicate
    with each other at the same layer.
  prefs: []
  type: TYPE_NORMAL
- en: Management layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer provides the management layer for the IoT ecosystem. This includes
    platforms that enable processing of data gathered from the IoT devices and turn
    that into meaningful insights. Also, device management, security management, and
    data flow management are included in this layer. It also manages communication
    between the device and application layers.
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer includes applications running on top of the IoT network. This layer
    can consist of many applications depending on the requirements such as transportation,
    healthcare, financial, insurance, or supply chain management. This list, of course,
    is not an exhaustive list by any stretch of the imagination; there is a myriad
    of IoT applications that can fall into this layer.
  prefs: []
  type: TYPE_NORMAL
- en: With the availability of cheap sensors, hardware, and bandwidth, IoT has gained
    popularity in recent years and currently has applications in many different areas
    including healthcare, insurance, supply chain management, home automation, industrial
    automation, and infrastructure management. Moreover, advancements in technology
    such as the availability of IPv6, smaller and powerful processors, and better
    internet access have also played a vital role in the popularity of IoT.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of IoT range from cost saving to enabling businesses to make vital
    decisions and thus improve performance based on the data provided by the IoT devices.
    Even in domestic usage IoT equipped home appliances can provide valuable data
    for cost saving. For example, smart meters for energy monitoring can provide valuable
    information on how the energy is being used and can convey that back to the service
    provider. Raw data from millions of things (IoT devices) is analyzed and provides
    meaningful insights that help in making timely and efficient business decisions.
  prefs: []
  type: TYPE_NORMAL
- en: The usual IoT model is based on a centralized paradigm where IoT devices usually
    connect to a cloud infrastructure or central servers to report and process the
    relevant data back. This centralization poses certain possibilities of exploitation
    including hacking and data theft. Moreover, not having control of personal data
    on a single, centralized service provider also increases the possibility of security
    and privacy issues. While there are methods and techniques to build a highly secure
    IoT ecosystem based on the normal IoT model, there are specific much more desirable
    benefits that blockchain can bring to IoT. A blockchain-based IoT model differs
    from the traditional IoT network paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: According to IBM, blockchain for IoT can help to build trust, reduce costs,
    and accelerate transactions. Additionally, decentralization, which is at the very
    core of blockchain technology, can eliminate single points of failure in an IoT
    network. For example, a central server perhaps is not able to cope with the amount
    of data that billions of IoT devices (things) are producing at high frequency.
    Also, the peer-to-peer communication model provided by blockchain can help to
    reduce costs because there is no need to build high-cost centralized data centers
    or implementation of complex public key infrastructure for security. Devices can
    communicate with each other directly or via routers.
  prefs: []
  type: TYPE_NORMAL
- en: As an estimate of various researchers and companies, by 2020 there will be roughly
    22 billion devices connected to the internet. With this explosion of billions
    of devices connecting to the internet, it is hard to imagine that centralized
    infrastructures will be able to cope with the high demands of bandwidth, services,
    and availability without incurring excessive expenditure. Blockchain-based IoT
    will be able to solve scalability, privacy, and reliability issues in the current
    IoT model.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain enables *things* to communicate and transact with each other directly
    and with the availability of smart contracts, negotiation, and financial transactions
    can also occur directly between the devices instead of requiring an intermediary,
    authority, or human intervention. For example, if a room in a hotel is vacant,
    it can rent itself out, negotiate the rent, and can open the door lock for a human
    who has paid the right amount of funds. Another example could be that if a washing
    machine runs out of detergent, it could order it online after finding the best
    price and value based on the logic programmed in its smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned five-layer IoT model can be adapted to a blockchain-based
    model by adding a blockchain layer on top of the network layer. This layer will
    run smart contracts, and provide security, privacy, integrity, autonomy, scalability,
    and decentralization services to the IoT ecosystem. The management layer, in this
    case, can consist of only software related to analytics and processing, and security
    and control can be moved to the blockchain layer. This model can be visualized
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6c6713c-9066-4482-bd29-9085e6562700.png)'
  prefs: []
  type: TYPE_IMG
- en: Blockchain-based IoT model
  prefs: []
  type: TYPE_NORMAL
- en: In this model, other layers would perhaps remain the same, but an additional
    blockchain layer will be introduced as a middleware between all participants of
    the IoT network.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be visualized as a peer-to-peer IoT network after abstracting away
    all the layers mentioned earlier. This model is shown in the following diagram
    where all devices are communicating and negotiating with each other without a
    central command and control entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/289f1c70-ba87-429f-aab2-9aa473b57dce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Blockchain-based direct communication model, source: IBM'
  prefs: []
  type: TYPE_NORMAL
- en: It can also result in cost saving which is due to easier device management by
    using a blockchain based decentralized approach. The IoT network can be optimized
    for performance by using blockchain. In this case, there will be no need to store
    IoT data centrally for millions of devices because storage and processing requirements
    can be distributed to all IoT devices on the blockchain. This can result in completely
    removing the need for large data centers for processing and storing the IoT data.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain-based IoT can also thwart denial of service attacks where hackers
    can target a centralized server or data center more efficiently, but with blockchain's
    distributed and decentralized nature, such attacks are no longer possible. Additionally,
    if as estimated there will be billions of devices connected to the internet soon,
    it will become almost impossible to manage security and updates of all those devices
    from traditional centrally-owned servers. Blockchain can provide a solution to
    this problem by allowing devices to communicate with each other directly in a
    secure manner and even request firmware and security updates from each other.
    On a blockchain network, these communications can be recorded immutably and securely
    which will provide auditability, integrity, and transparency to the system. This
    mechanism is not possible with traditional peer-to-peer systems.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, there are clear benefits that can be reaped with the convergence
    of IoT and blockchain and a lot of research and work in academia and industry
    are already in progress. There are various projects already proposed providing
    blockchain-based IoT solutions. For example, IBM Blue Horizon and IBM Bluemix
    are IoT platforms supporting blockchain IoT platforms. Various start-ups such
    as Filament have already proposed novel ideas on how to build a decentralized
    network that enables devices on IoT to transact with each other directly and autonomously
    driven by smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, a practical example is provided on how to build a
    simple IoT device and connect it to the Ethereum blockchain. This IoT device is
    connected to the Ethereum blockchain and is used to open a door (in this case
    the door lock is represented by an LED) when the appropriate amount of funds is
    sent by a user on the blockchain. This is a simple example and requires a more
    rigorously-tested version to implement it in production, but it demonstrates how
    an IoT device can be connected, controlled, and responded to in response to certain
    events on an Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: IoT blockchain experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example makes use of a Raspberry Pi device which is a **Single Board Computer**
    (**SBC**). The Raspberry Pi is a SBC developed as a low-cost computer to promote
    computer education but has also gained much more popularity as a tool of choice
    for building IoT platforms. A Raspberry Pi 3 Model B is shown in the following
    picture. You may be able to use earlier models too, but those have not been tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af1cf9b3-1737-49a0-b108-e764782a4dfe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi Model B
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, an example will be discussed where a Raspberry Pi
    will be used as an IoT device connected to the Ethereum blockchain and will act
    in response to a smart contract invocation.
  prefs: []
  type: TYPE_NORMAL
- en: First, the Raspberry Pi needs to be set up. This can be done by using NOOBS
    which provides an easy method of installing Raspbian or any other operating system.
  prefs: []
  type: TYPE_NORMAL
- en: This can be downloaded and installed from the link [https://www.raspberrypi.org/downloads/noobs/](https://www.raspberrypi.org/downloads/noobs/).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, only Raspbian can be installed from the link [https://www.raspberrypi.org/downloads/raspbian/](https://www.raspberrypi.org/downloads/raspbian/).
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative available at [https://github.com/debian-pi/raspbian-ua-netinst](https://github.com/debian-pi/raspbian-ua-netinst)
    can also be used to install a minimal non-GUI version of Raspbian OS.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, NOOBS has been used to install Raspbian, as such the rest
    of the exercise assumes Raspbian is installed on the SD memory card of the Raspberry
    Pi. The command output in the following screenshot shows that which architecture
    the operating system is running on. In this case, it is `armv71`; therefore ARM-compatible
    binary for Geth will be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The platform can be confirmed by running the command `uname -a` in a terminal
    window in Raspberry Pi Raspbian operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f785964f-ac2c-4e68-bbe6-242a54b3f0f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi architecture
  prefs: []
  type: TYPE_NORMAL
- en: Once the Raspbian operating system is installed, the next step is to download
    the appropriate Geth binary for the Raspberry Pi ARM platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The download and installation steps are described in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Geth download. Note that in the following example a specific version is downloaded
    however other versions are available which can be downloaded from [https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use `wget`, to download the `geth` client images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Other versions are also available, but it's recommended that you download this
    version, as this is the one that has been used in examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unzip and extract into a directory. The directory named `geth-linux-arm7-1.5.6-2a609af5`
    will be created automatically with the `tar` command shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a directory named `geth-linux-arm7-1.5.6-2a609af5`
    and will extract the Geth binary and related files into that directory.  The Geth
    binary can be copied into `/usr/bin` or the appropriate path on Raspbian to make
    it available from anywhere in the operating system. When the download is finished,
    the next step is to create the genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: A genesis block needs to be used . The genesis file can be copied from the other
    node on the network. This is shown in the following screenshot. Alternatively,
    an entirely new genesis block can be generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `genesis.json` file is copied onto the Raspberry Pi; the following
    command can be run to generate the genesis block. It is important that the same
    genesis block is used that was generated previously otherwise the nodes will effectively
    be running on separate networks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the output similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5af344b-1558-4731-94ae-f39dcb6ac953.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initialize genesis ﬁle
  prefs: []
  type: TYPE_NORMAL
- en: 'After genesis block creation, there is a need to add peers to the network.
    This can be achieved by creating a file named `static-nodes.json`, which contains
    the enode ID of the peer that `geth` on the Raspberry Pi will connect for syncing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a909c009-a5d2-4a30-abc2-b2dfc76d6b25.png)'
  prefs: []
  type: TYPE_IMG
- en: Static nodes conﬁguration
  prefs: []
  type: TYPE_NORMAL
- en: 'This information can be obtained from the Geth JavaScript console by running
    the following command, and this command should be run on the peer to which Raspberry
    Pi is going to connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the output similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e8f8557-ed16-47c7-8012-3c2dc11fd9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: geth nodeInfo
  prefs: []
  type: TYPE_NORMAL
- en: After this step, further instructions presented in the following sections can
    be followed to connect Raspberry Pi to the other node on the private network.
    In the example, the Raspberry Pi will be connected to the network ID `786` *.*
    The key is to use the same genesis file created previously and different port
    numbers. Same genesis file will ensure that clients connect to the same network
    in which the genesis file originated from.
  prefs: []
  type: TYPE_NORMAL
- en: Different ports are not a strict requirement, however, if the two nodes are
    running under a private network and access from an environment external to the
    network is required then a combination of DMZ, router and port forwarding will
    be used. Therefore, it is recommended to use different TCP ports to allow port
    forwarding to work correctly. The `--identity` switch shown in the following command
    for first node set up, which hasn't been introduced previously, allows for an
    identifying name to be specified for the node.
  prefs: []
  type: TYPE_NORMAL
- en: First node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, the `geth` client needs to be started on the first node using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edcc6dee-38c2-484d-90ee-23baa19dc291.png)'
  prefs: []
  type: TYPE_IMG
- en: geth on first node
  prefs: []
  type: TYPE_NORMAL
- en: Once this is started up, it should be kept running, and another `geth` instance
    should be started from the Raspberry Pi node.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Raspberry Pi, the following command is required to be run to start `geth`
    and to sync it with other nodes (in this case only one node). The following is
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This should produce the output similar to the one shown in the following screenshot.
    When the output contains the row displaying `Block synchronisation started` it
    means that the node has connected successfully to its peer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a027b48b-9a5b-404a-bc16-03d2c82eb8c1.png)'
  prefs: []
  type: TYPE_IMG
- en: geth on the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be further verified by running commands in the `geth` console on both
    nodes as shown in the following screenshot. The `geth` client can be attached
    by simply running the following command on the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open the JavaScript `geth` console for interacting with the `geth`
    node. We can use `admin.peers` command to see the connected peers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84ff77e5-98e8-4ff8-ad04-0e13394245ea.png)'
  prefs: []
  type: TYPE_IMG
- en: geth console admin peers command running on Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can attach to the `geth` instance by running the following command
    on the first node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the console is available `admin.peers` can be run to reveal the details
    about other connected nodes as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fcb4ee4-3d0b-4899-ac97-5831b605bcc3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: geth console admin peers command running on the other peer
  prefs: []
  type: TYPE_NORMAL
- en: Once both nodes are up-and-running further prerequisites can be installed to
    set up the experiment. Installation of Node.js and the relevant JavaScript libraries
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The required libraries and dependencies are listed here. First Node.js and
    npm need to be updated on the Raspberry Pi Raspbian operating system. For this
    the following steps can be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install latest Node.js on the Raspberry Pi using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This should display output similar to the following. The output is quite large
    therefore only the top part of the output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40c0f85b-884f-44a3-9d05-cd7793488e25.png)'
  prefs: []
  type: TYPE_IMG
- en: Node.js installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the update via `apt-get`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Verification can be performed by running the following command to ensure that
    the correct versions of Node.js and npm are installed, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48190d0c-42aa-4600-aa25-bf3b50a23cf4.png)'
  prefs: []
  type: TYPE_IMG
- en: npm and node installation veriﬁcation
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that these versions are not a necessity; any of the latest
    version of npm and Node.js should work. However, the examples in this chapter
    make use of npm 4.0.5 and node v7.4.0, so it is recommended that readers use the
    same version in order to avoid any compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Ethereum `web3` npm, which is required to enable JavaScript code to
    access the Ethereum blockchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that specific version of `web3` shown in the screenshot is installed
    or a version similar to this for example 0.20.2\. This is important because by
    default version 1.0.0-beta.26 (at the time of writing) will be installed which
    is beta and is under development. Therefore `web3` 0.20.2 or 0.18.0 stable version
    should be used for this example. Readers can install this version by using `$
    npm install web3@0.20.2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c09cca9c-bff3-40e4-a538-1886207c3d44.png)'
  prefs: []
  type: TYPE_IMG
- en: npm install web3
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, npm `onoff` can be installed, which is required to communicate with
    the Raspberry Pi and control GPIO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3bf03b0a-0405-470b-b4a8-06a99cee3758.png)'
  prefs: []
  type: TYPE_IMG
- en: Onoff installation
  prefs: []
  type: TYPE_NORMAL
- en: When all the prerequisites are installed, hardware setup can be performed. For
    this purpose, a simple circuit is built using a breadboard and a few electronic
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware components are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LED**: The abbreviation of **Light Emitting Diode**, this can be used as
    a visual indication for an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resistor**: A 330 ohm component is required which provides resistance to
    passing current based on its rating. It is not necessary to understand the theory
    behind it for this experiment; any standard electronics engineering text covers
    all these topics in detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breadboard**: This provides a means of building an electronic circuit without
    requiring soldering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T-Shaped cobbler**: This is inserted on the breadboard as shown in the following
    photo and provides a labeled view of all **General Purpose I/O** (**GPIO**) pins
    for the Raspberry Pi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ribbon cable connector**: This is simply used to provide connectivity between
    the Raspberry Pi and the breadboard via GPIO. All these components are shown in
    the following picture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5757c049-56cb-4de1-a214-489b8a11952b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Required components
  prefs: []
  type: TYPE_NORMAL
- en: Circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the following picture, the positive leg (long leg) of the LED is
    connected to pin number **21** of the GPIO, and the negative (short leg) is connected
    to the resistor, which is then connected to the **ground** (**GND**) pin of the
    GPIO. Once the connections are set up the ribbon cable can be used to connect
    to the GPIO connector on the Raspberry Pi simply.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96b739e1-6385-46bf-ae13-296f2d1f3c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Connections for components on the breadboard
  prefs: []
  type: TYPE_NORMAL
- en: Once the connections are set up correctly, and the Raspberry Pi has been updated
    with the appropriate libraries and Geth, the next step is to develop a simple,
    smart contract that expects a value. If the value provided to it is not what it
    expects it does not trigger an event; otherwise if the value passed matches the
    correct value, the event triggers which can be read by the client JavaScript program
    running via Node.js. Of course, the Solidity contract can be very complicated
    and can also deal with the Ether sent to it, and if the amount of Ether is equal
    to the required amount, then the event can trigger. However, in this example,
    the aim is to demonstrate the usage of smart contracts to trigger events that
    can then be read by JavaScript program running on Node.js, which then, in turn,
    can trigger actions on IoT devices using various libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smart contract source code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca16bbd7-4a9c-418b-bb4e-a1392972e1ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Solidity code for simple IOT
  prefs: []
  type: TYPE_NORMAL
- en: 'The online Solidity compiler (Remix IDE) can be used to run and test this contract.
    The **Application Binary Interface** (**ABI**) required for interacting with the
    contract is also available in the Details section as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/399e4c20-260d-405f-83cc-da4e91a1ffe6.png)'
  prefs: []
  type: TYPE_IMG
- en: ABI from Remix IDE
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the ABI of the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are two methods by which the Raspberry Pi node can connect to the private
    blockchain via the `web3` interface. The first is where the Raspberry Pi device
    is running its own `geth` client locally and maintains its ledger, but with resource-constrained
    devices, it is not possible to run a full `geth` node or even a light node in
    a few circumstances. In that case, the second method, which uses `web3` provider
    can be used to connect to the appropriate RPC channel. This will be shown later
    in the client JavaScript Node.js program.
  prefs: []
  type: TYPE_NORMAL
- en: 'A comparison of both of these approaches is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d969160-4874-4689-a9cc-8d7115a95612.png)'
  prefs: []
  type: TYPE_IMG
- en: Application architecture of room rent IoT application (IoT device with local
    ledger)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8e6fb7d-5ea8-41ad-8805-620b4cd5e63e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Application architecture of room rent IoT application (IoT device without local
    ledger)
  prefs: []
  type: TYPE_NORMAL
- en: There are obvious security concerns which arise from exposing RPC interfaces
    publicly; therefore, it is recommended that this option is used only on private
    networks and if required to be used on public networks appropriate security measures
    are put in place, such as allowing only the known IP addresses to connect to the
    `geth` RPC interface. This can be achieved by a combination of disabling peer
    discovery mechanisms and HTTP-RPC server listening interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: More information about this can be found using `geth help`. The traditional
    network security measures such as firewalls, **Transport Layer Security** (**TLS**)
    and certificates can also be used but have not been discussed in this example.
    Now Truffle can be used to deploy the contract on the private network ID `786`
    to which at this point the Raspberry Pi is connected. Truffle deploy can be performed
    simply by using the following shown command;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It should produce the output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c907b6d-9abe-4f4d-9295-53d92bd73681.png)'
  prefs: []
  type: TYPE_IMG
- en: Truffle deploy
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the contract is deployed correctly, JavaScript code can be developed that
    will connect to the blockchain via `web3`, listen for the events from the smart
    contract in the blockchain, and turn the LED on via the Raspberry Pi. The JavaScript
    code of the `index.js` file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding example the contract address `'0x975881c44fbef4573fef33cccec1777a8f76669c'`
    for variable `var ContractAddress` is specific to the deployment and it will be
    different when readers run this example. Simply change the address in the file
    to what you see after deploying the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the HTTP-RPC server listening port on which Geth has been started
    on Raspberry Pi. By default, it is TCP port `8545`. Remember to change this according
    to your Raspberry Pi setup and Geth configuration. It is set to `9002` in the
    preceding example code because Geth running on Raspberry Pi is listening on `9002`
    in the example. If it''s listening to a different port on your Raspberry Pi, then
    change it to that port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When Geth starts up it shown which port it has HTTP endpoint listening on. This
    is also configurable with `--rpcport` in `geth` by specifying the port number
    value as a parameter to the flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This JavaScript code can be placed in a file on the Raspberry Pi, for example,
    `index.js`. It can be run by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will start the program, which will run on Node.js and listen for events
    from the smart contract. Once the program is running correctly, the smart contract
    can be invoked by using the Truffle console as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `getRent` function is called with parameter `10`, which is
    the expected value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19a77308-ecbd-4be7-aa4f-e3b3ad8b3f80.png)'
  prefs: []
  type: TYPE_IMG
- en: Interaction with the contract
  prefs: []
  type: TYPE_NORMAL
- en: After the contract is mined, `roomRented` will be triggered, which will turn
    on the LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, it is a simple LED, but it can be any physical device such
    as a room lock that can be controlled via an actuator. If all works well, the
    LED will be turned on as a result of the smart contract function invocation as
    shown in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ff8a349-8303-4257-8726-4dc3b6737d1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi with LED control
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, on node side it will display output similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated in the preceding example, a private network of IoT devices can
    be built that runs a `geth` client on each of the nodes and can listen for events
    from smart contracts and trigger an action accordingly. The example shown is simple
    on purpose but demonstrates the underlying principles of an Ethereum network that
    can be built using IoT devices along with smart contract-driven control of the
    physical devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, other applications of the blockchain technology in government,
    finance, and health will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Government
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various applications of blockchain being researched currently that
    can support government functions and take the current model of e-government to
    the next level. First, in this section, some background for e-government will
    be provided, and then a few use cases such as e-voting, homeland security (border
    control), and electronic IDs (citizen ID cards) will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Government or electronic government is a paradigm where information and communication
    technology are used to deliver public services to citizens. The concept is not
    new and has been implemented in various countries around the world, but with blockchain,
    a new avenue of exploration has opened up. Many governments are researching the
    possibility of using blockchain technology for managing and delivering public
    services including but not limited to identity cards, driving licenses, secure
    data sharing among various government departments and contract management. Transparency,
    auditability, and integrity are attributes of blockchain that can go a long way
    in effectively managing various government functions.
  prefs: []
  type: TYPE_NORMAL
- en: Border control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated border control systems have been in use for decades now to thwart
    illegal entry into countries and prevent terrorism and human trafficking.
  prefs: []
  type: TYPE_NORMAL
- en: Machine-readable travel documents and specifically biometric passports have
    paved the way for automated border control; however current systems are limited
    to a certain extent and blockchain technology can provide solutions. A **Machine
    Readable Travel Document** (**MRTD**) standard is defined in document ICAO 9303
    ([https://www.icao.int/publications/pages/publication.aspx?docnum=9303](https://www.icao.int/publications/pages/publication.aspx?docnum=9303))
    by the **International Civil Aviation Organization** (**ICAO**) and has been implemented
    by many countries around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Each passport contains various security and identity attributes that can be
    used to identify the owner of the passport and also circumvent attempts at tampering
    with the passports. These include biometric features such as retina scan, fingerprints,
    facial recognition, and standard ICAO specified features including **Machine Readable
    Zone** (**MRZ**) and other text attributes that are visible on the first page
    of the passport.
  prefs: []
  type: TYPE_NORMAL
- en: One key issue with current border control systems is data sharing whereby the
    systems are controlled by a single entity and data is not readily shared among
    law enforcement agencies. This lack of the ability to share data makes it challenging
    to track suspected travel documents or individuals. Another issue is related to
    the immediate implementation of blacklisting of a travel document, for example,
    when there is an immediate need to track and control suspected travel documents.
    Currently, there is no mechanism available to blacklist or revoke a suspected
    passport immediately and broadcast it to the border control ports worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain can provide a solution to this problem by maintaining a blacklist
    in a smart contract which can be updated as required and any changes will be immediately
    visible to all agencies and border control points thus enabling immediate control
    over the movement of a suspected travel document. It could be argued that traditional
    mechanisms like PKIs and peer-to-peer networks can also be used for this purpose,
    but they do not provide the benefits that a blockchain can provide. With blockchain,
    the whole system can be simplified without the requirement of complex networks
    and PKI setups which will also result in cost reduction. Moreover, blockchain
    based systems will provide cryptographically guaranteed immutability which helps
    with auditing and discourages any fraudulent activity.
  prefs: []
  type: TYPE_NORMAL
- en: The full database of all travel documents perhaps cannot be stored on the blockchain
    currently due to scalability issues, but a backend distributed database such as
    BigchainDB, IPFS, or Swarm can be used for that purpose. In this case, a hash
    of the travel document with the biometric ID of an individual can be stored in
    a simple smart contract, and a hash of the document can then be used to refer
    to the detailed data available on the distributed filesystem such as IPFS. This
    way, when a travel document is blacklisted anywhere on the network, that information
    will be available immediately with the cryptographic guarantee of its authenticity
    and integrity throughout the distributed ledger. This functionality can also provide
    adequate support in anti-terrorism activities, thus playing a vital role in the
    homeland security function of a government.
  prefs: []
  type: TYPE_NORMAL
- en: A simple contract in Solidity can have an array defined for storing identities
    and associated biometric records. This array can be used to store the identifying
    information about a passport. The identity can be a hash of MRZ of the passport
    or travel document concatenated with the biometric record from the RFID chip.
    A simple Boolean field can be used to identify blacklisted passports. Once this
    initial check passes, further detailed biometric verification can be performed
    by traditional systems and eventually when a decision is made regarding the entry
    of the passport holder that decision can be propagated back to the blockchain,
    thus enabling all participants on the network to immediately share the outcome
    of the decision.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level approach to building a blockchain-based border control system can
    be visualized as shown in the following diagram. In this scenario, the passport
    is presented for scanning to an RFID and page scanner which reads the data page
    and extracts machine-readable information along with a hash of the biometric data
    stored in the RFID chip. At this stage, a live photo and retina scan of the passport
    holder is also taken. This information is then passed on to the blockchain where
    a smart contract is responsible for verifying the legitimacy of the travel document
    by first checking its list of blacklisted passports and then requesting more data
    from the backend IPFS database for comparison. Note that the biometric data such
    as photo or retina scan is not stored on the blockchain, instead only a reference
    to this data in the backend (IPFS or BigchainDB) is stored in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: If the data from the presented passport matches with what is held in the IPFS
    as files or in BigchainDB and also pass the smart contract logical check, then
    the border gate can be opened.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30e46cd-22d0-4dab-a1c2-93a6bb6e24e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Automated border control using blockchain
  prefs: []
  type: TYPE_NORMAL
- en: After verification, this information is propagated throughout the blockchain
    and is instantly available to all participants on the border control blockchain.
    These participants can be a worldwide consortium of homeland security departments
    of various nations.
  prefs: []
  type: TYPE_NORMAL
- en: Voting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Voting in any government is a key function and allows citizens to participate
    in the democratic election process. While voting has evolved into a much more
    mature and secure process, it still has limitations that need to be addressed
    to achieve a desired level of maturity. Usually, the limitations in current voting
    systems revolve around fraud, weaknesses in operational processes, and especially
    transparency. Over the years, secure voting mechanisms (machines) have been built
    which make use of specialized voting machines that promised security and privacy,
    but they still had vulnerabilities that could be exploited to subvert the security
    mechanisms of those machines. These vulnerabilities can lead to serious implications
    for the whole voting process and can result in mistrust in the government by the
    public.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain-based voting systems can resolve these issues by introducing end-to-end
    security and transparency in the process. Security is provided in the form of
    integrity and authenticity of votes by using public key cryptography which comes
    as standard in a blockchain. Moreover, immutability guaranteed by blockchain ensures
    that votes cast once cannot be cast again. This can be achieved through a combination
    of biometric features and a smart contract maintaining a list of votes already
    cast. For example, a smart contract can maintain a list of already casted votes
    with the biometric ID (for example a fingerprint) and can use that to detect and
    prevent double casting. Secondly, **Zero-Knowledge Proofs** (**ZKPs**) can also
    be used on the blockchain to protect voters' privacy on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Some companies are already providing such services, one example is [https://polys.me/blockchain/online-voting-system](https://polys.me/blockchain/online-voting-system).
  prefs: []
  type: TYPE_NORMAL
- en: Recently, presidential elections were held in Sierra Leone using blockchain
    technology, making it the first country to use blockchain technology for elections
    ([https://www.coindesk.com/sierra-leone-secretly-holds-first-blockchain-powered-presidential-vote/](https://www.coindesk.com/sierra-leone-secretly-holds-first-blockchain-powered-presidential-vote/)).
  prefs: []
  type: TYPE_NORMAL
- en: Citizen identification (ID cards)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Electronic IDs or national ID cards are issued by various countries around the
    world at present. These cards are secure and possess many security features that
    thwart duplication or tampering attempts. However, with the advent of blockchain
    technology, several improvements can be made to this process.
  prefs: []
  type: TYPE_NORMAL
- en: Digital identity is not only limited to just government-issued ID cards; it
    is a concept that applies to online social networks and forums too. There can
    be multiple identities used for different purposes. A blockchain-based online
    digital identity allows control over personal information sharing. Users can see
    who used their data and for what purpose and can control access to it. This is
    not possible with the current infrastructures which are centrally controlled.
    The key benefit is that a single identity issued by the government can be used
    easily and in a transparent manner for multiple services via a single government
    blockchain. In this case, the blockchain serves as a platform where a government
    is providing various services such as pensions, taxation, or benefits and a single
    ID is being used for accessing all these services. Blockchain, in this case, provides
    a permanent record of every change and transaction made by a digital ID, thus
    ensuring integrity and transparency of the system. Also, citizens can notarize
    birth certificates, marriages, deeds, and many other documents on the blockchain
    tied with their digital ID as a proof of existence.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are successful implementations of identity schemes in various
    countries that work well, and there is an argument that perhaps blockchain is
    not required in identity management systems. Although there are several benefits
    such as privacy and control over the usage of identity information due to the
    current immaturity of blockchain technology, perhaps it is not ready for use in
    real-world identity systems. However, research is being carried out by various
    governments to explore the usage of blockchain for identity management.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, laws such as the right to be forgotten can be quite difficult to incorporate
    into blockchain due to its immutable nature.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other government functions where blockchain technology can be implemented to
    improve cost and efficiency include the collection of taxes, benefits management
    and disbursement, land ownership record management, life event registration (marriages,
    births), motor vehicle registration, and licenses. This is not an exhaustive list,
    and over time many functions and processes of a government can be adapted to a
    blockchain-based model. The key benefits of blockchain such as immutability, transparency,
    and decentralization can help to bring improvements to most of the traditional
    government systems.
  prefs: []
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The health industry has also been identified as another major industry that
    can benefit by adapting blockchain technology. Blockchain provides an immutable,
    auditable, and transparent system that traditional peer-to-peer networks cannot.
    Also, blockchain provides a cost-effective, simpler infrastructure as compared
    to traditional complex PKI networks. In healthcare, major issues such as privacy
    compromises, data breaches, high costs, and fraud can arise from lack of interoperability,
    overly complex processes, transparency, auditability, and control. Another burning
    issue is counterfeit medicines; especially in developing countries, this is a
    major cause of concern.
  prefs: []
  type: TYPE_NORMAL
- en: With the adaptability of blockchain in the health sector, several benefits can
    be realized, ranging from cost saving, increased trust, faster processing of claims,
    high availability, no operational errors due to complexity in the operational
    procedures, and preventing the distribution of counterfeit medicines.
  prefs: []
  type: TYPE_NORMAL
- en: From another angle, blockchains that are providing a digital currency as an
    incentive for mining can be used to provide processing power to solve scientific
    problems that can help to find cures for certain diseases. Examples include FoldingCoin,
    which rewards its miners with FLDC tokens for sharing their computer's processing
    power for solving scientific problems that require unusually large calculations.
  prefs: []
  type: TYPE_NORMAL
- en: FoldingCoin is available at [http://foldingcoin.net/](http://foldingcoin.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Another similar project is called CureCoin which is available at [https://www.curecoin.net/](https://www.curecoin.net/).
    It is yet to be seen that how successful these projects will be in achieving their
    goals but the idea is very promising.
  prefs: []
  type: TYPE_NORMAL
- en: Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain has many applications in the finance industry. Blockchain in finance
    is the hottest topic in the industry currently, and major banks and financial
    organizations are researching to find ways to adapt blockchain technology primarily
    due to its highly-desired potential to cost-save.
  prefs: []
  type: TYPE_NORMAL
- en: Insurance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the insurance industry, blockchain technology can help to stop fraudulent
    claims, increase the speed of claim processing, and enable transparency. Imagine
    a shared ledger between all insurers that can provide a quick and efficient mechanism
    for handling intercompany claims. Also, with the convergence of IoT and blockchain,
    an ecosystem of smart devices can be imagined where all these things can negotiate
    and manage their insurance policies controlled by smart contracts on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain can reduce the overall cost and effort required to process claims.
    Claims can be automatically verified and paid via smart contracts and the associated
    identity of the insurance policyholder. For example, a smart contract with the
    help of Oracle and possibly IoT can make sure that when the accident occurred,
    it can record related telemetry data and based on this information can release
    payment. It can also withhold payment if the smart contract after evaluating conditions
    of payment concludes that payment should not be released. For example, in a scenario
    where an authorized workshop did not repair the vehicle or was used outside a
    designated area and so on and so forth. There can be many conditions that a smart
    contract can evaluate to process claims and choice of these rules depend on the
    insurer, but the general idea is that smart contracts in combination with IoT
    and Oracle can automate the entire vehicle insurance industry.
  prefs: []
  type: TYPE_NORMAL
- en: Several start-ups such as Dynamis have proposed smart contract-based peer-to-peer
    insurance platforms that run on Ethereum blockchain. This is initially proposed
    to be used for unemployment insurance and does not require underwriters in the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: It is available at [http://dynamisapp.com/](http://dynamisapp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Post-trade settlement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most sought-after application of blockchain technology. Currently,
    many financial institutions are exploring the possibility of using blockchain
    technology to simplify, automate, and speed up the costly and time-consuming post-trade
    settlement process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the problem better, the trade life cycle is described briefly.
    A trade life cycle contains three steps: execution, clearing, and settlement.
    Execution is concerned with the commitment of trading between two parties and
    can be entered into the system via front office order management terminals or
    exchanges. Clearing is the next step whereby the trade is matched between the
    seller and buyer based on certain attributes such as price and quantity. At this
    stage, accounts that are involved in payment are also identified. Finally, the
    settlement is where eventually the security is exchanged for payment between the
    buyer and seller.'
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional trade life cycle model, a central clearinghouse is required
    to facilitate trading between parties which bears the credit risk of both parties.
    The current scheme is somewhat complicated, whereby a seller and buyer have to
    take a complicated route to trade with each other. This comprises of various firms,
    brokers, clearing houses, and custodians but with blockchain, a single distributed
    ledger with appropriate smart contracts can simplify this whole process and can
    enable buyers and sellers to talk directly to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, the post-trade settlement process usually takes two to three days and
    has a dependency on central clearing houses and reconciliation systems. With the
    shared ledger approach, all participants on the blockchain can immediately see
    a single version of truth regarding the state of the trade. Moreover, the peer-to-peer
    settlement is possible, which results in the reduction of complexity, cost, risk,
    and the time it takes to settle the trade. Finally, intermediaries can be eliminated
    by making use of appropriate smart contracts on the blockchain. Also, regulators
    can also see view the blockchain for auditing and regulatory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This can be very useful in implementing MIFID-II regulation requirements ([https://www.fca.org.uk/markets/mifid-ii](https://www.fca.org.uk/markets/mifid-ii)).
  prefs: []
  type: TYPE_NORMAL
- en: Financial crime prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Know Your Customer** (**KYC**), and **Anti Money Laundering** (**AML**) are
    the key enablers for the prevention of financial crime. In the case of KYC, currently,
    each institution maintains their own copy of customer data and performs verification
    via centralized data providers. This can be a time-consuming process and can result
    in delays in onboarding a new client.'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain can provide a solution to this problem by securely sharing a distributed
    ledger between all financial institutions that contain verified and true identities
    of customers. This distributed ledger can only be updated by consensus between
    the participants thus providing transparency and auditability. This can not only
    reduce costs but also enable meeting regulatory and compliance requirements in
    a better and consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of AML, due to the immutable, shared, and transparent nature of
    blockchain, regulators, can easily be granted access to a private blockchain where
    they can fetch data for relevant regulatory reporting. This will also result in
    reducing complexity and costs related to the current regulatory reporting paradigm
    where data is fetched from various legacy and disparate systems and aggregated
    and formatted together for reporting purposes. Blockchain can provide a single
    shared view of all financial transactions in the system that are cryptographically
    secure, authentic, and auditable, thus reducing the costs and complexity associated
    with the currently employed regulatory reporting methods.
  prefs: []
  type: TYPE_NORMAL
- en: Media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Critical issues in the media industry revolve around content distribution, rights
    management, and royalty payments to artists. For example, digital music can be
    copied many times without any restriction and any attempts to apply copy protection
    have been hacked in some way or other. There is no control over the distribution
    of the content that a musician or songwriter produces; it can be copied as many
    times as needed without any restriction and consequently has an impact on the
    royalty payments. Also, payments are not always guaranteed and are based on traditional
    airtime figures. All these issues revolving around copy protection and royalty
    payments can be resolved by connecting consumers, artists, and all players in
    the industry, allowing transparency and control over the process. Blockchain can
    provide a network where digital music is cryptographically guaranteed to be owned
    only by the consumers who pay for it. This payment mechanism is controlled by
    a smart contract instead of a centralized media agency or authority. The payments
    will be automatically made based on the logic embedded within the smart contract
    and number of downloads.
  prefs: []
  type: TYPE_NORMAL
- en: A recent example of such an initiative is Musicoin ([https://musicoin.org](https://musicoin.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, illegal copying of digital music files can be stopped altogether because
    everything is recorded and owned immutably in a transparent manner on the blockchain.
    A music file, for example, can be stored with owner information and timestamp
    which can be traced throughout the blockchain network. Furthermore, the consumers
    who own a legal copy of some content are cryptographically tied to the content
    they have, and it cannot be moved to another owner unless permissioned by the
    owner. Copyrights and transfers can be managed easily via blockchain once all
    digital content is immutably recorded on the blockchain. Smart contracts can then
    control the distribution and payment to all concerned parties.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many applications of blockchain technology, and as discussed in the
    chapter they can be implemented in various industries to bring about multiple
    benefits to existing solutions. In this chapter, five main industries that can
    benefit from blockchain have been discussed. First IoT was discussed, which is
    another revolutionary technology on its own; and by combining it with the blockchain,
    several fundamental limitations can be addressed, which brings about tremendous
    benefits to the IoT industry. More focus has been given to IoT as it is the most
    prominent and most ready candidate for adapting blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Already, practical use cases and platforms have emerged in the form of **Platform
    as a Service** (**PaaS**) for blockchain-based IoT such as the IBM Watson IoT
    blockchain. IBM Blue Horizon is also now available for experimentation, which
    is a decentralized blockchain-based IoT network. Second, applications in the government
    sector were discussed whereby various government processes such as homeland security,
    identification cards, and benefit disbursements can be made transparent, secure,
    and more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, issues in the finance sector were discussed with possible solutions
    that blockchain technology could provide. Although the finance sector is exploring
    the possibilities of using blockchain with high energy and enthusiasm, it is still
    far away from production-ready blockchain-based systems. Finally, some aspects
    of the health sector and music industry were also discussed. All these use cases
    and much more in the industry stand on pillars provided by core attributes of
    blockchain technology such as decentralization, transparency, reliability, and
    security. However, certain challenges need to be addressed before blockchain technology
    can be adapted fully; these will be discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
