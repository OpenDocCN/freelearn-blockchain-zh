["```\nsudo apt-get install build-essential\nsudo apt-get install python3\nsudo apt-get install python3-dev libssl-dev libgmp-dev\n```", "```\nbrew install python3\nbrew install gmp\n```", "```\ngit clone https://github.com/nucypher/nucypher-pre-python.git\ncd nucypher-pre-python\npip3 install -e .\n```", "```\n# Import bbs98 from NuCypher PRE\nfrom npre import bbs98\n# Initialize the re-encryption object\npre = bbs98.PRE()\n\n# 'sk' means \"secret key\", and 'pk' means \"public key\"\n\n# Alice's Private key\nsk_a = pre.gen_priv(dtype=bytes)\n# Alice's Public Key\npk_a = pre.priv2pub(sk_a)\n\n# Bob's Private Key\nsk_b = pre.gen_priv(dtype=bytes)\n# Bob's Public Key\npk_b = pre.priv2pub(sk_b)\n\n# Print Alice's Private Key as Hex String\nprint(sk_a.hex()[2:])\n# Print Bob's Private Key as Hex String\nprint(sk_b.hex()[2:])\n\n# Encrypt Message using Alice's Public Key\nemsg = pre.encrypt(pk_a, \"Hello World\")\n\n# Generate Re-Encrypt Key using Private key of sender and receiver\nre_ab = pre.rekey(sk_a, sk_b)\n# Re-Encrypt Message using Re-Encrypt key\nemsg_b = pre.reencrypt(re_ab, emsg)\n\n# Decrypt the message using Bob's Private Key\ndmsg = pre.decrypt(sk_b, emsg_b)\n# Print Decrypted Message\nprint(dmsg.decode(\"utf-8\"))\n```", "```\npragma solidity ^0.4.22;\n\ncontract Health {\n\n    address owner;\n\n    struct ServiceProvider {\n        string publicKey;\n    }\n\n    struct Permission {\n        bool read;\n        bool write;\n        string reEncKey; //Re-Encrypt Key\n    }\n\n    struct Token {\n        int status;\n        bool read;\n        bool write;\n        string reEncKey; //Re-Encrypt Key\n    }\n\n    struct EMR {\n        string hash;\n        address issuer;\n    }\n\n    struct Patient {\n        string publicKey;\n        mapping (address => Permission) permissions;\n        mapping (bytes32 => Token) tokens;\n        bool closed;\n        EMR[] EMRs;\n    }\n\n    mapping (address => ServiceProvider) serviceProviders;\n    mapping (address => Patient) patients;\n\n    event tokenVerified (bytes32 hash, address patient, address\n      serviceProvider);\n    event reEncKeyAdded (address patient, address serviceProvider);\n    event patientAccountChanged(address oldAccountAddress, string\n      oldAccountPublicKey, address newAccountAddress, string \n      newAccountPublicKey, string reEncKey);\n    event emrAdded(address patient, address serviceProvider, \n      string emrHash);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    //Utilities\n    function fromHexChar(uint c) public pure returns (uint) {\n        if (byte(c) >= byte('0') && byte(c) <= byte('9')) {\n            return c - uint(byte('0'));\n        }\n        if (byte(c) >= byte('a') && byte(c) <= byte('f')) {\n            return 10 + c - uint(byte('a'));\n        }\n        if (byte(c) >= byte('A') && byte(c) <= byte('F')) {\n            return 10 + c - uint(byte('A'));\n        }\n    }\n\n    function fromHex(string s) public pure returns (bytes) {\n        bytes memory ss = bytes(s);\n        require(ss.length%2 == 0); // length must be even\n        bytes memory r = new bytes(ss.length/2);\n        for (uint i=0; i<ss.length/2; ++i) {\n            r[i] = byte(fromHexChar(uint(ss[2*i])) * 16 +\n                        fromHexChar(uint(ss[2*i+1])));\n        }\n        return r;\n    }\n\n    //Register Patient\n    function addPatient(string publicKey) returns (int reason) {\n        if(address(keccak256(fromHex(publicKey))) == msg.sender) {\n            patients[msg.sender].publicKey = publicKey;\n        }\n    }\n\n    //Register Service provider\n    function addServiceProvider(string publicKey) {\n        if(address(keccak256(fromHex(publicKey))) == msg.sender) {\n            serviceProviders[msg.sender].publicKey = publicKey;\n        }\n    }\n\n    //Patient:\n    //In QRCode include token string, address and private key\n    //Adds the hash of token and derivation key in Blockchain\n    function addToken(bytes32 hash, bool read, bool write, string reEncKey) {\n        if(patients[msg.sender].tokens[hash].status == 0 &&\n          patients[msg.sender].closed == false) {\n            patients[msg.sender].tokens[hash].status = 1;\n            patients[msg.sender].tokens[hash].read = read;\n            patients[msg.sender].tokens[hash].write = write;\n            patients[msg.sender].tokens[hash].reEncKey = reEncKey;\n        }\n    }\n\n    //Service Provider proves the token to get access\n    function requestAccess(string token, address patient) {\n        bytes32 hash = sha256(token);\n        if(patients[patient].tokens[hash].status == 1) {\n            patients[patient].tokens[hash].status = 2;\n            patients[patient].permissions[msg.sender].read =\n              patients[patient].tokens[hash].read;\n            patients[patient].permissions[msg.sender].write =\n              patients[patient].tokens[hash].write;\n            patients[patient].permissions[msg.sender].reEncKey =\n              patients[patient].tokens[hash].reEncKey;\n            tokenVerified(hash, patient, msg.sender);\n        }\n    }\n\n    //Add EMR\n    function addEMR(address patient, string hash) {\n        if(patients[patient].permissions[msg.sender].write == true) {\n            patients[patient].EMRs.push(EMR(hash, msg.sender));\n            emrAdded(patient, msg.sender, hash);\n        }\n    }\n\n    function getPatientPublicKey(address patient) returns\n      (string publicKey) {\n        return patients[patient].publicKey;\n    }\n\n    function isPatientProfileClosed(address patient) returns \n      (bool isClosed) {\n        return patients[patient].closed;\n    }\n\n    function getServiceProviderPublicKey(address serviceProvider)\n      returns (string publicKey) {\n        return serviceProviders[serviceProvider].publicKey;\n    }\n\n    //Revoke Access. Here you aren't changing the key.\n    function revokeServiceProviderAccess(address serviceProvider) {\n        patients[msg.sender].permissions[serviceProvider].read = false;\n        patients[msg.sender].permissions[serviceProvider].write =\n        false;\n    }\n\n    function getPermission(address patient, address serviceProvider)\n      returns(bool read, bool write, string reEncKey) {\n        return (patients[patient].permissions[serviceProvider].read,\n          patients[patient].permissions[serviceProvider].read,\n          patients[patient].permissions[serviceProvider].reEncKey);\n    }\n\n    function getToken(address patient, bytes32 hash) returns (int\n      status, bool read, bool write, string reEncKey) {\n        return (patients[patient].tokens[hash].status,\n          patients[patient].tokens[hash].read,\n          patients[patient].tokens[hash].write,\n          patients[patient].tokens[hash].reEncKey);\n    }\n\n    //Change your keys to revoke old account and move EMRs to new\n    // account.\n    function changePatientAccount(string reEncKey, \n      address newAddress, string newPublicKey) {\n        patients[msg.sender].closed = true;\n        if(address(keccak256(fromHex(newPublicKey))) == newAddress) {\n            patients[newAddress].publicKey = newPublicKey;\n            patientAccountChanged(msg.sender,\n              patients[msg.sender].publicKey, newAddress, \n              newPublicKey, reEncKey);\n        }\n    }\n}\n```", "```\nfrom npre import bbs98\npre = bbs98.PRE()\nimport base64\nimport sys\n\npublicKey = base64.b64decode(sys.argv[1])\nencrypted_message = pre.encrypt(publicKey, sys.argv[2])\n\nprint(base64.b64encode(encrypted_message))\n```", "```\nfrom npre import bbs98\npre = bbs98.PRE()\nimport base64\nimport sys\n\nprivateKey = base64.b64decode(sys.argv[1])\nencrypted_message = base64.b64decode(sys.argv[2])\n\ndecrypted_message = pre.decrypt(privateKey, encrypted_message)\n\nprint(decrypted_message)\n```", "```\nfrom npre import bbs98\npre = bbs98.PRE()\nimport base64\nimport sys\n\nbase64_privateKeyA = base64.b64decode(sys.argv[1])\nbase64_privateKeyB = base64.b64decode(sys.argv[2])\n\nre_ab = pre.rekey(base64_privateKeyA, base64_privateKeyB)\n\nprint(base64.b64encode(re_ab))\n```", "```\nfrom npre import bbs98\npre = bbs98.PRE()\nimport base64\nimport sys\n\nreEncryptKey = base64.b64decode(sys.argv[1])\nencrypted_message = base64.b64decode(sys.argv[2])\nre_encrypted_message = pre.reencrypt(reEncryptKey, encrypted_message)\n\nprint(base64.b64encode(re_encrypted_message))\n```", "```\n{\n    \"name\": \"health\",\n    \"private\": true,\n    \"dependencies\": {\n        \"eth-crypto\": \"^1.2.1\",\n        \"ethereumjs-tx\": \"~1.3.4\",\n        \"ethereumjs-util\": \"~5.2.0\",\n        \"ethereumjs-wallet\": \"~0.6.0\",\n        \"sha256\": \"~0.2.0\",\n        \"web3\": \"^0.20.6\",\n        \"child_process\": \"~1.0.2\"\n    }\n}\n```", "```\nlet Web3 = require(\"web3\");\nlet ethereumjsWallet = require(\"ethereumjs-wallet\")\nlet ethereumjsUtil = require(\"ethereumjs-util\");\nlet ethereumjsTx = require(\"ethereumjs-tx\");\nlet sha256 = require(\"sha256\");\nlet EthCrypto = require('eth-crypto');\nlet exec = require(\"child_process\").exec;\n\nlet web3 = new Web3(new \n  Web3.providers.HttpProvider(\"http://localhost:8545\"));\n\nlet healthContract = web3.eth.contract([]);\nlet health = healthContract.new({\n  from: web3.eth.accounts[0],\n  data: '0x608060aa31862e....',\n  gas: '4700000'\n}, function(e, contract) {\n  if (typeof contract.address !== 'undefined') {\n    let healthContractInstance = healthContract.at(contract.address);\n\n    //Generate Patient's Keys\n    let patient_wallet = ethereumjsWallet.generate();\n\n    //Register the Patient on blockchain.\n    let data = healthContractInstance.addPatient.getData\n      (patient_wallet.getPublicKey().toString('hex'));\n    let nonce = web3.eth.getTransactionCount\n      (patient_wallet.getAddressString())\n\n    let rawTx = {\n      gasPrice: web3.toHex(web3.eth.gasPrice),\n      gasLimit: web3.toHex(4700000),\n      from: patient_wallet.getAddressString(),\n      nonce: web3.toHex(nonce),\n      data: data,\n      to: contract.address\n    };\n\n    let privateKey = ethereumjsUtil.toBuffer(\"0x\" +\n      patient_wallet.getPrivateKey().toString('hex'), 'hex');\n    let tx = new ethereumjsTx(rawTx);\n    tx.sign(privateKey);\n\n    web3.eth.sendRawTransaction(\"0x\" + tx.serialize().toString('hex'),\n      function(error, result) {\n      if (error) {\n        console.log(error)\n        res.status(500).send({\n          error: \"An error occured\"\n        })\n      } else {\n        console.log(\"Patient Pub Key: \" +  \n          healthContractInstance.getPatientPublicKey.call\n          (patient_wallet.getAddressString()))\n\n        //Generate Service Provider's Keys\n        let hospital_wallet = ethereumjsWallet.generate();\n\n        //continue from here\n      }\n    })\n  }\n})\n```", "```\n//Generate Service Provider's Keys\nlet hospital_wallet = ethereumjsWallet.generate();\n\n//Register the Service Provider on blockchain\nlet data = healthContractInstance.addServiceProvider.getData\n  (hospital_wallet.getPublicKey().toString('hex'));\nlet nonce = web3.eth.getTransactionCount\n  (hospital_wallet.getAddressString())\n\nlet rawTx = {\n  gasPrice: web3.toHex(web3.eth.gasPrice),\n  gasLimit: web3.toHex(4700000),\n  from: hospital_wallet.getAddressString(),\n  nonce: web3.toHex(nonce),\n  data: data,\n  to: contract.address\n};\n\nlet privateKey = ethereumjsUtil.toBuffer(\"0x\" +\n   hospital_wallet.getPrivateKey().toString('hex'), 'hex');\nlet tx = new ethereumjsTx(rawTx);\ntx.sign(privateKey);\n\nweb3.eth.sendRawTransaction(\"0x\" + tx.serialize().toString('hex'),\n  function(error, result) {\n  if (error) {\n    console.log(error)\n  } else {\n    console.log(\"Hospital Pub Key: \" +\n      healthContractInstance.getServiceProviderPublicKey.call\n      (hospital_wallet.getAddressString()))\n\n    let token = \"yr238932\";\n    let tokenHash = \"0x\" + sha256(token);\n\n    //Generate private key like npre. It has a extra character 0x00 \n    //in beginning\n    let secKeyA = Buffer.concat([new Buffer([0x00]),\n      patient_wallet.getPrivateKey()]).toString('base64')\n    //Generate another private key to share with service provider\n    let temp_wallet = ethereumjsWallet.generate();\n    let secKeyB = Buffer.concat([new Buffer([0x00]),\n      temp_wallet.getPrivateKey()]).toString('base64')\n\n    exec('python3 ./generate_reEncKey.py ' + secKeyA + \" \" + secKeyB,\n      (error, stdout, stderr) => {\n      if (error !== null) {\n        console.log(error)\n      } else {\n        let reEncKey = stdout.substr(2).slice(0, -2)\n\n        console.log(\"Re-Encryption Key: \" + reEncKey)\n\n        //Add token to blockchain\n        let data = healthContractInstance.addToken.getData\n          (tokenHash, true, true, reEncKey);\n        let nonce = web3.eth.getTransactionCount\n          (patient_wallet.getAddressString())\n\n        let rawTx = {\n          gasPrice: web3.toHex(web3.eth.gasPrice),\n          gasLimit: web3.toHex(4700000),\n          from: patient_wallet.getAddressString(),\n          nonce: web3.toHex(nonce),\n          data: data,\n          to: contract.address\n        };\n\n        let privateKey = ethereumjsUtil.toBuffer(\"0x\" + \n          patient_wallet.getPrivateKey().toString('hex'), 'hex');\n        let tx = new ethereumjsTx(rawTx);\n        tx.sign(privateKey);\n\n        web3.eth.sendRawTransaction(\"0x\" + \n          tx.serialize().toString('hex'), \n          function(error, result) {\n          if (error) {\n            console.log(error)\n          } else {\n            console.log(\"Token Info: \" + \n              healthContractInstance.getToken.call\n              (patient_wallet.getAddressString(), tokenHash, {\n              from: patient_wallet.getAddressString()\n            }))\n\n            //Get access to patient's data\n            let data = \n              healthContractInstance.requestAccess.getData\n              (token, patient_wallet.getAddressString());\n            let nonce = web3.eth.getTransactionCount\n              (hospital_wallet.getAddressString())\n\n            let rawTx = {\n              gasPrice: web3.toHex(web3.eth.gasPrice),\n              gasLimit: web3.toHex(4700000),\n              from: hospital_wallet.getAddressString(),\n              nonce: web3.toHex(nonce),\n              data: data,\n              to: contract.address\n            };\n\n            let privateKey = ethereumjsUtil.toBuffer(\"0x\" +\n              hospital_wallet.getPrivateKey().toString('hex'),\n              'hex');\n            let tx = new ethereumjsTx(rawTx);\n            tx.sign(privateKey);\n\n            web3.eth.sendRawTransaction(\"0x\" + \n              tx.serialize().toString('hex'), \n              function(error, result) {\n              if (error) {\n                console.log(error)\n              } else {\n                console.log(\"Permission Info: \" +\n                  healthContractInstance.getPermission.call\n                  (patient_wallet.getAddressString(), \n                  hospital_wallet.getAddressString(), {\n                  from: hospital_wallet.getAddressString()\n                }))\n\n              }\n            })\n          }\n        })\n      }\n    })\n  }\n})\n```", "```\nlet emr = JSON.stringify({\n  \"Blood Group\": \"O+\",\n  \"type\": \"Blood Report\"\n});\nlet emrHash = sha256(emr);\n\nlet data = healthContractInstance.addEMR.getData\n  (patient_wallet.getAddressString(), emrHash);\nlet nonce = web3.eth.getTransactionCount\n  (hospital_wallet.getAddressString())\n\nlet rawTx = {\n  gasPrice: web3.toHex(web3.eth.gasPrice),\n  gasLimit: web3.toHex(4700000),\n  from: hospital_wallet.getAddressString(),\n  nonce: web3.toHex(nonce),\n  data: data,\n  to: contract.address\n};\n\nlet privateKey = ethereumjsUtil.toBuffer(\"0x\" + hospital_wallet.getPrivateKey().toString('hex'), 'hex');\nlet tx = new ethereumjsTx(rawTx);\ntx.sign(privateKey);\n\nweb3.eth.sendRawTransaction(\"0x\" + tx.serialize().toString('hex'),\n   function(error, result) {\n  if (error) {\n    console.log(error)\n  } else {\n    //Generate Public Key like npre. It's compressed and has a \n    //extra character 0x01 in beginning\n    let compressedPublicKey = Buffer.concat\n      ([new Buffer([0x01]), Buffer.from(EthCrypto.publicKey.compress\n      (patient_wallet.getPublicKey().toString(\"hex\")),\n      'hex')]).toString(\"base64\")\n\n    exec('python3 ./encrypt.py ' + compressedPublicKey + \" '\" + \n      emr + \"'\", (error, stdout, stderr) => {\n      if (error !== null) {\n        console.log(error)\n      } else {\n        //Assume we are pushing encrypted data to proxy \n        //re-encryption server\n        let encryptedEMR = stdout.substr(2).slice(0, -2);\n        console.log(\"Encrypted Message: \" + encryptedEMR)\n\n        //Assume that proxy re-encryption server re-encrypting\n        // data when requested by authorized service provider\n        exec('python3 ./re_encrypt.py ' + reEncKey + \" \" +\n          encryptedEMR, (error, stdout, stderr) => {\n          if (error !== null) {\n            console.log(error)\n          } else {\n            let reEncryptedEMR = stdout.substr(2).slice(0, -2)\n            console.log(\"Re-Encrypted Message: \" + reEncryptedEMR)\n\n            //Assume service provider decrypting the re-encrypted \n            //data provided by the proxy re-encryption server\n            exec('python3 ./decrypt.py ' + secKeyB + \" \" +\n              reEncryptedEMR, (error, stdout, stderr) => {\n              if (error) {\n                console.log(error)\n              } else {\n                let decrypted_message = stdout.substr(2).slice(0, -2)\n\n                console.log(\"Decrypted Message: \" + decrypted_message)\n\n                //Generate a new key for patient\n                let new_patient_wallet = ethereumjsWallet.generate();\n\n                let secKeyA = Buffer.concat([new Buffer([0x00]),\n                  patient_wallet.getPrivateKey()]).toString('base64')\n                let secKeyB = Buffer.concat\n                  ([new Buffer([0x00]),\n                   new_patient_wallet.getPrivateKey()]\n                   ).toString('base64')\n\n                exec('python3 ./generate_reEncKey.py ' + secKeyA + \" \"\n                  + secKeyB, (error, stdout, stderr) => {\n                  if (error !== null) {\n                    console.log(error)\n                  } else {\n                    let reEncKey = stdout.substr(2).slice(0, -2)\n\n                    console.log(\"Re-encryption Key for Patient's new\n                      Wallet: \" + reEncKey)\n\n                    //Change patient's key\n                    let data = healthContractInstance.\n                      changePatientAccount.getData\n                      (reEncKey, new_patient_wallet.getAddressString(),\n                      new_patient_wallet.getPublicKey().\n                      toString('hex'));\n                    let nonce = web3.eth.getTransactionCount\n                      (patient_wallet.getAddressString())\n\n                    let rawTx = {\n                      gasPrice: web3.toHex(web3.eth.gasPrice),\n                      gasLimit: web3.toHex(4700000),\n                      from: patient_wallet.getAddressString(),\n                      nonce: web3.toHex(nonce),\n                      data: data,\n                      to: contract.address\n                    };\n\n                    let privateKey = ethereumjsUtil.toBuffer(\"0x\" +\n                      patient_wallet.getPrivateKey().toString\n                      ('hex'), 'hex');\n                    let tx = new ethereumjsTx(rawTx);\n                    tx.sign(privateKey);\n\n                    web3.eth.sendRawTransaction(\"0x\" +\n                      tx.serialize().toString('hex'), \n                      function(error, result) {\n                      if (error) {\n                        console.log(error)\n                      } else {\n                        let events = healthContractInstance.allEvents({\n                          fromBlock: 0,\n                          toBlock: 'latest'\n                        });\n                        events.get(function(error, logs) {\n                          for (let count = 0; count < logs.length;\n                            count++) {\n                            console.log(\"Event Name: \" +\n                              logs[count].event + \" and Args: \" +\n                              JSON.stringify(logs[count].args))\n                          }\n                        });\n                      }\n                    })\n                  }\n                })\n              }\n            })\n          }\n        })\n      }\n    });\n  }\n})\n```"]