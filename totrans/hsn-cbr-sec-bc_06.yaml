- en: Deploying PKI-Based Identity with Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations have several applications to manage, and these are hosted by different
    systems and servers. Organizations have deployed several ways to authenticate
    users based on methods such as multi-factor authentication system, one for each
    system/application, **single sign-on** (**SSO**), and the directory server; however,
    authenticating users on the internet is comparatively a difficult mechanism. It
    is also extremely important to achieve trust over the internet before exchanging
    information because Internet has been kept open for trusted and untrusted parties.
    In order to established the trust over the public network, there is a need of
    an independent trusted party. A **public key infrastructure** (**PKI**) is an
    open framework built to resolve trust factors between the internet-connected users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Public key infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges of the existing PKI model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How blockchain technology can help?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab and test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PKI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations have hundreds of cloud-based applications to manage and maintain.
    Managing individual access control and authentication is a difficult daily task.
    When it comes to internet users and enormous web applications, it becomes difficult
    to trust individual websites, and users tend to lose their privacy and confidential
    information through them. The PKI provides a secure means of authenticating an
    individual's identity.
  prefs: []
  type: TYPE_NORMAL
- en: Businesses can simplify the deployment and management issues that are encountered
    with applications by employing a PKI. As businesses are moving more toward cloud-based
    applications, it is critical to protect security-sensitive applications from emerging
    threats. There are several security threats when communicating online such as
    identity theft, **man-in-the-middle** (**MITM**) attacks, and data leaks.
  prefs: []
  type: TYPE_NORMAL
- en: PKI in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The internet allows anyone to connect to anyone else and, unlike the real world,
    geographical/physical barriers don''t exist. This makes it difficult to identify
    a person over the internet and establish trust for further communication. In the
    following diagram, Alice wants to talk to Bob over the internet; however, Bob
    refuses because he doesn''t have any means of verifying Alice''s identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd9c854c-a576-4f4f-8e81-02a79228a5ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The PKI solves this problem by appending a **trusted third party** (**TTP**)
    between Bob and Alice. So, before they can start getting to know each other, they
    have to establish a trust and the TTP helps to accomplish that. In the following
    diagram, Alice shares the digital certificate with Bob and Bob uses the public
    key from a trusted certificate authority to decrypt this signature and authenticate
    Alice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f3b68d3-f0eb-43c6-aee7-8b5d909f5bfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the TTP is the **certificate authority** (**CA**).
    This CA generates a certificate that helps an internet user show his/her identity
    over the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PKI**: A PKI provides a hierarchical standard to manage the digital assets
    of an entity to establish a secure communication channel. It is not just limited
    to the users; it is also used by several different systems such as emails, web
    applications, smart cards, and more, which will be explained later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network devices**: A PKI is used to control access to routers and switches
    with 802.1X authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applications**: Applications need to get a signed certificate from CA to
    run in the OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPsec tunnels:** Routers and firewalls use certificates to authenticate other
    endpoints over the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius servers:** An **Lightweight Directory Access Protocol** (**LDAP**)
    query is protected with PKI certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows PKI security architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11058a5a-be0e-46a7-a536-9ec46ed640cb.png)'
  prefs: []
  type: TYPE_IMG
- en: The evolution of PKI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The X.509 design elaborates data formats and procedures for the storage and
    distribution of public keys through certificates that are digitally signed by
    CA. However, X.509 does not include a profile to specify supporting many of the
    certificate''s subfields and extensions shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b1925f-55b6-495b-896b-03faa45d20f6.png)'
  prefs: []
  type: TYPE_IMG
- en: The standard efforts prepared an outline for PKI of X.509 version 3 as well
    as version 2 certificate revocation lists. Before coming to RFC 2459, there were
    around 11 drafts to enhance the X.509 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 2510 was developed to specify a message protocol used in PKI. After this,
    there were two parallel developments with the need of an enrollment protocol and
    the preference to use the PKCS#10 message format. The following diagram explains
    the evolution of the PKI header. In version 2, an issuer unique ID and subject
    unique ID were added to the header. In version 3, an extension field was introduced
    to identify policy and other related information, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f911fbf-3958-4e7f-a82c-f84065524253.png)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, the certificate request syntax was developed in S/MIME WG with
    PKCS#10\. With RFC 2510, a simple enrollment protocol was defined, but it did
    not use PKCS#10 as a certificate request format.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PKI is a collection of a wide variety of components, applications, policies,
    and practices to combine and accomplish the three security principals which are
    integrity, authentication, and non-repudiation. Digital certificates are the main
    components in PKI as they act as a digital identity over the internet. The five
    core components of PKI are explained in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric key encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In cryptography, encryption is the process of encoding information so that
    only an intended party can see it. There are two methods of accomplishing this
    cryptography encryption—symmetric encryption and asymmetric encryption, defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric encryption: **In symmetric encryption, the same key is used for
    the encryption and decryption of data. It is needed to ensure that both parties
    use the same key to encrypt and decrypt the data, shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/739e3630-a59c-403c-bdfb-b75902305058.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Asymmetric encryption: **In asymmetric encryption, a different set of keys
    are used to encrypt and decrypt the data. This key pair is a combination of a
    public and private key. A public key is used to encrypt the data, whereas a private
    key is used to decrypt the data. A public key goes along with the data over the
    internet, but a private key remains with the individuals who are using it, shown
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d28739f-d8d6-49e4-9e14-d978e36775d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The public and private key pair comprise two uniquely related crypto graphical
    keys. Here is an example of a public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A public key is made available to everyone through the internet and is stored
    in the accessible repository or directory. On the other hand, the private key
    must remain private to its owner; hence, it is also named a **secret key**.
  prefs: []
  type: TYPE_NORMAL
- en: Both public key and secret keys are mathematically connected with each other;
    hence, data encrypted with a public key can only be decrypted by a respective
    secret key.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A certificate is an electronic ID that represents the identity of a user or
    a device interested in communicating over a network. The certificate basically
    ensures that only a legitimate user can connect to the network. A certificate
    is generated by signing the public key by a trusted third party, that is, the
    CA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three main types of certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Socket Layer (SSL) certificate**: SSL server certificates are installed
    on server hosting services, such as a web application, mail server, directory,
    or LDAP server. This certificate contains identifying information about the organization
    that owns the application. SSL certificates also contain a system public key.
    The subject of the certificate matches the hostname of the server. This certificate
    has to be signed by a trusted certificate authority. The primary hostname is listed
    as the Common Name in the subject field of the certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client certificate**:Client certificates are used to identify an internet
    user, a device, a gateway, or any other type of device. It is a digital credential
    that validates the identity of the client who owns the certificate. Today, many
    applications allow using certificates to authenticate users for a specific resource
    instead of a username and a password. Two users communicating over email will
    also use a client certificate to authenticate their respective identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code signing certificate**:Code signing certificates are used to sign software
    running on the system. With millions of applications being downloaded by a user
    machine, it is important to verify the code; hence, code signing certificates
    play an important role in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email certificate**: The sender needs to identify which public key to use
    for any given recipient with S/MIME protocol. The sender gets this information
    from an email certificate. Usually, S/MIME protocol is used when email communication
    is deployed within the organization and with its own CA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate authority (CA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CA is a trusted third-party that certifies that users, servers, databases,
    and administrators are who they say they are. The CA checks the credentials of
    users and grants the certificate, signing it with a secret key. The CA can be
    an on-premises solution or it can be a managed solution that offers certificate
    services, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1eede33-e739-42c1-9895-afb23faebd89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The functions of the CA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Issuing and delivering certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting certificates and **certificate revocation list** (**CRL**) to repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing revocation requests from a certificate owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the list of digital signatures in a
    client system. There is a list of certificates from several certificate authorities
    with their expiry dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccb75289-ba36-4cc4-ae32-f733a77c3674.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The different types of CA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public digital certificate authority**: There are several public certificate
    providers who manage the certificates used for commercial and personal purposes.
    Credentials are issued only after a specific fee is paid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private digital certificate authority**: Organization administrators can
    issue certificates to internal systems and users within the domain. A Windows
    server can create and store key pairs, but these private certificates won''t be
    valid for outside communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registration authority (RA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RA is responsible for authenticating the identity of newer entities that
    require a certificate from the certificate authority. It also maintains local
    registration data information and initiates the renewal and revocation process
    for old certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions of the RA are as follows and illustrated in the subsequent diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: It is responsible for authentication of new users or systems that require certificates
    from CAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also performs some of the functions of the CA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acts as an agent to the CA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It maintains local registration data from the renewal and revocation of redundant
    certificates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/85f3f0eb-d039-4130-890f-6de71121716e.png)'
  prefs: []
  type: TYPE_IMG
- en: Certificate repository (CR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CR is a certificate database that is accessible by all nodes in the PKI
    environment. It also holds certificate revocation-related information and the
    governing policy information. Certificate revocation lists are used in this repository
    to get an updated list of certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions of the certificate repository are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows information retrieval in an unauthenticated manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acts as a database to hold information such as public key certificates, revocation
    lists, and policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entire PKI architecture works on a model named the *chain of trust*. This
    model lies within the trust relationship between each identity. Specifically,
    the difference between a two-tier hierarchy and three-tier hierarchy is that the
    second tier is placed between root CA and the issuing CA. The main reason for
    using a second-tier CA is to have a policy CA that is responsible for issuing
    certificates to the issuing CA however, three tier hierarchy provides a better
    security. This policy CA can also be used as an administrative boundary. This
    design is also useful if the administrator needs to revoke a number of CAs due
    to a key compromise; the revoke can be performed at the second level, leaving
    other branches of the root available as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d616335c-2159-4555-a46e-2ea6ec193ee6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'During the signing process, the root CA digitally signs the intermediate certificate
    using its secret key. This process achieves authenticity, stating that the intermediate
    certificate is trusted by the root CA. Each CA can receive the certificate request
    from the client and issue it. Normally, the root CA can''t be reached by client
    but client is eligible  to hold the root CA certificates. The client sends the
    certificate request to some subordinate CAs and gets the certificate installed
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdd5e68b-8167-4d4e-a2c3-27007d607a35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following diagram, we can see the flow of sharing digital certificates
    and their decryption. In order to authenticate the party, the digital certificate
    is decrypted by using the public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a05def17-88c9-471a-a3e9-263b67d90f97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After understanding the hierarchy of digital certificates with identity, intermediate,
    and root certificate authorities, now, we will learn how communication is established
    and processed between end clients with browser and SSL websites. Client requests
    to access the HTTPS website. A client''s browser is preloaded with a number of
    root CA certificates. Consider the steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client connects to the SSL website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website responds to the client with its identity and intermediate certificates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then confirms the identity of the intermediate certificate by decrypting
    the digital signature using the intermediate public key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then confirms that the requested URL matches with a distinguished
    name within the identity certificate. If there is a mismatch, it displays a warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traffic then gets encrypted/decrypted by the client using a public key and by
    the server using a secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certificate life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the **National Institute of Standards and Technology** (**NIST**), an
    encryption key life cycle is a combination of the pre-operational, operational,
    post-operational, and deletion stages of key management. It is important to consider
    the time spent in the account as the validity of a key is always limited. Hence,
    the crypto period is used to record time during which a specific key is authorized
    for use. The crypto period is determined by combining the estimated time during
    which the encryption will be applicable and the time when it will be decrypted
    for use, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9caabd8a-c001-4cd5-aa90-3788741585a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the crypto period flowchart with multiple keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5220d549-1714-4400-b5bb-349b55846bab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can examine the several stages in which a key is used and processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key creation**: The encryption key is generated and stored on the key management
    server. The key manager generates the encryption key pair through the process
    of cryptography by using a secure random bit generator. Once the key pair is created,
    it is then stored with all its attributes in the key storage database. The attributes
    usually consist of name, size, instance, activation date, rollover, mirroring,
    key access, and other related attributes. The key activation time can be scheduled,
    or it can activated the moment it was created. The encryption key manager keeps
    track of current and past instances of the encryption key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key use and rollover**: The key manager is responsible for allowing authorized
    users or the system to retrieve information and also allowing them to process
    encryption or decryption. It is also responsible for managing the state of an
    encryption key throughout its lifetime and over every instance. If an organization
    has a policy that states it should use a new set of keys every year, then the
    key manager should retain previous versions of the key and dispense only the current
    version. However, previous versions can still be retrieved in order to perform
    the decryption process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key revocation**: An administrator connects to a key manager to revoke a
    key so that it is no longer used for further encryption and decryption processes.
    If required, the administrator can even reactivate the key and use it for further
    steps. There are some situations where the administrator can also use the decrypted
    data that was previously encrypted, such as an old backup. The encryption life
    cycle is illustrated as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c7d95681-8434-45e6-9da4-182ff6d75bef.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Back up (escrow)**: The NIST recommends an archive for all deactivated keys.
    This archive has to be protected from any unauthorized modification, deletion,
    and alteration. It is also recommended that it has a recoverable key mechanism
    after the end of its crypto period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key deletion (destruction)**: If the key is compromised or is not being used
    for a long period of time, the administrator should choose to delete the key from
    the key storage database of the encryption key manager. The key manager removes
    the key and all of its associated instances, or it can specifically remove certain
    instances. This option plays an important role when the data is compromised in
    its encrypted state. If the key is deleted, the compromised data will be completely
    secure and unrecoverable because it is impossible to recreate the encryption key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Key Management Interoperability Protocol** (**KMIP**) is used for communication
    between clients and servers to perform management operations on stored objects
    which are maintained by a key management system. This is a standardized way to
    manage encryption keys throughout the life cycle and it has been developed to
    facilitate both symmetric and asymmetric cryptographic keys, digital certificates,
    and other related templates to streamline object creation and management, illustrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9d77ee-a0f4-410d-8d2a-c68c660a89ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the guidelines of **Organization for the Advancement of Structured Information
    Standards** (**OASIS**), a nonprofit consortium that provides standards for people
    to exchange information over the internet and within their organizations, there
    are certain lists of objects a client can request to the key management server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a key or a key pair**: This is used to generate a new symmetric key
    or a new public/secret key pair and register new, managed cryptographic objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register**: It is mainly used to register a managed object with keys, passwords,
    or some other cryptographic materials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Re-key:** In order to generate a replacement key, also called a key change,
    re-key is used for existing symmetric keys or key pairs for an existing public/private
    key pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Derive key**: In order to derive a symmetric key or secret object, a derive
    key is used to fetch the data objects that are already known to the key management
    system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locate**: In order to find one or more managed objects, a locate request
    is used for attributes specified in the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check**: This is used to check for the use of a managed object, as per the
    value specified in the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get or get attributes**: This is used to return a managed object specified
    by its unique identifier or more than one attributes associated with a managed
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add, modify, or delete attributes**: These are used to add, delete, or modify
    an attribute instance associated with a managed object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activate**: This is used to activate a managed cryptographic object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revoke**: This is used to revoke a managed cryptographic object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destroy**: This is used when you are required to destroy a key material for
    a specific managed object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive**: This is used to specify a managed object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recover**: This is used to get access to a data recovery process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges of the existing PKI model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The challenges of the existing PKI model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 1** – **the need for additional security**: According to a report
    from the Ponemon Institutes 2016 research, 62% of businesses have deployed cloud-based
    applications using PKI, with an increase of 50% in 2015\. If the central certificate
    repository gets compromised, it will lead to a massive data breach and account
    theft. Organizations tend to use an additional layer of security such as **hardware
    security modules** (**HSMs**) to secure their PKI. HSMs are deployed to protect
    PKIs for the most critical root and issuing CA private keys. Organizations are
    opting for multi-factor authentication for administrators and HSM usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem 2** – **central authority**: In the current state of the internet,
    a central authority (root authority) is responsible for managing DNS requests
    and responses (root authority), X.509 certificates, and much more. Therefore,
    all internet-connected devices and systems have to trust the third party to manage
    public keys and identifiers. Let''s take an example of a domain name; even though
    it has been purchased by its owner, it practically belongs to third parties, such
    as the **Internet Corporation for Assigned Names and Numbers** (**ICANN**), domain
    registrars, and certificate authorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, these trusted third parties are very much capable of intercepting
    and compromising the integrity and security of users worldwide. There have been
    several cases where these trusted third parties have shared their customer's information
    to security agencies and other bodies. They can either do this for financial gain
    or to prepare customer behavior analytics.
  prefs: []
  type: TYPE_NORMAL
- en: How can blockchain help?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PKI has major vulnerability because of its centralized management system. Blockchain,
    however, is fundamentally decentralized and allow communication between several
    parties without any third party involvement. The approach of going decentralized
    can be paradigm shift in the PKI; however, it needs a systematic approach to deploy
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain is about achieving a decentralized network of multiple participants
    without third-party involvement. A **decentralized public key infrastructure**
    (**DPKI**) is an innovative concept that achieves authentication systems over
    public systems without depending on a single third party that can compromise the
    integrity and security of the system. As we already know, blockchain is built
    with a trustless approach that allows both trusted and untrusted parties to communicate
    with each other. However, trust is usually established among geographically and
    politically disparate participants with several consensus models for the state
    of the ledger. By definition, blockchain allows you to store any kind of value
    with several nodes in the network. With DPKI, this value will be a form of secret
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: A principal can be given direct control over global readable identifiers, like
    a website domain, by registering the identifier in the blockchain. With the key-value
    database, the principal uses the identifier as the lookup key. Blockchain can
    allow the assignment of confidential assets, such as public keys and other attributes,
    and permit these values to be globally readable in a secure manner that can't
    be compromised by any MITM, which is possible in PKIX. This is accomplished by
    allowing the most correct public key to link with the identifier value, and authentication
    is performed by an identifier lookup to the latest public key.
  prefs: []
  type: TYPE_NORMAL
- en: In this design of DPKI, the system remains decentralized, and the control over
    the identifier remains with the principal and eliminates the risk of the identifier
    data store getting compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ethereum, among other platforms, is one of the most flexible and reliable blockchains.
    It is a programmable blockchain and fits with a granular and policy-based PKI.
    The PKI is implemented as a function in a smart contract in an Ethereum blockchain.
    Each entity can have multiple attributes to authenticate ownership. These entity
    can be a public key or an Ethereum address. Each transaction is identified using
    a public key and then represented by a corresponding entity ID and PKI. A smart
    contract is used to program the events and functions of various operations in
    the PKI. The smart contract can also be configured to invoke specific PKI operations
    such as create, derive, remove, destroy, and many more. These functions and processes
    will be written in Solidity and deployed in EVM, which will deliver an ease of
    user management for PKI operations. The following sets of PKI operations are made
    available by programming a smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The registration of an entity**: Users or systems are added to the PKI system
    by calling a registration event from the smart contract. The entity can be as
    simple as an Ethereum address, public key, attribute ID, data, and data hashes.
    The configured event on the smart contract collects the entity and forwards it
    as a transaction to Ethereum. The queued transactions are mined, and a block is
    created that will be later added to the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The signing of attributes**: An entity can be characterized using a registration
    event. Each attribute of the entity can be signed by the PKI system through a
    smart contract, and a transaction will be issued. This signed entity will later
    be made available to other entities or users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The retrieval of attributes**: The attributes of the entities can be located
    by applying a filter to the blockchain using the respective IDs of events that
    have been configured on the smart contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revoke signature**: This is one of the most critical functions required by
    any PKI solution to revoke the digital signature on attributes or entities. Revocation
    becomes extremely important when a user loses his/her key or it is compromised.
    Smart contracts can be configured to invoke the revocation event and revoke the
    signature on a specific entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the DPKI deployment, the registrar still has a role in the infrastructure,
    but it is restricted as follows to ensure that identities to entities are represented
    in the network:'
  prefs: []
  type: TYPE_NORMAL
- en: It is required to ensure that software is always under the control of principals
    and corresponding keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private keys have to be generated in a decentralized way to ensure that they
    remain under control of the principal. The generation of a key pair on behalf
    of a principal has to be strictly prohibited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There has to be no single entity that can change other entities without consent
    from the principal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a namespace is created within a blockchain through an Ethereum smart contract,
    it can't be destroyed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registration and renewal of identifiers has to be transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, software that manages identifiers must ensure that all activities
    such as creating, updating, renewing, or deleting identifiers is forwarded through
    a decentralized mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin the lab by first turning up the Node.js and Ganache-CLI framework.
    Installation of  `ganache-cli` has to be performed carefully as it creates the
    entire Ethereum environment in our local system. Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Node.js using the commands shown in the website at [https://nodejs.org/uk/download/package-manager/#arch-linux](https://nodejs.org/uk/download/package-manager/#arch-linux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we  start the test network by using the command as shown in the following
    screenshot in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43765ced-32ce-4175-9b04-1ba8507ddab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have to enable the developer mode to see the browser content in detail.
    We also have to enable the LOAD UNPACKED extension, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/49195490-22c4-4b5e-be73-a733b1e3868f.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CAs can issue **Reaction Policies** (**RP**) which take effect if an unauthorized
    certificate for a domain is issued. In the process of testing, we need to register
    **Domain Certificate Policies** (**DCPs**) and create RPs. The testing can be
    done with the following steps on our local  system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need first add a detector and register it. The following script is required
    to add detector by defining its detector ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc30f1fc-9bea-403b-a991-1e124ed1180d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now register a CA used by the domain owner to issue certificates. It
    is required to define CA ID, CA owner address and  name shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21ad23c1-12fc-4a2e-86d2-10ae98b83d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Register DCP with CAs, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4080b4e-6626-411e-814d-adf57d35802c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an associated RP under the smart contract, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9662ef9f-8784-4404-bdeb-2384943dd7ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Revoke a certificate when the detector receives reports of a malicious certificate
    in the wild, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88214aee-3deb-4370-a13a-e135246e4d1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The detector can now blacklist the CA when a rogue CA misbehaves frequently,
    shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fbecab45-3f50-4b7f-ba12-df4d9b449edd.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, we have successfully deployed the PKI with an Ethereum blockchain.
    With this infrastructure, we have described the full process, from registering
    a CA to claiming reaction payouts. We have successfully developed a model describing
    reaction payouts and developed a method to enforce accountability on CAs that
    are misbehaving.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the importance of PKI and how it solves trust
    factors between the internet-connected users. We also understood several components
    in the PKI that are responsible for making PKI a more reliable model to keep trust
    over a public network.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There have been several revisions published under the PKI proposal, and different
    technologies have been integrated. These are some of the questions that might
    still be important to answer:'
  prefs: []
  type: TYPE_NORMAL
- en: What are some other methods that are used to manage keys?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the advances in PKI-based identity with blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Readers can refer to the following links to further explore the PKI framework
    and related technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PKI Technical Standards* at [http://www.oasis-pki.org/resources/techstandards/](http://www.oasis-pki.org/resources/techstandards/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IKP: Turning a PKI Around with Blockchains* at [https://eprint.iacr.org/2016/1018.pdf](https://eprint.iacr.org/2016/1018.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PKI - Public Key Infrastructure* at [https://www.ssh.com/pki/](https://www.ssh.com/pki/)[.](https://www.ssh.com/pki/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
