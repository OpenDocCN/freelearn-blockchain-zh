- en: Various dApps Integrations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种 dApps 集成
- en: This chapter is about improving your existing dApps and smart contracts with
    new techniques that will make them faster, better, and more efficient. What's
    interesting is that most dApps can be improved with a few tricks. You'll discover
    new aspects of dApp development, including creating your own oracles and backends
    that work with smart contracts. First, you'll start by improving your React skills,
    and then we'll move to the backend so that you learn how to create better centralized
    backends for hybrid dApps that require intensive resources to work properly. After
    that, we'll go back to the frontend to learn how to build stronger dApps with
    web3.js. To cover all the areas related to your dApps, you'll build oracles with
    your recently acquired knowledge about servers, which are the main components
    to take into consideration when dealing with oracles. Finally, to come full circle
    with the improvements, you'll learn how to improve your development workflow to
    produce your most efficient code time- and resource-wise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何利用新技术改进现有的 dApps 和智能合约，使它们更快、更好、更有效。有趣的是，大多数 dApps 都可以通过一些技巧进行改进。你将发现
    dApp 开发的新方面，包括创建自己的预言机和与智能合约一起工作的后端。首先，你将通过改进你的 React 技能开始，然后我们将转向后端，以便你学会为需要大量资源才能正常工作的混合型
    dApps 创建更好的集中式后端。之后，我们将回到前端，学习如何使用 web3.js 构建更强大的 dApps。为了涵盖与你的 dApps 相关的所有领域，你将利用最近获得的关于服务器的知识构建预言机，这是处理预言机时要考虑的主要组件。最后，为了对改进做一个完整的回顾，你将学习如何改进你的开发工作流程，以便以时间和资源为基础生产出最有效的代码。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Better React applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 React 应用程序
- en: Scalable Node.js backends with NGINX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NGINX 构建可扩展的 Node.js 后端
- en: Better web3.js dApps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 web3.js dApps
- en: Building your own oracles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的预言机
- en: Improving your development workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进你的开发工作流程
- en: Better React applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的 React 应用程序
- en: You're familiar with the workflow that's required to create a React application.
    However, many aspects of newer dApps are harder to control. This includes things
    such as smart contract connectivity, processing data for your functions in Solidity,
    and creating components that scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你对创建 React 应用程序所需的工作流程很熟悉。但是，许多较新的 dApps 方面更难以控制。这包括智能合约连接性、为 Solidity 函数处理数据以及创建可扩展组件等方面。
- en: Organizing components properly
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确组织组件
- en: When your application starts growing, you want to make sure your code base is
    clean enough to support new improvements without having to rewrite the entire
    system later on. To do so, you'll start by separating your components into different
    files so that you can keep your content ordered properly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序开始增长时，你希望确保你的代码库足够干净，以支持新的改进而无需在以后重写整个系统。为此，你将从将组件分离到不同文件开始，以便你可以正确地组织你的内容。
- en: 'For instance, take a look at this file named `index.js`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一看名为`index.js`的这个文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see that there are five components that are all in one single big file
    made up of hundreds of lines of code. This is acceptable for smaller projects
    where you just have a few components, but when you start working on bigger applications,
    you must separate your components in different files. To do so, create a file
    for each component with the exact same name. Here is an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到有五个组件都在一个大文件中，由数百行代码组成。这对于只有几个组件的较小项目来说是可以接受的，但是当你开始处理更大的应用程序时，你必须将你的组件分开放在不同的文件中。为此，请为每个组件创建一个具有相同名称的文件。以下是一个示例：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that you must export your component using the `export default` keyword
    so that you get that one specifically. Then, your `src` folder will end up looking
    similar to this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须使用`export default`关键字导出你的组件，这样你才能得到特定的组件。然后，你的`src`文件夹最终会看起来类似于这样：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, in your `Main.js` component, you have to import all the components that
    you'll use. Otherwise, it won't work. This kind of restructuring can easily be
    done in any sort of project since it's just separating components into files;
    however, make sure to import them and export them to the right places.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的`Main.js`组件中，你必须导入所有将要使用的组件。否则，它不会工作。这种重构可以很容易地在任何项目中完成，因为它只是将组件分离到文件中；但是，请确保将它们导入并导出到正确的位置。
- en: Generating components dynamically
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态生成组件
- en: Another trick when it comes to improving your React dApps is to generate components
    dynamically. You've probably been in a situation where you have to generate several
    child components with different attributes because you have some sort of array.
    It may seem simple, but it's quite unintuitive because React only understands
    a certain type of object in its virtual HTML.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进React dApps时的另一个技巧是动态生成组件。您可能曾经处于这样一种情况，您必须生成具有不同属性的多个子组件，因为您有某种数组。这似乎很简单，但却非常不直观，因为React只能理解其虚拟HTML中的某种对象类型。
- en: 'Let''s say you have the following array of objects containing different attributes
    of some animals that you get from your smart contract:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含不同动物属性的对象数组，这些属性是从智能合约中获取的：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You want to generate an `Animal` component for each of those objects. You can''t
    just simply loop them all and create components; you must use the `.map()` function
    with normal brackets, not curly brackets, since React components are very picky.
    Here''s how it would look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您想为这些对象中的每一个生成`Animal`组件。您不能只是简单地循环它们并创建组件；您必须使用带有普通括号的`.map()`函数，而不是花括号，因为React组件非常挑剔。看看它会是这样：
- en: 'First, you set up the constructor with the elements that you want to display
    in an array, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以按照以下方式设置构造函数来呈现数组中要显示的元素：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, set up the render function to look through all the elements with the
    `map()` function, although you can use a normal `for()` loop to generate an array
    of JSX components. Pay attention to the fact that we are returning each element
    inside normal `()` brackets, not curly `{}` brackets, because it''s required by
    JSX to return dynamic HTML elements:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置呈现函数以通过`map()`函数查看所有元素，尽管您可以使用普通的`for()`循环来生成JSX组件数组。请注意，因为JSX要求返回动态HTML元素，我们将每个元素返回在普通的`()`括号内而不是花括号`{}`内：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, create the `Animal` component so that it gets displayed on your dApp:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`Animal`组件以在您的dApp上显示它：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the `AnimalContainer` component is generating `Animal` dynamically
    with the `.map()` function. That''s how you translate a JavaScript object into
    a React component. Pay attention to the fact that we are generating the components
    inside the render function and that the `.map()` function block is inside normal
    brackets, not curly ones:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`AnimalContainer`组件正在使用`.map()`函数动态生成`Animal`。这就是如何将JavaScript对象转换为React组件。请注意，我们是在render函数内生成组件的，并且`.map()`函数块在普通括号中而不是花括号中：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting up projects faster
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快地启动项目
- en: Another problem with React projects is that you must always install the dependencies
    from scratch, set up a `webpack` file, and make sure everything works properly.
    This is tedious and takes way too much valuable time. To solve this, there is
    the `create-react-app` library, although it adds many unnecessary packages that
    could end up causing trouble later on, making upgradability harder, since it's
    based on a closed system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React项目的另一个问题是，您必须始终从头安装依赖项，设置`webpack`文件，并确保一切正常运行。这很烦人，耗费了太多宝贵的时间。为了解决这个问题，有`create-react-app`库，尽管它添加了许多不必要的包，可能会在以后造成麻烦，增加了可升级性更困难，因为它基于封闭系统。
- en: 'It''s better to use the most reduced version possible of a startup React project.
    That''s why I created the open source `dapp` project, which contains precisely
    the smallest, most minimal version of a react dApp project with Truffle to get
    you started right away. You can get the most recent version from my GitHub with
    the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽可能使用最简化的版本启动React项目。这就是我创建的开源`dapp`项目，其中包含了最小、最精简的使用Truffle启动React dApp项目的版本，让您可以立即开始。您可以使用以下代码从我的GitHub上获取最新版本：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then install all the dependencies with `npm i`, run `webpack watch` to keep
    your files bundled as you make changes with `webpack -d -w`, and run the static
    server of your choice in the `dist/` folder. For instance, you might choose `http-server
    dist/`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`npm i`安装所有依赖项，运行`webpack watch`以在进行更改时保持文件捆绑为`webpack -d -w`，并在`dist/`文件夹中运行您选择的静态服务器。例如，您可能会选择`http-server
    dist/`。
- en: 'The `dapp` project is doing the following tasks for you so that you can start
    working on your new dApp immediately:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`dapp`项目正在为您执行以下任务，以便您可以立即开始新的dApp工作：'
- en: Installing all the `react`, `webpack`, `babel`, and `truffle` dependencies.
    Just the right amount, since it doesn't even include `.css` loaders so that you
    manage your packets easily. You still need to have Truffle globally installed
    if you want to use it.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装所有 `react`, `webpack`, `babel`, 和 `truffle` 的依赖项。刚刚好，因为它甚至不包括 `.css` 加载器，这样你就可以轻松管理你的包。如果你想使用它，你仍然需要全局安装
    Truffle。
- en: Setting up the `webpack.config.js` file for you with an entry at `/src/index.js`
    and an output to `/dist/`, and loading all the `.js` and `.html` files with loaders.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你设置 `webpack.config.js` 文件，其中入口为 `/src/index.js`，输出为 `/dist/`，并使用加载器加载所有 `.js`
    和 `.html` 文件。
- en: Setting up the simplest HTML and JavaScript index files.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置最简单的 HTML 和 JavaScript 索引文件。
- en: So, every time you have to start a new project, you can simply clone the `dapp`
    repository to start faster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当你需要启动一个新项目时，你可以简单地克隆 `dapp` 存储库以加快启动速度。
- en: Scalable Node.js backends with NGINX
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有 NGINX 的可伸缩 Node.js 后端
- en: '**Node.js** is one of the most powerful tools when it comes to creating command-line
    applications, servers, real-time backends, and all sorts of tools for developing
    web applications. The beauty of it is that Node.js is JavaScript on the server,
    which combines nicely with your React frontend for JavaScript everywhere. Even
    though it''s centralized, you''ll use it plenty of times for decentralized projects
    where you just can''t get by with the limitations of the Ethereum blockchain.
    You see, Solidity and Vyper are severely limited: you can''t do much besides basic
    function-based code. At some point or another, you''ll have to use a centralized
    backend for advanced applications such as those that require a dashboard.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js** 是创建命令行应用程序、服务器、实时后端以及各种用于开发 Web 应用程序的工具中最强大的工具之一。它之所以美妙，是因为 Node.js
    就是服务器上的 JavaScript，这与你的 React 前端很好地结合在一起，实现了 JavaScript 到处都是。即使它是集中式的，你也会在许多场合使用它，用于去中心化项目，你无法摆脱以太坊区块链的限制。你看，Solidity
    和 Vyper 的限制很严重：除了基本的基于函数的代码之外，你几乎什么都做不了。迟早你都得使用集中式后端来实现像需要仪表板这样的高级应用程序。'
- en: At least until decentralized hosting and storage solutions drastically improve,
    we'll have to get by with centralized backends for specific tasks that cannot
    be accomplished easily with smart contracts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在去中心化的主机和存储解决方案显着改进之前，我们将不得不使用集中式后端来处理那些不能轻松通过智能合约完成的特定任务。
- en: '**NGINX** (pronounced **engine X**), on the other hand, is a web server that
    can be used as a reverse proxy and load balancer, among other things. It''s a
    marvelous tool in conjunction with Node.js, since it speeds up backend calls and
    drastically improves scalability. Put simply, NGINX is the best friend of Node.js
    for advanced projects that require the best performance for a huge quantity of
    users. That doesn''t mean that it can''t be used for simple Node.js applications,
    not at all: NGINX is also excellent for small applications to help you control
    ports and understand domain names easily. You''ll learn all that you need to use
    it properly for bigger dApps.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**NGINX**（发音为**engine X**），另一方面，是一个可以用作反向代理和负载均衡器等的 Web 服务器。与 Node.js 结合使用是一个神奇的工具，因为它加速了后端调用并显着提高了可伸缩性。简单来说，NGINX
    是大量用户需要最佳性能的高级项目的 Node.js 的最佳伙伴。这并不意味着它不能用于简单的 Node.js 应用程序，绝对不是这样：NGINX 也非常适用于小型应用程序，帮助你轻松控制端口并理解域名。你将学到所有必要的知识，以便正确地为更大的
    dApps 使用它。'
- en: We'll start by learning how to create a Node.js application with an NGINX backend,
    then we'll connect it to a real domain name to finally deploy a scalable NGINX
    backend with load balancing, among other improvements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何创建一个带有 NGINX 后端的 Node.js 应用程序开始，然后我们将把它连接到一个真实的域名，最终部署一个可扩展的 NGINX 后端，包括负载均衡等其他改进。
- en: Creating a Node.js server
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Node.js 服务器
- en: You can create Node.js applications wherever you want, but at some point or
    another you'll have to move that application to a real hosting service such as
    **Amazon Web Services EC2** (**AWS EC2**) or DigitalOcean. Both are excellent
    choices, so we'll explore how to deploy to DigitalOcean.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方创建 Node.js 应用程序，但迟早你都得将该应用程序迁移到真实的托管服务，比如 **亚马逊云服务 EC2**（**AWS EC2**）或
    DigitalOcean。两者都是优秀的选择，所以我们将探讨如何部署到 DigitalOcean。
- en: 'In any case, we''ll start by creating the Node.js server locally to then move
    it to a hosting solution. Suppose we had the following scenario: you have just
    created a dApp with React that''s working flawlessly with very good efficiency,
    so you want others to be able to use this application for free. You could deploy
    it to a static hosting site such as GitHub pages or those provided by HostGator,
    but you want to expand the features of your application and to have a database
    and administrator pages only accessible by certain users. That''s where you need
    a custom server and a **Virtual Private Server** (**VPS**), which is basically
    a remote computer where you can do whatever you want to create custom servers,
    usually with a Linux OS.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们将首先在本地创建 Node.js 服务器，然后将其移动到托管解决方案中。假设我们有以下情景：你刚刚使用 React 创建了一个功能完善且效率非常高的
    dApp，因此你希望其他人能够免费使用这个应用程序。你可以将其部署到 GitHub 页面或 HostGator 提供的静态托管网站等，但你希望扩展应用程序的功能，并具有仅对特定用户可访问的数据库和管理页面。这就是你需要自定义服务器和**虚拟专用服务器**（**VPS**）的地方，它基本上是一个远程计算机，你可以在其中进行自定义服务器的创建，通常使用
    Linux 操作系统。
- en: 'To achieve all that, you must start by creating a Node.js server that serves
    static files for you instead of using tools such as `http-server`. Let''s start
    by creating a static server for our Social Music application that we created in
    the previous chapters. Go ahead and create a `server/` and `public/` folders inside
    your project''s directory, and move the essential code to the `public` folder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一切，你必须首先创建一个 Node.js 服务器，为你提供静态文件，而不是使用诸如`http-server`之类的工具。让我们从在前几章中创建的
    Social Music 应用程序创建一个静态服务器开始吧。继续在项目目录内创建`server/`和`public/`文件夹，并将基本代码移动到`public`文件夹中：
- en: '![](img/e897cb84-07a3-48ca-b869-b331f7de3bd9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e897cb84-07a3-48ca-b869-b331f7de3bd9.png)'
- en: We moved all of the files except those related to nodes such as `package.json`
    and those related to GitHub, such as `LICENSE`, so that we can organize our server
    files in a separate location.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有与节点相关的文件（例如`package.json`）和与 GitHub 相关的文件（例如`LICENSE`）移动到了与服务器文件分开的地方，以便进行组织。
- en: 'Start by creating a file called `server.js` inside `server/` as the main file
    with the main required libraries that we''ll use to set up a server:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`server/`中创建一个名为`server.js`的文件，作为设置服务器所需的主要文件，包括所需的库：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, configure the server listeners that will be in charge of delivering the
    right file when requested by external users:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，配置服务器监听器，负责在外部用户请求时提供正确的文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we did first is import `express` and `body-parser`. Express is a framework
    for creating web servers using Node.js, while body-parser is processing all our
    JSON requests to be able to understand these types of messages, since by default,
    Node.js doesn't understand JavaScript request `json` objects. Then, I created
    several `get` requests handlers to send the `bundle.js` file and `index.html`
    when requested from the `dist` folder; `app.use()` is a piece of middleware, which
    means that it receives all requests, does some processing, and lets other request
    blocks do their job. In this case, we're using that middleware to log information
    about each request so that we can debug the server in case anything wrong happens.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们导入了`express`和`body-parser`。Express 是一个使用 Node.js 创建 web 服务器的框架，而 body-parser
    则用于处理所有我们的 JSON 请求，以便能够理解这些类型的消息，因为默认情况下，Node.js 无法理解 JavaScript 请求的`json`对象。然后，我创建了几个`get`请求处理程序，以便在从`dist`文件夹请求时发送`bundle.js`文件和`index.html`；`app.use()`是一个中间件，这意味着它接收所有请求，进行一些处理，并让其他请求块继续执行它们的工作。在这种情况下，我们使用该中间件来记录有关每个请求的信息，以便在出现任何问题时调试服务器。
- en: 'Install the required server dependencies with the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的服务器依赖项：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can run the server:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行服务器了：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The problem with the preceding command is that you have to restart the server
    anytime there''s a bad request or you make changes to the server file. For development,
    it''s better to use the `nodemon` utility, which that automatically refreshes
    the server. Install it with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的问题在于，每当出现错误请求或者对服务器文件进行更改时，你都必须重新启动服务器。对于开发工作，最好使用`nodemon`实用程序，它会自动刷新服务器。使用以下代码安装它：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run your server again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次运行你的服务器：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make development easier, create a new script for running that command faster
    inside your `package.json` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更轻松地进行开发，在你的`package.json`文件中创建一个新的脚本，以便更快地运行该命令：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, you'll be able to run `npm run server` to start the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行`npm run server`来启动服务器：
- en: Getting a hosting solution
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取托管解决方案
- en: Now that we have our static server running, we can deploy it on a hosting solution
    to make our dApp accessible from the outside world. Before that, add your project
    to GitHub with all the latest changes to use it later on another computer. Go
    to [https://digitalocean.com](https://digitalocean.com) and create an account
    with the link [https://m.do.co/c/db9317c010bb](https://m.do.co/c/db9317c010bb),
    which will give you $100 dollars worth of service for 60 days for free and an
    additional $25 dollars when you add $25 dollars to the service. That will be more
    than enough to run a basic VPS server for at least 3 months. You'll have to add
    your credit/debit card or add $5 PayPal dollars to start using it. In my case,
    I used PayPal by paying $5 dollars.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的静态服务器已经运行，我们可以将其部署到托管解决方案上，以使我们的 dApp 从外部世界访问。在此之前，将您的项目添加到 GitHub，并包含所有最新更改，以便稍后在另一台计算机上使用。转到[https://digitalocean.com](https://digitalocean.com)，并使用链接[https://m.do.co/c/db9317c010bb](https://m.do.co/c/db9317c010bb)创建帐户，这将为您提供价值
    $100 的服务，免费使用 60 天，并在您添加 $25 到服务时额外获得 $25。这将足以至少运行一个基本的 VPS 服务器 3 个月。您需要添加信用卡/借记卡或添加
    $5 的 PayPal 美元才能开始使用它。在我的情况下，我支付了 $5 美元。
- en: 'Go to the Droplets section and click on Create Droplet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 Droplets 部分，然后单击“创建 Droplet”：
- en: '![](img/4580562e-5303-4d51-8390-427472787d5c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4580562e-5303-4d51-8390-427472787d5c.png)'
- en: 'Then, you have to choose what distribution to install inside that server; this
    distribution is called Droplets. You could select a one-click installation with
    Node.js, but I believe it''s important that you know how to install Node.js from
    scratch when you don''t have a user interface. So, choose Ubuntu 18.04 as the
    OS with a $5 dollar per month plan:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须选择在该服务器内安装哪个发行版；此发行版称为 Droplets。您可以选择使用 Node.js 的一键式安装，但我认为在没有用户界面时了解如何从头安装
    Node.js 非常重要。因此，请选择 Ubuntu 18.04 作为操作系统，并选择每月 $5 的计划：
- en: '![](img/0fdfd8bd-0986-47c6-bc79-946329d94e76.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fdfd8bd-0986-47c6-bc79-946329d94e76.png)'
- en: 'Select the datacenter closest to where you live to get the best performance.
    I live in Spain, so I will choose servers in Germany or the United Kingdom. For
    you, it may be different:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 选择距离您所在地最近的数据中心以获得最佳性能。我住在西班牙，所以我会选择德国或英国的服务器。对您来说，可能会有所不同：
- en: '![](img/0f35797e-ee0a-4a86-bca0-bcf730f9f543.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f35797e-ee0a-4a86-bca0-bcf730f9f543.png)'
- en: 'Leave the rest of the options as they are and press Create to create it. You''ll
    see how it''s created in real time. Click on your droplet and copy the IPv4 address,
    which you''ll need to connect to that server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将其余选项保持不变，然后按“创建”进行创建。您将看到实时创建的过程。单击您的 droplet 并复制 IPv4 地址，您将需要连接到该服务器：
- en: '![](img/e87945d6-af2e-4ca3-9bbe-a06c697d2f88.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e87945d6-af2e-4ca3-9bbe-a06c697d2f88.png)'
- en: Setting up your server on a VPS hosting
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 VPS 主机上设置您的服务器
- en: 'If you''re using Windows, download PuTTY to connect to external servers from
    their official page, here: [https://www.putty.org](https://www.putty.org/). Open
    it after installing it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows，请从官方网站下载 PuTTY 以连接到外部服务器，网址在这里：[https://www.putty.org](https://www.putty.org/)。安装后打开它：
- en: '![](img/c181034f-f3a0-452f-ace8-9867c9dce765.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c181034f-f3a0-452f-ace8-9867c9dce765.png)'
- en: 'Paste your IP address into the Host Name input and connect to it by clicking
    on Open. It will warn you about connecting to an unknown server; just click Yes.
    Then, it will ask you to log in; type `root` as your default username: it''s different
    for each hosting provider.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 IP 地址粘贴到主机名输入框中，并通过单击“打开”连接到它。它会警告您连接到一个未知的服务器；只需点击“是”。然后，它会要求您登录；将`root`作为您的默认用户名：对于每个托管提供商，它都是不同的。
- en: 'If you''re using Mac, you can simply use the following command instead of using
    PuTTY:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Mac，则可以简单地使用以下命令而不是使用 PuTTY：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although **root** is the default user provided by DigitalOcean, note that it
    may be different for each hosting solution, so check the information provided
    on their website.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 **root** 是 DigitalOcean 提供的默认用户，但请注意每个托管解决方案可能会有所不同，因此请查看其网站上提供的信息。
- en: Then, it will ask you for your password, which you can get via email; since
    DigitalOcean has sent you your login credentials, you won't see it as you paste
    it as a security measure. You can paste it with a right-click and nothing else,
    since that's the way PuTTY works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会要求您输入密码，您可以通过电子邮件获得；由于 DigitalOcean 已经向您发送了登录凭据，因此您在粘贴时将不会看到它，这是一种安全措施。您可以通过右键单击粘贴，除此之外什么都不要做，因为
    PuTTY 就是这样工作的。
- en: 'Immediately after that, it will request that you retype your current password,
    then change your Unix password to a new one, since you can''t rely on an autogenerated
    one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，它将要求您重新输入当前密码，然后将您的 Unix 密码更改为新密码，因为您不能依赖自动生成的密码：
- en: '![](img/3d4d50ea-a67b-4d48-b085-b01e48462662.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d4d50ea-a67b-4d48-b085-b01e48462662.png)'
- en: 'You should now have access to your server. As you can see, you don''t have
    a user interface except for your command-line tools. You don''t want to do all
    the tasks as the root user since it''s a security risk, given that any action
    has access to the entire system without restrictions. Create a new user with the
    following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该可以访问您的服务器。正如您所看到的，除了您的命令行工具之外，您没有用户界面。您不希望像 root 用户一样执行所有任务，因为这是一个安全风险，任何操作都可以无限制地访问整个系统。使用以下代码创建一个新用户：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s an example: `useradd -m merunas`. The `-m` flag will create a `/home/merunas`
    user folder. Then, change to that user with `su merunas` or whatever user you
    created. The `su` command means "substitute user".'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：`useradd -m merunas`。 `-m` 标志将创建一个 `/home/merunas` 用户文件夹。然后，使用 `su merunas`
    或您创建的任何用户切换到该用户。`su` 命令表示“切换用户”。
- en: 'You also have to set up a password with the `passwd` command, otherwise you
    won''t be able to log in at the start of the session. For instance, you could
    use this command: `passwd merunas`. You''ll want to log in as that user next time
    to avoid potential security risks as the root user. Then, you''ll want to change
    your shell to Bash instead of sh to get autocompletes when pressing *ab*, among
    other nice utilities to help you write commands. Do so with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须使用 `passwd` 命令设置密码，否则您将无法在会话开始时登录。例如，您可以使用此命令：`passwd merunas`。您下次想要以该用户登录，以避免作为
    root 用户的潜在安全风险。然后，您将想要将您的 shell 更改为 Bash 而不是 sh，以便在按 *ab* 时获得自动完成，以及其他帮助您编写命令的实用程序。请使用以下命令执行此操作：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add your user to the `sudo` group to be able to run commands as the `root`
    user without having to change users. You must run this as the `root` user:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将您的用户添加到 `sudo` 组中，以便能够以 `root` 用户身份运行命令而无需更改用户。您必须以 `root` 用户身份运行此命令：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an example: `usermod -aG sudo merunas`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：`usermod -aG sudo merunas`。
- en: 'What we''ll do now is install Node.js and NGINX from scratch. The process for
    Node.js is a bit complicated because they are constantly improving their software,
    so it''s harder to set up, but perfectly doable. Go to [https://nodejs.org/en/download/current/](https://nodejs.org/en/download/current/)
    and copy the link address of the Source Code by right-clicking on the button for
    it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是从头开始安装 Node.js 和 NGINX。Node.js 的过程有点复杂，因为他们不断改进他们的软件，所以设置起来更困难，但完全可行。转到
    [https://nodejs.org/en/download/current/](https://nodejs.org/en/download/current/)
    并通过右键单击其中的按钮复制源代码的链接地址：
- en: '![](img/70b46c66-5a68-4967-95c3-86876001ccb8.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70b46c66-5a68-4967-95c3-86876001ccb8.png)'
- en: 'Go back to your PuTTY session and run the `wget` command with that source code
    link to download the node binaries so that you can install it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 PuTTY 会话并运行 `wget` 命令与源代码链接一起下载节点二进制文件，以便您可以安装它：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Extract it with `tar`, as shown in the following command line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tar` 进行提取，如下命令行所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Navigate to the current directory by running `cd node-v11.10.0` . To install
    Node.js from that folder, you need a few dependencies that can be installed in
    a package known as `build-common`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cd node-v11.10.0` 切换到当前目录。要从该文件夹安装 Node.js，您需要安装一些依赖项，这些依赖项可以通过名为 `build-common`
    的软件包安装：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, run the `./configure` and `sudo make` commands to run the installation.
    The `make` command generates the required configuration, but it takes several
    minutes, so be patient. Previously, you also had to run `sudo ./install.sh`, but
    it''s no longer necessary; you still get your nice `node` executable. Simply copy
    it to the binaries location to be able to use it globally:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 `./configure` 和 `sudo make` 命令来运行安装。`make` 命令生成所需的配置，但需要几分钟的时间，所以请耐心等待。以前，您还必须运行
    `sudo ./install.sh`，但现在不再需要；您仍然可以获得漂亮的 `node` 可执行文件。只需将其复制到二进制文件位置以便能够全局使用：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can now remove the installation folder and the downloaded file. Alternatively,
    you could have used `sudo apt install nodejs` to install Node.js, but that''s
    an outdated version that''s not as maintained as the official binaries. Now that
    you have Node.js installed, git clone your social-music project from GitHub or
    use mine with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以删除安装文件夹和下载的文件。或者，您可以使用 `sudo apt install nodejs` 来安装 Node.js，但这是一个过时的版本，不如官方二进制文件维护得好。现在您已经安装了
    Node.js，请从 GitHub 克隆您的社交音乐项目，或者使用以下命令使用我的：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Install `npm` externally with `sudo apt install npm` so that you can install
    packets. You have to get it from this other source because Node.js doesn't include
    it. The good thing about npm is that you can update it immediately with `sudo
    npm i -g npm` to the latest version with ease, so it doesn't matter which version
    you get where with Node.js, you can't simply update it to the latest version without
    going through a lengthy process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用`sudo apt install npm`在外部安装`npm`，以便你可以安装数据包。你必须从另一个来源获取它，因为 Node.js 不包含它。npm
    的好处是你可以立即使用`sudo npm i -g npm`将其更新到最新版本，因此无论你从哪里获取哪个版本，都不重要，你都可以轻松地将其更新到最新版本，而不需要经过漫长的过程。
- en: 'Now, you can run `npm install` to install your dependencies from the `social-music`
    project. Check that your `package.json` file contains your `npm run server` command
    that you created previously. Otherwise, add it again with `vim` or any other text
    editor, such as `nano`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`npm install`来安装你在`social-music`项目中的依赖项。检查你的`package.json`文件是否包含你之前创建的`npm
    run server`命令。否则，使用`vim`或任何其他文本编辑器，如`nano`，再次添加它：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you use the `npm run server` command, you'll see that your server runs
    properly; the problem is that you shouldn't use `nodemon` because it's designed
    to be used for development without considering the problems that could arise in
    different environments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`npm run server`命令时，你会发现你的服务器正常运行；问题在于你不应该使用`nodemon`，因为它是为开发而设计的，没有考虑到在不同环境下可能出现的问题。
- en: 'For that reason, you have a utility that''s ideal for Node.js projects in production.
    It''s called `pm2` and it will keep your server alive, even if a breaking error
    occurs at some point. This utility is great because you can monitor your server
    and run various instances of different services. Install it globally with the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，你有一个非常适合在生产环境中使用的实用工具。它叫做`pm2`，它会保持你的服务器在线，即使在某个时间点发生严重错误。这个实用工具非常好，因为你可以监控你的服务器并运行不同服务的各种实例。使用以下命令在全局安装它：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It's very easy to use. You can daemonize a service with just `pm2 start server/server.js`,
    which means restarting it whenever it stops running for whatever reason. To stop
    it, use `pm2 delete server` from the list of running services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常容易使用。你只需运行`pm2 start server/server.js`就可以使服务成为守护进程，这意味着无论出于什么原因停止运行，都会重新启动它。要停止它，从运行服务的列表中使用`pm2
    delete server`。
- en: Congratulations! You have a Node.js application running on your server. Now,
    to make it available to the world, you have to expose it to port `80`, which is
    the public port used by all websites. You can do so by modifying your `server.js`
    file or with what's called a frontend server, which receives all the requests
    and redirects them to the right place. In our case, that will be NGINX. But before
    that, we need an accessible domain that will make our IP management easier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的 Node.js 应用程序正在你的服务器上运行。现在，为了让它对世界可用，你必须将它暴露在`80`端口上，这是所有网站使用的公共端口。你可以通过修改你的`server.js`文件或使用所谓的前端服务器来实现，该服务器接收所有请求并将它们重定向到正确的位置。在我们的情况下，那将是
    NGINX。但在此之前，我们需要一个易于访问的域名，这将使我们的 IP 管理更加轻松。
- en: Getting a domain name
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一个域名
- en: 'You need a domain to help people access your website with an easy-to-remember
    name instead of writing a long IP number on their browsers. The domain will be
    associated with your hosting solution with a few changes. To get a domain, go
    to [godaddy.com](https://in.godaddy.com/) and search for the name you desire:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个域名来帮助人们通过一个易于记忆的名称访问你的网站，而不是在他们的浏览器上输入一个长长的 IP 数字。只需进行一些更改，域名将与你的托管解决方案关联起来。要获得一个域名，请访问[godaddy.com](https://in.godaddy.com/)并搜索你想要的名称：
- en: '![](img/b3d2f064-f8bb-46d9-a8b9-be0fba87a097.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3d2f064-f8bb-46d9-a8b9-be0fba87a097.png)'
- en: 'Select the domain that best fits your business:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最适合你业务的领域：
- en: '![](img/5d3fa06e-c6a6-4f64-b101-7c9bcfc2aed9.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d3fa06e-c6a6-4f64-b101-7c9bcfc2aed9.png)'
- en: 'Buy it by clicking on the Add to Cart button and creating an account if you
    don''t have one. I always use PayPal since it''s easier to manage. After a few
    minutes, you''ll have your domain available in your dashboard:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加到购物车”按钮购买，并创建一个账户（如果你没有账户）。我总是使用 PayPal，因为它更容易管理。几分钟后，你的域名将在你的仪表板上可用：
- en: '![](img/e6b1abd4-588e-4dec-a9aa-ae0de2a65993.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6b1abd4-588e-4dec-a9aa-ae0de2a65993.png)'
- en: 'Now, you can go to your DNS management settings to point your domain to your
    hosted server so that it''s accessible from that name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以转到你的 DNS 管理设置，将你的域名指向你托管的服务器，以便从该名称访问：
- en: '![](img/d37552b3-b5eb-414a-97bc-4103272ccb0c.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d37552b3-b5eb-414a-97bc-4103272ccb0c.png)'
- en: 'Click on the pencil icon next to your A records and change the pointer to your
    IP address like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击A记录旁边的铅笔图标，并将指针更改为您的IP地址，如下所示：
- en: '![](img/f59de043-7d0c-4bc0-a1d9-f0b57edfb019.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f59de043-7d0c-4bc0-a1d9-f0b57edfb019.png)'
- en: 'With that change, you can now connect to your server with the domain name instead
    of IP, for instance in Mac like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一变化，您现在可以使用域名而不是IP连接到您的服务器，在Mac中，例如这样：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And it will work exactly as before. You can also start your Node.js server on
    port 80 and you'll be able to access the website with that domain. However, Node.js
    is limited when it comes to talking to domains, so we have to use a more advanced
    solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它将与以前完全相同的方式工作。您还可以在端口80上启动Node.js服务器，并且您将能够使用该域名访问网站。但是，当涉及与域名通信时，Node.js受到了限制，因此我们必须使用更高级的解决方案。
- en: Setting up NGINX
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NGINX
- en: Now that your domain is set up, it's time to configure NGINX as a frontend server
    to connect your domain with your Node.js instance. NGINX will process all the
    requests for you so that you can focus on improving your Node.js application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的域名已经设置好了，是时候将NGINX配置为前端服务器，以将您的域名与Node.js实例连接起来了。NGINX将为您处理所有请求，这样您就可以专注于改进您的Node.js应用程序。
- en: 'Connect to your server as before and install `nginx` with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样连接到服务器，并使用以下命令安装`nginx`：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, you''ll have to edit the configuration files of NGINX, which are
    located at `/etc/nginx/sites-enabled/default`. Simply edit your default file with
    `vim`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将需要编辑NGINX的配置文件，位于`/etc/nginx/sites-enabled/default`。只需用`vim`编辑您的默认文件：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, add the following code to be able to use a domain with your Node.js server:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码以能够在Node.js服务器中使用域名：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we defined an `upstream` block. That's where we tell NGINX the location
    of our running `node.js` server at the right port. This is important to protect
    port 80 since it's where most of the requests will be executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`upstream`块。在这里，我们告诉NGINX我们在正确端口上运行的`node.js`服务器的位置。这对于保护端口80非常重要，因为大部分请求都会在那里执行。
- en: Then, we created a `server` block. These types of blocks are used to set up
    some configuration at the port defined inside. The `listen 80;` statement tells
    NGINX to process the request for port 80 inside that server block. We then added
    some `gzip` compression for faster loading times and a location block that will
    pass all the requests to `upstream nodejs`. The other location block is for serving
    static files in case you had images and the like, since it's a faster way to deliver
    static content. Note that the `root /home/merunas/social-music/public;` root location
    is where our static files will be located.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`server`块。这些类型的块用于在定义的端口上设置一些配置。`listen 80;`语句告诉NGINX在该服务器块内处理端口80的请求。然后，我们为更快的加载时间添加了一些`gzip`压缩，以及一个将所有请求传递给`upstream
    nodejs`的位置块。另一个位置块是用于提供静态文件的，以便您有图像之类的文件，因为这是传递静态内容的更快方式。请注意，`root /home/merunas/social-music/public;`根位置是我们的静态文件的位置。
- en: 'Remember to change `socialmusic.online` for your domain. You can now run NGINX
    with the following command line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得将`socialmusic.online`改为您的域名。您现在可以使用以下命令行运行NGINX：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That will restart the service to keep it running in the backend. Your website
    is now accessible at your domain name from any browser. To finish the deployment,
    we'll add SSL. **SSL** is an encryption algorithm that's used to secure communications
    for those accessing your dApp. It's very common and must be added for any serious
    project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新启动服务，使其在后台保持运行。您的网站现在可以在任何浏览器中使用您的域名访问。要完成部署，我们将添加SSL。**SSL**是用于保护访问您的dApp的通信的加密算法。这是非常常见的，并且对于任何重要项目来说都必须添加。
- en: Adding SSL security
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SSL安全性
- en: 'To install SSL, we''ll use the free certificates from **Let''s Encrypt**, a
    non-profit whose goal is to secure the internet with free SSL certificates for
    everybody. Here are the steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SSL，我们将使用**Let's Encrypt**的免费证书，这是一个非营利性组织，其目标是为每个人提供免费SSL证书来保护互联网。以下是步骤：
- en: 'Install the following libraries:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装以下库：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `certbot` application to add your NGINX server:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`certbot`应用程序向您的NGINX服务器添加：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Provide your email address, accept the terms of service, and select 1 for your
    domain name:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的电子邮件地址，接受服务条款，并选择1作为您的域名：
- en: '![](img/1461c4f9-b450-413d-b0e7-560b199d0e66.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1461c4f9-b450-413d-b0e7-560b199d0e66.png)'
- en: 'It will ask you if you want to redirect all requests to the 443 secure HTTPS
    port. Simply say yes by selecting the second option:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问您是否想要将所有请求重定向到443安全的HTTPS端口。只需通过选择第二个选项说是：
- en: '![](img/7118af8a-a3f3-4b10-aaf5-2767bd7e090a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7118af8a-a3f3-4b10-aaf5-2767bd7e090a.png)'
- en: That should be it! You now have HTTPS enabled for all requests, and your domain
    will automatically redirect to HTTPS. This can be done manually, but this way
    is far easier so that you avoid countless headaches when dealing with these kinds
    of complex authentication systems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，所有请求都启用了 HTTPS，并且您的域将自动重定向到 HTTPS。这可以手动完成，但这种方式要简单得多，这样您在处理这些类型的复杂身份验证系统时就可以避免无数的头痛。
- en: You now have a NGINX server with HTTPS running for your decentralized application
    using a Node.js centralized backend that you can expand as much as you wish with
    advanced features that can't be done in a simple smart contract. The best of both
    worlds.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的去中心化应用程序使用了一个 NGINX 服务器，并且启用了 HTTPS，使用了一个 Node.js 集中式后端，您可以根据需要扩展其功能，这些功能在简单的智能合约中无法实现。两全其美。
- en: Better web3.js dApps
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的 web3.js dApps
- en: web3.js is the most used utility for communicating with smart contracts in your
    web applications to convert them into decentralized applications. It's capable
    of managing endless transactions and works automatically once set up.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 是您的 Web 应用程序中与智能合约通信的最常用实用程序，可以将它们转换为去中心化应用程序。它能够管理无尽的交易，并且一旦设置完成就会自动工作。
- en: The problem comes from the fact that many web3.js applications are not optimized,
    at least not as well as possible. Because we're dealing with smart contracts,
    inevitably the code gets confusing really quickly, making maintenance harder over
    the medium-long term. That's why it's important that you study systems to create
    better web3.js dApps from the start to learn tips and tricks that will make you
    a better programmer when it comes to interacting with smart contracts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于许多 web3.js 应用程序并没有被优化，至少不尽可能好。因为我们正在处理智能合约，所以代码很快就会变得混乱，这使得中长期内的维护变得更加困难。因此，重要的是您从一开始就研究系统，以创建更好的
    web3.js dApps，学习使您在与智能合约交互时成为更好的程序员的技巧和诀窍。
- en: You'll be working with a lot of dApps using web3, so why not learn the best
    way of doing things to save you headaches in the long run while creating higher
    quality code? Here are some tips and tricks to make better web3.js dApps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会使用很多基于 web3 的 dApps，那么为什么不学习做事情的最佳方式，以便在长期内减少头痛，并创建更高质量的代码呢？以下是一些使 web3.js
    dApps 更好的技巧和诀窍。
- en: Setting up a fixed web3.js version
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置固定的 web3.js 版本
- en: 'If you, used MetaMask in the past, you''ll have noticed that it injects web3.js
    into every single page you visit since it requires web3.js to be able to interact
    with smart contracts. That''s great: it''s an expected behavior, but it usually
    leads to ancient web3.js versions, mainly version 0.20, which has been used and
    is still used for several years after web3.js 1.0 came out. They don''t want to
    force users to update to the latest version because that would break many web3.js
    dApps already dependent on MetaMask; it''s a huge potential issue.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过 MetaMask，您可能已经注意到它会将 web3.js 注入到您访问的每个页面中，因为它需要 web3.js 才能与智能合约进行交互。这很好：这是一种预期的行为，但通常会导致旧版本的
    web3.js，主要是版本 0.20，这个版本在 web3.js 1.0 推出几年后仍在被使用。他们不想强迫用户更新到最新版本，因为那样会破坏许多已经依赖于
    MetaMask 的 web3.js dApps；这是一个巨大的潜在问题。
- en: That's why it's imperative that you set up a fixed web3.js version for your
    project so that you don't depend on what MetaMask or any other Ethereum client
    forces you to use. It's mandatory to provide some kind of guarantee that your
    dApp will continue working in the future.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么非常必要为您的项目设置一个固定的 web3.js 版本，以便您不依赖于 MetaMask 或任何其他以太坊客户端强制您使用的版本。必须提供某种保证，即您的
    dApp 将在未来继续正常工作。
- en: 'To do so, take a look at this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请看一下这段代码：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using web3.js 1.0 for this example. Next, we import the `NewWeb3` class,
    which is just a different name to differentiate it from `Web3` provided by MetaMask
    to set up a new `web3` object to communicate with the blockchain using our particular
    version of `web3`. It's called `web3Instance` instead of plain `web3` because
    we want to use a different name to avoid using the one provided by MetaMask. You
    see, we can't know when MetaMask will inject its own version of `web3`, so we,
    make sure to use a different name to guarantee that our version is set up. Then,
    we set up a global `web3Instance` variable using the `window` object so that it's
    accessible from anywhere within our application, and we do it after the page loads
    by listening to the event `'load'`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用 web3.js 1.0。接下来，我们导入`NewWeb3`类，这只是一个不同的名称，用于区分它与 MetaMask 提供的`Web3`。设置一个新的
    `web3` 对象来使用我们特定版本的 `web3` 与区块链通信。它称为 `web3Instance` 而不是普通的 `web3`，因为我们希望使用不同的名称来避免使用
    MetaMask 提供的名称。你看，我们不知道 MetaMask 何时会注入自己的 `web3` 版本，因此，我们确保使用不同的名称来保证我们的版本已经设置好了。然后，我们使用
    `window` 对象设置了一个全局的 `web3Instance` 变量，以便它可以在我们应用程序的任何地方访问，并且我们在页面加载后通过监听事件`'load'`来实现。
- en: Try it in a project and you'll see that `web3Instance` is the version you defined
    in your import. Note that `.givenProvider` is taking the injected web3.js data
    from MetaMask to set up a new web3.js version. Make sure to use this tip for all
    your future projects to guarantee that your dApp works for future and past web3.js
    versions, since MetaMask is constantly changing it own system in an unreliable
    manner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中尝试一下，你会发现`web3Instance`是你在导入中定义的版本。请注意，`.givenProvider`正在从 MetaMask 中注入的
    web3.js 数据中获取数据以设置一个新的 web3.js 版本。确保在所有未来的项目中使用这个提示，以确保你的 dApp 适用于未来和过去的 web3.js
    版本，因为 MetaMask 不断地以不可靠的方式更改它自己的系统。
- en: Creating helper functions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帮助函数
- en: Helper functions are those that help you manage more complex functions with
    ease. They are essentially functions that are intended to help other functions
    with some common logic so that you don't have to repeat your code over and over.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助函数是那些帮助你轻松管理更复杂的函数的函数。它们本质上是帮助其他函数的函数，其中一些通用逻辑可以帮助你避免反复编写代码。
- en: These are important functions because they will improve the maintainability
    of your code vastly. You'll be able to see what's happening in fewer lines and
    you'll be able to upgrade your code faster.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是重要的函数，因为它们会极大地提高代码的可维护性。你将能够在更少的行数中看到发生的事情，并且你将能够更快地升级你的代码。
- en: 'For instance, in web3.js 1.0, contracts have to use a large line of code for
    every smart contract call and transaction:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 web3.js 1.0 中，合约必须为每个智能合约调用和事务使用一行较大的代码：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s descriptive, but a bit longer than necessary. Let''s reduce it with a
    helper function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述性的名称比必要的稍长一点。让我们用一个帮助函数来缩短它：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, we''ve converted a method in call to the brackets version since
    that''s the way you can dynamically generate function names with unique parameters
    for objects. In the past, I recall using the following shortcut to select elements
    quickly without having to type the same structure over and over:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们已经将一种方法转换成了括号版本，因为这是你可以使用唯一参数动态生成函数名称的方法。过去，我记得使用以下快捷方式来快速选择元素，而不必一遍又一遍地输入相同的结构：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With such a simple helper function, I've converted a 22-character function into
    a 1-character function with the same logic. It may seem absurd at first, but when
    you have to use it 100 times in a project, you'll realize that you're drastically
    reducing the size of your code and you're making it easier to read. You're literally
    saving 2,200 lines of code. Now that's efficiency with the smallest change possible!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个简单的帮助函数，我将一个 22 个字符的函数转换成了一个具有相同逻辑的 1 个字符的函数。起初可能看起来荒谬，但当你在一个项目中需要使用它
    100 次时，你会意识到你大大减少了代码的大小，并且使其更易于阅读。你实际上节省了 2,200 行代码。现在这就是用最小的改变来提高效率！
- en: Promisifying your functions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使你的函数变成 Promise
- en: Modern JavaScript uses promises to process transactions cleanly since it gives
    you the choice to run your code synchronously or asynchronously using the same
    function instead of callbacks where you have to stack layers of code to control
    the flow of things.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 JavaScript 使用 promises 来清晰地处理事务，因为它让你选择使用同一个函数同步或异步地运行代码，而不是使用回调函数，其中你必须堆叠代码层来控制事物的流程。
- en: That's why all your callback functions must be converted in to promises if they
    are not already. This is not a problem with the latest versions of web3, but with
    web3.js 0.20 and many other libraries where you have to use callbacks, it's better
    to just convert them to promises for easier code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么如果你的回调函数还没有转换成 promises，那么所有的回调函数都必须被转换成 promises。对于最新版本的 web3 来说，这不是问题，但对于
    web3.js 0.20 和许多其他需要使用回调函数的库来说，最好将它们转换为 promises，以便更轻松地编写代码。
- en: 'There''s a library called `bluebird` that helps you with that by converting
    all the functions inside an object in to promises. Install it with the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`bluebird`的库可以帮助你实现这一点，它会将对象内的所有函数转换为 promises。使用以下命令进行安装：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Import it into your React project with the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容将其导入到你的 React 项目中：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following function to convert your object methods into `Async`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下函数将你的对象方法转换为`Async`：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, you can use `Async` functions instead of callback functions, like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`Async`函数而不是回调函数，就像这样：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s just an example: the idea is that you add the `Async` keyword to your
    callback functions to use the promisified version without having to do anything
    else.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子：你只需在你的回调函数中添加`Async`关键字，就可以使用 promise 版本，而不需要做其他任何事情。
- en: Listening to events with web3.js
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 web3.js 监听事件
- en: Events are essential to manage the flow of your decentralized applications since
    you can get real-time updates about changes that are happening in your smart contracts
    and act accordingly. You can even create Node.js applications to notify you about
    critical changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对于管理你的去中心化应用程序的流程至关重要，因为你可以实时获取关于智能合约中发生的变化的更新，并相应地采取行动。你甚至可以创建 Node.js 应用程序来通知你有关关键变化的信息。
- en: 'For instance, let''s say that you run a bank smart contract and have an event
    that gets activated when the funds in your smart contract reach a critical 10
    ETH low:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你运行一个银行智能合约，并且有一个事件在你的智能合约中的资金达到临界的 10 以太币时被激活：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You want to be notified about such changes, so you''ve set up a simple web3.js
    dApp on a `node.js` instance that sends you an email when that happens:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要被通知这些变化，所以你在一个`node.js`实例上建立了一个简单的 web3.js dApp，当发生这种情况时会给你发送一封电子邮件：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That could be a monitoring system that you''ve set up yourself to manage a
    dApp used by millions of users so that it stays operative for as long as possible.
    You can argue that listening to events in such a scenario is essential, so how
    do you do it? Here''s the basic structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个监控系统，你自己设置的，用来管理一个被数百万用户使用的 dApp，以使其尽可能长时间地保持运行状态。你可以说，在这样的场景中监听事件是必不可少的，那么你该如何做呢？这是基本结构：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Your `web3.eth.subscription` function will execute the callback when the event
    is generated. That's basically how you listen to events in web3\. Now, you know
    how to use them for critical operations in your dApp's workflow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件生成时，你的`web3.eth.subscription`函数将执行回调。这基本上就是你如何在 web3 中监听事件的方法。现在，你知道如何在你的
    dApp 工作流程中运用它们了。
- en: Building your own Oracles
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的 Oracle
- en: 'Oracles are external applications that help your smart contract receive information
    from the outer world to perform some functions outside of what''s possible inside
    Solidity or Vyper. How they work is simple: you create a centralized server that
    calls specific functions of your smart contract when needed.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 是外部应用程序，它们帮助你的智能合约从外部世界获取信息，以执行一些 Solidity 或 Vyper 中不可能实现的功能。它们的工作原理很简单：你创建一个中心化的服务器，在需要时调用你的智能合约的特定函数。
- en: They are used to generate random numbers, to provide live price data, and to
    show information from websites. As you know, smart contracts can't generate random
    numbers because there can't be any uncertainty regarding being able to avoid unexpected
    situations in the blockchain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于生成随机数、提供实时价格数据和显示网站信息。正如你所知，智能合约无法生成随机数，因为在区块链中不能存在任何关于能够避免意外情况的不确定性。
- en: In this section, you'll learn how to create an Oracle to generate a random number
    between 1 and 100 for a game on the blockchain. There are already oracles doing
    these tasks, namely Oraclize, which has been used for a long time with Solidity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习如何创建一个 Oracle 来为区块链上的游戏生成一个 1 到 100 之间的随机数。已经有一些做这些任务的 Oracle，即 Oraclize，它已经在
    Solidity 中被使用了很长时间。
- en: Building a random generation Oracle
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建随机生成的 Oracle
- en: Oracles are a smart contracts' way of getting information from the external
    world. They are the bridge between centralized servers, external blockchains,
    and APIs, with smart contracts running on Ethereum. Essentially, they are a service
    that provides you with important information from places inaccessible with normal
    smart contracts, and they work by setting a centralized server listening to web3
    events for your contract.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle是智能合约从外部世界获取信息的一种方式。它们是中心化服务器、外部区块链和API与运行在以太坊上的智能合约之间的桥梁。基本上，它们是一种服务，可以为您提供来自无法通过普通智能合约访问的地方的重要信息，它们通过设置一个中心化服务器监听您的合约的web3事件来工作。
- en: 'First, create a new project named `oracle`, run `truffle init` to be able to
    compile contracts, set up npm with `npm init -y`, and create a smart contract
    that generates events and handles `Oracle.sol`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`oracle`的新项目，运行`truffle init`以便编译合约，使用`npm init -y`设置npm，并创建一个生成事件并处理`Oracle.sol`的智能合约：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It''s pretty basic: the idea is to execute the `__callback()` function with
    the randomly generated number when the user requests it by calling the `generateRandom()`
    function. We''ll set up an event listener that will give users random numbers
    at the right time, with the right sequence identifier.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这很基本：当用户通过调用`generateRandom()`函数请求时，执行带有随机生成的数字的`__callback()`函数的想法。我们将设置一个事件监听器，在适当的时间给用户提供随机数，带有正确的序列标识符。
- en: 'Remember to update your `1_initial_migrations.js` file inside the `migrations`
    folder to tell Truffle to deploy the right contract:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记得更新您`migrations`文件夹中的`1_initial_migrations.js`文件，以告诉Truffle部署正确的合约：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, deploy it to `ropsten` by setting up the right configuration inside `truffle-config.js`.
    You already know how to do this since we learned how to set up Infura for Ropsten
    inside the configuration file of Truffle in previous chapters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在`truffle-config.js`中设置正确的配置来将其部署到`ropsten`。您已经知道如何做到这一点，因为我们在之前的章节中学习了如何在Truffle的配置文件中设置Infura以用于Ropsten：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can create the Node.js application that listens to events generated
    by our smart contract and makes the right request with a randomly generated number
    type using the following code to start inside an `oracle.js` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个Node.js应用程序，该应用程序监听由我们的智能合约生成的事件，并使用以下代码在一个`oracle.js`文件中启动生成一个随机生成的数字类型的正确请求：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've imported `web3`, `fs`, and `path` as the libraries to interact with our
    contract. Then, we defined a websockets Infura URL to use it to connect to Ropsten
    for deploying and interacting with contracts. It's important that you use `wss`
    instead of `http` since it's the only way to receive events. Finally, we added
    some global variables that we'll need later on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`web3`、`fs`和`path`作为与合约交互的库。然后，我们定义了一个用于连接到Ropsten部署和与合约交互的websockets
    Infura URL。重要的是您使用`wss`而不是`http`，因为这是接收事件的唯一方式。最后，我们添加了一些稍后会需要的全局变量。
- en: 'The way we generate transactions without MetaMask is by creating and signing
    our custom transaction object with our private key, which we can generate with
    the following function based on our mnemonic located in the `.secret` file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建和签署使用我们的私钥的自定义交易对象，我们可以生成没有MetaMask的交易。我们可以使用以下基于`.secret`文件中的助记词生成私钥的函数：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It''s quite complicated, although we only have to focus on installing and importing
    the `bip39` and `ethereumjs-wallet` libraries to generate `privateKey` used for
    signing transactions. We can install the dependencies with the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当复杂，尽管我们只需要专注于安装和导入`bip39`和`ethereumjs-wallet`库以生成用于签署交易的`privateKey`。我们可以使用以下命令安装依赖项：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we can create a `start` function that will set up the required contracts
    and start listening to the right trigger event to call the `__callback()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个`start`函数，该函数将设置所需的合约并开始监听正确的触发事件以调用`__callback()`函数：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we read the mnemonic 12-word passphrase to generate our privateKey and
    address using the previous `generateAddressesFromSeed()` function. Then, we set
    up a new web3 instance with `WebsocketProvider` for our Ropsten Infura URL because
    we can't listen to events with `HttpProvider`. After that, we set up `contractInstance`
    by reading the ABI data from the JSON file that was generated by Truffle, which
    includes the address of the deployed contract.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取助记词的12个单词的密码来使用先前的`generateAddressesFromSeed()`函数生成我们的privateKey和address。然后，我们使用`WebsocketProvider`为我们的Ropsten
    Infura URL设置一个新的web3实例，因为我们无法使用`HttpProvider`监听事件。之后，我们通过从Truffle生成的包含部署合约地址的JSON文件中读取ABI数据来设置`contractInstance`。
- en: 'Finally, we set up a subscription for the `GenerateRandom` event using the
    `contractInstance.events.GenerateRandom()` function, which will call the `callback()`
    function with the sequence that corresponds. Let''s see what the callback function
    looks like. Remember that this function will run the `__callback()` of our smart
    contract to provide users with a randomly generated number, since we can''t directly
    generate random numbers with Solidity:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`contractInstance.events.GenerateRandom()`函数为`GenerateRandom`事件设置了一个订阅，这将使用与之对应的序列调用`callback()`函数。让我们看看回调函数是什么样子的。请记住，这个函数将运行我们智能合约的`__callback()`函数，以向用户提供一个随机生成的数字，因为我们不能直接使用Solidity生成随机数：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function receives the sequence parameter to map the values to the right
    ID so that users can identify which event is the right one for them. First, we
    generate a random number between 1 and 100 using `Math.random()`, with some calculations
    to adapt it to our desired range. Then we generate a transaction object called
    `tx` that includes our function data with `sequence` and `generatedNumber`, and
    some essential parameters such as `gas` and the `from` address. Finally, we send
    that transaction to our `Oracle` smart contract by first signing it with `privateKey`
    and then sending it using `web3.eth.sendSignedTransaction`. When it's confirmed
    by the miners, we'll see `console.log` saying `"Callback transaction confirmed!"`,
    or an error in case something goes wrong.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收序列参数以将值映射到正确的ID，使用户能够确定哪个事件适合他们。首先，我们使用`Math.random()`生成一个介于1和100之间的随机数，通过一些计算来使其适应我们期望的范围。然后，我们生成一个称为`tx`的交易对象，其中包括我们的函数数据，包括`sequence`和`generatedNumber`，以及一些基本参数，如`gas`和`from`地址。最后，我们通过首先使用`privateKey`进行签名，然后使用`web3.eth.sendSignedTransaction`发送该交易到我们的`Oracle`智能合约。当矿工确认时，我们会看到`console.log`显示`"Callback
    transaction confirmed!"`，或者在出现问题时显示错误。
- en: 'That''s about it! We can add the `start()` function initialization at the bottom
    to start listening to events. Here''s the full code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了！我们可以在底部添加`start()`函数初始化以开始监听事件。以下是完整的代码：
- en: 'Import your required libraries and set up the variables that will be used in
    the project at the beginning of the file:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头导入所需的库并设置将在项目中使用的变量：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the `generateAddressesFromSeed()` function, which provides you with
    access to the accounts contained in the given seed:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`generateAddressesFromSeed()`函数，它为您提供了访问给定种子中包含的帐户的权限：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `start` function to set up the web3 listeners:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`start`函数以设置web3监听器：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, create the callback function that executes the `__callback()` function
    from the smart contract. The function name starts with two underscores to avoid
    calling an existing function, since it''s a special function used exclusively
    by the oracle:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建执行智能合约中的`__callback()`函数的回调函数。函数名称以两个下划线开头，以避免调用现有函数，因为它是一个专门由Oracle专用的特殊函数：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Remember to start the oracle by running the `start` function at the end of
    the file once everything is loaded:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在文件加载完毕后运行`start`函数来启动oracle：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Optionally, we can add a function to execute the `generateRandom()` function
    from our smart contract to verify that we''re indeed receiving events with another
    subscription, such as the following:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以添加一个函数来执行来自我们智能合约的`generateRandom()`函数，以验证我们是否确实收到了另一个订阅的事件，例如以下内容：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, update the `start` function to listen to the new event we created by
    using the `generateRandom()` function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过使用`generateRandom()`函数更新`start`函数以监听我们创建的新事件：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That way you'll be able to see how the contract is actually receiving your randomly
    generated number from your Node.js oracle to confirm that it's working properly.
    Go ahead and try it yourself by deploying your own oracles that provide smart
    contracts with external data that they couldn't get by themselves using this callback-based
    mechanism with unique identifiers. Additionally, you could add some external proofs
    to verify that the data is coming from the right oracle, although that's outside
    of the scope of this guide since it would be too extensive to describe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就能够看到合约实际上是如何从你的Node.js oracle接收到你的随机生成数字以确认它是否正常工作的。尝试自己部署自己的Oracle，以通过唯一标识符的基于回调的机制为智能合约提供外部数据，而它们自己无法获取。此外，您可以添加一些外部证明来验证数据是否来自正确的Oracle，尽管这超出了本指南的范围，因为描述起来太复杂了。
- en: As usual, you have the full, updated code updated on my GitHub ([https://github.com/merlox/oracle](https://github.com/merlox/oracle))
    if you want to see the latest changes and try the working version. Take a look
    at the Truffle configuration file if you want to see how I set it up.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，如果你想要查看最新的更改并尝试工作版本，你可以在我的GitHub上找到完整的、更新的代码（[https://github.com/merlox/oracle](https://github.com/merlox/oracle)）。如果你想要查看我是如何设置它的，可以看一下Truffle配置文件。
- en: Improving your development workflow
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进你的开发工作流程
- en: When it comes to creating smart contracts and decentralized applications, a
    common problem is that we must work in the most efficient way possible to create
    the highest quality code so that we don't spend unnecessary hours on fixing problems
    that shouldn't be there in the first place.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建智能合约和去中心化应用时，一个常见的问题是我们必须以最有效的方式工作，以创建最高质量的代码，这样我们就不会花费不必要的时间去解决一开始就不应该存在的问题。
- en: In my personal experience, the best applications that I've created were born
    from exhaustive planning beforehand. It may feel unnecessary, but the more you
    work, the more you realize how much time you can save by getting your ideas in
    place with a clear plan that describes each element of your idea.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的个人经验，我创建的最好的应用程序都是通过事先进行详尽的规划而诞生的。它可能感觉是不必要的，但你工作得越多，你就越意识到通过清晰描述你的想法的详细计划来节省多少时间。
- en: Have you worked on projects where you're constantly getting into problems such
    as bugs or confusion? That's probably because you didn't do enough planning. In
    this section, you'll learn how to plan your applications to set up projects that
    are easy to understand so that you can develop way more efficiently.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经在项目中遇到过不断出现问题，如bug或混乱？那很可能是因为你没有做足够的规划。在本节中，你将学习如何规划你的应用程序，以建立易于理解的项目，从而使你能够更有效地开发。
- en: Let's say that you want to put your skills into practice to learn more about
    Ethereum technology with real projects. So, you decide to work on a relatively
    complex dApp. You first get the idea, then you detail the components of your application
    based on how you think it should work, and you start to code right away to get
    it done quickly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将你的技能付诸实践，以了解更多关于以太坊技术的真实项目。所以，你决定在一个相对复杂的dApp上工作。你首先得到了这个想法，然后基于你认为它应该如何工作，详细描述了你应用程序的组件，并立即开始编码以快速完成。
- en: 'That''s a very common approach to most projects, given that we don''t want
    to waste time on projecting—we want to get it done fast so we develop the code
    immediately. That''s fine for small projects, but for bigger ones we must follow
    guidelines like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目来说，这是一种非常常见的方法，因为我们不想浪费时间在规划上——我们想要立即完成代码的开发。对于小型项目来说这没问题，但对于更大的项目，我们必须遵循以下准则：
- en: 'Write a detailed description of what you have in mind: the most important features,
    how it will feel to the customers, and what is it about.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详细描述你心中所想的内容：最重要的特性，对客户的感觉，以及这个项目的主旨。
- en: 'Break it down into smaller pieces: the frontend, the backend, and the smart
    contract, if any. Then describe those elements in a way that you can understand
    how they will be used.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其分解成较小的部分：前端、后端和智能合约（如果有）。然后以一种你能理解它们将如何被使用的方式描述这些元素。
- en: 'Go deeper by writing down the functions that will be added to each of those
    three parts. Those will be the main functions for your application. Write them
    in an empty file without body: just the functions with the parameters and return
    values.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过写下将添加到这三个部分的函数来深入了解。这些将是你应用程序的主要函数。在一个空文件中写下它们，没有实际的代码，只有带有参数和返回值的函数。
- en: Document those functions by describing what they are supposed to do on a technical
    level using NatSpec documentation so that each parameter and return value is explained
    clearly.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用NatSpec文档记录这些函数，以清楚地解释每个参数和返回值在技术层面上应该做什么。
- en: Start working on the smaller independent functions. Those could be getter functions
    that return some variable or simple functions for calculating a value.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始处理较小的独立函数。这些可以是返回某个变量的getter函数，或者是用于计算值的简单函数。
- en: Move on to more complex functions until all of them are completed. While you
    do so, write empty tests as they come to mind to check every aspect of those functions.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到更复杂的函数，直到所有函数都完成为止。在这样做的同时，根据想法编写空测试，以检查这些函数的每个方面。
- en: Correct the project by writing unit tests from those that you set up previously
    and add a few more focusing on the potential of the problem they could cause if
    unchecked.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写从之前设置的单元测试中得出的单元测试，并添加一些关注它们可能造成的问题潜力的更多单元测试，来校正项目。
- en: 'Your planning may be different: what you just read is only a simple guide that
    I came up with after trying to understand the process behind a successful project.
    Just so that you can take it with you in a more visual manner, here''s an illustration
    of that development process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计划可能会有所不同：你刚刚读到的只是我试图理解成功项目背后的过程后提出的一个简单指南。只是为了让你更直观地理解，这里有一个该开发过程的示意图：
- en: '![](img/17dd7a95-db7c-45f7-ad0d-9ed61c9e1fde.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17dd7a95-db7c-45f7-ad0d-9ed61c9e1fde.png)'
- en: 'While you create each function, leave `//TODO` notes describing what needs
    to be done next, so that when you come back, you have a clear and simple objective
    to go for. For instance, here''s a function that I''ve been working on recently:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建每个函数时，请留下`//TODO`注释，描述接下来需要做什么，这样当您回来时，您就有一个清晰简明的目标可供实现。例如，这是我最近正在努力的一个函数：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is an extension already installed in the famous [atom.io](https://atom.io/)
    code editor called `language-todo` that highlights these types of `TODO` notes
    so that you can see them easily. You can also search for those inside your entire
    project with the search function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的 [atom.io](https://atom.io/) 代码编辑器中已经安装了一个名为`language-todo`的扩展，它会突出显示这些类型的`TODO`注释，以便您可以轻松看到它们。您还可以使用搜索功能在整个项目中查找这些注释。
- en: 'Also, there''s another extension that allows you to manage those reminders
    in a single panel. Here''s the package name so that you can install it if you
    want:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有另一个扩展，允许您在一个单独的面板中管理这些提醒。以下是包名称，如果您愿意，可以安装它：
- en: '![](img/20ac7f43-50ac-4f76-9a17-afe5f4ff4950.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20ac7f43-50ac-4f76-9a17-afe5f4ff4950.png)'
- en: 'Here are some additional recommendations to improve your workflow when you
    work on creating a successful project:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外的建议，以提高您在创建成功项目时的工作流程：
- en: At the top of each file, create a list of things that need to be completed in
    that particular file so that you know when it's completed.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个文件的顶部，创建一个列出了需要在该文件中完成的事项的列表，这样你就知道何时完成了它。
- en: Use already made tools to deploy your contracts and write tests to verify functionality
    efficiently. For instance, Truffle, Ganache, and Remix are essentials for testing
    while improving your efficiency.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已有的工具部署您的合约并编写测试以有效验证功能。例如，Truffle、Ganache 和 Remix 在测试和提高效率方面是必不可少的。
- en: Set a time limit to everything; be as precise as possible, since projects have
    the tendency to use up as much time as you give them. Be strict to keep your mind
    focused.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每件事情设定一个时间限制；尽量精确，因为项目往往会耗尽你给予的所有时间。要严格保持专注。
- en: Determine what can be done in different time limits. For instance, in 1 week,
    you could create a basic version of your idea with the core two features, in 1
    day, you can complete 5 of the 100 functions required to complete a solid beta
    version, and in 1 month, you could have the basic code completed. The idea is
    to imagine what would be a realistic estimate of what's possible with enough time
    for your idea. Write down what needs to be completed in 1 day, in 1 week, and
    in 1 month.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定在不同时间限制下可以完成哪些工作。例如，在 1 周内，您可以使用核心两个功能创建您的想法的基本版本，在 1 天内，您可以完成所需的 100 个功能中的
    5 个，以完成一个稳定的 beta 版本，而在 1 个月内，您可以完成基本代码。关键是想象在足够时间内完成您的想法的可能性的现实估计。记录下需要在 1 天内、1
    周内和 1 个月内完成的工作。
- en: Put yourself in places where you're comfortable. Usually, great ideas come when
    your body feels good and your mind is relaxed. For instance, a shower where the
    right temperature and the constant flow of water relaxes your entire being is
    one of the best places to examine your assumptions and explore new ideas that
    could be great.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自己放在你感到舒适的地方。通常，当你的身体感觉良好，心情放松时，会有伟大的想法涌现。例如，一个水温合适，水流不断的淋浴是检查你的假设和探索可能很棒的新想法的最佳场所之一。
- en: Always remember to create a Git repository for your projects, even if you think
    you won't work on it, because oftentimes you will need a piece of code for a particular
    thing you did years ago and now you need to remember for a new project. Keeping
    your code on GitHub is also great for seeing your progress as a developer and
    to build a solid online presence.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终记得为你的项目创建一个 Git 存储库，即使你认为你不会用它，因为往往你会需要几年前做的某个特定事情的代码片段，现在你需要为新项目记起。将你的代码保存在
    GitHub 上也很好，可以看到你作为开发人员的进步，并建立一个坚实的在线存在。
- en: Coming up with great ideas could have a chapter on its own. The thing with creativity
    is that you'll only get it when you break routines, since you can't expect your
    mind to create new associations based on the same daily experiences. Travel to
    new local places, explore weird hobbies, and be genuinely interested in different
    subjects that are completely different to what you're familiar with, even if they
    seem boring at first.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 想出好点子可能需要单独一章。创造力的问题在于只有当你打破常规时才能获得它，因为你不能指望你的头脑基于同样的日常经验创造新的联想。去新的本地地方旅行，探索奇怪的爱好，并真正对与你熟悉的完全不同的主题感兴趣，即使它们一开始看起来很无聊。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You just completed one of the most important chapters of this book, since we
    talked about optimization and efficiency, two things that are essential for every
    project you work on. We started by building better React applications, where you
    learned to optimize the way you create frontend applications using this powerful
    framework, along with interesting tips to properly structure your components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了本书中最重要的章节之一，因为我们讨论了优化和效率，这两个对你所做的每一个项目都至关重要的事情。我们首先构建了更好的 React 应用程序，你学会了如何使用这个强大的框架优化创建前端应用程序的方式，以及如何正确地结构化你的组件的有趣技巧。
- en: Then you learned to create centralized Node.js applications with NGINX that
    you can use for hybrid projects where smart contracts are just not enough, including
    all the steps from idea to code to deployment on a VPS server with an HTTPS certificate.
    After that, you explored several web3.js improvements to create stronger frontends
    with subscriptions to events, helper functions, and promises that can be better
    controlled.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学会了使用 NGINX 创建集中式 Node.js 应用程序，你可以将其用于智能合约不够的混合项目，包括从想法到代码再到在 VPS 服务器上部署带有
    HTTPS 证书的过程中的所有步骤。之后，你探索了几个 web3.js 的改进，以创建具有事件订阅、辅助函数和可以更好地控制的 promises 的更强大的前端。
- en: 'You''ve gone through one of the most interesting topics when it comes to creating
    capable smart contracts: **oracles**, since they provide smart contracts with
    valuable external information that could be indispensable for specific applications.
    Finally, you discovered 14 tips to improve the way you think about creating projects
    so that you can become proficient when working to deliver higher quality code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到创建能力强大的智能合约时，你已经经历了最有趣的话题之一：**预言机**，因为它们为智能合约提供了有价值的外部信息，这些信息对于特定应用可能是不可或缺的。最后，你发现了14个改进项目创建思路的提示，这样你就可以在努力提供更高质量代码的过程中变得熟练。
- en: In the next chapter, you'll start working on the very interesting topic of decentralized
    exchanges by building one from scratch. It's an exciting opportunity that you'll
    love taking!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始从头构建一个非常有趣的去中心化交易所，这是一个令人兴奋的机会，你会喜欢的！
