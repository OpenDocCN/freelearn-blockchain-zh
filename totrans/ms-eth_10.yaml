- en: Various dApps Integrations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种 dApps 集成
- en: This chapter is about improving your existing dApps and smart contracts with
    new techniques that will make them faster, better, and more efficient. What's
    interesting is that most dApps can be improved with a few tricks. You'll discover
    new aspects of dApp development, including creating your own oracles and backends
    that work with smart contracts. First, you'll start by improving your React skills,
    and then we'll move to the backend so that you learn how to create better centralized
    backends for hybrid dApps that require intensive resources to work properly. After
    that, we'll go back to the frontend to learn how to build stronger dApps with
    web3.js. To cover all the areas related to your dApps, you'll build oracles with
    your recently acquired knowledge about servers, which are the main components
    to take into consideration when dealing with oracles. Finally, to come full circle
    with the improvements, you'll learn how to improve your development workflow to
    produce your most efficient code time- and resource-wise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何利用新技术改进现有的 dApps 和智能合约，使它们更快、更好、更有效。有趣的是，大多数 dApps 都可以通过一些技巧进行改进。你将发现
    dApp 开发的新方面，包括创建自己的预言机和与智能合约一起工作的后端。首先，你将通过改进你的 React 技能开始，然后我们将转向后端，以便你学会为需要大量资源才能正常工作的混合型
    dApps 创建更好的集中式后端。之后，我们将回到前端，学习如何使用 web3.js 构建更强大的 dApps。为了涵盖与你的 dApps 相关的所有领域，你将利用最近获得的关于服务器的知识构建预言机，这是处理预言机时要考虑的主要组件。最后，为了对改进做一个完整的回顾，你将学习如何改进你的开发工作流程，以便以时间和资源为基础生产出最有效的代码。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Better React applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 React 应用程序
- en: Scalable Node.js backends with NGINX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NGINX 构建可扩展的 Node.js 后端
- en: Better web3.js dApps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 web3.js dApps
- en: Building your own oracles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的预言机
- en: Improving your development workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进你的开发工作流程
- en: Better React applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的 React 应用程序
- en: You're familiar with the workflow that's required to create a React application.
    However, many aspects of newer dApps are harder to control. This includes things
    such as smart contract connectivity, processing data for your functions in Solidity,
    and creating components that scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你对创建 React 应用程序所需的工作流程很熟悉。但是，许多较新的 dApps 方面更难以控制。这包括智能合约连接性、为 Solidity 函数处理数据以及创建可扩展组件等方面。
- en: Organizing components properly
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确组织组件
- en: When your application starts growing, you want to make sure your code base is
    clean enough to support new improvements without having to rewrite the entire
    system later on. To do so, you'll start by separating your components into different
    files so that you can keep your content ordered properly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序开始增长时，你希望确保你的代码库足够干净，以支持新的改进而无需在以后重写整个系统。为此，你将从将组件分离到不同文件开始，以便你可以正确地组织你的内容。
- en: 'For instance, take a look at this file named `index.js`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一看名为`index.js`的这个文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see that there are five components that are all in one single big file
    made up of hundreds of lines of code. This is acceptable for smaller projects
    where you just have a few components, but when you start working on bigger applications,
    you must separate your components in different files. To do so, create a file
    for each component with the exact same name. Here is an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到有五个组件都在一个大文件中，由数百行代码组成。这对于只有几个组件的较小项目来说是可以接受的，但是当你开始处理更大的应用程序时，你必须将你的组件分开放在不同的文件中。为此，请为每个组件创建一个具有相同名称的文件。以下是一个示例：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that you must export your component using the `export default` keyword
    so that you get that one specifically. Then, your `src` folder will end up looking
    similar to this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须使用`export default`关键字导出你的组件，这样你才能得到特定的组件。然后，你的`src`文件夹最终会看起来类似于这样：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, in your `Main.js` component, you have to import all the components that
    you'll use. Otherwise, it won't work. This kind of restructuring can easily be
    done in any sort of project since it's just separating components into files;
    however, make sure to import them and export them to the right places.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的`Main.js`组件中，你必须导入所有将要使用的组件。否则，它不会工作。这种重构可以很容易地在任何项目中完成，因为它只是将组件分离到文件中；但是，请确保将它们导入并导出到正确的位置。
- en: Generating components dynamically
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态生成组件
- en: Another trick when it comes to improving your React dApps is to generate components
    dynamically. You've probably been in a situation where you have to generate several
    child components with different attributes because you have some sort of array.
    It may seem simple, but it's quite unintuitive because React only understands
    a certain type of object in its virtual HTML.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进React dApps时的另一个技巧是动态生成组件。您可能曾经处于这样一种情况，您必须生成具有不同属性的多个子组件，因为您有某种数组。这似乎很简单，但却非常不直观，因为React只能理解其虚拟HTML中的某种对象类型。
- en: 'Let''s say you have the following array of objects containing different attributes
    of some animals that you get from your smart contract:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含不同动物属性的对象数组，这些属性是从智能合约中获取的：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You want to generate an `Animal` component for each of those objects. You can''t
    just simply loop them all and create components; you must use the `.map()` function
    with normal brackets, not curly brackets, since React components are very picky.
    Here''s how it would look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您想为这些对象中的每一个生成`Animal`组件。您不能只是简单地循环它们并创建组件；您必须使用带有普通括号的`.map()`函数，而不是花括号，因为React组件非常挑剔。看看它会是这样：
- en: 'First, you set up the constructor with the elements that you want to display
    in an array, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以按照以下方式设置构造函数来呈现数组中要显示的元素：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, set up the render function to look through all the elements with the
    `map()` function, although you can use a normal `for()` loop to generate an array
    of JSX components. Pay attention to the fact that we are returning each element
    inside normal `()` brackets, not curly `{}` brackets, because it''s required by
    JSX to return dynamic HTML elements:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置呈现函数以通过`map()`函数查看所有元素，尽管您可以使用普通的`for()`循环来生成JSX组件数组。请注意，因为JSX要求返回动态HTML元素，我们将每个元素返回在普通的`()`括号内而不是花括号`{}`内：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, create the `Animal` component so that it gets displayed on your dApp:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`Animal`组件以在您的dApp上显示它：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the `AnimalContainer` component is generating `Animal` dynamically
    with the `.map()` function. That''s how you translate a JavaScript object into
    a React component. Pay attention to the fact that we are generating the components
    inside the render function and that the `.map()` function block is inside normal
    brackets, not curly ones:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`AnimalContainer`组件正在使用`.map()`函数动态生成`Animal`。这就是如何将JavaScript对象转换为React组件。请注意，我们是在render函数内生成组件的，并且`.map()`函数块在普通括号中而不是花括号中：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting up projects faster
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快地启动项目
- en: Another problem with React projects is that you must always install the dependencies
    from scratch, set up a `webpack` file, and make sure everything works properly.
    This is tedious and takes way too much valuable time. To solve this, there is
    the `create-react-app` library, although it adds many unnecessary packages that
    could end up causing trouble later on, making upgradability harder, since it's
    based on a closed system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React项目的另一个问题是，您必须始终从头安装依赖项，设置`webpack`文件，并确保一切正常运行。这很烦人，耗费了太多宝贵的时间。为了解决这个问题，有`create-react-app`库，尽管它添加了许多不必要的包，可能会在以后造成麻烦，增加了可升级性更困难，因为它基于封闭系统。
- en: 'It''s better to use the most reduced version possible of a startup React project.
    That''s why I created the open source `dapp` project, which contains precisely
    the smallest, most minimal version of a react dApp project with Truffle to get
    you started right away. You can get the most recent version from my GitHub with
    the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽可能使用最简化的版本启动React项目。这就是我创建的开源`dapp`项目，其中包含了最小、最精简的使用Truffle启动React dApp项目的版本，让您可以立即开始。您可以使用以下代码从我的GitHub上获取最新版本：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then install all the dependencies with `npm i`, run `webpack watch` to keep
    your files bundled as you make changes with `webpack -d -w`, and run the static
    server of your choice in the `dist/` folder. For instance, you might choose `http-server
    dist/`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`npm i`安装所有依赖项，运行`webpack watch`以在进行更改时保持文件捆绑为`webpack -d -w`，并在`dist/`文件夹中运行您选择的静态服务器。例如，您可能会选择`http-server
    dist/`。
- en: 'The `dapp` project is doing the following tasks for you so that you can start
    working on your new dApp immediately:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`dapp`项目正在为您执行以下任务，以便您可以立即开始新的dApp工作：'
- en: Installing all the `react`, `webpack`, `babel`, and `truffle` dependencies.
    Just the right amount, since it doesn't even include `.css` loaders so that you
    manage your packets easily. You still need to have Truffle globally installed
    if you want to use it.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `webpack.config.js` file for you with an entry at `/src/index.js`
    and an output to `/dist/`, and loading all the `.js` and `.html` files with loaders.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the simplest HTML and JavaScript index files.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, every time you have to start a new project, you can simply clone the `dapp`
    repository to start faster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Node.js backends with NGINX
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Node.js** is one of the most powerful tools when it comes to creating command-line
    applications, servers, real-time backends, and all sorts of tools for developing
    web applications. The beauty of it is that Node.js is JavaScript on the server,
    which combines nicely with your React frontend for JavaScript everywhere. Even
    though it''s centralized, you''ll use it plenty of times for decentralized projects
    where you just can''t get by with the limitations of the Ethereum blockchain.
    You see, Solidity and Vyper are severely limited: you can''t do much besides basic
    function-based code. At some point or another, you''ll have to use a centralized
    backend for advanced applications such as those that require a dashboard.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: At least until decentralized hosting and storage solutions drastically improve,
    we'll have to get by with centralized backends for specific tasks that cannot
    be accomplished easily with smart contracts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**NGINX** (pronounced **engine X**), on the other hand, is a web server that
    can be used as a reverse proxy and load balancer, among other things. It''s a
    marvelous tool in conjunction with Node.js, since it speeds up backend calls and
    drastically improves scalability. Put simply, NGINX is the best friend of Node.js
    for advanced projects that require the best performance for a huge quantity of
    users. That doesn''t mean that it can''t be used for simple Node.js applications,
    not at all: NGINX is also excellent for small applications to help you control
    ports and understand domain names easily. You''ll learn all that you need to use
    it properly for bigger dApps.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by learning how to create a Node.js application with an NGINX backend,
    then we'll connect it to a real domain name to finally deploy a scalable NGINX
    backend with load balancing, among other improvements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Node.js server
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create Node.js applications wherever you want, but at some point or
    another you'll have to move that application to a real hosting service such as
    **Amazon Web Services EC2** (**AWS EC2**) or DigitalOcean. Both are excellent
    choices, so we'll explore how to deploy to DigitalOcean.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we''ll start by creating the Node.js server locally to then move
    it to a hosting solution. Suppose we had the following scenario: you have just
    created a dApp with React that''s working flawlessly with very good efficiency,
    so you want others to be able to use this application for free. You could deploy
    it to a static hosting site such as GitHub pages or those provided by HostGator,
    but you want to expand the features of your application and to have a database
    and administrator pages only accessible by certain users. That''s where you need
    a custom server and a **Virtual Private Server** (**VPS**), which is basically
    a remote computer where you can do whatever you want to create custom servers,
    usually with a Linux OS.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们将首先在本地创建 Node.js 服务器，然后将其移动到托管解决方案中。假设我们有以下情景：你刚刚使用 React 创建了一个功能完善且效率非常高的
    dApp，因此你希望其他人能够免费使用这个应用程序。你可以将其部署到 GitHub 页面或 HostGator 提供的静态托管网站等，但你希望扩展应用程序的功能，并具有仅对特定用户可访问的数据库和管理页面。这就是你需要自定义服务器和**虚拟专用服务器**（**VPS**）的地方，它基本上是一个远程计算机，你可以在其中进行自定义服务器的创建，通常使用
    Linux 操作系统。
- en: 'To achieve all that, you must start by creating a Node.js server that serves
    static files for you instead of using tools such as `http-server`. Let''s start
    by creating a static server for our Social Music application that we created in
    the previous chapters. Go ahead and create a `server/` and `public/` folders inside
    your project''s directory, and move the essential code to the `public` folder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一切，你必须首先创建一个 Node.js 服务器，为你提供静态文件，而不是使用诸如`http-server`之类的工具。让我们从在前几章中创建的
    Social Music 应用程序创建一个静态服务器开始吧。继续在项目目录内创建`server/`和`public/`文件夹，并将基本代码移动到`public`文件夹中：
- en: '![](img/e897cb84-07a3-48ca-b869-b331f7de3bd9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e897cb84-07a3-48ca-b869-b331f7de3bd9.png)'
- en: We moved all of the files except those related to nodes such as `package.json`
    and those related to GitHub, such as `LICENSE`, so that we can organize our server
    files in a separate location.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有与节点相关的文件（例如`package.json`）和与 GitHub 相关的文件（例如`LICENSE`）移动到了与服务器文件分开的地方，以便进行组织。
- en: 'Start by creating a file called `server.js` inside `server/` as the main file
    with the main required libraries that we''ll use to set up a server:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`server/`中创建一个名为`server.js`的文件，作为设置服务器所需的主要文件，包括所需的库：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, configure the server listeners that will be in charge of delivering the
    right file when requested by external users:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，配置服务器监听器，负责在外部用户请求时提供正确的文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we did first is import `express` and `body-parser`. Express is a framework
    for creating web servers using Node.js, while body-parser is processing all our
    JSON requests to be able to understand these types of messages, since by default,
    Node.js doesn't understand JavaScript request `json` objects. Then, I created
    several `get` requests handlers to send the `bundle.js` file and `index.html`
    when requested from the `dist` folder; `app.use()` is a piece of middleware, which
    means that it receives all requests, does some processing, and lets other request
    blocks do their job. In this case, we're using that middleware to log information
    about each request so that we can debug the server in case anything wrong happens.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们导入了`express`和`body-parser`。Express 是一个使用 Node.js 创建 web 服务器的框架，而 body-parser
    则用于处理所有我们的 JSON 请求，以便能够理解这些类型的消息，因为默认情况下，Node.js 无法理解 JavaScript 请求的`json`对象。然后，我创建了几个`get`请求处理程序，以便在从`dist`文件夹请求时发送`bundle.js`文件和`index.html`；`app.use()`是一个中间件，这意味着它接收所有请求，进行一些处理，并让其他请求块继续执行它们的工作。在这种情况下，我们使用该中间件来记录有关每个请求的信息，以便在出现任何问题时调试服务器。
- en: 'Install the required server dependencies with the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的服务器依赖项：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can run the server:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行服务器了：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The problem with the preceding command is that you have to restart the server
    anytime there''s a bad request or you make changes to the server file. For development,
    it''s better to use the `nodemon` utility, which that automatically refreshes
    the server. Install it with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的问题在于，每当出现错误请求或者对服务器文件进行更改时，你都必须重新启动服务器。对于开发工作，最好使用`nodemon`实用程序，它会自动刷新服务器。使用以下代码安装它：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run your server again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次运行你的服务器：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make development easier, create a new script for running that command faster
    inside your `package.json` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更轻松地进行开发，在你的`package.json`文件中创建一个新的脚本，以便更快地运行该命令：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, you'll be able to run `npm run server` to start the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行`npm run server`来启动服务器：
- en: Getting a hosting solution
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取托管解决方案
- en: Now that we have our static server running, we can deploy it on a hosting solution
    to make our dApp accessible from the outside world. Before that, add your project
    to GitHub with all the latest changes to use it later on another computer. Go
    to [https://digitalocean.com](https://digitalocean.com) and create an account
    with the link [https://m.do.co/c/db9317c010bb](https://m.do.co/c/db9317c010bb),
    which will give you $100 dollars worth of service for 60 days for free and an
    additional $25 dollars when you add $25 dollars to the service. That will be more
    than enough to run a basic VPS server for at least 3 months. You'll have to add
    your credit/debit card or add $5 PayPal dollars to start using it. In my case,
    I used PayPal by paying $5 dollars.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Droplets section and click on Create Droplet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4580562e-5303-4d51-8390-427472787d5c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Then, you have to choose what distribution to install inside that server; this
    distribution is called Droplets. You could select a one-click installation with
    Node.js, but I believe it''s important that you know how to install Node.js from
    scratch when you don''t have a user interface. So, choose Ubuntu 18.04 as the
    OS with a $5 dollar per month plan:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fdfd8bd-0986-47c6-bc79-946329d94e76.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Select the datacenter closest to where you live to get the best performance.
    I live in Spain, so I will choose servers in Germany or the United Kingdom. For
    you, it may be different:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f35797e-ee0a-4a86-bca0-bcf730f9f543.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Leave the rest of the options as they are and press Create to create it. You''ll
    see how it''s created in real time. Click on your droplet and copy the IPv4 address,
    which you''ll need to connect to that server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e87945d6-af2e-4ca3-9bbe-a06c697d2f88.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Setting up your server on a VPS hosting
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re using Windows, download PuTTY to connect to external servers from
    their official page, here: [https://www.putty.org](https://www.putty.org/). Open
    it after installing it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c181034f-f3a0-452f-ace8-9867c9dce765.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'Paste your IP address into the Host Name input and connect to it by clicking
    on Open. It will warn you about connecting to an unknown server; just click Yes.
    Then, it will ask you to log in; type `root` as your default username: it''s different
    for each hosting provider.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Mac, you can simply use the following command instead of using
    PuTTY:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although **root** is the default user provided by DigitalOcean, note that it
    may be different for each hosting solution, so check the information provided
    on their website.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Then, it will ask you for your password, which you can get via email; since
    DigitalOcean has sent you your login credentials, you won't see it as you paste
    it as a security measure. You can paste it with a right-click and nothing else,
    since that's the way PuTTY works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after that, it will request that you retype your current password,
    then change your Unix password to a new one, since you can''t rely on an autogenerated
    one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d4d50ea-a67b-4d48-b085-b01e48462662.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'You should now have access to your server. As you can see, you don''t have
    a user interface except for your command-line tools. You don''t want to do all
    the tasks as the root user since it''s a security risk, given that any action
    has access to the entire system without restrictions. Create a new user with the
    following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s an example: `useradd -m merunas`. The `-m` flag will create a `/home/merunas`
    user folder. Then, change to that user with `su merunas` or whatever user you
    created. The `su` command means "substitute user".'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have to set up a password with the `passwd` command, otherwise you
    won''t be able to log in at the start of the session. For instance, you could
    use this command: `passwd merunas`. You''ll want to log in as that user next time
    to avoid potential security risks as the root user. Then, you''ll want to change
    your shell to Bash instead of sh to get autocompletes when pressing *ab*, among
    other nice utilities to help you write commands. Do so with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add your user to the `sudo` group to be able to run commands as the `root`
    user without having to change users. You must run this as the `root` user:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an example: `usermod -aG sudo merunas`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do now is install Node.js and NGINX from scratch. The process for
    Node.js is a bit complicated because they are constantly improving their software,
    so it''s harder to set up, but perfectly doable. Go to [https://nodejs.org/en/download/current/](https://nodejs.org/en/download/current/)
    and copy the link address of the Source Code by right-clicking on the button for
    it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70b46c66-5a68-4967-95c3-86876001ccb8.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Go back to your PuTTY session and run the `wget` command with that source code
    link to download the node binaries so that you can install it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Extract it with `tar`, as shown in the following command line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Navigate to the current directory by running `cd node-v11.10.0` . To install
    Node.js from that folder, you need a few dependencies that can be installed in
    a package known as `build-common`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, run the `./configure` and `sudo make` commands to run the installation.
    The `make` command generates the required configuration, but it takes several
    minutes, so be patient. Previously, you also had to run `sudo ./install.sh`, but
    it''s no longer necessary; you still get your nice `node` executable. Simply copy
    it to the binaries location to be able to use it globally:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can now remove the installation folder and the downloaded file. Alternatively,
    you could have used `sudo apt install nodejs` to install Node.js, but that''s
    an outdated version that''s not as maintained as the official binaries. Now that
    you have Node.js installed, git clone your social-music project from GitHub or
    use mine with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Install `npm` externally with `sudo apt install npm` so that you can install
    packets. You have to get it from this other source because Node.js doesn't include
    it. The good thing about npm is that you can update it immediately with `sudo
    npm i -g npm` to the latest version with ease, so it doesn't matter which version
    you get where with Node.js, you can't simply update it to the latest version without
    going through a lengthy process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run `npm install` to install your dependencies from the `social-music`
    project. Check that your `package.json` file contains your `npm run server` command
    that you created previously. Otherwise, add it again with `vim` or any other text
    editor, such as `nano`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you use the `npm run server` command, you'll see that your server runs
    properly; the problem is that you shouldn't use `nodemon` because it's designed
    to be used for development without considering the problems that could arise in
    different environments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, you have a utility that''s ideal for Node.js projects in production.
    It''s called `pm2` and it will keep your server alive, even if a breaking error
    occurs at some point. This utility is great because you can monitor your server
    and run various instances of different services. Install it globally with the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It's very easy to use. You can daemonize a service with just `pm2 start server/server.js`,
    which means restarting it whenever it stops running for whatever reason. To stop
    it, use `pm2 delete server` from the list of running services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have a Node.js application running on your server. Now,
    to make it available to the world, you have to expose it to port `80`, which is
    the public port used by all websites. You can do so by modifying your `server.js`
    file or with what's called a frontend server, which receives all the requests
    and redirects them to the right place. In our case, that will be NGINX. But before
    that, we need an accessible domain that will make our IP management easier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Getting a domain name
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need a domain to help people access your website with an easy-to-remember
    name instead of writing a long IP number on their browsers. The domain will be
    associated with your hosting solution with a few changes. To get a domain, go
    to [godaddy.com](https://in.godaddy.com/) and search for the name you desire:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3d2f064-f8bb-46d9-a8b9-be0fba87a097.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Select the domain that best fits your business:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d3fa06e-c6a6-4f64-b101-7c9bcfc2aed9.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Buy it by clicking on the Add to Cart button and creating an account if you
    don''t have one. I always use PayPal since it''s easier to manage. After a few
    minutes, you''ll have your domain available in your dashboard:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6b1abd4-588e-4dec-a9aa-ae0de2a65993.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can go to your DNS management settings to point your domain to your
    hosted server so that it''s accessible from that name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d37552b3-b5eb-414a-97bc-4103272ccb0c.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Click on the pencil icon next to your A records and change the pointer to your
    IP address like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击A记录旁边的铅笔图标，并将指针更改为您的IP地址，如下所示：
- en: '![](img/f59de043-7d0c-4bc0-a1d9-f0b57edfb019.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f59de043-7d0c-4bc0-a1d9-f0b57edfb019.png)'
- en: 'With that change, you can now connect to your server with the domain name instead
    of IP, for instance in Mac like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一变化，您现在可以使用域名而不是IP连接到您的服务器，在Mac中，例如这样：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And it will work exactly as before. You can also start your Node.js server on
    port 80 and you'll be able to access the website with that domain. However, Node.js
    is limited when it comes to talking to domains, so we have to use a more advanced
    solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它将与以前完全相同的方式工作。您还可以在端口80上启动Node.js服务器，并且您将能够使用该域名访问网站。但是，当涉及与域名通信时，Node.js受到了限制，因此我们必须使用更高级的解决方案。
- en: Setting up NGINX
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NGINX
- en: Now that your domain is set up, it's time to configure NGINX as a frontend server
    to connect your domain with your Node.js instance. NGINX will process all the
    requests for you so that you can focus on improving your Node.js application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的域名已经设置好了，是时候将NGINX配置为前端服务器，以将您的域名与Node.js实例连接起来了。NGINX将为您处理所有请求，这样您就可以专注于改进您的Node.js应用程序。
- en: 'Connect to your server as before and install `nginx` with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样连接到服务器，并使用以下命令安装`nginx`：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, you''ll have to edit the configuration files of NGINX, which are
    located at `/etc/nginx/sites-enabled/default`. Simply edit your default file with
    `vim`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将需要编辑NGINX的配置文件，位于`/etc/nginx/sites-enabled/default`。只需用`vim`编辑您的默认文件：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, add the following code to be able to use a domain with your Node.js server:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码以能够在Node.js服务器中使用域名：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we defined an `upstream` block. That's where we tell NGINX the location
    of our running `node.js` server at the right port. This is important to protect
    port 80 since it's where most of the requests will be executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`upstream`块。在这里，我们告诉NGINX我们在正确端口上运行的`node.js`服务器的位置。这对于保护端口80非常重要，因为大部分请求都会在那里执行。
- en: Then, we created a `server` block. These types of blocks are used to set up
    some configuration at the port defined inside. The `listen 80;` statement tells
    NGINX to process the request for port 80 inside that server block. We then added
    some `gzip` compression for faster loading times and a location block that will
    pass all the requests to `upstream nodejs`. The other location block is for serving
    static files in case you had images and the like, since it's a faster way to deliver
    static content. Note that the `root /home/merunas/social-music/public;` root location
    is where our static files will be located.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`server`块。这些类型的块用于在定义的端口上设置一些配置。`listen 80;`语句告诉NGINX在该服务器块内处理端口80的请求。然后，我们为更快的加载时间添加了一些`gzip`压缩，以及一个将所有请求传递给`upstream
    nodejs`的位置块。另一个位置块是用于提供静态文件的，以便您有图像之类的文件，因为这是传递静态内容的更快方式。请注意，`root /home/merunas/social-music/public;`根位置是我们的静态文件的位置。
- en: 'Remember to change `socialmusic.online` for your domain. You can now run NGINX
    with the following command line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得将`socialmusic.online`改为您的域名。您现在可以使用以下命令行运行NGINX：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That will restart the service to keep it running in the backend. Your website
    is now accessible at your domain name from any browser. To finish the deployment,
    we'll add SSL. **SSL** is an encryption algorithm that's used to secure communications
    for those accessing your dApp. It's very common and must be added for any serious
    project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新启动服务，使其在后台保持运行。您的网站现在可以在任何浏览器中使用您的域名访问。要完成部署，我们将添加SSL。**SSL**是用于保护访问您的dApp的通信的加密算法。这是非常常见的，并且对于任何重要项目来说都必须添加。
- en: Adding SSL security
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SSL安全性
- en: 'To install SSL, we''ll use the free certificates from **Let''s Encrypt**, a
    non-profit whose goal is to secure the internet with free SSL certificates for
    everybody. Here are the steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SSL，我们将使用**Let's Encrypt**的免费证书，这是一个非营利性组织，其目标是为每个人提供免费SSL证书来保护互联网。以下是步骤：
- en: 'Install the following libraries:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装以下库：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `certbot` application to add your NGINX server:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`certbot`应用程序向您的NGINX服务器添加：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Provide your email address, accept the terms of service, and select 1 for your
    domain name:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的电子邮件地址，接受服务条款，并选择1作为您的域名：
- en: '![](img/1461c4f9-b450-413d-b0e7-560b199d0e66.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1461c4f9-b450-413d-b0e7-560b199d0e66.png)'
- en: 'It will ask you if you want to redirect all requests to the 443 secure HTTPS
    port. Simply say yes by selecting the second option:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问您是否想要将所有请求重定向到443安全的HTTPS端口。只需通过选择第二个选项说是：
- en: '![](img/7118af8a-a3f3-4b10-aaf5-2767bd7e090a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: That should be it! You now have HTTPS enabled for all requests, and your domain
    will automatically redirect to HTTPS. This can be done manually, but this way
    is far easier so that you avoid countless headaches when dealing with these kinds
    of complex authentication systems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You now have a NGINX server with HTTPS running for your decentralized application
    using a Node.js centralized backend that you can expand as much as you wish with
    advanced features that can't be done in a simple smart contract. The best of both
    worlds.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Better web3.js dApps
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: web3.js is the most used utility for communicating with smart contracts in your
    web applications to convert them into decentralized applications. It's capable
    of managing endless transactions and works automatically once set up.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The problem comes from the fact that many web3.js applications are not optimized,
    at least not as well as possible. Because we're dealing with smart contracts,
    inevitably the code gets confusing really quickly, making maintenance harder over
    the medium-long term. That's why it's important that you study systems to create
    better web3.js dApps from the start to learn tips and tricks that will make you
    a better programmer when it comes to interacting with smart contracts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: You'll be working with a lot of dApps using web3, so why not learn the best
    way of doing things to save you headaches in the long run while creating higher
    quality code? Here are some tips and tricks to make better web3.js dApps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a fixed web3.js version
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you, used MetaMask in the past, you''ll have noticed that it injects web3.js
    into every single page you visit since it requires web3.js to be able to interact
    with smart contracts. That''s great: it''s an expected behavior, but it usually
    leads to ancient web3.js versions, mainly version 0.20, which has been used and
    is still used for several years after web3.js 1.0 came out. They don''t want to
    force users to update to the latest version because that would break many web3.js
    dApps already dependent on MetaMask; it''s a huge potential issue.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: That's why it's imperative that you set up a fixed web3.js version for your
    project so that you don't depend on what MetaMask or any other Ethereum client
    forces you to use. It's mandatory to provide some kind of guarantee that your
    dApp will continue working in the future.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, take a look at this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using web3.js 1.0 for this example. Next, we import the `NewWeb3` class,
    which is just a different name to differentiate it from `Web3` provided by MetaMask
    to set up a new `web3` object to communicate with the blockchain using our particular
    version of `web3`. It's called `web3Instance` instead of plain `web3` because
    we want to use a different name to avoid using the one provided by MetaMask. You
    see, we can't know when MetaMask will inject its own version of `web3`, so we,
    make sure to use a different name to guarantee that our version is set up. Then,
    we set up a global `web3Instance` variable using the `window` object so that it's
    accessible from anywhere within our application, and we do it after the page loads
    by listening to the event `'load'`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Try it in a project and you'll see that `web3Instance` is the version you defined
    in your import. Note that `.givenProvider` is taking the injected web3.js data
    from MetaMask to set up a new web3.js version. Make sure to use this tip for all
    your future projects to guarantee that your dApp works for future and past web3.js
    versions, since MetaMask is constantly changing it own system in an unreliable
    manner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Creating helper functions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helper functions are those that help you manage more complex functions with
    ease. They are essentially functions that are intended to help other functions
    with some common logic so that you don't have to repeat your code over and over.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: These are important functions because they will improve the maintainability
    of your code vastly. You'll be able to see what's happening in fewer lines and
    you'll be able to upgrade your code faster.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in web3.js 1.0, contracts have to use a large line of code for
    every smart contract call and transaction:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s descriptive, but a bit longer than necessary. Let''s reduce it with a
    helper function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, we''ve converted a method in call to the brackets version since
    that''s the way you can dynamically generate function names with unique parameters
    for objects. In the past, I recall using the following shortcut to select elements
    quickly without having to type the same structure over and over:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With such a simple helper function, I've converted a 22-character function into
    a 1-character function with the same logic. It may seem absurd at first, but when
    you have to use it 100 times in a project, you'll realize that you're drastically
    reducing the size of your code and you're making it easier to read. You're literally
    saving 2,200 lines of code. Now that's efficiency with the smallest change possible!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Promisifying your functions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern JavaScript uses promises to process transactions cleanly since it gives
    you the choice to run your code synchronously or asynchronously using the same
    function instead of callbacks where you have to stack layers of code to control
    the flow of things.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: That's why all your callback functions must be converted in to promises if they
    are not already. This is not a problem with the latest versions of web3, but with
    web3.js 0.20 and many other libraries where you have to use callbacks, it's better
    to just convert them to promises for easier code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a library called `bluebird` that helps you with that by converting
    all the functions inside an object in to promises. Install it with the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Import it into your React project with the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following function to convert your object methods into `Async`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, you can use `Async` functions instead of callback functions, like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s just an example: the idea is that you add the `Async` keyword to your
    callback functions to use the promisified version without having to do anything
    else.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Listening to events with web3.js
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are essential to manage the flow of your decentralized applications since
    you can get real-time updates about changes that are happening in your smart contracts
    and act accordingly. You can even create Node.js applications to notify you about
    critical changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say that you run a bank smart contract and have an event
    that gets activated when the funds in your smart contract reach a critical 10
    ETH low:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You want to be notified about such changes, so you''ve set up a simple web3.js
    dApp on a `node.js` instance that sends you an email when that happens:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That could be a monitoring system that you''ve set up yourself to manage a
    dApp used by millions of users so that it stays operative for as long as possible.
    You can argue that listening to events in such a scenario is essential, so how
    do you do it? Here''s the basic structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Your `web3.eth.subscription` function will execute the callback when the event
    is generated. That's basically how you listen to events in web3\. Now, you know
    how to use them for critical operations in your dApp's workflow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Building your own Oracles
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracles are external applications that help your smart contract receive information
    from the outer world to perform some functions outside of what''s possible inside
    Solidity or Vyper. How they work is simple: you create a centralized server that
    calls specific functions of your smart contract when needed.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: They are used to generate random numbers, to provide live price data, and to
    show information from websites. As you know, smart contracts can't generate random
    numbers because there can't be any uncertainty regarding being able to avoid unexpected
    situations in the blockchain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn how to create an Oracle to generate a random number
    between 1 and 100 for a game on the blockchain. There are already oracles doing
    these tasks, namely Oraclize, which has been used for a long time with Solidity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Building a random generation Oracle
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracles are a smart contracts' way of getting information from the external
    world. They are the bridge between centralized servers, external blockchains,
    and APIs, with smart contracts running on Ethereum. Essentially, they are a service
    that provides you with important information from places inaccessible with normal
    smart contracts, and they work by setting a centralized server listening to web3
    events for your contract.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new project named `oracle`, run `truffle init` to be able to
    compile contracts, set up npm with `npm init -y`, and create a smart contract
    that generates events and handles `Oracle.sol`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It''s pretty basic: the idea is to execute the `__callback()` function with
    the randomly generated number when the user requests it by calling the `generateRandom()`
    function. We''ll set up an event listener that will give users random numbers
    at the right time, with the right sequence identifier.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to update your `1_initial_migrations.js` file inside the `migrations`
    folder to tell Truffle to deploy the right contract:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, deploy it to `ropsten` by setting up the right configuration inside `truffle-config.js`.
    You already know how to do this since we learned how to set up Infura for Ropsten
    inside the configuration file of Truffle in previous chapters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can create the Node.js application that listens to events generated
    by our smart contract and makes the right request with a randomly generated number
    type using the following code to start inside an `oracle.js` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've imported `web3`, `fs`, and `path` as the libraries to interact with our
    contract. Then, we defined a websockets Infura URL to use it to connect to Ropsten
    for deploying and interacting with contracts. It's important that you use `wss`
    instead of `http` since it's the only way to receive events. Finally, we added
    some global variables that we'll need later on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we generate transactions without MetaMask is by creating and signing
    our custom transaction object with our private key, which we can generate with
    the following function based on our mnemonic located in the `.secret` file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It''s quite complicated, although we only have to focus on installing and importing
    the `bip39` and `ethereumjs-wallet` libraries to generate `privateKey` used for
    signing transactions. We can install the dependencies with the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we can create a `start` function that will set up the required contracts
    and start listening to the right trigger event to call the `__callback()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we read the mnemonic 12-word passphrase to generate our privateKey and
    address using the previous `generateAddressesFromSeed()` function. Then, we set
    up a new web3 instance with `WebsocketProvider` for our Ropsten Infura URL because
    we can't listen to events with `HttpProvider`. After that, we set up `contractInstance`
    by reading the ABI data from the JSON file that was generated by Truffle, which
    includes the address of the deployed contract.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we set up a subscription for the `GenerateRandom` event using the
    `contractInstance.events.GenerateRandom()` function, which will call the `callback()`
    function with the sequence that corresponds. Let''s see what the callback function
    looks like. Remember that this function will run the `__callback()` of our smart
    contract to provide users with a randomly generated number, since we can''t directly
    generate random numbers with Solidity:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function receives the sequence parameter to map the values to the right
    ID so that users can identify which event is the right one for them. First, we
    generate a random number between 1 and 100 using `Math.random()`, with some calculations
    to adapt it to our desired range. Then we generate a transaction object called
    `tx` that includes our function data with `sequence` and `generatedNumber`, and
    some essential parameters such as `gas` and the `from` address. Finally, we send
    that transaction to our `Oracle` smart contract by first signing it with `privateKey`
    and then sending it using `web3.eth.sendSignedTransaction`. When it's confirmed
    by the miners, we'll see `console.log` saying `"Callback transaction confirmed!"`,
    or an error in case something goes wrong.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s about it! We can add the `start()` function initialization at the bottom
    to start listening to events. Here''s the full code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Import your required libraries and set up the variables that will be used in
    the project at the beginning of the file:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the `generateAddressesFromSeed()` function, which provides you with
    access to the accounts contained in the given seed:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `start` function to set up the web3 listeners:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, create the callback function that executes the `__callback()` function
    from the smart contract. The function name starts with two underscores to avoid
    calling an existing function, since it''s a special function used exclusively
    by the oracle:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Remember to start the oracle by running the `start` function at the end of
    the file once everything is loaded:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Optionally, we can add a function to execute the `generateRandom()` function
    from our smart contract to verify that we''re indeed receiving events with another
    subscription, such as the following:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, update the `start` function to listen to the new event we created by
    using the `generateRandom()` function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That way you'll be able to see how the contract is actually receiving your randomly
    generated number from your Node.js oracle to confirm that it's working properly.
    Go ahead and try it yourself by deploying your own oracles that provide smart
    contracts with external data that they couldn't get by themselves using this callback-based
    mechanism with unique identifiers. Additionally, you could add some external proofs
    to verify that the data is coming from the right oracle, although that's outside
    of the scope of this guide since it would be too extensive to describe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you have the full, updated code updated on my GitHub ([https://github.com/merlox/oracle](https://github.com/merlox/oracle))
    if you want to see the latest changes and try the working version. Take a look
    at the Truffle configuration file if you want to see how I set it up.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Improving your development workflow
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to creating smart contracts and decentralized applications, a
    common problem is that we must work in the most efficient way possible to create
    the highest quality code so that we don't spend unnecessary hours on fixing problems
    that shouldn't be there in the first place.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In my personal experience, the best applications that I've created were born
    from exhaustive planning beforehand. It may feel unnecessary, but the more you
    work, the more you realize how much time you can save by getting your ideas in
    place with a clear plan that describes each element of your idea.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Have you worked on projects where you're constantly getting into problems such
    as bugs or confusion? That's probably because you didn't do enough planning. In
    this section, you'll learn how to plan your applications to set up projects that
    are easy to understand so that you can develop way more efficiently.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you want to put your skills into practice to learn more about
    Ethereum technology with real projects. So, you decide to work on a relatively
    complex dApp. You first get the idea, then you detail the components of your application
    based on how you think it should work, and you start to code right away to get
    it done quickly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a very common approach to most projects, given that we don''t want
    to waste time on projecting—we want to get it done fast so we develop the code
    immediately. That''s fine for small projects, but for bigger ones we must follow
    guidelines like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a detailed description of what you have in mind: the most important features,
    how it will feel to the customers, and what is it about.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Break it down into smaller pieces: the frontend, the backend, and the smart
    contract, if any. Then describe those elements in a way that you can understand
    how they will be used.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go deeper by writing down the functions that will be added to each of those
    three parts. Those will be the main functions for your application. Write them
    in an empty file without body: just the functions with the parameters and return
    values.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document those functions by describing what they are supposed to do on a technical
    level using NatSpec documentation so that each parameter and return value is explained
    clearly.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start working on the smaller independent functions. Those could be getter functions
    that return some variable or simple functions for calculating a value.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move on to more complex functions until all of them are completed. While you
    do so, write empty tests as they come to mind to check every aspect of those functions.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correct the project by writing unit tests from those that you set up previously
    and add a few more focusing on the potential of the problem they could cause if
    unchecked.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your planning may be different: what you just read is only a simple guide that
    I came up with after trying to understand the process behind a successful project.
    Just so that you can take it with you in a more visual manner, here''s an illustration
    of that development process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17dd7a95-db7c-45f7-ad0d-9ed61c9e1fde.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'While you create each function, leave `//TODO` notes describing what needs
    to be done next, so that when you come back, you have a clear and simple objective
    to go for. For instance, here''s a function that I''ve been working on recently:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is an extension already installed in the famous [atom.io](https://atom.io/)
    code editor called `language-todo` that highlights these types of `TODO` notes
    so that you can see them easily. You can also search for those inside your entire
    project with the search function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, there''s another extension that allows you to manage those reminders
    in a single panel. Here''s the package name so that you can install it if you
    want:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20ac7f43-50ac-4f76-9a17-afe5f4ff4950.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'Here are some additional recommendations to improve your workflow when you
    work on creating a successful project:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: At the top of each file, create a list of things that need to be completed in
    that particular file so that you know when it's completed.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use already made tools to deploy your contracts and write tests to verify functionality
    efficiently. For instance, Truffle, Ganache, and Remix are essentials for testing
    while improving your efficiency.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a time limit to everything; be as precise as possible, since projects have
    the tendency to use up as much time as you give them. Be strict to keep your mind
    focused.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine what can be done in different time limits. For instance, in 1 week,
    you could create a basic version of your idea with the core two features, in 1
    day, you can complete 5 of the 100 functions required to complete a solid beta
    version, and in 1 month, you could have the basic code completed. The idea is
    to imagine what would be a realistic estimate of what's possible with enough time
    for your idea. Write down what needs to be completed in 1 day, in 1 week, and
    in 1 month.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put yourself in places where you're comfortable. Usually, great ideas come when
    your body feels good and your mind is relaxed. For instance, a shower where the
    right temperature and the constant flow of water relaxes your entire being is
    one of the best places to examine your assumptions and explore new ideas that
    could be great.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always remember to create a Git repository for your projects, even if you think
    you won't work on it, because oftentimes you will need a piece of code for a particular
    thing you did years ago and now you need to remember for a new project. Keeping
    your code on GitHub is also great for seeing your progress as a developer and
    to build a solid online presence.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming up with great ideas could have a chapter on its own. The thing with creativity
    is that you'll only get it when you break routines, since you can't expect your
    mind to create new associations based on the same daily experiences. Travel to
    new local places, explore weird hobbies, and be genuinely interested in different
    subjects that are completely different to what you're familiar with, even if they
    seem boring at first.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just completed one of the most important chapters of this book, since we
    talked about optimization and efficiency, two things that are essential for every
    project you work on. We started by building better React applications, where you
    learned to optimize the way you create frontend applications using this powerful
    framework, along with interesting tips to properly structure your components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Then you learned to create centralized Node.js applications with NGINX that
    you can use for hybrid projects where smart contracts are just not enough, including
    all the steps from idea to code to deployment on a VPS server with an HTTPS certificate.
    After that, you explored several web3.js improvements to create stronger frontends
    with subscriptions to events, helper functions, and promises that can be better
    controlled.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve gone through one of the most interesting topics when it comes to creating
    capable smart contracts: **oracles**, since they provide smart contracts with
    valuable external information that could be indispensable for specific applications.
    Finally, you discovered 14 tips to improve the way you think about creating projects
    so that you can become proficient when working to deliver higher quality code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll start working on the very interesting topic of decentralized
    exchanges by building one from scratch. It's an exciting opportunity that you'll
    love taking!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
