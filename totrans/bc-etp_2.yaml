- en: Building Blockchain Using Quorum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw what a DApp, DLT, and blockchain are. We also
    saw an overview of some popular blockchain-based DApps. At present, Ethereum is
    the most popular public DApp after Bitcoin. In this chapter, we will learn how
    to build permissioned blockchain-based DApps using Quorum. We will learn about
    Quorum in depth by exploring all the various consensus protocols it supports,
    its permissioning and privacy features, and finally, tools that enable us to quickly
    deploy a Quorum network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: User accounts in Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Merkle tree and what is it used for in blockchain?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do **Istanbul Byzantine Fault Tolerant** (**IBFT**) and Raft work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various mechanisms supported by Quorum to achieve privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up constellation, Raft, and IBFT networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various third-party tools or libraries related to Quorum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Quorum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quorum is a permissioned decentralized platform that allows us to deploy DApps
    on top of it. DApps are created using one or more smart contracts. Smart contracts
    are programs that run exactly as programmed without any possibility of downtime,
    censorship, fraud, or third-party interface. In Quorum, smart contracts can be
    written in Solidity, LLL, or Serpent. Solidity is the preferred one. There can
    be multiple instances of a smart contract. Each instance is identified by a unique
    address, and you can deploy multiple DApps on the same Quorum network.
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, there is an internal currency called **ether**. To deploy or execute
    smart contracts, you need to pay ether to the miners and as Quorum is a fork of
    Ethereum, the same thing exists here too. But in Quorum, ether is valueless and
    a fixed number of ether is generated at the **genesis block**, and no more ether
    can be generated after that. Both user accounts and smart contracts can hold ether.
    In Quorum, you need to have some ether to execute transactions on the network,
    but ether is not deducted and sending ether to another account doesn't deduct
    ether, therefore you can say ether in Quorum provides a way to track the owner
    of a account if anything suspicious is by a account by tracking the ether transfers
    and also provide a way such that to make transactions you need to get permission
    from one of the permitted members; that is, get some ether from a network member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, Quorum supports three consensus protocols: QuorumChain, IBFT, and
    Raft. In this book, we will learn only about Raft and IBFT as they are the most-used
    ones. For privacy, it supports two mechanisms: the zero-knowledge security layer
    protocol and private contracts. We will learn about private contracts but will
    not be covering ZSL as it''s still not production-ready.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an account, we just need an asymmetric key pair. There are various
    algorithms, such as **Rivest–Shamir–Adleman** (**RSA**) and **E****lliptic Curve
    Cryptography** (**ECC**) for generating asymmetric key pairs. Ethereum uses ECC.
    ECC has various curves. These curves have a different speed and security. Ethereum
    uses  **secp256k1** curves. To go in to  ECC and it's curves will require mathematical
    knowledge, and it's not necessary to understand it in depth to build DApps using
    Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses 256-bit encryption. An Ethereum private and public key is a 256-bit
    number. As processors cannot represent such big numbers therefore it's always
    encoded as a hexadecimal string of length 64.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every account is represented by an address. Once we have the keys we need to
    generate the address, here is the procedure to generate the address, and here
    is the procedure to generate the address from the public key:'
  prefs: []
  type: TYPE_NORMAL
- en: First, generate the **Keccak-256** hash of the public key. It will give you
    a 256-bit number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the first 90 bits and 12 bytes. You should now have 160 bits of binary
    data (20 bytes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, encode the address as a hexadecimal string. So, finally, you will have
    a byte string of 40 characters, which is your account address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, anyone can send ether to this address, and then you can sign and send transactions
    from this address.
  prefs: []
  type: TYPE_NORMAL
- en: What are Ethereum transactions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transaction is a data package to transfer ether from an account to another
    account or contract, invoke methods of a contract, or deploy a new contract. A
    transaction is using **Elliptic Curve Digital Signature Algorithm** (**ECDSA**),
    which is a digital signature algorithm based on ECC. A transaction contains a
    signature identifying the sender and proving their intention, the amount of ether
    to transfer, the maximum number of computational steps the transaction execution
    is allowed to take (called a **gas limit**), and the cost the sender of the transaction
    is willing to pay for each computational step (called the **gas price**). The
    product of the gas used and the gas price is called the **transaction fees**.
  prefs: []
  type: TYPE_NORMAL
- en: In permissioned networks, ether is valueless. In a Quorum network, ether is
    supplied in the genesis block and is not generated dynamically at runtime. You
    need to supply ether in the genesis block. You need to provide gas to prevent
    attacks, such as infinite loops. Ether is not deducted from accounts when transactions
    are mined.
  prefs: []
  type: TYPE_NORMAL
- en: If the transaction's intention is to invoke a method of a contract, it also
    contains input data, or if its intention is to deploy a contract, then it can
    contain the initialization code. To send ether or to execute a contract method,
    you need to broadcast a transaction to the network. The sender needs to sign the
    transaction with its private key.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is said to be confirmed if we are sure that it will always appear
    in the blockchain at the same place. In Ethereum's proof of work, it's recommended
    to wait for the transaction to appear 15 blocks below the newest block (that is,
    wait for 15 confirmations) before assuming the transaction to be confirmed as
    there are chances of forking and the transaction disappearing from the blockchain.
    But, in Quorum's Raft or IBFT, as soon as the transaction appears in one of the
    blocks, we can say it's confirmed as there is no possibility of forking.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Merkle tree?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into what a Merkle root in blocks of blockchain is, let's understand
    the structure of blockchain. A block is made up of two parts; the first part is
    the block header and the second part is the set of transactions of that block.
    The block header contains information such as the previous block hash (it's actually
    a hash of the previous block's header), timestamp, Merkle root, and information
    related to achieving consensus.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of sync, while downloading a block a node downloads the block header
    and the block's transactions. Now, how would the receiving node know that these
    transactions are actually part of that block and are in the correct order? Every
    block is identified by a unique hash, but the block hash is not part of the block
    header and is uniquely calculated by every node after downloading the block; therefore
    we cannot use the idea of a block hash. Instead, we can rely on something like
    a transactions hash; a hash stored in the block header, which is calculated by
    combining all transactions and hashing it. This idea will work perfectly, and
    we can detect if any transaction is missing or extra transactions included, or
    if transactions are in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, a Merkle root is an alternative to the transactions hash approach but
    provides another major advantage: it allows the network to have light nodes. We
    can, of course, have blockchain implemented without Merkle root, but if there
    is a need for light nodes in the network, then Merkle roots are required to be
    used. A light node is one that only downloads block headers but no transactions
    but still it should be able to provide all APIs to the client. For example: a
    smartphone cannot have the full blockchain as it could be very large in size;
    therefore, we can install a light client in smartphones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first understand what a binary Merkle tree is with respect to blockchain. A
    hash tree or Merkle tree is a tree in which every leaf node is a hash of a transaction,
    and every non-leaf node is a hash of the hashes of its child nodes. Hash trees
    allow efficient and secure verification of which transactions are part of the
    block. Every blocks forms it''s own Merkle tree. A Merkle tree is called a **binary
    Merkle tree** when every parent has two children. Binary Merkle trees are what
    is used in blockchain. Here is an example of a binary Merkle tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ec86d17-12ee-40b8-93ec-182de6126017.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, at first the individual hash of every transaction
    is calculated. Then, they are grouped into two. And then, a hash of the two hashes
    is calculated for each pair. This process will continue until we have a single
    hash called the **Merkle root**. In case there are odd numbers of transactions,
    the last transaction is duplicated to make the total number of transactions even.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the time of downloading a complete block, the block header, and transactions
    of the block, a node can verify whether the set of transactions is correct or
    not by forming the binary Merkle tree and checking that the generated Merkle root
    is the same as the one included in the block header. Of course, this can be done
    without a Merkle tree, as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: A light node can take advantage of the Merkle tree to serve requests to the
    client. For example, a light node can make a request to a full node asking if
    a particular transaction is committed in a block or not, and the full node replies
    with the block number and Merkle proof if the transaction is committed in a block.
    A light node cannot just believe the full node if the full node provides a block
    number, therefore the full node also provides Merkle proof. To understand what
    a Merkle proof is, let's take the preceding diagram and a scenario where the light
    node asks the full node if *TxD* is committed or not. Now, the full node returns
    the block number along with a sub-tree, which is *H[ABCD]*, *H[AB]*, *H[CD]*,
    *H[C]*, and *H[D]*. This sub-tree is the Merkle proof. Now, the light client can
    take this Merkle proof and verify it. Verification will include looking at whether
    the Merkle proof is constructed correctly and whether the Merkle root of the Merkle
    proof is the same as the Merkle root present in the block header of the block
    that the full node claimed the transaction was in. You must be wondering, what
    if a full node claims that the transaction is not committed even after it's committed?
    In this case, the only way to tackle this issue is to request multiple full nodes,
    and it's unlikely all of them will lie. This functionality cannot be achieved
    without Merkle trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum blockchain is more complicated. Now, suppose an Ethereum light node
    wants to know the balance of an account, read data from a smart contract, find
    the gas estimation for a transaction, and so on, then with this simple transactions
    binary Merkle will not be able to provide this functionality. So, in Ethereum,
    every block header contains not just one Merkle tree, but three trees for three
    kinds of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction receipts (essentially, pieces of data showing the effect of each
    transaction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we now have three trees, let''s take an advanced query example that a light
    node would make to a full node. The query is *pretend to run this transaction
    on this contract. What would the transaction receipt and new state be**?* This
    is handled by the state tree, but the way that it is computed is more complex.
    Here, we need to construct what can be a **Merkle state** transition proof. Essentially,
    it is a proof that makes the claim: if you run transaction *T* on the state with
    root *S*, the result will be a state with root *S''*, with transaction receipt
    *R*. To compute the state transaction proof, the full node locally creates a fake
    block, sets the state to *S*, and pretends to be a light node while applying the
    transaction. That is, if the process of applying the transaction requires the
    light node to determine the balance of an account, the light node makes a balance
    query. If the light node needs to check a particular item in the storage of a
    particular contract, the light node makes a query for that, and so on. The full
    node *responds* to all of its own queries correctly, but keeps track of all the
    data that it sends back. The full node then sends the light node the combined
    data from all of these requests as a proof. The light client then undertakes the
    exact same procedure, but using the provided proof as its database instead of
    making requests to the full node and if its result is the same as what the full
    node claims, the light client accepts output to be the one full node claims to
    be.'
  prefs: []
  type: TYPE_NORMAL
- en: For state, Ethereum uses the Merkle Patricia tree instead of the binary tree.
    For the state tree, the situation is more complex. The state in Ethereum essentially
    consists of a key-value map, where the keys are addresses and the values are account
    balance, nonce, code, and storage for each account (where the storage is itself
    a tree). To learn how the Merkle Patricia tree works, visit [https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/.](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/)
  prefs: []
  type: TYPE_NORMAL
- en: In enterprise blockchains, there is no use of light clients as the nodes represent
    an enterprise, and enterprises have infrastructure to run full nodes.
  prefs: []
  type: TYPE_NORMAL
- en: What is forking in blockchain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fork is said to have happened when there is a conflict among the nodes regarding
    the validity of the blockchain, that is, more than one blockchain happens to be
    in the network. There are three kinds of fork: regular, soft, and hard.'
  prefs: []
  type: TYPE_NORMAL
- en: A regular fork is said to be happening when there are two or more blocks at
    the same height. It is a temporary conflict and is resolved automatically. This
    is resolved by nodes by selecting the most accurate blockchain. For example, in
    proof-of-work, if two miners mine a block at the same time then it creates a regular
    fork. And, this is resolved by selecting the blockchain with the highest difficulty
    as the most accurate one.
  prefs: []
  type: TYPE_NORMAL
- en: A soft fork, by contrast, is any change to the blockchain protocol that's backward-
    compatible. Say, instead of 2 MB blocks, a new rule might only allow 1 MB blocks. Non-upgraded
    nodes will still see the new transactions as valid (1 MB is less than 2 MB in
    this example). However, if non-upgraded nodes continue to create blocks, the blocks
    they create will be rejected by the upgraded nodes. So, if the minority of a nodes
    in the network are upgraded then the chain they will form will become less accurate
    and overridden by the blockchain created by the non-upgraded nodes. Soft forks
    are resolved when the majority of the nodes in the network upgrade their node
    software.
  prefs: []
  type: TYPE_NORMAL
- en: A hard is a software upgrade that introduces a new rule to the network that
    isn't with the older software. You can think of a hard fork as an expansion of
    the rules. For example, a new rule that allows the block size to be 2 MB instead
    of 1 MB would require a hard fork. Nodes that continue running the old version
    of the software will see new transactions as invalid. So, the fork can only be
    resolved when all the nodes in the network upgrade their node software. Until
    then, there will be two different blockchains in the network.
  prefs: []
  type: TYPE_NORMAL
- en: You must have heard about Bitcoin and Ethereum forks. For example, Bitcoin cash
    and Ethereum classic were formations of hard forks. Many miners and nodes in the
    network didn't agree to the new protocol and chose to run the old software, and
    split out of the network and formed a different network.
  prefs: []
  type: TYPE_NORMAL
- en: Raft consensus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how the Raft consensus protocol works at a level which will make us
    comfortable enough to build DApps. We won't go in depth into Raft as it's not
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Raft is used in a semi-trusted network, and there is a desire for faster blocktimes
    (on the order of milliseconds instead of seconds) and single confirmation (the
    absence of regular forks).
  prefs: []
  type: TYPE_NORMAL
- en: Every node in the network keeps a list of all other nodes in the network regardless
    of whether they are up and running or not. A server in a Raft cluster is either
    a leader or a follower, and can be a candidate in the case of an election, which
    happens when the leader is unavailable. There can be only one leader at a time.
    The leader is responsible for creating and sending blocks to the followers. It
    regularly informs the followers of its existence by sending a heartbeat message.
    Each follower has a timeout (typically between 150 and 300 ms) called the **election
    timeout**, in which it expects the heartbeat from the leader. Every node uses
    a randomized election timeout in the range of 120-300 ms. The election timeout
    is reset on receiving the heartbeat. If no heartbeat is received, the follower
    changes its status to candidate and starts the leader election to elect a new
    leader in the network. When a candidate starts the leader election, it basically
    purposes itself as the new leader and becomes the leader if more than 50% of nodes
    vote for it. If a leader is not elected in a certain timeout, then a new leader
    election process is started. It's not necessary to understand the leader election
    process in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Raft is designed in such a way that a Raft network requires more than 50% of
    the nodes to be available for new transactions to get committed to the blockchain;
    if the cluster has *2 * F + 1* nodes it can tolerate *F* failures and still function
    correctly. If more than *F* nodes fail, then the application will fail and it
    will again resume working properly once the cluster again has more than F nodes
    working properly. Even leader election will fail if more than 50% nodes are not
    available in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Every transaction from every node is sent to every other node in the network. The
    leader is responsible for creating and broadcasting blocks. When a leader creates
    a block, it will first send the block to all the followers, and once more than
    50% of the followers receive the block, the leader will commit the block to its
    blockchain and then send a commit message to the followers so that the followers
    also commit the block to their blockchain. In the case of unavailability of the
    followers, the leader retries the requests indefinitely until the block is eventually
    committed by all of the followers. This process makes sure that once a block is
    committed to blockchain, it can never be reversed. Even the leader election process
    makes sure that whoever is selected as a leader has its blockchain up to date.
  prefs: []
  type: TYPE_NORMAL
- en: In Quorum, the default block time is 50 ms, and you can change that according
    to your needs. So, every 50 ms, a block is created, but remember that if there
    are no transactions then blocks are not created; empty blocks are not created
    in Raft. The leader can create new blocks and send them to followers before the
    previous block is committed, and block creation is asynchronous. But of course,
    they are committed serially. When a node starts up, it retrieves the missed blocks
    from the leader only, not from other nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: For the Raft cluster to function properly, it's very important that the average
    time it takes a server to send a heartbeat request to every server in the cluster
    and receive responses is less than the election timeout. Also, there is no way
    for the leader to delete or modify committed blocks; a leader can only append
    new blocks to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Istanbul Byzantine Fault Tolerence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how the IBFT consensus protocol works at a level that will make us
    comfortable enough to build DApps. We won't go in depth into IBFT as it's not
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'IBFT is a type of proof-of-authority protocol. In IBFT, there are two kinds
    of nodes: validator nodes (referred to as authorities when they are linked to
    physical entities) and regular nodes. Authority nodes are the ones that create
    blocks. IBFT is used in a network where there is a need for BFT, blocktime up
    to a few seconds is good enough, and we need a single confirmation (the absence
    of regular forks).'
  prefs: []
  type: TYPE_NORMAL
- en: The system can tolerate at most *F* Byzantium or crashed nodes in a *N* validator
    nodes network that is, *F = (N-1)/3* . The default block time in IBFT is between one
    to ten seconds and Quorum does allow you to customize this.
  prefs: []
  type: TYPE_NORMAL
- en: In IBFT, a round involves creating and committing a new block to the blockchain.
    A new round is started once a new block is committed in the *(2F + 1)* validators
    blockchain. Before each block creation round, the validators will pick one of
    them as the proposer. The proposer is the validator responsible for creating the
    block. For the block to be committed to the blockchain, it must be signed by at
    least *(2F + 1)* validators. So, there is a process which involves sending and
    receiving various messages between the purposer and other validators at each round
    to agree to the new block.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two algorithms supported by Quorum for selection of the purposer:
    round robin and sticky purposer. Round robin is used by default, and in round
    robin algorithms the purposer is selected in round robin fashion. But, in the
    sticky purposer algorithm, a single validator becomes the purposer for all rounds,
    and if the purposer crashes then the next validator is selected as the new purposer,
    which again remains the sole purposer for all rounds; the purposer remains constant
    until it fails. Regardless of the round robin or sticky purposer algorithm, if
    the purposer fails to commit a block in *1-10* seconds time, then a new round
    is started and the next validator becomes the purposer of the new round.'
  prefs: []
  type: TYPE_NORMAL
- en: If the network manages to have more than *F* faulty nodes, then these faulty
    nodes can prevent creation of new blocks by declining to sign blocks. When a crashed
    node in the network comes up, it can get missed blocks from any node in the network.
    There is no way more than *F* faulty nodes can rewrite blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The list of validators is stored in the header of genesis blocks, and the `extraData`
    field in the header contains the list of validators. For the first round, the
    first validator is selected. The header also contains various other fields and
    details related to IBFT to help the network reach consensus.
  prefs: []
  type: TYPE_NORMAL
- en: A validator can add or remove a validator. Even adding or removing new validators
    to the network requires *2F + 1* validators agreeing to it. This process of validators
    agreeing or disagreeing to adding or removing a validator is done manually. It
    cannot be an automatic process as validators can start adding multiple validating
    nodes of their own and compromise the network. Therefore, a manual process makes
    sure that other validators learn who the new validator is and decide whether to
    allow it or not.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about how IBFT works in depth at [https://github.com/ethereum/EIPs/issues/650.](https://github.com/ethereum/EIPs/issues/650)
  prefs: []
  type: TYPE_NORMAL
- en: Private contracts and constellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private contracts are an out-of-the-box feature provided by Quorum for enabling
    data privacy. Private contracts are used for sharing information privately between
    two or more nodes without other nodes being able to see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what private contracts in Quorum are. Contracts that are deployed
    using private transactions are called **private contracts**. A private transaction
    is basically one whose payload (contract code for contract deployment or function
    arguments for calling functions, the data part of transactions) is shared point
    to point, outside of blockchain between a selected list of peers mentioned at
    the time of sending the transaction, and the hash of the payload is recorded in
    the blockchain by replacing the actual payload with the hash of the payload. Now,
    the nodes in the network check whether they have the content that hashes to the
    hash present in the blockchain as payload, and if yes, then they execute the original
    payload. Quorum forms two different states of the same blockchain: the public
    and private state. Private transactions form the private state, whereas public
    transactions form the public state. These states cannot interact with each other.
    But, private-private contracts can certainly interact with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum uses constellation for sending and receiving actual transaction payloads
    for private transactions. Constellation is a separate software built by J.P. Morgan. Constellation
    forms a network of nodes, each of which advertises a list of public keys that
    they are the recipient for. Each node exposes an API which allows the user to
    send a payload to one or more public keys. That payload will be encrypted for
    the public key before being transferred over to the recipient node. It exposes
    APIs via IPC for applications to connect to their constellation node and send
    or receive data. At a high level, if you are connected to a constellation network,
    then you just have to mention the public key of the recipient and the data is
    encrypted and sent to the IP address mapped to the public key. While sending a
    private transaction, the list of public keys and the transaction is only broadcast
    to the blockchain network once the payload is successfully sent to all the listed
    constellation nodes. If any listed constellation node is down, then the transaction
    fails and is never broadcast to the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, before starting your Quorum node, you need to start your constellation
    node and then provide the IPC path for constellation to the Quorum node before
    starting the Quorum node. Then, your Quorum node uses the constellation for sending
    or receiving private transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Private transactions are not the ultimate solution to achieving privacy in
    Quorum. They have various downsides. Following are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you send a private transaction to a list of nodes, you cannot add new nodes
    to that list. For example, if you deployed a private contract that used for interbank
    transfers. Suppose initially the central bank was not part of the network, and
    later if they decide to join in then they won't be able to monitor the transactions
    because there is no way we can make the private contract visible to them nor the
    previous bank transfers visible to them. Although they can see the new private
    transactions, as they don't have the new private transactions they cannot execute
    the transactions and so will not be able to see the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to check whether private transactions pointing to a private
    contracts have exactly the same list of public keys that were used while deploying
    the private contracts. This can lead to double spend attacks; in other words,
    you will be able to transfer the same assets twice. For example, it at the time
    of deploying contracts you mentioned three nodes *A*, *B*, and *C*. Now, when
    *A* is transferring assets it may exclude *C* from the private transaction and
    then later transfer the same assets to *C* by creating a new private transaction.
    There is no way for *C* to verify that the new owner of the asset is *B*. For
    this reason, private transactions aren't used for transferring digital assets,
    but private transactions can used for all other forms of data representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to build your own backup mechanisms for the constellation nodes.
    So, if your constellation node crashes, then it will not automatically get back
    payloads from the constellation network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Quorum and constellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are quite confident about the Quorum's consensus protocols, Ethereum
    accounts, transactions, and private contracts. It's time to build a Quorum network.
    Before that, we need to learn how to install Quorum and constellation. Remember
    that constellation is optional and should only be integrated in the Quorum network
    if private contracts are required.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to install Quorum and constellation is to build the source code.
    In this book, we will concentrate on steps for Ubuntu and macOS only. You can
    find Quorum's source code at [https://github.com/jpmorganchase/quorum](https://github.com/jpmorganchase/quorum)
    , whereas you can find constellation source code at [https://github.com/jpmorganchase/constellation.](https://github.com/jpmorganchase/constellation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the three basic commands to build Quorum from source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, go into the `build/bin/` directory and you will find the `geth` executable,
    which is the node software for running the Quorum node. Also, you will find another
    executable file named `bootnode`, and we will use this to generate the enode ID
    only. We will see later what an enode ID is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install constellation, you need a few prerequisites. In Ubuntu, run the
    following commands to install the prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in macOS, run the following commands to install the prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to install constellation, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, after you run they preceding commands and they are executed successfully,
    you will get a message stating the path of the `constellation-node` executable.
    Move the executable from that path to a place where you can find it easily.
  prefs: []
  type: TYPE_NORMAL
- en: Build your first Raft network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have installed Quorum and constellation successfully, it's time to set
    up our first Quorum network. Before setting up the network, you need to decide
    whether you want to use Raft or IBFT, and accordingly you need to plan and set
    up. We will learn setting up both kinds of networks. We will also set up a constellation
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's build a Raft network with constellation. We will also see how to
    add and remove new nodes once the network is up and running. We will build a network
    of four nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `raft`. Then, place the `geth` and `constellation-node` binaries
    in it. You can use the `--help` option of `geth` and `constellation-node` to find
    the various sub-commands and options available.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a constellation network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s first create four constellation nodes. For development purposes,
    we will run all four nodes in the same machine. For every constellation node,
    we have to generate a separate asymmetric key pair. Run the following commands
    in the `raft` directory to create the key pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are generating a single public key for each constellation node. But,
    you can have multiple public keys for each constellation node. At the time of
    running the preceding commands, it will ask you to enter a password to encrypt
    the keys, but you can skip that by pressing the *Enter* key. In case you want
    to encrypt at the time of running the constellation node, you have to provide
    the password for decryption. To keep things simple, we will not set a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'While starting a constellation node, you need to pass the various required
    and optional variables, such as the URL to advertize to other nodes (reachable
    by them), the local port to listen on, the directory to store the payload, public
    keys, private keys, TLS settings, and so on. You can pass these variables to the
    constellation node as options to the command, or else in the form of a configuration
    file. Let''s create a configuration file for each constellation node, which will
    provide these settings for the constellation nodes to start. Following are the
    configuration files for the constellation nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `constellation1.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for `constellation2.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for `constellation3.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for `constellation4.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the variable's name reveals what the variable is all about. One important
    thing to notice here is that we are not providing the other three nodes' URLs
    in the last three nodes, because constellation has a built-in auto-discovery protocol
    to find nodes in the network. So, here the first node is pointing to the last
    three, and the last three have a connection to the first, but in the end all will
    be able to find each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following commands in different shell windows to start the constellation
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generating enodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Raft, before setting up the network you have to decide the total number of
    nodes that will be in the network, and then generate and enode ID for each. Then,
    you create a `static-nodes.json` file listing the enode URL of all the nodes,
    and feed this file to every node in the network. Adding nodes to the network once
    the network is set up involves a different process.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, you need to know what an enode in Ethereum is. An enode
    is a way to describe an Ethereum node in the form of a URI. Every node in the
    network has a different enode. The enode conatins a 512-bit public key called
    a **node ID**, which is used to verify communication from a particular node on
    the network. The encode also contains the IP address and port number along with
    the node ID. The private key associated with the node ID is called a **node key**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up a network of three nodes, and then add the fourth node dynamically.
    Use the following three commands to generate the node keys of all four nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create the private keys. Now, to find the node ID,
    you need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will not create any new file; instead they will simply
    print a sample node URL with the actual node ID associated with the corresponding
    private key. For example: `enode://[nodeID]@[IP]:[port]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a `static-nodes.json` file and add the following code. Make sure
    you replace the node IDs with your generated ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `2300x` ports are for Ethereum protocol communication, and `2100x` ports
    are for Raft protocol communication.
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, `static-nodes.json` is used to list enodes of some nodes that you
    always want to connect to. And, using these nodes, your node can discover other
    nodes in the network. But, in the case of Quorum's Raft, this file has to include
    the enode of all the nodes in the network, as in Raft this file is used for achieving
    consensus, unlike in Ethereum, where this file is used for nodes discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to generate an Ethereum account. We are doing this now because
    at the time of creating the genesis block, we have to supply ether to the network.
    So, we will supply ether to this generated account. Here is the command for creating
    an Ethereum account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At the time of running this command, it will ask for a password to encrypt the
    account. You can press the *Enter* key twice and skip. This will make an empty
    string the password to decrypt the account. Here, the `--datadir` option is used
    to mention where to store the key. Basically, in the `accounts/keystore` directory,
    you will find a file with the format `UTC--DATE-TIME--ADDRESS`. Rename this file
    to `key1`. This file stores the private key and address of the account. Open the
    file and copy the address, as you will need it while creating the genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the last step is to create the genesis block. The genesis block is always
    hardcoded in the network. Here is the genesis block content. Create a `genesis.json`
    file and place the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, make sure you replace the account address, `0x65d8c00633404140986e5e23aa9de8ea689c1d05`,
    with your account address. Here, we supplied ether to the `0x65d8c00633404140986e5e23aa9de8ea689c1d05`
    account.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get rid of ether in a Quorum network, you can use the `--gasPrice
    0` option while starting `geth`. Therefore, you will not need to supply ether
    in the genesis block. But, ether gives the advantage of traceability.
  prefs: []
  type: TYPE_NORMAL
- en: Starting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, before we start the nodes, we need to initialize them and create data directories
    for each node; copy the `static-nodes.json` file in each node's data directory,
    copy the account keys to the data directory, and Bootstrap the blockchain with
    the genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum node's data directory structure includes `geth` and `keystore` directories,
    and also, a `static-nodes.json` file. The `keystore` directory contains accounts
    files and the `geth` directory contains all other data related to Ethereum, such
    as blockchain transactions, state, and the enode key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the commands to do all the initialize operations for all the
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands are self-explanatory. Now, run the following commands
    to start the Quorum nodes. Run each command in a new shell window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the meaning of the different options we provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIVATE_CONFIG`: This variable is used to make `geth` aware of the constellation
    node which it needs to send the private payload to. It points to the constellation
    node''s configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--datadir`: Data directory to store state, transactions, accounts, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--raft`: This is used to specify that we want to run a Raft consensus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--port`: The port to bind for the Ethereum transport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--raft-port`: The port to bind for the Raft transport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ipcpath`: Filename for the IPC socket and pipe. IPC is enabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geth` provides JSON-RPC APIs for clients to communicate with it. `geth` serves
    JSON-RPC APIs using HTTP, WS, and IPC. The APIs provided by JSON-RPC are divided
    into various categories. `geth` also provides an interactive JavaScript console
    to interact with it programatically using JavaScript APIs. The interactive console
    uses JSON-RPC over IPC to communicate with `geth`. We will learn more about this
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to open the interactive console of `node1`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have completed creating our first Raft network.
  prefs: []
  type: TYPE_NORMAL
- en: Adding or removing nodes dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s add the fourth node dynamically. Any node can add the fourth node
    to the network. Let''s add it from `node1`. The first step is to do the initialize
    operations for `node4`. Run the following commands for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, here, we didn''t copy the `static-nodes.json` file, as we are adding
    it dynamically. Now, from the fourth node''s interactive console, run the following
    line of code to add the fourth peer to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, replace the node ID with your generated one. When you run the following
    command, you will get a number as a return value. This number is important, and
    is called the Raft ID of the node. Raft consensus assigns a unique ID to every
    node. The first node in the `static-nodes.json` file is given Raft if `1`, the
    next one is given Raft ID `2`, and so on. The fourth node will have Raft ID `4`.
    While starting the fourth node you will need this number. Now, start the fourth
    node using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, everything looks similar except a new option, `--raftjoinexisting`.
    While starting nodes that were added dynamically, we need to specify this option
    and assign it to the node's Raft ID. This Raft ID will appear while adding a node
    using `raft.addPeer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s remove a node from the network. Let''s remove the third node from
    the `static-nodes.json` file. This node will have `raft` ID of `3`. In the node
    1''s interactive console, run the following code to remove the third node from
    the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, the third peer will be removed from the network.  You can now use the `admin.peers`
    API to check the list of total nodes connected to this node. It should be two
    nodes in the list, a total of three nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: In case a node is down at the time of adding or removing a new node to the network,
    then the downed node will come to know about the changes to the network once it's
    up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first IBFT network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build a network of six nodes. The first four will be validators and
    the other two will be non-validators. We will not add a constellation in this
    network. If you want to add one, the instructions are the same as previously.
  prefs: []
  type: TYPE_NORMAL
- en: In IBFT, every validator is identified uniquely using an Ethereum account derived
    from its node key. Similar to Raft, in IBFT, before setting up the network you
    have to decide on the total number of validators that will be in the network and
    then generate an enode for each. And then, we create a `static-nodes.json` file
    listing the enodes of all the validating nodes, and feed this file to every validator
    in the network. After that, derive Ethereum addresses from the node IDs. And finally,
    we construct the `extraData` field and create the `genesis` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of IBFT, creating the `static-nodes.json` file is not necessary.
    You can connect nodes using the `admin.addPeer(url)` API too.
  prefs: []
  type: TYPE_NORMAL
- en: Installing IBFT tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IBFT software contains tools for configuring the IBFT network, generating
    enodes, generating addresses derived from the node key, creating genesis blocks,
    and so on. Creating a genesis block for IBFT is not as simple as creating it for
    Raft, as there is a encoded `extraData` field that needs to be included in the
    genesis block listing the list of validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to install IBFT tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `~/go/bin` directory, you will find an executable file named `istanbul`.
    This is the tool to create the genesis block. Create a directory named `ibft`
    and move the executable there.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IBFT tools can automate the creation of a genesis block. At the same time, it
    also generates node keys, addresses derived from node keys, and the `static-nodes.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate all these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, you will get a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will see different addresses, enodes, and so on. Now, create the `static-nodes.json`,
    `genesis.json`, and `enode` key files and place the preceding content in it. Set
    the node key file names as `enode_id_1`, `enode_id_2`, `enode_id_3`, and `enode_id_1`.
    Change the ports in the enode URLs to `23000`, `23001`, `23002`, and `23003`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s generate an Ethereum account, and in the genesis block assign some
    ether to it. Ether is not generated dynamically, therefore we need to pre-supply.
    Use the following command to generate an Ethereum account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the name of the file in `accounts/keystore` to `key1`. And then
    copy the address, put it in the `genesis` file, and assign some balance. For example,
    if my newly generated account''s address is `0x65d8c00633404140986e5e23aa9de8ea689c1d05`,
    then my `genesis` file content will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Starting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we start the nodes, we need to initialize them: create data directories
    for each node, copy the account keys to the data directory, copy the enode keys
    of the validators, and Bootstrap the blockchain with the genesis block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the commands to achieve these for all six nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands are self-explanatory. For the last two nodes, we didn''t
    generate any enode keys because `geth` will automatically generate the if one
    doesn''t exist. Now, run the following commands to start the Quorum nodes. Run
    each command in a new shell window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the meaning of the different options we just passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--mine` is required while running the validators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--istanbul.requesttimeout` is the maximum block time (`default: 10000ms`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--istanbul.blockperiod` is the minimum block time (`default: 1s`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--istanbul.blockpausetime` is the pause time when zero transactions in previous
    block. Values should be larger than `istanbul.blockperiod` (`default: 2s`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a list of all validators in the network. you can use the `istanbul.getValidators()`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding or removing a validator dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first see how to add a new validator dynamically. To add a validator,
    we first need to generate the node key and address of the new validator. Run the
    following command to generate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same command we used earlier. Now, we don''t need the `genesis`
    file or the `static-nodes.json` file. We just need the node key and address. Create
    a file named `node_id_5` and place the node key in it. Run the following commands
    to initialize the new validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after the preceding commands have run successfully, it''s time for (*2F+
    1*) other validators to agree on the insertion of the new validator. For this,
    run the following command in all the other validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the first argument with the new validator''s address you got. Now,
    start the new validator node using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run `istanbul.getValidators()` to check the list of all validators
    in the network. It should be five now. Let''s remove a validator from the network.
    Let''s assume that we want to remove the first validator. Run `eth.coinbase` in
    the console of the first validator to find its unique address. Then, run the following
    command in (*2F + 1*) validators to remove the first validator from the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, replace the first argument with the address of the first validator you
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of removing or adding a validator, if some validating node is down
    then it will automatically come to know about these changes once it's up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the basics of Ethereum blockchain in general,
    and then we jumped into the features and consensus protocols of Quorum. Then,
    we got our first hands-on with Quorum by setting up a constellation, Raft, and
    IBFT network. Now, you should be comfortable with the process of setting up a
    network. The next step is to learn about writing smart contracts, and deploy our
    first smart contracts. We will achieve this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
