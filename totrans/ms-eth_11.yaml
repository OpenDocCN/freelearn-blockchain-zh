- en: Decentralized Exchanges Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decentralized exchanges, also known as **DAXs**, are a hot topic for the simple
    reason that all cryptocurrencies need to be exchanged by others to give them some
    kind of utility. Could you imagine a world where you couldn't trade Bitcoin for
    dollars? Or Ethereum for Bitcoin? It would destroy the real-world utility of most
    cryptocurrencies. That's why we have exchanges, to allow the trading of all kinds
    of currencies in a free market. We'll start by working on an explanation about
    DAXs so that you understand the idea behind them. Then you'll understand how the
    orders are made and how to manage user funds in a secure manner. After that, you'll
    create a real-world DAX with a complex smart contract and a detailed interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introducing decentralized exchanges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the trading and matching engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing cryptocurrency wallets and cold storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Ethereum backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finishing the dApp
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing decentralized exchanges
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are DAXs, really? Well, normal exchanges, such as the stock market, are
    built upon a centralized system where a server processes all orders and displays
    the results to the users. They run very efficient systems that are quite expensive
    to set up, although it's understandable given the utility they provide. DAXs,
    on the other hand, don't rely on a centralized system where all orders have to
    go through a server that makes the necessary computations. Instead, DAXs work
    on top of Ethereum's infrastructure to provide users with a system that can be
    executed by anyone and processed by the gigantic net of computers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The first difference with DAX compared to centralized exchanges is that they
    are limited by the technology behind them. You can't create a DAX that trades
    fiat currencies, such as the American dollar or the European euro, because those
    currencies are based on a different technology; they run on a different market,
    known as FOREX, where banks all over the world trade global currencies. Equally,
    you can't trade ERC20 tokens on the stock market exchange because they run on
    top of Ethereum, and the developers working on those centralized exchanges don't
    have the tools required to create a fluid connection between those systems – the
    main reason being the differences in speed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum naturally makes slower transactions because they have to be confirmed
    by every node of the network. That's why it's expected to have a slow trading
    system in DAXs. However, there are scaling technologies, such as *plasma* and
    *state channels*, that allow you to trade way more efficiently after an initial
    setup. We'll explore how they work and we'll build a DAX so that you understand
    how they work. You could even create your own rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Cons of DAXs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DAXs are generally slower since you can't make instant transactions unless you
    rely on off-chain systems between a pair of currencies, slowing you down when
    you desire to trade between other cryptocurrencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs通常较慢，因为除非你依赖于货币对之间的链下系统，否则无法进行即时交易，在你希望在其他加密货币之间进行交易时将会放慢你的速度。
- en: They are also limited in the sense that you can't trade fiat currencies or cryptocurrencies
    based on different blockchains. For instance, the only way to exchange **Bitcoin**
    (**BTC**) for **Ethereum** (**ETH**) is to have a centralized system that holds
    both of those currencies and provides the user with a fair exchange at any given
    moment. There are a few projects that have integrated both types of currencies,
    but they are still young and need to mature to become popular.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在某种程度上也受限，因为你不能交易不同区块链上基于法定货币或加密货币的货币。例如，交换**比特币**（**BTC**）兑换**以太坊**（**ETH**）的唯一方法是拥有中心化系统，该系统持有这两种货币，并在任何时刻提供用户公平的交换。有一些项目已经整合了这两种类型的货币，但它们仍然年轻，并需要成熟才能变得受欢迎。
- en: DAXs are not yet used by the mainstream public, so they are not as good as they
    could be, since we lack the tools and protocols needed to create the type of exchanges
    that work without issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs目前尚未被主流公众使用，所以它们没有达到它们可能达到的水平，因为我们缺乏创建无故障工作的交易所所需的工具和协议。
- en: Pros of DAXs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DAXs的优势
- en: On the other hand, these types of exchanges have the potential to overcome the
    outdated technology from most markets that rely on centralized transactions. Because
    they are being created from scratch, they can take all that's great from other
    projects and implement them with better features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这些类型的交易所有可能克服多数依赖中心化交易的大多数市场过时技术。因为它们是从零开始创建的，所以它们可以在其他项目中获取所有优点，并将其更好地实施。
- en: DAXs can work with thousands of tokens by default, since most of them implement
    the ERC20 standard, giving them a huge array of possibilities. There are great
    projects that are building protocols, such as the **0xprotocol** where developers
    can implement a set of known functions to their own systems so that they can communicate
    freely as one global system of interconnected DAXs. In fact, the 0xprotocol shares
    the liquidity of tokens among many exchanges, giving them the power to perform
    as a trader without requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DAXs默认可以使用数千种代币，因为它们大多数实施了ERC20标准，为它们提供了巨大的可能性。有许多优秀的项目正在构建协议，比如**0xprotocol**，其中开发人员可以将一组已知功能添加到自己的系统中，以便它们可以自由通信，作为一个全球互连DAXs系统。事实上，0xprotocol分享了代币的流动性，使它们可以在没有任何要求的情况下作为交易者运行。
- en: With the new scaling solutions being developed by the core Ethereum team, DAXs
    are about to vastly improve, with faster transactions that resemble real-work
    centralized markets, making Ethereum a core player in the global economy of virtual
    currency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着以太坊核心团队开发的新的扩容解决方案，DAXs即将大幅改善，交易速度更快，类似于真实的中心化市场，使以太坊成为全球虚拟货币经济中的核心参与者。
- en: Many successful exchanges are improving to expand the paradigm of what's possible
    with decentralized technology, and they are using stablecoins, such as Tether
    and USD Coin, to keep a constant value backed on fiat currencies, thus bridging
    the gap between both worlds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多成功的交易所正不断提高以扩展去中心化技术的可能性范式，并且它们正在使用稳定币，如泰达币和USD Coin，以维持以法定货币支持的不变价值，从而弥合了两个世界之间的鸿沟。
- en: We could talk about DAXs for hours in several different books, but the point
    that I'm trying to bring across is that DAXs have the potential to surpass existing
    technology to become the main place where the global market of centralized and
    decentralized currencies takes place. That's why I want you to understand how
    all of this is possible by building a simple DAX based on solidity smart contracts
    to have the practical experience required to work for the many companies that
    create DAXs, or even start your own since they are one of the core elements of
    decentralized technology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几本不同的书中讨论数小时有关DAXs，但我想要传达的观点是，DAXs有潜力超越现有技术，成为全球中心化和去中心化货币市场的主要场所。这就是为什么我希望你通过构建基于solidity智能合约的简单DAX来明白所有这些是如何可能的，以获取为创建DAXs的许多公司工作所需的实践经验，甚至自己开始DAX，因为它们是去中心化技术的核心要素之一。
- en: Essential trading terms
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本交易术语
- en: The world of exchanges is vast and complicated; that's why the people using
    them created lots of terms to help each other understand what they mean precisely.
    For instance, instead of saying *I want to buy 10 BTC hoping that it goes up in
    the future*, you say *I want to go long on 10 BTC*. They mean the same thing,
    but it's a more precise way of communicating with each other.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through some important terminology to comprehend some aspects of
    exchange markets:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Market order**: An action that consists of selling or buying a currency for
    the lowest or highest price available. You see, in exchanges there are sellers
    and buyers, those that want to get rid of some currency and those that want to
    grab some of it. Each one of them sets a price for what they want to get in return
    and the prices are always in pairs. For instance, *I want to buy 10 BTC at the
    price of 50 ETH*. In this case the pair would be BTC-ETH because you''re stating
    that you want to get ETH in exchange for your Bitcoin; there, you''re being a
    buyer of Bitcoin and a seller of Ether at the same time. People set different
    prices, so when you make a market order you just buy or sell at the largest profit.
    The same thing happens when you buy something online with dollars. If you are
    European, like me, you''d notice that many things online are priced in dollars,
    making it impossible to buy those items as you have euros, and they are not the
    same thing. So what happens when you buy say, a book? In the backend, some program
    is exchanging euros for dollars at the price set by the market and it''s buying
    the book with dollars.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit order**: An action where you sell or buy at a fixed price that you
    set by yourself. These types of orders are used for those that predict price movements
    or are comfortable waiting until their order gets filled over a longer time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broker**: A person that lends you money with interest for your trading activities.
    Brokers usually help you with actions, such as executing your trades, because
    they have more money so they enjoy special privileges in the exchange you''re
    in.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Margin account**: A special type of user account where you can borrow money
    from brokers as you trade.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long buying**: An action where you buy a specific currency because you believe
    it will go up in value to make a profit, or to support the technology behind the
    currency.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Short selling**: An action where you win when the currency that you''re shorting
    goes down in value. For instance, you could say, *I''m going to go short on euros
    because I believe the price will go down in the next five days*. It''s a system
    where you can sell currencies that you don''t own. The reasoning behind consists
    of the following:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you borrow money from another person, called the broker, who gives you
    the desired amount of currencies that you want to short, such as 100 ETH that
    you short.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You automatically sell those 100 ETH at the market price.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At a later date, you buy those 100 ETH. This is called closing your position.
    For instance, after 20 days, you close your short position by buying 100 ETH at
    the market price.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在稍后的日期，你会购买这 100 个 ETH。这被称为平仓。例如，20 天后，你以市价购买 100 个 ETH 来平掉你的空头仓位。
- en: You win or lose money based on the price when selling and buying. If you start
    shorting at a high price and close your position at a low price, you win the difference.
    For instance, if you go 100 ETH short at $20 each and you close your position
    5 days later where ETH is worth $10, you would have won $10 dollars per Ether
    or a total of 100 ETH × $10 = $1,000 dollars.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据买入和卖出时的价格，你会赚取或亏损资金。如果你在高价位做空，然后在低价位平仓，你会赚取价格差。例如，如果你以每个以太币 20 美元的价格做空 100
    个 ETH，5 天后以太币价格为 10 美元时平仓，你将赚取每个以太币 10 美元，总计 100 个 ETH × 10 美元 = 1000 美元。
- en: Usually shorting is only available on margin accounts. Those are accounts where
    you can borrow money from brokers with some restrictions.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常做空只在保证金账户上可用。这些账户是你可以从经纪人借钱的账户，但有一些限制。
- en: There's also the bid and ask, which are equivalent to buy and sell. Now that
    you better understand a few complicated concepts, you can move on to learn more
    about the DAX that we are going to build in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有买价和卖价，分别等同于买入和出售。现在你更好地理解了一些复杂的概念，你可以继续学习我们将在本章构建的 DAX 更多相关内容。
- en: Understanding the trading and matching engine
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解交易和匹配引擎
- en: A trading and matching engine is a set of functions that use different types
    of algorithms to create and close orders. An algorithm could focus on completing
    the orders with the higher price or those that were executed earlier. It depends
    on the preferences of the developers. Because we'll work with smart contracts
    and ERC20 tokens, our engine will focus on completing the orders as quickly as
    they come, since it will be the users that close the orders, given that the frontend
    is where most of the logic will be.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 交易和匹配引擎是一组使用不同类型算法创建和关闭订单的函数。算法可能专注于完成具有更高价格或之前执行的订单。这取决于开发人员的偏好。因为我们将使用智能合约和
    ERC20 代币，我们的引擎将专注于按照订单依次快速完成，因为将会是用户关闭订单，前端将包含大部分逻辑。
- en: We can't process large amounts of information on smart contracts since gas is
    expensive, so we let the React application take control of the trading to save
    people's funds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在智能合约中处理大量信息，因为 gas 费用昂贵，所以我们让 React 应用程序控制交易以保护人们的资金。
- en: 'Let''s start by planning the functions that we''ll need so that we have a solid
    foundation when we create the contracts and the frontend functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计划我们将需要的函数开始，这样当我们创建合约和前端函数时就有了坚实的基础：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That function signature (the function name with parameters but no body) will
    take care of generating limit orders. Let''s see some examples and check whether
    the signature of the function checks out:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数签名（带参数但不含主体的函数名称）将负责生成限价订单。让我们看一些示例，并检查函数签名是否正确：
- en: 'For example, *I want to sell 7 BTC in exchange for 90 ETH*, execute the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*我想用 90 个 ETH 换取 7 个 BTC*，执行以下代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we reversed the order of the symbol to convert that sell order
    into a buy order where the user is willing to buy `ETH` in exchange for `BTC`.
    It has the same effect with just one function, instead of creating an exclusive
    function for selling.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将符号的顺序颠倒，将卖出订单转换为买入订单，用户愿意用 `ETH` 换取 `BTC`。它具有相同的效果，只需一个函数，而不需要为出售创建专门函数。
- en: For example, *I want to buy 10 BTC for 20 ETH*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*我想用 20 个 ETH 买入 10 个 BTC*。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we put the symbols in the same order as expected since we are
    creating a limit order to buy `BTC` while selling `ETH`. Now we can create the
    signature of the market order function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将符号按照期望的顺序放置，因为我们正在创建一个买入 `BTC` 并卖出 `ETH` 的限价订单。现在我们可以创建市价订单函数的签名。
- en: Market orders are interesting, since we want to immediately fill the order at
    the cheapest or highest price possible. What happens under the hood is that we're
    closing a limit order with our market order. Nevertheless, it's often impossible
    to fill the entire order at the latest market price for the simple reason that
    the most profitable limit order is buying or selling minimal quantities of a token.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 市价订单很有趣，因为我们希望以最便宜或最贵的价格立即填充订单。背后发生的是我们用市价订单来关闭限价订单。然而，通常不可能以最新市价填满整个订单，简单的原因是最赚钱的限价订单是购买或出售最少数量的代币。
- en: For instance, we want to sell 10 TokenA at the market price for TokenB. The
    most profitable limit order available says *buy 5 TokenA in exchange for 40 TokenB*.
    In that case, the price of 1 TokenA would be 8 TokenB and vice versa. So we create
    the market order and we immediately sell 5 TokenA to buy 40 TokenB from that limit
    order, but what happens with the remaining 5 TokenA that we want to sell? We go
    to the next most profitable buy order, which says *buy 100 TokenA for 700 TokenB*.
    In that case, the price of 1 TokenA would be 7 TokenB, which is less profitable
    than the last one but still not bad. So we sell 5 TokenA in exchange for 35 TokenB,
    leaving that limit buy order at *buy 95 tokenA for 665 TokenB* until the next
    user fills it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想以市场价格出售10个TokenA换取TokenB。最有利可图的限价订单是*以40个TokenB换取5个TokenA*。在这种情况下，1个TokenA的价格将为8个TokenB，反之亦然。因此，我们创建了市价订单，立即从该限价订单中出售5个TokenA以换取40个TokenB，但是我们想要出售的剩余的5个TokenA怎么办？我们转向下一个最有利可图的买单，即*以700个TokenB换取100个TokenA*。在这种情况下，1个TokenA的价格将为7个TokenB，虽然不如上一个订单的利润高，但仍然不错。因此，我们交换了5个TokenA以换取35个TokenB，将该限价买单保留在*以665个TokenB购买95个TokenA*，直到下一个用户填满为止。
- en: 'At the end, we got 75 TokenB for 10 TokenA using a combination of market prices
    at that specific moment that depended on the most profitable limit orders at that
    time. With that understanding, we can create the signature of our market order
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用那一特定时刻的最有利可图限价订单的组合，以10个TokenA获得了75个TokenB。通过这种理解，我们可以创建我们的市场订单功能的签名：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_maxPrice` parameter is simply a number that states the lowest price that
    you're willing to sell, or the highest price that you're willing to buy. By default,
    it's zero, which is unlimited so you'll get the most profitable price as long
    as there are sellers or buyers available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`_maxPrice`参数只是一个数字，表示您愿意出售的最低价格，或者您愿意购买的最高价格。默认情况下为零，即无限制，因此只要有卖家或买家可用，您就会得到最有利可图的价格。'
- en: Managing cryptocurrency wallets and cold storage
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理加密货币钱包和冷存储
- en: When it comes to storing people's funds, we must pay extra attention to how
    we do it since we could risk losing millions of dollars using our DAX. That's
    why the largest exchanges use cold storage with lots of security systems in place.
    Essentially, they keep funds offline in a remote location stored in secure hardware
    devices that are customized to their needs such as Trezor, Ledger, or their own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管理人们的资金时，我们必须格外注意我们的操作方式，因为使用我们的DAX可能会面临数百万美元的风险。这就是为什么最大的交易所采用冷存储并配备了许多安全系统的原因。基本上，他们会将资金离线存储在远程位置的安全硬件设备中，这些设备根据其需求进行定制，如Trezor、Ledger或他们自己的设备。
- en: In our case, we'll store funds in a series of smart contracts, known as **escrows**,
    whose only goal is to store people's money. There will be an escrow contract associated
    with each user account to independently secure all of their funds. That escrow
    contract will have a function to receive funds, only ERC20 tokens, and a function
    to extract funds executable by the owner of that escrow. Go ahead and create a
    folder named `decentralized-exchange`, then run the `truffle init` and `npm init
    -y` commands, and create a contract inside the `contracts/` folder named `Escrow.sol`.
    The following is how our escrow will look.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将资金存储在一系列智能合约中，称为**托管合约**，其唯一目标是存储人们的资金。每个用户帐户将关联一个托管合约，独立安全地保管所有他们的资金。该托管合约将具有一个函数来接收资金，仅限ERC20代币，并具有一个可以由该托管合约所有者执行的提取资金的函数。现在，请创建一个名为`decentralized-exchange`的文件夹，然后运行`truffle
    init`和`npm init -y`命令，在`contracts/`文件夹中创建一个名为`Escrow.sol`的合约。以下是我们的托管合约的外观。
- en: 'First, it contains the interface for ERC20 tokens since we don''t need the
    entire implementation to be able to trade with tokens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它包含了ERC20代币的接口，因为我们不需要整个实现来进行代币交易：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we add the `Escrow` contract, which will be used to manage the funds of
    each user:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们添加了`Escrow`合约，用于管理每个用户的资金：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Escrow` contract receives token transfers to keep the funds safely inside.
    Each user will have a unique escrow contract to decentralize the location of funds
    so that attackers can't focus on a single place. You can manage the token funds
    inside with the `transferTokens()` function and you can check the balance of tokens
    inside the contract with the `checkTokenBalance()` function, which is a simplified
    `.balanceOf()` ERC20 helper function. Finally, I've added an empty non-payable
    fallback function to avoid receiving Ether since we only want tokens inside.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: We'll use this `Escrow` contract to manage people's funds later on, since we
    want a secure place to keep their precious tokens. Ideally, we would create a
    system that uses cold storage in hardware devices, but such an action would require
    a complex system that takes care of securely managing every step of the way to
    prevent middlemen attacks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface for DAXs is the same as the ones used for traditional exchanges,
    such as the stock exchange, or centralized crypto-exchanges, such as **Binance**.
    The idea is to provide a data-driven design where they can quickly understand
    the situation of the selected token pairs. A central section will be used for
    the data, a sidebar will be used for the actions that users may take, and an additional
    sidebar to the right will be used for secondary data; in our case, it will be
    used for past trades.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: As usual, create a `src` and `dist` folder that will include our project. You
    can just copy the setup from previous projects by taking a look at my own version
    on [github.com/merlox/dapp](http://github.com/merlox/dapp). Our design will be
    based on most exchanges since they have a studied formula that feels great. Create
    the sidebar with a new component inside your `index.js` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `Main` component along with the required imports for a normal
    React application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then add the `Sidebar` component with some basic actions that the user can
    take, such as a money-management section to add or withdraw money, and a section
    to create buy or sell orders:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The classes and elements that you add are completely up to you. Personally,
    I like to show users the currency pair they are trading, their balance for each
    one, and a set of actions such as buy, sell, deposit, and withdraw. Then we can
    add some `css`. In this project, we''ll be using a `css` preprocessor known as
    `stylus` ([stylus-lang.com](http://stylus-lang.com)), which allows you to write
    `css` without brackets and nested classes, among many other nice features. You
    can install it as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add it to your `webpack` configuration file as a new rules block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new `index.styl` file inside your source folder and add your Stylus
    code. If you want to create the same design as me, check the stylus code on the
    official GitHub here: [https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的源文件夹内创建一个新的`index.styl`文件，并添加你的Stylus代码。如果你想创建和我一样的设计，请在官方GitHub上查看stylus代码：[https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl)。
- en: 'This generates a nice-looking sidebar for our DAX. Remember to bundle your
    files with `webpack -w -d`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的DAX生成了一个漂亮的侧边栏。记得用`webpack -w -d`打包你的文件：
- en: '![](img/0c8388d6-1c5b-42cf-94c9-93968fa57683.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8388d6-1c5b-42cf-94c9-93968fa57683.png)'
- en: As you can see, Stylus allows you to write clean, nestable `css` to organize
    big chunks of styling easily so that your projects are easier to maintain. At
    the end, the code gets converted into valid `css` that runs on all browsers since
    Stylus compiles each file properly. Then we can add a trades section where we'll
    show the trades taking place in our exchange for all pairs, so that people understand
    the overall price of their coins.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Stylus允许你编写清晰、可嵌套的`css`，以便轻松组织大块的样式，从而使你的项目更易于维护。最后，该代码会被转换成有效的在所有浏览器上运行的`css`，因为Stylus会正确地编译每个文件。然后我们可以添加一个交易部分，展示在我们的交易所中所有货币对的交易，以便人们了解他们的硬币的总体价格。
- en: 'First, add new state trades to the state object with fake data to the `Main`
    component so that we can see how the dApp will look once completed in its final
    design:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Main`组件的状态对象中添加假数据的新交易以实现最终设计时dApp的展示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, update the `render()` function with the new state objects by passing
    the props to the `Trades` and `History` components:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过将props传递给`Trades`和`History`组件，用新的状态对象更新`render()`函数：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the new `Trades` component so that it displays the trades that we just
    added:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的`Trades`组件，以便显示我们刚刚添加的交易：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we''ve added lots of sample trades and history trades since
    we''ll need them to understand how our exchange looks in a real environment; note
    how we updated the `Main` component to pass the state data to each component.
    Then we can add some Stylus to make it look good. Check the final Stylus code
    on the official GitHub here: [https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl.).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由于我们需要它们来了解我们的交易所在实际环境中的样子，我们增加了许多样例交易和历史交易；请注意我们如何更新了`Main`组件，以将状态数据传递给每个组件。然后我们可以添加一些Stylus让它看起来更好。在官方GitHub上查看最终的Stylus代码：[https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl](https://github.com/merlox/decentralized-exchange/blob/master/src/index.styl)。
- en: 'To get a great-looking design. Notice that I''ve included 15 trade objects
    and 15 history trade objects in the state of the `Main` component so that we can
    see how the dApp looks when fully loaded:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个外观漂亮的设计。请注意，我在`Main`组件的状态对象中包含了15个交易对象和15个历史交易对象，以便我们在完全加载后看到dApp的样子：
- en: '![](img/31ff1751-fdc3-48c3-8fc1-aa1f88b065c1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31ff1751-fdc3-48c3-8fc1-aa1f88b065c1.png)'
- en: 'The trade at the top of each BUY and SELL section is the market price for that
    cryptocurrency pair, since market orders are always the most profitable trade
    at that particular moment. Those trades will update in real-time as people trade
    different currencies over time. It''s a fantastic way to understand price movements.
    Finally, we can add the `History` section, which will show the most recent trades:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个BUY和SELL部分顶部最上面的交易是该加密货币对的市价，因为市价订单在那个特定时刻一直是最有利可图的交易。随着人们随着时间交易不同的货币，这些交易将实时更新。这是了解价格走势的一种奇妙方式。最后，我们可以添加`History`部分，它将显示最近的交易：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remember to add the `render()` function from the `react-dom` package to render
    your components. Then we can add some more `css`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得添加来自`react-dom`包的`render()`函数以渲染你的组件。然后我们可以添加更多`css`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if you run `webpack` and an `http-server`, you''ll see our finished product.
    It''s not responsive for mobile devices since our goal is to create an exchange
    to be used in desktop computers and it''s quite a time-consuming task to verify
    every breakpoint to accommodate it to the different dimensions for phones and
    tablets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`webpack`和`http-server`，你会看到我们的成品。由于我们的目标是创建一个用于桌面电脑的交易所，而要验证每个断点以适应手机和平板电脑的不同尺寸是一项耗时的任务，因此它对移动设备不具有响应性：
- en: '![](img/ba5184f6-415d-49c9-bd5c-4fa2fc4fdf98.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5184f6-415d-49c9-bd5c-4fa2fc4fdf98.png)'
- en: This will be our basic design. You can freely add more currency pairs with ERC20
    tokens, graphs with D3.js, and even state channels! The great thing about the
    project shown in this book is that you can build upon the existing structure to
    create a truly high-quality product that you can use for an ICO or to grow the
    ecosystem of dApps with your own solution. Let's move on to build the smart contracts
    needed to create trades and use the DAX with MetaMask.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Building the Ethereum backend
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backend for our project will take care of generating trades that can be
    filled by anyone as long as they have enough funds to pay the established price.
    When the user gets registered, they'll deploy an Escrow contract which will be
    used by our main DAX contract. So let's start by setting up the requirements and
    the contract structure before starting to fill all the functions to practice the
    system to improve, developer's efficiency that we studied in [Chapter 4](2b43135a-08f4-46d3-8c2a-5dd70bb02843.xhtml),
    *Mastering Smart Contracts*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the functions that we''ll need in a big comment at the beginning
    of the file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set up the Solidity version used, import the `Escrow` contract, and define
    the token interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `DAX` contract by first defining the `Order` struct that we''ll
    use for creating new orders:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then define the many variables needed to manage sell and buy orders, while
    also whitelisting tokens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the mappings required for add and manage the token symbols and to find
    the orders by the given IDs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, add the `onlyOwner` modifier, the fallback function which reverts, and
    the constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the whitelisting token function with the complete NatSpec documentation
    and the function signature. I''ve highlighted the function so that you can clearly
    differentiate the function from the comments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To manage tokens, create the following two functions with the documentation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the market and limit the order functions with the parameters required for
    them to work properly, since these will be the main functions used to create orders
    and to interact with the DAX:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, add the `view` functions that you''ll use as helpers and getters for
    important variables that your interface may need. Try to add them yourself. Then
    check the solution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we set up an `event` to log token transfers so that people can see when
    a token is sold or purchased. We could add more events but I'll leave it up to
    you to discover which events you need. Then we added a ton of necessary variables,
    starting with an `enum` that defines whether an order is open or closed. We added
    a `struct` for each property of each order to clearly define which token is being
    dealt.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Then we added three arrays to store existing orders, while also having a few
    variables to whitelist new tokens so that we can trade with a wider set of cryptocurrencies.
    After that, we added multiple mappings to find each specific order easily while
    optimizing gas costs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We added an `onlyOwner` modifier to restrict access to the whitelisting function
    so that it doesn't get too crazy when it comes to adding cryptocurrencies. We
    added a fallback function that doesn't allow ETH transfers so that people don't
    send funds to this exchange, as well as a constructor that defines DAX's owner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Then we added the `whitelistToken()` function, which takes a token address,
    and an array of symbols to create pairs with that main token; that way, you're
    able to trade with a large quantity of pairs at once. The `depositTokens()` function
    is used by users that want to increase their token balance. They can directly
    transfer the tokens they want to trade to their associated Escrow contract, but
    users first have to create a new Escrow, which can only be done through this function.
    Then the `Escrow` address will be associated with that account in the `escrowByUserAddress`
    mapping. This deposit function also requires that the user previously uses the
    `approve()` function to allow the DAX contract to transfer tokens to the Escrow
    contract; otherwise, it will fail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `extractTokens()` function is used to move tokens from the Escrow
    to the user's address. It's a shortcut to the `transferTokens()` function inside
    the `Escrow` contract to facilitate token management. After that, we have the
    complex market and limit order functions. Both are big functions because they
    have to sort, update, and find orders to match existing ones while working within
    the limitations of the blockchain regarding gas usage. We'll soon see how they
    are implemented in depth. Finally, we have some helper functions to sort orders,
    check whether a given pair of token exists, and to retrieve an array of token
    pairs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement some of those functions. Remember to start with
    the simplest ones, and progress to the more complex ones, so that you have a solid
    structure behind them. Here is how the `whitelisting` function should look:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The whitelisting function makes some require checks, then whitelists each of
    the given token pairs so that you can trade with them independently. For instance,
    if your main token symbol is BAT and your array of `_tokenPairSymbols` contains
    `['TOK', 'TIK']`, you'll be able to trade with BAT - TOK and BAT - TIK. Simple
    stuff. The function should not run out of gas as long as you keep a low number
    of token pairs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the next functions for managing token funds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The deposit function checks whether the user has an `Escrow` contract associated
    with their address. If not, the function creates a new `Escrow`, then transfers
    the deposit of tokens that the user requested as long as they previously approved
    some in the appropriate ERC20 contract.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The extract function is simply running the `transferTokens()` function to the
    owner's address, as long as they have some previous balance inside. Otherwise
    it will revert.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the limit order function. Because this is a larger function,
    we'll break it down into smaller parts so that you understand how each section
    operates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have an updated document based on changes that come across as you
    create the function. It''s never too late to improve the documentation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we run the many `require()` checks to be sure that the user is executing
    the limit order function properly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, execute the `buy` functionality if the user is creating a buy limit
    order:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Otherwise, change the array where the order will get added while also sorting
    the orders once added:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s the entire limit order function broken down into comprehensible pieces
    to explain the logic behind every statement. You saw that we used the `sortIdsByPrices`
    function because we need to sort the orders arrays. The following is how the sort
    function looks once completed. Notice that the function is a `view` type, which
    means that it won''t cost any gas to run all of the calculations, because they
    will be done locally so the sorted array can be limitless:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pay attention to the `sortIdsByPrice()` function. It reads the respective state
    variables that contain the order structs, and then organizes the orders in ascending
    order if those are buy limit orders, or descending, if they are sell limit orders.
    We need it for the limit order function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The `limitOrder()` function starts by checking that the parameters are valid
    and that the tokens can be traded. Depending on the type of order requested, it
    will push a new `Order` struct instance to the `sellOrders()` or `buyOrders()`
    arrays while sorting those arrays to push this new limit order to the right location.
    Remember, the idea is to have a sorted array of orders so that we can find the
    most profitable ones quickly; that's why we have the sort function. Finally, it
    updates the arrays of orders and the mapping of order indexes, so that we can
    later find where each `Order` instance is located in those arrays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can take a look at the massive `marketOrder` function implementation;
    this is my own way of doing it, I recommend you try to recreate a market order
    function from scratch, considering all the gas restrictions and limitations. It''s
    not perfect but it clearly displays how a DAX exchange works. Here''s the function
    breakdown for your understanding. First, update the documentation of the function
    to be sure that it explains what''s executed inside:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then add the `require()` function checks to verify that the given tokens are
    valid and that the quantities are correct:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just like with the limit order function, we execute the buying or selling functionality
    depending on the state of the existing orders:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It never hurts to add some additional comments when developing such complex
    logic. Here, I''ve added some clarifications to remind myself of how this function
    should work on a more technical level:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we''ve generated an array of orders to fill and the quantities required
    per order, we can start filling each of those orders with another loop:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们生成了要填充的订单数组和每个订单所需的数量，我们可以开始使用另一个循环填充每个订单：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have to break it down by type to see whether the order is actually a buy
    or sell order, to guarantee that we are fulfilling the right order with the right
    quantities:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按类型分解，以查看订单实际上是买单还是卖单，以确保我们以正确的数量实现正确的订单：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If it''s a sell order, we change the arrays used, but the logic is the same:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个卖单，我们改变使用的数组，但逻辑是一样的：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At first glance, you can see that we have no less than three `for` loops, which
    is extremely unoptimized since it won't be able to handle more than a few orders
    at a time, but it's one of the few solutions for a DAX that doesn't require a
    centralized server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你会发现我们不止有三个`for`循环，这是非常不经优化的，因为它无法处理超过几个订单，但对于不需要中心服务器的 DAX，这是为数不多的解决方案之一。
- en: First, we do the required checks to verify that the user is creating a valid
    market order with the appropriate `approve()` to what they want to buy or sell
    so that the contract can purchase the tokens freely. Then, we start looping through
    all of our sorted order arrays to fill the most profitable ones first, while keeping
    track of how many tokens will be filled for each order. Once we have a list of
    orders to fill with the quantities, we can move on to filling each one of those.
    How do we do it?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进行所需的检查，以验证用户是否创建了一个具有适当`approve()`的有效市场订单，以便合同可以自由购买代币。然后，我们开始循环遍历我们排好序的所有订单数组，首先填充利润最高的订单，同时跟踪每个订单将填充多少代币。一旦我们有了要填充的订单列表和数量，我们就可以开始填充其中的每一个。我们应该如何做？
- en: We update the state of each order so that we mark the quantities as zero or
    a reduced amount while also using `enum OrderState.CLOSED` for those that are
    filled completely. We then transfer the right quantity of tokens to each user.
    That's where the mapping of `buyOrderIndexById[]` is especially useful since we
    want to update a specific order without altering the order of the entire array,
    thus saving gas and processing costs. Finally, we emit some events to indicate
    that we made some token transfers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新每个订单的状态，以便在数量为零或减少数量的同时，对完全填充的订单使用`enum OrderState.CLOSED`。然后我们将正确数量的代币转移到每个用户。这就是`buyOrderIndexById[]`映射特别有用的地方，因为我们想要更新特定订单而不改变整个数组的顺序，从而节省燃气和处理成本。最后，我们发出一些事件，以指示我们进行了一些代币转移。
- en: That should be it! The following is the entire contract so that you can see
    how it all ties together. It is available on the official GitHub at [https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol](https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容了！以下是完整的合同，以便您了解所有内容是如何联系在一起的。它可以在官方 GitHub 上找到： [https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol](https://github.com/merlox/decentralized-exchange/blob/master/contracts/DAX.sol)。
- en: 'It''s quite a big contract, so I recommend you write some tests for it to verify
    that it''s working. You can check and run the tests I''ve written by cloning my
    GitHub with all the code here: [https://github.com/merlox/decentralized-exchange](https://github.com/merlox/decentralized-exchange).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大的合同，所以我建议您为它编写一些测试，以验证它是否正常运行。您可以通过克隆我的 GitHub 并使用这里的所有代码来检查并运行我编写的测试：[https://github.com/merlox/decentralized-exchange](https://github.com/merlox/decentralized-exchange)。
- en: Finishing the dApp
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 dApp
- en: 'Now that we have a working smart contract with our desired logic, we can implement
    the dApp using Truffle and web3.js in a simple React application. Start by importing
    the required components inside your `index.js` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个具有所需逻辑的工作智能合同，我们可以在简单的 React 应用程序中使用 Truffle 和 web3.js 实现 dApp。首先在您的`index.js`文件中导入所需的组件：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll use only two tokens in this prototype for you to learn how to create the
    application since a fully-featured DAX is outside the scope of this book. The
    goal is to show you the path so you can create a more advanced DAX if you desire.
    We start by importing our required ABIs for creating the token instances and the
    token addresses. Those are the tokens we'll use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型中，我们将只使用两种代币，以便您学习如何创建应用程序，因为一个具有完整功能的 DAX 超出了本书的范围。我们首先导入所需的 ABIs 来创建代币实例和代币地址。这些就是我们将使用的代币。
- en: 'Start by updating the state object in the `Main` component with the new required
    variables that we''ll use to interact with the smart contract. Notice how we removed
    the trades and history arrays because we''ll get that data from the contract instead:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the `bytes32()` helper function, which generates a valid hexadecimal string
    required for web3.js:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then create the `setup()` to initialize the web3.js instance while also getting
    the user''s consent to use their MetaMask account credentials:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because the contract setup in the react application is more complicated, we
    have to create a separate function for maintainability:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After setting up the web3 and contract instances, we can start getting orders
    from the smart contract to populate our user interface with orders. First, we
    get the length of the arrays used to be able to loop through all the orders. That''s
    the only way to securely take into account all the elements contained in the arrays:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we start looping over the buy orders array by calling the smart contract
    with each component independently:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We do the same thing with the sell orders array:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Again, we do the same thing with the closed orders array. We need this one
    to display past historical trades that can help people understand what happened
    before they joined the fun:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, create a function named `setPairs()`, which will be used in the future
    to add new token pairs to the platform. Because we don''t want to overcomplicate
    this initial DAX that we''re creating, we''ll limit ourselves to just one token
    pair composed of two imaginary tokens, named `WAT` and `BAT`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We start by setting up the constructor with the essential variables required
    for the entire application. Then a `setup()` function takes care of getting all
    the initial information. The `bytes32()` function is used to convert normal strings
    to hexadecimal since the new version of web3 forces us to send hexadecimal strings
    instead of plain texts to identify the `bytes32` variables. Personally, I prefer
    to write the `bytes32` variables as strings, but `web3` is their framework so
    we have to follow its programming style. We continue by setting up the contract
    instances with the `setContractInstances()` function that starts our contract
    from the given addresses and ABIs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Then we set up the orders with the `setOrders()` function. This one looks scarier
    since it contains a lot more code, but the idea is to simply get each order from
    the smart contract and store them in organized arrays inside the react state variables.
    Finally, we set up the token pairs with `setPairs()`, which updates the state
    with our tokens.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to implement the remaining functions in the smart contract. Here
    is how the whitelist function looks in the React dApp:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we implement the deposit tokens function which will increase the available
    balance that the user adds to the platform for trading the tokens. I''ve added
    plenty of comments for you to understand what''s going on:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The withdraw tokens function is quite simple and will be used for both tokens:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we have to implement the limit and market orders functions which,
    ironically, are the smallest ones, since we only have to pass the required information
    to the smart contract for it to execute the entire functionality by itself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The whitelist function is pretty straightforward since we only run the whitelisting
    function from the smart contract using the main Ethereum address. Remember that
    this function can only be executed by the owner of the contract.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The deposit tokens function checks whether you have enough tokens in your Ethereum
    address, and then it creates two approvals: the first one is to reduce the approval
    to zero since we can''t increase the approval quantity safely since there are
    some security risks in that function; the second one is to `approve()` the desired
    quantity of tokens to deposit for the selected token. Then we run the `depositTokens()`
    method from our `DAX` contract to move the tokens to the escrow address and create
    one if the user doesn''t have an escrow yet.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The withdraw function simply runs the `extractTokens()` method from our `DAX`
    contract to move the tokens from escrow to the user's address because we don't
    need to check anything there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Then we move to the `createLimitOrder()` function. Remember how complicated
    and large it was in the `DAX` contract? Well, in this case, it's just a matter
    of putting the right parameters in the right places. We'll see later in the `render()`
    function how we get those parameters. The same thing applies with the `createMarketOrder()`
    which runs the `marketOrder` method from our `DAX` contract.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `render()` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The render function generates three components: `Sidebar`, `Orders`, and `History`.
    Those are the three sections that we created earlier. In this case, we''ve added
    lots of props to each component to communicate data easily. You can see that the
    limit order and market order props are simply taking parameters and sending them
    to the functions of the `Main` component.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore my implementation of each of those components; this is my own
    way of doing it so you can see how a DAX should look. I recommend you create your
    own version based on what you''ve learned. The following is the `Sidebar` component;
    we start by creating the updated `constructor()`, `bytes32()`, and `resetInputs()`
    functions that will be used in the render:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `render()` function in this case is a bit too large for you to understand
    it, so we''ll break it down into smaller, digestible pieces. Because we want to
    give the user more options, we''ve added a deposit and withdraw button for each
    token to keep it simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, those buttons ask the user how many tokens to move with the
    `prompt()` global JavaScript function, which provides a clear, albeit basic, dynamic
    input. Then the respective functions get called on the `Main` component by passing
    them via `props`. Then, we can add the `buy` button functionality to format the
    required input for the limit or market orders:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The sell button does the same thing, but with the sell type in the topmost
    functions to tell the smart contract that we want to sell:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we give the user a simple select input to indicate that they want
    to create a limit order or a market order. If they select a limit order, an additional
    input will be displayed to indicate the sell or buy price:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As before, we have a constructor, a `bytes32` function, and a `render()` function.
    The `resetInputs()` function takes care of cleaning the input fields so that you
    reset their values after buying or selling. The most complex part is the render,
    which creates our design. The main logic can be found in the buttons. We have
    four buttons in the money management section to deposit BAT or WAT and withdraw
    BAT or WAT. There is a simple system for managing how many tokens you have in
    your escrow. Then, there are a couple of main buttons to buy or sell. Each of
    those buttons runs the `createLimitOrder` or `createMarketOrder` methods, depending
    on whether you have selected the limit order drop-down or the other. When you
    click the buttons, the component reads the values stored in the input to transmit
    them to the right functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a closer look at the logic behind the buttons to understand how they decide
    which function to call and how they move that information to the `Main` component.
    Let''s move on to the `Orders` component, previously named `Trades`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We only have a render and constructor to generate our desired design from the
    buy or sell orders objects given from the `Main` component. There isn't much to
    say about it, apart from the fact that it creates a clean interface for endless
    orders.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here''s the last `History` component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It's almost identical to the `Orders` component, but with a different styling.
    Remember to run the `ReactDOM.render()` function to display your dApp.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s about it! Now you should have a working DAX that you can use and build
    upon to create a stronger exchange for hundreds or even thousands of tokens, since
    you understand how it works from the inside out. This is probably the most direct
    way to start your own exchange. Here''s how it looks after some trades:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cc7387d-dcc8-41d5-99fe-5f3919182a81.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build a DAX from scratch, going from the
    idea of how exchanges work, to the user interface using react and truffle, to
    creating the required smart contracts so that you saw for yourself how a fully-decentralized
    system works, to finally combining it all together in a beautiful dApp that communicates
    with your deployed contracts and tokens. You learned about the differences between
    traditional, centralized cryptocurrency exchanges and fully-featured DAXs, so
    that you can choose the best type for your requirements.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何从零开始构建一个 DAX，从交易所的工作原理的想法，到使用 react 和 truffle 构建用户界面，再到创建所需的智能合约，以便你亲眼看到一个完全去中心化的系统如何工作，最后将所有这些组合在一起，创建一个与你部署的合约和代币进行通信的漂亮
    dApp。你了解了传统的、中心化的加密货币交易所与功能齐全的 DAX 之间的区别，以便你可以选择最适合你需求的类型。
- en: After that short introduction, you got into the technical aspects of the DAX
    by understanding how we implement the trading and matching engine via a set of
    smart contracts. Finally, you developed a clean interface without graphs to keep
    it simple, and you integrated all the complex smart contract logic via manageable
    components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个简短的介绍之后，你通过理解我们如何通过一系列智能合约实现交易和撮合引擎的技术方面，深入了解了 DAX 的技术方面。最后，你开发了一个简洁的界面，没有图表，以保持简单，并且通过可管理的组件集成了所有复杂的智能合约逻辑。
- en: In the next chapter, we'll explore Machine Learning on the blockchain, a topic
    that you may have heard about, since it combines the two most popular technologies
    regarding the future of money and computing by building a dApp that allows us
    to make predictions with a trained model using Linear Regression algorithms in
    a smart contract.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨区块链上的机器学习，这可能是你听说过的话题，因为它结合了关于货币和计算未来的两种最流行的技术，通过构建一个允许我们使用智能合约中的线性回归算法训练模型来进行预测的
    dApp。
