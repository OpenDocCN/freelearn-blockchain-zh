- en: Ethereum Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is an open source public blockchain and is considered to be an alternative
    coin to Bitcoin. A Canadian cryptocurrency researcher and programmer, Vitalik
    Buterin, proposed the idea in late 2013\. Founded by an online crowdsale that
    took place in the middle of 2014, the platform went live at the end of July 2015\.
    *The DAO* event in 2016 led to a hard fork, resulting in a split into **Ethereum**
    (**ETH**) and **Ethereum Classic** (**ETC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics about Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts such as ether, ERC20 tokens, smart contracts, EVM, gas, accounts, and
    oracles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum performance issue and ongoing efforts to address the issue, such
    as PoS, Casper, Plasma, and Sharding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In late 2013, Vitalik Buterin sent an email to the blockchain community announcing
    a white paper outlining the idea for Ethereum. He described it as a universal
    platform with internal languages, so anyone could write an application. According
    to Vitalik, the original idea for Ethereum was to create a general-purpose blockchain
    for fintech. Ethereum is a variation on Bitcoin. Unlike Bitcoin, which is a blockchain
    focusing on payments, Ethereum is a programmable, general-purpose blockchain.
    The introduction of smart contracts is the key to differentiating Ethereum from
    Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: A well-known analogy to describe Ethereum and smart contracts, which bring together
    untrusting parties trading digital or digitized physical assets, is a vending
    machine, as described at the end of [*Chapter 12*](67341a1f-a57c-4247-8b13-b78ce565d9cf.xhtml),
    *Introduction to Blockchain Technology*.
  prefs: []
  type: TYPE_NORMAL
- en: After a vending machine is made, nobody, including the machine owner, can change
    the rules. A buyer does not need to worry about the owner altering the rules prior
    to or during the transaction. As a result, a buyer can trust the machine to behave
    in the expected way and feels comfortable enough to go ahead with a transaction.
    Of course, the vending machine does not necessarily provide a perfect solution.
    A customer could occasionally face a malfunctioning machine and insert $1, yet
    nothing happens. If the vending machine does not provide a refund solution, such
    as posting a contact phone, the customer would permanently lose the $1\. On the
    other hand, Ethereum's solution is much more robust. The rules in the form of
    smart contracts are distributed to all nodes. The same smart contracts will run
    on thousands of nodes (or even more) worldwide at approximately the same time.
    As long as at least one node runs, the transaction is successfully executed. In
    other words, Ethereum is truly a world computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some blockchain enthusiasts responded to Vitalik''s email and formed a core
    group in advancing and executing the idea. (This groundbreaking paper, titled
    *A Next-Generation Smart Contract and Decentralized Application Platform*, is
    available at [https://github.com/ethereum/wiki%20Wiki/](https://github.com/ethereum/wiki%20Wiki/),
    archived from the original on 28 March 2015 with 169 revisions as of August 22,
    2018.) In January 2014, the Ethereum Foundation was created. Soon (in early 2014),
    a British computer science PhD, Gavin Wood, published a yellow paper titled *Ethereum:
    A Secure Decentralized Generalized Transaction Ledger* ([https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)).
    Gavin''s paper unified multiple initiatives for implementing the Ethereum idea
    and served as a blueprint for future development work.'
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about the Ethereum crowdsale event, we need to first explain
    the concept of **crowdfunding**. Crowdfunding refers to the practice of funding
    a project or an initiative by raising money from a large number of people, commonly
    on the internet. Crowdfunding is an alternative way of financing an initiative.
    In the case of blockchain projects, crowdfunding often takes place in the form
    of a project owner selling a portion of a hardcoded (preminted) total number of
    digital coins in circulation, exchanging them for an amount in a fiat currency
    or another established digital currency such as Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'From July to August 2014, an online crowdfunding sale took place. The event
    led to selling 11.9 million coins of *premined* Ether—Ethereum''s native cryptocurrency.
    This is about 12% of the total Ether coin supply: 102,431,467\. Funded by the
    proceeds from this crowdfunding sale, development started. The core Ethereum team
    consisted of Vitalik Buterin, Mihai Alisie, Anthony Di Iorio, and Charles Hoskinson.
    The real development of the Ethereum project was started by a Swiss company, Ethereum
    Switzerland GmbH (EthSuisse). The platform went live on 30 July 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stephan Tual, an ex-Ethereum CMO, formed a company called the *The DAO* on
    April 30, 2016\. The purpose of this entity was to manage the process of selecting
    which smart contract to deploy. *The* *DAO* came up with the clever idea of selecting
    contracts based on investments. Completed smart contracts were posted on the internet.
    A potential investor would declare an amount to be invested in a smart contract.
    Smart contracts with the top amounts would be chosen for deployment. *The DAO*
    raised a record US $150 million via crowdfunding sales to fund the project. *The
    DAO* was hacked in June and lost US $50 million worth of Ether due to bugs in
    its software. The hacking ignited a heated debate within the Ethereum community
    on how to deal with it. Two contesting opinions emerged:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhance the Ethereum code to make a similar attack in future not feasible and
    deploy the code to all nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make no changes to the core Ethereum code and take the risk of future attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vitalik made a call for a hard fork solution and publicly asked all Ethereum
    nodes to stop trading for the deployment of patch code. Within hours, all of the
    thousands of nodes worldwide were completely shut down. The majority of the nodes
    voted for adopting the hard fork approach and upgraded their core Ethereum code
    with the patch, yet a small portion of nodes chose not to take the patch and still
    run the same code.
  prefs: []
  type: TYPE_NORMAL
- en: This hard fork event split the Ethereum blockchain into two. The nodes running
    the old code maintaining the original blockchain became Ethereum Classic, with
    the coin symbol ETC, and the nodes with the patched code, maintaining a forked
    Ethereum blockchain, became Ethereum, with the coin symbol ETH. The fork occurred
    exactly at block number 1,920,000\. The hard fork created a rivalry between the
    two networks. Now, the ETH price has gone up more than 130 times and ETC is worth
    only one-tenth of ETH's price, due to its unpopularity and the concerns of suffering
    a future *The DAO* type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: After the *The DAO* hard fork, Ethereum forked twice in Q4 of 2016 to deal with
    new attacks. While the hard forks resolved past hackers' attacks, this is obviously
    not a scalable solution as one cannot always rely on creating a hard fork to resolve
    every future hack. Consequently, Ethereum has increased its protection by preventing
    new spam attacks by hackers.
  prefs: []
  type: TYPE_NORMAL
- en: 'While hard forks are used to address hacking, soft forks are used by Ethereum
    for protocol upgrades, which are important changes affecting the underlying functionality
    and/or incentive structures of Ethereum. Some notable soft forks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Homestead** was for improvements to transaction processing, gas pricing,
    and security. The soft fork took place on 31 July 2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metropolis part 1**: **Byzantium** was for changes to reduce the complexity
    of the EVM and add more flexibility for smart contract developers. The soft fork
    took place on 16 October 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two more protocol upgrades are planned in the future: **Metropolis part 2***:
    Constantinople* helps to lay the foundations for the transition to proof-of-stake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In March 2017, blockchain startups, research groups, and major companies created
    the **Enterprise Ethereum Alliance** (**EEA**) consisting of 30 founding members.
    In May, the nonprofit organization expanded to include 16 enterprise members with
    household names such as Cornell University's research group, Samsung SDS, Microsoft,
    Intel, J. P. Morgan, DTCC, Deloitte, Accenture, Banco Santander, BNY Mellon, ING,
    and National Bank of Canada. By July 2017, the list had increased to 159 members.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the many improvements made since its initial launch, Ethereum continues
    to evolve. Ethereum 2.0 sets out to address one of the weakest links, scalability,
    and is expected to launch in 2019, in phases, as per Vitalik's recent comments.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum builds on top of the Bitcoin blockchain, including key features such
    as a distributed ledger containing chained blocks, the proof-of-work algorithm,
    and so on. However, its biggest addition is the introduction of smart contracts,
    which are coded in a Turing-complete scripting language. Because of this new addition,
    unlike Bitcoin or its non-smart contract close relatives, Ethereum allows developers
    to address generic business problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting to the basic concepts, we summarize some useful facts on Ethereum
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum has three main ingredients:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralization**: For guaranteed execution'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hashes**: For safeguarding the world state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signatures**: For authorizing programs and transactions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Ethereum is a blockchain, it uses mathematical algorithms to replace intermediary
    entities and bring untrusting parties together to do businesses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum blockchain brings trust in data due to its ability to verify the validity
    of data on a node via its consensus mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses total validation to replace central control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like a transaction, a digital signature is required for deploying a smart contract.
    A deployed smart contract is permanent and is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is assigned with an address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose a smart contract has a bug and requires a fix. The patched smart contract
    will be deployed with a newly assigned address and therefore is treated as a completely
    new smart contract with no relationship to the old one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In May 2017, Ethereum had 25,000 reachable nodes worldwide, consisting of full
    nodes and light nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full node has the full blockchain downloaded and available. The Ethereum ledger
    can be pruned. Full nodes verify transactions in a block in construction. A miner
    node has to be a full node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A light node does not store the entire blockchain, but it stores the parts it
    cares about from someone it trusts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts of a contract code are executed via the **Ethereum virtual machine**
    (**EVM**) on full nodes. A smart contract's address stores bytecode, called opcode,
    that runs on the EVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a smart contract runs on full nodes on tens of thousands of machines,
    it truly is worldwide. In other words, writing a smart contract to a blockchain
    is global and permanent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since smart contract scripts are stored in a decentralized way, it provides
    an additional layer of security. This is true as all full nodes know that other
    nodes store the same code. It is not feasible for a hacker to push malicious scripts
    to all good nodes worldwide and crash them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is a scripted legal document and is guaranteed for execution.
    Since a smart contract is signed at its deployment and a transaction that invokes
    it is also signed, there should not be a dispute between the two trading parties
    in the transaction. In other words, with a decentralized blockchain such as Ethereum,
    the need for a judge disappears! node and can grow to a full network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the nature of permanence and immutability, data and programs on Ethereum
    blockchain are auditable. This could be of special interest to the government
    for enforcing regulation and compliance requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is open source. Anyone can download the code and create his or her
    own version of an Ethereum network. Of course, the issue is about how to convince
    others of its value so they join the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is decentralized. As a result, there is no master node that controls
    or dictates the whole network. The network operates via consensus, as per its
    protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum provides fault tolerance as well. As long as at least one full node
    survives during a catastrophic attack, the network can be rebuilt from the surviving
    node and grow to a full network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While Ethereum provides extreme robustness, the flip side is the problem of
    how to stop it when it is out of control. Like in the example of the *The DAO* hack,
    the network had to rely on Vitalik and his authority to shut it down completely.
    Compared to today, the network then was many times smaller. As the network continues
    to grow in size, this approach will become harder. In future, the network may
    grow to tens of millions of nodes or more. As long as one node does not respond to
    an authoritative call, the Ethereum network is still alive. In other words, it
    becomes extremely difficult to shut down a network completely. Of course, this
    is what a decentralized blockchain is all about: no centralized authority dictating
    to everyone else!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum allows for recursive calls to other smart contracts. Poorly written
    smart contracts can lead to infinite loops. To address this issue, Ethereum builds
    in a circuit breaker mechanism, Gas, which is explained later in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a big data platform, a task is divided into chunks that are distributed to
    nodes on the network and the work is shared by nodes. However, Ethereum's full
    nodes execute the same pieces of scripts. That means every full node of the Ethereum
    blockchain stores and computes the same data; this is reliable but not scalable.
    The scalability issue is one of the major criticisms of Ethereum. As we will discuss
    later, multiple efforts are underway to address this issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether is the native cryptocurrency of Ethereum. Ethereum allows a user to issue
    their own digital coins called tokens. ERC-20/ERC-721/ERC 1400 are common technical
    standards to be followed for issuing Ethereum tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum can be seen as the third generation of the internet. This could be
    one reason that Ethereum's JS API was called Web3\. There are discussions on rewriting
    the internet with blockchain technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The practice of providing centralized services on top of a decentralized internet
    (such as Google providing a centralized searching functionality on a decentralized
    internet) will apply to blockchain as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Ethereum is built on top of Bitcoin, it is considered to be a Bitcoin
    altcoin. Ether to Ethereum is similar to BTC to Bitcoin. Ethereum is the name
    used when referring to the protocols, the blockchain, the client software, and
    the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum mainnet is the blockchain network that is used by clients for transferring
    a digital asset from a sender to a recipient. In other words, it is the network
    where actual transactions take place on a distributed ledger. Mainnet is equivalent
    to a production environment. The Ethereum testnet is for development. As mentioned
    at [https://www.ethernodes.org/network/2](https://www.ethernodes.org/network/2),
    as of October 8, 2018, the mainnet had 13,662 nodes and the testnet had 29 nodes.
    Since the actual transactions take place on the mainnet, Ether has a real value
    only on the Ethereum mainnet. In other words, on the testnet, it is worth nothing.
    Ether coins (ETH and ETC) are listed and exchanged in tens of thousands of digital
    currency markets. Their prices vary greatly. For example, on October 8, 2018,
    ETH was traded at around $223 and ETC at $11.
  prefs: []
  type: TYPE_NORMAL
- en: Ether can be transferred between addresses (accounts). It is used to pay miners
    for their computational work; they are paid in transaction fees and also for gas
    consumption resulting from executing a transaction. Here, the concept of gas is
    essential for Ethereum and it is discussed later in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ether is the largest denomination. There are other units. The smallest is called
    WEI, named after the digital money pioneer, Wei Dai, who is the inventor of B-money.
    B-money was his proposal for an anonymous, distributed electronic cash system.
    Other units include Gwei, microether, and milliether. They all have a second name.
    For example, milliether is also called finney, named after another digital money
    pioneer, Harold Thomas Finney II, who in 2004 wrote the world''s first implemented
    cryptocurrency, RPOW (reusable proofs of work) before Bitcoin. The following table
    gives the conversion rate between ether and other units:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unit** | **Wei value** | **Wei** |'
  prefs: []
  type: TYPE_TB
- en: '| **Gwei (shannon)** | 10⁹ Wei | 1,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| **microether (szabo)** | 10^(12) Wei | 1,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| **miliether (finney)** | 10^(15) Wei | 1,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| **ether** | 10^(18) Wei | 1,000,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: ERC20 tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is a generic blockchain. It allows developers to build a DApp and trade
    digital assets.  Correspondingly, it allows a developer to define a user-specific
    coin called a token. The majority of these tokens are ERC20 tokens. ERC refers
    to Ethereum Request for Comment, and 20 is the number that was assigned to this
    request. In other words, ERC-20 is a technical standard used for smart contracts
    on the Ethereum blockchain for implementing tokens. According to Etherscan.io,
    as of October 8, 2018, a total of 125,330 ERC-20 compatible tokens were found
    on the Ethereum main network.
  prefs: []
  type: TYPE_NORMAL
- en: ERC-20 defines a list of rules for Ethereum tokens to follow. By doing so, it
    allows for interaction and conversion between Ethereum tokens within the larger
    Ethereum ecosystem. Currently, Ether does not conform to the ERC-20 standard.
    However, since Ether is the native coin of Ethereum, it can be converted into
    other tokens. The ERC-20 specification defines an interface containing methods
    and events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is list of required methods (github.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: It returns the name of the token, for instance, `HelloToken: function
    name() view returns (string name)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`: It returns the symbol of the token, for instance, `HTC: function
    symbol() view returns (string symbol)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimals`: It returns the number of decimals the token uses; for instance,
    8 means to divide the token amount by 100,000,000 to get its user representation:
    `function decimals() view returns (uint8 decimals)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalSupply`: It returns the total token supply: `function totalSupply() view
    returns (uint256 totalSupply)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`balanceOf`: It returns the account balance of another account with `address
    _owner: function balanceOf (address _owner) view returns (uint256 balance)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer`: It transfers a specified number (`_value`) of tokens to the `_to` address,
    and MUST fire the transfer event. The function should throw an error if the `_from`
    account balance does not have enough tokens to spend: `function transfer(address
    _to, uint256 _value) returns (bool success)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transferFrom`: It transfers a specified amount (`_value`) of tokens from the
    `_from` address to the `_to` address, and MUST fire the Transfer event. The function
    should throw an error unless the `_from` account has deliberately authorized the
    sender of the message via some mechanism: `function transferFrom (address _from,
    address _to, uint256 _value) returns (bool success)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`approve`: It allows `_spender` to withdraw from your account multiple times,
    up to  the `_value` amount. If this function is called again, it overwrites the
    current allowance with `_value: function approve (address _spender, uint256 _value)
    returns (bool success)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowance`: It returns the amount that `_spender` is still allowed to withdraw
    from `_owner: function allowance (address _owner, address _spender) view returns
    (uint256 remaining)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of required events is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transfer`: Must trigger when tokens are transferred, including zero value
    transfers. A token contract that creates new tokens SHOULD trigger a `Transfer`
    event with the `_from` address set to 0x0 when tokens are created: `event Transfer
    (address indexed _from, address indexed _to, uint256 _value)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`approval`: Must trigger on any successful call to approve `(address _spender`,
    `uint256 _value):  event Approval (address indexed _owner, address indexed _spender,
    uint256 _value)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Ethereum allows for a person to create his or her own money, Ethereum's
    true value is its guaranteed execution of a smart contract. Ether and ERC20 token
    creation are mainly for initial crowdfunding purposes to support a project and
    are used for payment during the transaction to circumvent a bank. Without a real
    business use case, a token is worth nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *smart contract* was initially coined by Nick Szabo, who is a computer
    scientist, a legal scholar, and the inventor of Bit Gold, in 1994\. He is a living
    legend in the world of cryptocurrency for his research into digital contracts
    and digital currency. He is even considered to be Satoshi Nakomoto by some people,
    although he rejected that claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nick Szabo originally defined smart contracts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A smart contract is a computerized transaction protocol that executes the
    terms of a contract. The general objectives of smart contract design are to satisfy
    common contractual conditions (such as payment terms, liens, confidentiality,
    and even enforcement), minimize exceptions both malicious and accidental, and
    minimize the need for trusted intermediaries. Related economic goals include lowering
    fraud loss, arbitration and enforcement costs, and other transaction costs."'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a vending machine, transaction rules are built into the machine hardware.
    Transaction rules on a digital asset are built into scripts. That is, the smart
    contract consists of code. Here are some useful facts on smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is permanent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is timestamped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is globally available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is a digitized legal document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract is a computer protocol intended to facilitate, verify, or enforce
    an agreed contract between trading parties digitally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts allow for execution of transactions without the third party
    as an intermediary. The transactions are auditable and irreversible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract moves digital coins, executes a conventional payment, or transfers
    a digital asset, or even delivers real-world goods and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a third-party-involved business transaction, for instance, buying/selling
    a house, escrow accounts are often used to temporarily store the trading parties'
    money. With a smart contract, no escrow account is needed. Smart contracts eliminate
    the need for escrow accounts since they are guaranteed to be executed for transferring
    the money and assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts provide more security than traditional contract law and their
    transaction costs are only a fraction of other transaction costs associated with
    contracting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the interpretation used by the Ethereum Foundation, a smart contract does
    not necessarily refer to the classical concept of a contract. It can be any kind
    of computer program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To deploy and run a smart contract, one has to digitally sign the deployment,
    similar to sending other data or transactions on the Ethereum blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts can be public and are open to developers. This leads to a security
    issue. If a smart contract has a bug or security loophole, it is visible to all
    developers. To make the issue worse, such a bug or loophole is not easily fixable,
    due to its immutability. This gives hackers plenty of time to explore weaknesses
    and initiate attacks on the Ethereum blockchain. *The DAO* event was a high-profile
    example of this issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Ethereum smart contract can be developed in one of four languages: solidity
    (inspired by JavaScript), Serpent (inspired by Python, no longer used), LLL (inspired
    by Lisp), and Mutan (inspired by Go, no longer used). Regardless of the language
    used, smart contracts are coded in a high-level programming language which needs
    to be compiled into a low level, machine-runnable language. In the Ethereum smart
    contract implementation, a VM approach similar to the concept of Java VM (JVM)
    is used. The Ethereum VM is called **EVM**. Smart contract scripts are converted
    to EVM-runnable code called **bytecode**. The opcode is then deployed to the Ethereum
    blockchain for execution. Currently, a research-oriented language is under development,
    which is called Vyper and is a strongly typed Python-based language.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum virtual machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sixties, when computers had just been invented, coding was in a lower
    level language, for instance an assembly language (assembler). For example, an
    assembler code line, *ADD R1 R2 R3,* is an instruction to add the contents of
    register 1 and register 2 with the result being placed in the third register,
    R3\. A register is a temporary storage area built into a CPU. With a 32-bit CPU,
    a register is 32 bits long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in an assembly language is then converted to a machine language in
    0 and 1 sequences, which is machine-executable. Coding in a low-level language
    is tedious and time-consuming. When high-level languages such as ALGOL or BASIC
    were invented, coding time was greatly reduced. However, the underlying process
    remained the same: compiling the code into a machine executable language in 0
    and 1 sequences. Java, Python, JavaScript and C++ are currently popular high-level
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the compiling approach works well, it does have one inconvenience: lack
    of portability. A piece of code that is compiled on a computer is machine-dependent.
    In other words, it is not portable. To address this issue, the concept of the
    virtual machine was introduced. A **virtual machine** (**VM**) is an emulation
    of a computer system. There are two types of virtual machine: **system virtual
    machine** (also called full virtualization), which provide a substitute for a
    real machine, and **process virtual machines, **which are for executing computer
    programs in a platform-independent environment. It is the process of VM that we
    refer to in our preceding discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: A program written in a high-level language is compiled into VM-executable code.
    As long as a computer supports such a VM, the compiled code can run on it without
    the need to be recompiled. For example, JVM is a well-known Java VM that enables
    a computer to run Java programs compiled into Java bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Ethereum, smart contracts are written in a high-level language,
    mostly solidity. A smart contract is compiled to opcodes, which are executable
    on a VM built specifically for Ethereum, the **EVM**. The EVM brings portability
    along with robustness, since EVM performs runtime checks to prevent crashes. These
    types of checks do have a performance penalty though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Ethereum contracts can be written in any one of the four languages: solidity,
    serpent, LLL, and Mutan, there are four compilers to convert each of the four
    languages'' coded smart contracts into opcodes for running on the EVM. Another
    relevant concept is the **Ethereum client**, which refers to a collection of software
    being installed on a node for parsing and verifying blockchain transactions, smart
    contracts, and everything related. The Ethereum client is implemented in one of
    eight languages: Python, C++, Go, JavaScript, Java, Haskell, Ruby, and Rust. Implemented
    EVMs are an essential part of the Ethereum client. As a result, opcodes can run
    on any one of the eight client implementations. EVM was originally designed for
    currency transactions and later extended to other digital assets. As a result,
    there are restrictions on supporting certain features. Developers face some severe
    restrictions (for instance, the use of string or local registers).'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum gas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ethereum transaction can call a smart contract, which can in turn call another
    smart contract, and then another, and so on. When smart contracts are buggy, it
    can lead to infinite loops. Outside a blockchain, it is easy to resolve an infinite
    loop issue. One can stop the out-of-control program by simply shutting down a
    server, rebooting it, debugging the program, fixing the faulty logic in the code,
    recompiling it, and redeploying.
  prefs: []
  type: TYPE_NORMAL
- en: With the Ethereum blockchain, this approach simply does not work! Imagine if
    tens of thousands of nodes went into infinite loops at approximately the same
    time worldwide. In order to stop infinitely looping smart contracts, all the nodes
    need to be shut down within a short time window. As long as one node fails to
    comply, the infinitely looping smart contract would still be alive and running.
    It is a logistical nightmare to coordinate and shutdown all these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this issue, the concept of **gas** was introduced. A vehicle relies
    on an engine burning gas to move. When an engine runs out of gas, the vehicle
    stops. Ethereum introduced the gas concept to achieve the same effect. When submitting
    a transaction to the Ethereum blockchain, the requester is required to provide
    a max gas amount. For example, in the following example, a transaction request
    is submitted to call a HelloWorld smart contract with the maximum consumption
    not exceeding a specified gas value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ca65450-9dd9-4752-9c74-0ab213ac66fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When this request is validated by mining nodes, the HelloWorld smart contract
    is invoked. Every operation running on the EVM consumes a predefined quantity
    of gas. For example, ADD (sum operation) consumes three gas and MUL (multiplication
    operation) uses five gas. For illustration purposes, suppose a smart contract
    was badly written and contains an infinite loop. Furthermore, we assume each loop
    consists of  an ADD operation and a MUL operation. Therefore, a loop will consumes
    eight gas (three gas for ADD and five gas for MUL). After EVM executes enough
    loops,  the specified maximum gas value will be consumed. Consequently, EVM stops
    executing the contract. Therefore, all nodes would stop running at approximately
    the same time. Another advantage of gas is to make spamming monetarily expensive
    and, therefore, reduce the risk of hacking.
  prefs: []
  type: TYPE_NORMAL
- en: Gas is a metering unit for measuring consumption, just as the kilowatt is the
    unit for measuring electricity usage. Suppose that, in a month, a family uses
    210 KW. Before sending a bill to the family, the utility company first converts
    210 KW into USD, based on a predefined conversion rate. Suppose a unit of KW costs
    $0.2 USD, the total charge for the month is 0.2 * 210 = $42 USD. Similarly, gas
    usage is converted to Ether and charged to a requester. Ethereum allows a requester
    to specify the conversion rate when the transaction is submitted. A miner has
    the right to selectively process transactions by giving higher priority to transactions
    with higher rates. If a requester does not specify a rate, EVM uses a default
    rate, which varies. For example, in 2016 the rate was 1 gas = 0.00001 ETH. In
    2018, one gas = 0.00000002 ETH.
  prefs: []
  type: TYPE_NORMAL
- en: Account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 12*](67341a1f-a57c-4247-8b13-b78ce565d9cf.xhtml), *Introduction
    to Blockchain Technology*, we discussed addresses, an account-like concept, which
    is used to *host* balances of BTC. Bitcoin uses the UTOX model to manage the transfer
    of BTCs between addresses. However, one has to retrieve the entire ledger to find
    the balance of an address, which is very inconvenient. This inconvenience is due
    to the fact that Bitcoin does not support an on-chain Turing-complete programming
    language and it does not have the concept of states. On the other hand, Ethereum
    blockchain supports scripting languages and smart contracts; it can maintain state.
    Ethereum transactions manage state transitions by calling smart contract methods.
    Ethereum no longer needs to rely on UTOX to manage payments. Instead, it operates
    using accounts and balances via state transitions. State denotes the current balance
    of all accounts, along with other data. State is not stored on the blockchain.
    It is saved off-chain in a Merkle Patricia tree. This is because state is mutable
    data, while a block is not mutable. As with Bitcoin, a cryptocurrency wallet can
    be used to manage public and private *keys* or accounts, which are for receiving
    or sending ETH. In other words, Ethereum introduced the concept of **accounts**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum supports two types of account: externally owned accounts (controlled
    by human users via ownership of private keys) and contract accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**An externally controlled account**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has an Ether balance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can initiate transactions for either transferring Ether or triggering smart
    contract code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is controlled by users via private keys
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has no associated smart contract code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A contract account**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has an Ether balance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has associated smart contract code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract code execution is triggered by transactions or calls received
    from other contracts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For both types of account, there are four components**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nonce`: For an externally owned account, it refers to the number of transactions
    sent from the account''s address; for a contract account, nonce is increased every
    time this contracts calls another contract'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`balance`: It is the number of Wei owned by this address'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`storageRoot`: A 256-bit hash of the storage contents of the account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`codeHash`: The hash of the code of this account is EVM; this is the code that
    gets executed when the address receives a call'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When Ether is transferred from contract accounts to an externally owned account,
    there is a fee, for instance 21,000 gas. When Ether is sent from an externally
    owned account to a contract account, the fee is higher, and depends on the smart
    contract code and data being sent in the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum addresses have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the prefix 0x, a common identifier for hexadecimal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rightmost 20 bytes of the Keccak-256 hash (big-endian) of the ECDSA public key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since, in hexadecimal, two digits are stored in one byte, a 20-byte address
    is represented with 40 hexadecimal digits. A sample address is `0xe99356bde974bbe08721d77712168fa074279267`.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already learned, identical Ethereum smart contracts are executed on nodes
    worldwide. What we have not emphasized yet is that all these nodes take the same
    set of inputs and should yield the same outputs. This is called **determinism**.
    Ethereum relies on this determinism since, in order to verify the validity of
    smart contracts and transactions, mining nodes have to yield the same results
    while running the same code with the same inputs.
  prefs: []
  type: TYPE_NORMAL
- en: This determinism raises a challenge. On one side, Ethereum is a generic platform
    that can be used to transfer any digital or digitized assets. Its smart contracts
    require data or inputs from external sources such as the internet, for example,
    stock prices, macroeconomic or microeconomic indices, and so on. Without access
    to these sources of information, use cases for smart contracts will be restricted
    to only a tiny fraction of their potential. On the other side, even with a tiny
    time difference, nodes may retrieve different information from an external source.
    With different inputs, nodes will end up with different outputs. Consequently,
    the determinism property does not hold. As a result, smart contracts are not permitted
    to call an internet URL or directly pull data from an external source. To address
    the paradox, the concept of the **oracle** is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: According to Merriam-Webster, one of the definitions of oracle is *a shrine
    in which a deity reveals hidden knowledge or the divine purpose through such a
    person*. In the blockchain world, an oracle refers to the third-party or decentralized
    data feed services that provide external data. Oracles provide interfaces from
    the real world to the digital world. Oracle data is not part of the blockchain.
    It is saved off-chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of oracle. Two of them are software oracles and hardware
    oracles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software oracles**: Normally refer to easily accessible online information
    such as stock index close prices, FX rates, economic news or weather forecasts,
    and so on. Software oracles are useful since they provide smart contracts with
    wide varieties and up-to-date information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware oracles**: Normally refers to scanned information such as UPS delivery
    scanning, registered mail scanning, or supplier goods delivery scanning. This
    feed can be useful to activate a smart contract that is triggered upon an event''s
    occurrence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Ethereum is built on top of Bitcoin, many of the basic concepts were already
    discussed in [*Chapter 12*](67341a1f-a57c-4247-8b13-b78ce565d9cf.xhtml), *Introduction
    to Blockchain Technology*. For the rest of this subsection, we briefly cover a
    few of them with a focus on the key differences.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus algorithms**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like Bitcoin, PoW is its consensus algorithm. Unlike Bitcoin, Ethereum is working
    on switching to another consensus algorithm called **Proof-of-Stake** (**P****oS**)
    to significantly improve performance with its next release tag of serenity.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private blockchain**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, both Bitcoin and Ethereum are public blockchains since the network
    is open to anyone and a node can join freely.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum has variants on private chains. With private Ethereum, a node needs
    approval prior to joining a network. These blockchains are called private blockchains.
    Private blockchains are suitable for enterprise applications. Hyperledger and
    JPM Morgan's Quorum are examples of well-known private blockchain variants of
    Ethereum. Another example is Brainbot's hydrachain.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Off-chain data**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the Bitcoin blockchain, we do not talk much about the concept of off-chain
    data. With the Ethereum blockchain, this topic needs to be discussed. There are
    multiple scenarios where data cannot be stored on-chain:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first case is state variables. All data stored in a blockchain is immutable
    since the contents of a block are hashed and blocks are linked via these hashes.
    A tiny change in the contents of a block will lead to the reconstruction of all
    the blocks afterwards, which is obviously not feasible. However, state variables
    are, for instance, used to hold balances. They do change content to reflect the
    balance move. A solution is to save them off-chain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracles are another example, where information pulled from external sources
    is saved off-chain to be fed to smart contracts.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum was invented to allow for trading generic digital or digitized assets.
    Metadata describing the underlying assets is saved off-chain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With Bitcoin, the distributed ledger has to be saved on all nodes in order to
    provide the information required for transaction validation. In the case of Ethereum,
    the balance of a cryptocurrency or digital asset can be directly retrieved from
    state variables. There is no need to browse the ledger to obtain balances in order
    to determine whether a _from address has sufficient funds. As a result, a full
    node can choose to keep only a portion of the ledger, that is, trim a ledger.
    The blocks being trimmed can be saved off-chain at a centralized location for
    future inquiries.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is vital to thoroughly test, double-test, and triple-test a smart contract.
    Safety testing is critical. As explained earlier, in Ethereum's short history,
    there have been several high-profile hacking events, which occurred mainly due
    to buggy smart contract code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is less safe than Bitcoin because of bugs introduced in smart contracts.
    Ethereum smart contracts are saved in chained blocks and are not encrypted. Hackers
    can easily spot and explore the vulnerability of buggy contract code and engage
    in attacks. On the other hand, like Bitcoin, data and transactions on Ethereum
    are relatively secure and not vulnerable to hacking. It is only the contract that
    a hacker can construct malicious transactions to call and abuse.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After a smart contract is deployed, it is permanent and immutable. Deployment
    of revised code will become a new contract with a different address. It has different
    state variables with new balances.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment of a smart contract is not free. It burns gas.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital signature, encryption, and public/private keys**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin is a multi-signature process. In order for a transaction to be executed,
    both sides have to sign it. Ethereum is similar. In addition, deployment of a
    smart contract also requires digital signatures.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like Bitcoin, with an Ethereum blockchain one can take a wallet application
    and generate a pair of public and private keys at the same time. An address is
    derived from a public key; that is, an address is just the hash of a public key.
    A sender uses a private key to sign a transaction and a receiver uses a public
    key to verify the authenticity of a signature. In general, a pair of public and
    private keys can be used to support the following two types of activity:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sending a secret message**: The public key is used to encrypt a message and
    the private key is used to decrypt the message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: A private key is used to encrypt and generate a signature. The
    public key is used to decrypt for signature verification.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Block transaction contents in both Bitcoin and Ethereum are currently not encrypted.
    On the other hand, block contents in Zcash are encrypted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since every Ethereum transaction, including smart contracts, has to be digitally
    signed, a node only needs to accept digitally signed requests, potentially without
    the need to verify the entire transaction history. This approach can help to improve
    performance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DAO**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DAO refers to a decentralized autonomous organization. One should not confuse
    it with the organization called *The DAO*, which is famously linked to a hacking
    event that resulted in the split of **Ethereum** into **Ethereum** (**ETH**) and **Ethereum
    Classic** (**ETC**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DAO can be considered to consist of smart contracts, which is in term-built
    form decentralized codes, that is, a hierarchical structure of decentralized core
    → smart contract → DAO.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized code is saved in multiple nodes. It will definitely run and cannot
    be stopped.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts move money and digital assets.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DAO consists of smart contracts and creates an independent entity or community.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DApp**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DApp is a big topic. We briefly mention it due to restrictions on the size
    of the book:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DApp refers to decentralized application and uses decentralized code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is a general-purpose DApp platform.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethereum DApp, like any other blockchain DApp, has a decentralized backend
    (for instance, smart contracts) and a centralized frontend (a client-side application
    for interacting with the blockchain). This architecture is due to the performance
    and limitations of today's blockchain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As discussed before, a large portion of the backend, the database and business
    logic, is hosted off-ch.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethereum issues**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ethereum suffers from issues inherited from Bitcoin:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can get lost due to forking or splitting. When there are two competing
    chains, the chain that cannot manage to grow fast has to be discarded in order
    to maintain data consistency on all nodes. Transactions on the short chain will
    get lost if they are not included in blocks of the winning chain without even
    being known by their original requesters!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since data on-chain is not encrypted, a blockchain is not anonymous and not
    confidential.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Addresses are not verified. This is bad. When a receiver's address is wrongly
    entered, the coins being transferred to it will be permanent as transactions are
    permanent and coins are locked forever!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The PoW algorithm consumes a huge amount of power. It is reported that some
    large mining operations in China require dedicated power stations to supply electricity.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem inherited from Bitcoin is that Ethereum is slow. It is many
    magnitudes slower than other platforms that host transaction data, for instance
    a traditional database. For example, it takes an average of 10 minutes to build
    a new record for Bitcoin. As a rule of thumb, after waiting for six new blocks
    to be built, a transaction is considered to be finalized (the same as a commitment
    in a database). This means that, on average, a requester will wait for one hour
    to see a request completed. In Ethereum, the average time for miners to build
    a block is 17 seconds and it is recommended you wait for 12 blocks before a transaction
    is confirmed. This is 12 * 17 = 204 seconds, or 3.4 minutes' waiting time for
    a user. Here, waiting for a few subsequent blocks to be built before confirming
    a transaction is useful. At any point, Ethereum can have competing chains. The
    waiting gives Ethereum sufficient time to work out the issue of having competing
    chains and reach a consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughput is a measure of how many units of information a system can process
    in a given time window. To measure performance on a transaction platform, throughput
    is expressed in terms of **TPS**, transactions per second:'
  prefs: []
  type: TYPE_NORMAL
- en: For Bitcoin, TPS can be computed as follows. A Bitcoin block normally contains
    1,500-2,000 transactions. Let's use the high-end number, 2,000\. Since it takes
    60 minutes to confirm these 2000 transactions, its TPS = 2,000 / (60*60) = 0.56;
    that is, only half a transaction per second. A similar calculation for Ethereum
    yields a TPS = 2,000 / 204 = 9.8, almost 10 transactions per second—much better
    than Bitcoin. Led by Vitalik, the Ethereum Foundation is working on the sharding
    approach, targeting at increasing TPS by 80 times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For comparison, VISA has an average TPS  of 2000 with a peak at 40,000\. A high-performance
    database such as VoltDB can handle over a million insertions per second. A stock
    exchange can match thousands of trades per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this comparison is not complete. From a business point of view, a credit
    card or exchange transaction is finalized only when it is cleared and settled.
    For credit cards, a billing cycle is normally 2-3 months. A stock exchange takes
    three days to settle a transaction. In this sense, Ethereum is much faster, since
    on the blockchain transaction and settlement occur simultaneously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When compared with a database, Ethereum is at a disadvantage. A database commitment
    can take place right after the insertion, updating, or deletion of a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the reasons causing Ethereum''s slowness:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every full node must execute the same smart contract code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As the Ethereum network becomes larger, the time for reaching a consensus will
    take longer, as it takes time to transfer data between a growing number of nodes
    to verify transactions, access info, and communicate.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are ways to increase the throughput. The following are a few:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the block size is increased, more transactions can be hosted in a block
    and a higher TPS can be obtained.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple chains in parallel. Enterprise chains such as Hyperledger Fabric
    and R3's Corda use this approach.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State channel design helps to increase throughput. An example of a state channel
    implementation for Ethereum is Raiden. Micro Raiden was launched in November 2017\.
    The idea behind state channels is to use off-chain for a transaction between two
    parties and use on-chain for the settlement of the transaction. Off-chain transactions
    are another topic worth an in-depth discussion, but not in this book.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Proof-of-Stake (PoS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PoS consensus algorithm is based on the principle that when a miner owns
    more coins, the miner has more power to mine or validate transactions, a higher
    chance of building new blocks, and therefore a higher chance of receiving more
    reward coins. PoS is energy-efficient and can reach a consensus much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several randomization methods are available for selecting a miner to build
    the next block, not just based on Ether balances of externally owned accounts,
    in order to avoid a scenario where the richest miner is always selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Randomized block selection***:* Uses a formula to look for the lowest hash
    value in combination with the size of the stake for selecting a miner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coin age-based selection***:* Coins owned for long enough, say 30 days, are
    eligible to compete for the next block. A miner with older and larger sets of
    coins has a better chance of being granted the role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegated Proof-of-Stake***:* This implementation chooses a limited number
    of nodes to propose and validate blocks to the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Randomized Proof-of-Stake***:* Each node is selected randomly, using a verifiable
    random beacon to build the new block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is working on replacing PoW with PoS in a new tagged release.
  prefs: []
  type: TYPE_NORMAL
- en: Casper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PoS is being worked on as a replacement to the computationally inefficient PoW
    algorithm. PoS is not being fully implemented and upgraded on mainnet due to concerns
    about an issue such as emerging of a set of centralized supernodes (which receive
    an outsized role in building the new blocks). Casper is the Ethereum community's
    effort to transition from PoW to PoS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Per Casper protocol, validators (the Ethereum equivalent of miners in
    Bitcoin) set aside a portion of their Ether as a stake. When a validator identifies
    a candidate block to build, Ether is bet on that block by the validator. If the
    block is indeed added to the chain, the validator is rewarded based on the size
    of his or her bet. Validators acting maliciously will be penalized by having their
    stakes removed. Casper has two main projects: Casper FFG and Casper CCB.'
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG (Friendly Finality Gadget; Vitalik's version of Casper) is a hybrid
    algorithm running on PoW but treating every 50^(th) block on the network as a
    PoS checkpoint. Validators vote on the finality of these blocks and write them
    into the blockchain. FFG is meant to be an intermediate step in a transition to
    a complete adoption of PoS. FFG is already running on a test network. It will
    soon be implemented completely on mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: The Casper **CBC** (**Correct by Construction**, Vlad's Casper) is more dramatic.
    CBC focuses on designing protocols where one can extend local views of a node's
    estimate of safety to achieve consensus safety. So far, the approach has been
    merely researched and no release plan is available for making it to Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Plasma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2017, Buterin and Joseph Poon presented their idea, which called for scaling
    up Ethereum's performance, that is, increasing TPS. Like the state channel design,
    plasma is a technique for conducting off-chain transactions while relying on the
    underlying Ethereum blockchain to provide its security. Therefore, plasma belongs
    to the group of *off-chain* technologies. Truebit is another example in this group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plasma works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are created on the main-chain and served to be the roots for
    Plasma child-chains. They define rules for child chains and are called to move
    assets between the main-chain and child-chains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child-chain is created with its own consensus algorithm, for instance, PoS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy smart contracts, which define the actual business rules, to the child-chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital assets being created on the main-chain are transferred onto the child-chain
    by calling the plasma rooting contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The block builders on the child-chain periodically commit a validation to the
    main-chain, proving that the current state of the child-chain is valid, in accordance
    with the consensus rules. A user sends and gets requests executed without ever
    interacting with the main-chain directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plasma has these advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows an Ethereum blockchain to handle larger datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enables more complicated applications to run on the blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases throughput greatly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum community is actively working on the implementation of Ethereum
    plasma. Plasma-MVP (minimum viable product) is being worked on first, to gain
    experience and test its viability. There is the possibility of releasing plasma-mvp
    by the end of 2018\. Plasma's release will follow in one or more quarters.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vitalik initially proposed the sharding idea for scaling Ethereum blockchain.
    His proposal was to chop the blockchain into hundreds or thousands of independent
    pieces: shards. All shards share the same consensus algorithm and security model.
    These shards will not handle different types of task and do not need to be validated
    by all full nodes. Instead, each shard serves a single purpose and therefore is
    very efficient at it. In summary, sharding splits up the state of the network
    into multiple shards, where each shard has its own transaction history and a portion
    of the network''s state. To implement the sharding idea on the blockchain, a Validator
    Management Contract is needed, which is a smart contract. It verifies each shard''s
    block headers, maintains validators'' stakes, and selects validators between shards
    pseudo-randomly. Sharding provides an alternative way to increase Ethereum''s
    performance dramatically and could be implemented as early as 2020.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum was developed on top of Bitcoin by introducing smart contracts along
    with Turing-complete scripting languages such as solidity. Ethereum is a general-purpose
    platform for DApp development. The platform is very popular. However, Ethereum
    is not mature yet. Compared to Bitcoin, it is more vulnerable to hacking, since
    any human errors in writing a smart contract are visible to everybody. It inherited
    the performance issue from Bitcoin. Many initiatives are ongoing to address this
    scalability problem. In the next chapter, we will dive into the details of solidity,
    the most popular language for writing Ethereum smart contracts.
  prefs: []
  type: TYPE_NORMAL
