- en: Creating a Blockchain-Based E-Commerce Marketplace
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于区块链的电子商务市场
- en: A decentralized e-commerce marketplace is one of the best cases of blockchain
    technology for the simple reason that you don't have to pay fees or entrust your
    data into the hands of powerful corporations that will sell it for profit. Ethereum
    is an excellent solution for this, is the new ERC-721 token standard has been
    approved for you to generate digitalized objects on the blockchain. In this chapter,
    you'll learn how to deal with personal user data so that it's protected for each
    individual, given that Ethereum is a public system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术最佳应用案例之一是分散的电子商务市场，原因很简单，你不必支付费用，也不必把数据委托给那些会为了利润出售数据的强大企业。Ethereum为此提供了一个出色的解决方案，新的ERC-721代币标准已经为您在区块链上生成数字化物体。在本章中，你将学习如何处理个人用户数据，以便为每个个体保护数据，鉴于Ethereum是一个公共系统。
- en: In the first section, we'll look at how an e-commerce website should be structured
    so that users can interact with it as if it were a real store. You'll build the
    user interface that will display the unique products identified with the ERC-721
    convention. Then, you'll implement the React router module to organize your different
    views in a user-friendly interface. Finally, you'll create the smart contract
    that implements ERC-721 tokens and creates the functions needed to manage decentralized
    products.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们将研究电子商务网站应该如何构建，使用户可以像在真实商店一样与之互动。你将构建用户界面，用于显示使用ERC-721约定标识的独特产品。然后，你将实现React路由器模块，以在用户友好的界面中组织不同的视图。最后，你将创建实施ERC-721代币并创建管理分散式产品所需功能的智能合约。
- en: 'Also, in this chapter, you''ll learn what it takes to create a fully featured
    e-commerce marketplace for your business on Ethereum by learning about the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，你将学习如何在Ethereum上为您的企业创建一个完整的电子商务市场，学习以下主题：
- en: Creating the user interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Understanding ERC-721 tokens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ERC-721代币
- en: Developing the e-commerce smart contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发电子商务智能合约
- en: Finishing the dApp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成dApp
- en: Creating the user interface
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: The great thing about these types of guides is that you can take what you learn
    about decentralize e-commerce here and expand upon those ideas to create a more
    advanced product that will provide a complex solution in order to raise funds,
    or so that you can simply build a business out of it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这类指南的最大优点是，你可以将在这里学到的关于分散电子商务的知识应用到扩展这些想法上，创造一个更高级的产品，提供一个复杂的解决方案以募集资金，或者简单地以此来建立一个业务。
- en: Planning the marketplace interface
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划市场界面
- en: 'This marketplace has almost unlimited options, given that you won''t have to
    face many blockchain limitations. Each product is an independent instance that
    can be molded as you need, so you''re free to add as many features as you desire,
    such as the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该市场几乎拥有无限的选择，因为你不必面对许多区块链的限制。每个产品都是一个独立的实例，可以根据需要进行修改，因此你可以自由添加尽可能多的功能，比如以下功能：
- en: A carting system to add products to the cart while shopping instead of purchasing
    them directly for larger, combined purchases
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将产品加入购物车的购物系统，从而实现较大的综合采购，而不是直接购买
- en: A dynamic shipping address functionality to add several different addresses
    so that you can send orders quickly to many locations by saving your preferred
    locations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态的发货地址功能，以添加多个不同的地址，以便您可以通过保存您的首选位置快速向多个地点发送订单
- en: A bidding system to create auctions for user products
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于用户产品拍卖的竞标系统
- en: Profile and review functionalities for better user interactions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更好的用户互动而创建的个人资料和评价功能
- en: 'In this project, we won''t implement any of those advanced features because
    they would take way too much time to develop, although you can add them yourself
    once the base product is completed. That''s why we''ll create a simple interface
    with the following features:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不会实现任何那些高级功能，因为它们会花费太多时间来开发，尽管你可以在基本产品完成后自己添加它们。这就是为什么我们将创建一个具有以下功能的简单接口：
- en: A buy system to purchase physical and digital products directly with Ethereum
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Ethereum直接购买实物和数字产品的购买系统
- en: A sell functionality to publish products to the marketplace as an independent
    seller
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为独立卖家，在市场上发布产品的销售功能
- en: An order-display functionality to see pending orders as a buyer and as a seller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为买家和卖家查看待处理订单的订单展示功能
- en: In general, users will be able to interact as a normal online store with direct
    payments, using MetaMask instead of a credit card. The marketplace won't charge
    fees to users, compared to e-commerce stores such as Amazon that charge about
    15% of the total payment in fees, which really adds up. Another important point
    is that there won't be any censoring or rules to follow, meaning users can freely
    publish products without fearing a ban from a centralized entity, a recurring
    problem that has affected sellers, causing them to lose thousands of dollars in
    locked funds and reverted orders.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，用户将能够像使用信用卡一样作为普通在线商店与MetaMask进行直接付款交互。与像亚马逊这样收取约15%总付款费用的电子商务商店相比，该市场不会向用户收取费用，这真的很费钱。另一个重要的点是，不会有任何审查或需要遵循的规则，这意味着用户可以自由发布产品，而不必担心被来自中心化实体的禁令所影响，这是一个经常发生的问题，导致卖家损失了数千美元的锁定资金和撤销的订单。
- en: There won't be several quantities of a single product because we'll use unique,
    **non fungible tokens** (**NFTs**), which means that each product has to be unique.
    Since we will be exchanging tokens from one user to another, we won't be able
    to have multiple copies of the same product. You could, however, implement an
    ERC-20 token or a system to generate multiple copies of the same token ID for
    multiple quantities of the same product.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不会有多个数量的单个产品，因为我们将使用独特的**不可替代令牌**（**NFT**），这意味着每个产品都必须是唯一的。由于我们将从一个用户向另一个用户交换令牌，所以我们将无法拥有同一产品的多个副本。然而，你可以实现一个ERC-20代币或一个系统，用于为同一产品的多个数量生成相同的令牌ID的多个副本。
- en: 'Let''s start by setting up the project by cloning the base repository ([https://github.com/merlox/dapp](https://github.com/merlox/dapp))
    or by configuring `npm` and Truffle yourself. You should have the following folders
    and initial files after setting up Truffle or cloning the repository:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过克隆基础存储库（[https://github.com/merlox/dapp](https://github.com/merlox/dapp)）或自行配置`npm`和Truffle来设置项目。在设置Truffle或克隆存储库后，你应该有以下文件夹和初始文件：
- en: '`contracts/`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contracts/`'
- en: '`dist/`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist/`'
- en: '`migrations/`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrations/`'
- en: '`node_modules/` (remember to use `npm install` after cloning the repository)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules/`（在克隆存储库后记得使用`npm install`）'
- en: '`src/`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/`'
- en: '`index.js`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`'
- en: '`index.html` or `index.ejs` ,based on your preference'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`或`index.ejs`，根据你的喜好'
- en: '`index.css` or `index.styl` ,based on your preference'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.css`或`index.styl`，根据你的喜好'
- en: '`.babelrc`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.babelrc`'
- en: '`.gitignore`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`'
- en: '`LICENSE`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`'
- en: '`package.json`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '`README.md`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`'
- en: '`truffle-config.js`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truffle-config.js`'
- en: '`webpack.config.js` (remember to set up your webpack configuration)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack.config.js`（记得设置好你的webpack配置）'
- en: 'Inside your `src/` folder, create a new folder called `components/` ,which
    will contain a file for every single JavaScript component, since this is a larger
    dApp and we will have lots of different components. Because we''ll have multiple
    pages, we want to use the react router to manage the history location and URLs
    so that the user will be able to navigate between pages. Install the React router
    and `web3` libraries by running the following command on your terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`src/`文件夹内，创建一个名为`components/`的新文件夹，其中将包含每个JavaScript组件的文件，因为这是一个较大的dApp，我们将有许多不同的组件。因为我们将有多个页面，我们希望使用React路由器来管理历史位置和URL，以便用户可以在页面之间进行导航。通过在终端上运行以下命令来安装React路由器和`web3`库：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting up the index page
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置索引页面
- en: 'Open up your `index.js` file, import the required libraries, and set the initial
    state with some placeholder products using fake data just to see how the final
    design will look. we do this by going through the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`index.js`文件，导入所需的库，并使用一些虚拟数据设置初始状态，以查看最终设计的外观。我们通过以下步骤来实现这一点：
- en: 'Import the required libraries. We need several components from the `react-router`
    library, as shown in the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库。我们需要来自`react-router`库的几个组件，如下所示的代码：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the constructor with a few products that have the necessary properties
    to display the greatest amount of information to the user as possible, as shown
    in the following code. Properties such as `title`, `description`, `id`, and `price`
    are a must:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建构造函数，并添加一些具有必要属性的产品，以尽可能多地向用户显示信息，如下所示的代码。标题、描述、ID和价格等属性是必须的：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can add more products by copying the `product` object and changing a few
    parameters to make it look unique. Then add the `bytes32()` function to convert
    strings into valid hexadecimal and the `render()` function, as shown in the following
    code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过复制 `product` 对象并更改一些参数使其看起来独特来添加更多产品。然后添加 `bytes32()` 函数将字符串转换为有效的十六进制以及
    `render()` 函数，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `withRouter()` function provided by the React router to provide our
    `Main` component with the history property, which is necessary to navigate between
    pages in your dApp. This is shown in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 React 路由器提供的 `withRouter()` 函数为我们的 `Main` 组件提供历史属性，这对于在您的 dApp 中在页面之间导航是必要的。如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the `BrowserRouter` component from the react router to initialize the router
    object, as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加来自 React 路由器的 `BrowserRouter` 组件以初始化路由器对象，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `BrowserRouter` component is the main component that is used to initialize
    the router so that they can manage different pages. We're using the `withRouter`
    import to access the navigational history so that we can change pages programmatically.
    Basically, we need it to redirect users to different pages in our dApp at specific
    times whenever we need. Then we set up some basic products with different properties
    in the `this.state` object. Note how the image is a URL instead of a file. Since
    we don't have a server that handles files, we need sellers to host their own pictures
    on some kind of public service, such as Imgur.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserRouter` 组件是用于初始化路由器的主要组件，以便它们可以管理不同的页面。我们使用 `withRouter` 导入来访问导航历史，以便我们可以编程方式更改页面。基本上，我们需要它在我们的
    dApp 中在特定时间重定向用户到不同页面。然后我们在 `this.state` 对象中设置一些基本产品与不同的属性。注意图片是一个 URL 而不是文件。由于我们没有处理文件的服务器，我们需要卖家在某种公共服务上托管自己的图片，比如
    Imgur。'
- en: The React router library will use several `Route` instances to determine which
    page has to be loaded at what time. We also have to add the high-level `BrowserRouter`
    component on top of our `Main` component to activate the router. Note how we're
    rendering a single route with `exact path="/"`, which shows the setup text to
    confirm that the application has loaded successfully after the configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: React 路由库将使用多个 `Route` 实例来确定在什么时间加载哪个页面。我们还必须在我们的 `Main` 组件顶部添加高级 `BrowserRouter`
    组件来激活路由器。注意我们如何使用 `exact path="/"` 渲染单个路由，显示设置文本以确认应用程序配置成功加载后。
- en: Configuring the webpack dev server
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 webpack 开发服务器
- en: 'After creating the `Main` component, you will want to run the application to
    see how it looks, however, in this case, we''ll use the `webpack-dev-server` extension,
    which automatically reloads the website as we develop so that we don''t have to
    constantly reload it manually and compiles the files in the backend. So instead
    of setting up a webpack watcher and a static server, it''s all contained in a
    single command. Install the webpack server locally with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Main` 组件后，您将想要运行应用程序以查看其外观，但在这种情况下，我们将使用 `webpack-dev-server` 扩展，该扩展会在我们开发时自动重新加载网站，以便我们不必不断手动重新加载它并在后端编译文件。因此，而不是设置
    webpack 观察者和静态服务器，它全部包含在一个单独的命令中。使用以下命令在本地安装 webpack 服务器：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then update your `package.json` file with a new script under the `scripts`
    section(as shown in the following code); otherwise, it won''t work, since we need
    to execute this command from inside the project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `package.json` 文件的 `scripts` 部分下更新新的脚本（如下所示）；否则，它将无法工作，因为我们需要从项目内部执行此命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simply runs the `webpack-dev-server` command with the `-d` flag, which
    sets the mode to development, allowing you to see complete error messages from
    uncompressed files. If you wish, you can add the `-o` flag, which opens a browser
    when you run the command. Execute it by running the following command line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用 `-d` 标志运行 `webpack-dev-server` 命令，该标志将模式设置为开发模式，允许您从未压缩的文件中看到完整的错误消息。如果愿意，可以添加
    `-o` 标志，在运行命令时打开浏览器。通过运行以下命令行来执行它：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If everything is correct, you'll be able to go to `localhost:8080` and see your
    page with the router set up.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，您将能够访问 `localhost:8080` 并看到已设置路由器的页面。
- en: Creating the Header component
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建头部组件
- en: 'Our application will have several pages for buyers, sellers, and orders. That''s
    why it''s important to separate each component as much as possible into unique
    blocks that can be imported where required by performing the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有几个页面用于买家、卖家和订单。这就是为什么尽可能将每个组件尽可能地分离成可以在需要时导入的唯一块的重要性，通过执行以下步骤来完成：
- en: 'Create a new component inside the `src/components/` folder to display a header
    for our website, and create a file named `Header.js` inside your `components`
    folder, as shown in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components/` 文件夹内创建一个新的组件，用于显示我们网站的标题，并创建一个名为 `Header.js` 的文件，放在你的 `components`
    文件夹内，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Export it with `export default Header` so that other files can access your
    component. Then import it into your `index.js` page as shown in the following
    code to display it right under your imported libraries to keep them in order:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `export default Header` 导出，以便其他文件可以访问你的组件。然后按照下面的代码将其导入到你的 `index.js` 页面中，以在导入的库下方显示它，以保持它们的顺序：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update your `render()` function with the component instance, as shown in the
    following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用组件实例更新你的 `render()` 函数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You''ll see your header loaded automatically without having to refresh your
    webpack service, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你的标题会自动加载，无需刷新你的 webpack 服务，如下面的截图所示：
- en: '![](img/7397c524-025b-41a4-bbf3-13ef8445f937.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7397c524-025b-41a4-bbf3-13ef8445f937.png)'
- en: 'It doesn''t look good yet, so let''s improve the design with some `stylus`
    CSS. If you haven''t configured it already, install the `stylus` and `stylus-loader`
    libraries with the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前看起来不太好，所以让我们用一些 `stylus` CSS 来改进设计。如果你还没有配置它，请使用以下命令安装 `stylus` 和 `stylus-loader`
    库：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update your `webpack` configuration as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下内容更新你的 `webpack` 配置：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the main things that we changed in the `webpack` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在 `webpack` 文件中进行的主要更改：
- en: We imported webpack so that we could use `webpack.HotModuleReplacementPlugin()`
    to reload the page partially when we make changes. Instead of reloading the entire
    page, only the changed components will be reloaded.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入 webpack，以便我们可以使用 `webpack.HotModuleReplacementPlugin()` 在进行更改时部分重新加载页面。而不是重新加载整个页面，只会重新加载更改的组件。
- en: Then we set up the stylus loader to load `styl` files.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们设置 stylus 加载器来加载 `styl` 文件。
- en: 'Create `index.styl` with the following design, although it''s up to you to
    decide how your e-commerce store will end up looking:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `index.styl`，采用以下设计，尽管最终你的电子商务商店的外观是由你决定的：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note the `productPadding` variable at the top. Stylus allows us to create variables
    so that we can configure multiple instances of the same value across the styling
    file easily; we''ll use that variable later on. Then import the stylus file in
    your `index.js` file like so:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意顶部的 `productPadding` 变量。Stylus 允许我们创建变量，以便我们可以轻松地在样式文件中配置相同值的多个实例；我们稍后会使用该变量。然后像这样在你的
    `index.js` 文件中导入 stylus 文件：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now check how your app looks in your browser; you may have to reload your webpack
    server since you updated the webpack configuration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查你的应用在浏览器中的外观；由于你更新了 webpack 配置，你可能需要重新加载你的 webpack 服务器：
- en: '![](img/7c7d25d2-9c5b-4be6-a18c-b4e1e2f92802.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c7d25d2-9c5b-4be6-a18c-b4e1e2f92802.png)'
- en: Creating the Home component
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主页组件
- en: The `Home` component will contain the logic to display the first page that users
    see when opening the dApp for the first time so that they can begin buying products.
    This component will be the core component to manage the remaining pages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home` 组件将包含显示用户首次打开 dApp 时看到的第一个页面的逻辑，以便他们可以开始购买产品。该组件将是管理剩余页面的核心组件。'
- en: 'Create a `Home` component with the default design for the main page; it will
    contain the latest products in a clean design. Here''s the code for the `Home.js`
    file inside the components folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个默认设计的 `Home` 组件，用于主页；它将包含一个干净设计的最新产品。以下是位于组件文件夹中的 `Home.js` 文件的代码：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can import it into your `index.js` file, which will be the main source
    of data and functions. Also remove the `Header` import in the index because it''s
    already included in the `Home` component. The following steps show the changes
    that you have to make to include the `Home` component in your dApp:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其导入到你的 `index.js` 文件中，这将是主要的数据和功能来源。同时，从索引中删除 `Header` 的导入，因为它已经包含在 `Home`
    组件中了。下面的步骤显示了你需要做的更改，以便将 `Home` 组件包含在你的 dApp 中：
- en: 'Import the component at the beginning of the file while removing the `Header`
    component, because we have included it in the `Home` component:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头导入组件，同时移除`Header`组件，因为我们已经在`Home`组件中包含了它：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make things simple, I''ve created a prototype JavaScript method for the
    `Array` object. This is an advanced implementation of JavaScript methods that
    you can use to change how certain functions work. In particular, I''ve created
    an asynchronous `for` loop, which can be `awaited`, to make sure that it''s completed
    before continuing with the rest of the code, as shown in the following code fragment.
    Essentially, it''s a clean way of running loops:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化事情，我创建了`Array`对象的原型 JavaScript 方法。这是一种可以用来改变某些函数工作方式的 JavaScript 方法的高级实现。特别地，我创建了一个异步的`for`循环，可以被`await`，以确保它在继续执行代码的其余部分之前完成，如下面的代码片段所示。基本上，这是一种干净的运行循环的方法：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside your constructor, include a `setup()` function call, as shown in the
    following code fragment:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的构造函数中，包括一个`setup()`函数调用，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `setup()` function with code to start a web3 instance and to
    display the products, as shown in the following code fragment:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段展示的代码来实现`setup()`函数，并启动web3实例和显示产品：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ve included a call to the `displayProducts()` function, which will be used
    to display products by looping through our array of products inside the `state`
    object, as shown in the following code fragment:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了对`displayProducts()`函数的调用，这将用于通过循环遍历我们`state`对象中的产品数组来显示产品，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Modify the `render()` function and include a function named `redirectTo()`,
    which will allow you to change pages when the user clicks on a button using the
    React router, as shown in the following code fragment:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`render()`函数，并包括一个名为`redirectTo()`的函数，当用户使用React路由器点击按钮时，将允许您更改页面，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We made the following important additions to this index file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对此索引文件进行了以下重要的添加：
- en: First, we set up a custom prototype function for the `Array` object, named `asyncForEach`.
    You may not be familiar with how JavaScript works in depth, but you have to understand
    that all types of variables are objects with a property called `prototype`, which
    contains the methods for that type of variable. The default `forEach` method is
    defined somewhere in JavaScript as `Array.prototype.forEach = function () {...}`;
    the point of this is to create a custom `for` look which we can `await` until
    it is finished to take full advantage of the `async` functions. So instead of
    typing `for(let i = 0; i < array.length; i++) {}`, we can type `await array.asyncForEach()`,
    which is way easier to read and has less confusing code. That's just an implementation
    that I wanted to use for improving code readability while increasing its usability.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为`Array`对象设置了一个自定义的原型函数，名为`asyncForEach`。你可能对 JavaScript 的深层原理不熟悉，但你必须了解所有类型的变量都是带有名为`prototype`的属性的对象，该属性包含该变量类型的方法。默认的`forEach`方法在
    JavaScript 的某个地方被定义为`Array.prototype.forEach = function() {...}`；这样做的目的是创建一个自定义的`for`循环，我们可以在这里使用`await`，以充分利用`async`函数。因此，我们可以用`await
    array.asyncForEach()`来代替`for(let i = 0; i < array.length; i++) {}`，这样更容易阅读，且减少了混乱的代码。这只是我想要用来提高代码可读性和增加可用性的一种实现。
- en: Then we imported the `Home` component instead of the `Header` component and
    replaced that in the `render()` function inside `Route`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们导入了`Home`组件而不是`Header`组件，并在`Route`的`render()`函数内替换了它。
- en: The `redirectTo` function changes the `Route` that we're currently seeing by
    loading a new page using the `withRouter` history object that we saw previously.
    This function will be used when the user clicks on the `View` button inside the
    `displayProducts` function.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectTo`函数通过使用我们之前看到的`withRouter`历史对象加载新页面来更改我们当前所见的`Route`。当用户点击`displayProducts`函数内的`View`按钮时，将使用此函数。'
- en: After this, we added a `setup` function that configures MetaMask while adding
    the owner address to each of those sample products so that you can see who owns
    those objects.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此之后，我们添加了一个`setup`函数，该函数配置MetaMask并将所有这些示例产品的所有者地址添加到其中，这样你就可以看到谁拥有这些物品。
- en: Finally, we created a `displayProducts()` function that generates the HTML for
    each product while pushing it into the array of products and updating the state.
    The `Home` component then receives those products as `prop` and displays each
    product.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个名为`displayProducts()`的函数，用于为每个产品生成HTML，并将其推入产品数组并更新状态。`Home`组件然后将这些产品作为`prop`接收，并显示每个产品。
- en: 'Now we can add some CSS code to improve the appearance of the home page, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一些 CSS 代码来改善主页的外观，如下所示：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the web page looks like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网页的外观如下所示：
- en: '![](img/546b7397-03d0-48e3-8656-5604bc69f860.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/546b7397-03d0-48e3-8656-5604bc69f860.png)'
- en: 'As you can see, we are progressing fast! The initial setup takes a bit of time
    for these kinds of complex applications, but then it''s a wonderful thing to work
    on because you can update each separate section with ease while guaranteeing a
    great maintainability factor for future improvements. The theme for the e-commerce
    shop is similar to many shoe stores: it uses flat designs and black tones while
    also popping an element, such as buttons, to give it that three-dimensional feeling.
    It reminds me of a fashion magazine.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们正在快速进展！对于这些类型的复杂应用程序，初始设置需要一些时间，但之后它是一件很棒的事情，因为您可以轻松更新每个单独的部分，同时为未来的改进保证了良好的可维护性因素。电子商务商店的主题与许多鞋店相似：它使用扁平设计和黑色调，同时也弹出一个元素，如按钮，以赋予它三维感。它让我想起了时尚杂志。
- en: Creating the Product component
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品组件
- en: 'Now that we have a basic design, we can create the product pages when the user
    clicks on the View button so that the user can see in detail more information
    about that particular piece. The user will be able to purchase products inside
    the product page. Let''s go through the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的设计，当用户点击“查看”按钮时，我们可以创建产品页面，以便用户可以详细了解有关特定产品的更多信息。用户将能够在产品页面内购买产品。让我们按照以下步骤进行：
- en: 'Add a new `Product.js` file inside your components with the following code,
    although I always recommend you to try it yourself before seeing the solution:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的组件内添加一个新的 `Product.js` 文件，并使用以下代码，尽管我总是建议您在查看解决方案之前自己尝试：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need a new header because when we change pages, a new component will be
    loaded (in this case, the `Product` component,) so we need to show only the essential
    information to the `Product` component. Then we can import it into a new `Route`
    in the index file, as shown in the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新的页眉，因为当我们更改页面时，将加载一个新的组件（在本例中是 `Product` 组件），所以我们需要仅向 `Product` 组件显示必要的信息。然后，我们可以将其导入到索引文件中的新
    `Route` 中，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should be able to access the custom product page when you click on the
    View button, given that we set up the required history functionality. The `product`
    prop for the `Product` component is set up when the user clicks on the View button
    as well. Add the following CSS code to fix the design of the product page:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您单击“查看”按钮时，应该能够访问自定义产品页面，假设我们已设置所需的历史功能。当用户单击“查看”按钮时，`Product` 组件的 `product`
    属性也会设置。添加以下 CSS 代码以修复产品页面的设计：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can open your dApp, click on the View button of a product, and see the
    detailed product page, which shows larger images and the full description, as
    shown in the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以打开您的 dApp，点击产品的“查看”按钮，查看详细的产品页面，其中显示更大的图片和完整的描述，如下面的截图所示：
- en: '![](img/54664023-2a56-4390-85e7-6404ce0ec02a.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54664023-2a56-4390-85e7-6404ce0ec02a.png)'
- en: 'What''s left is adding the buy, sell, and orders pages. Here''s how we use
    the `Buy` component, which will be displayed when the user clicks on the `Buy`
    button located in the Product page:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的是添加购买、销售和订单页面。以下是我们如何使用 `Buy` 组件的方法，当用户单击位于产品页面中的“购买”按钮时，它将被显示：
- en: 'Import the required libraries using the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库，使用以下代码：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the constructor inside the `Buy` component with empty state variables,
    just so you know which variables will be used across the entire component, you
    can do this by using the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Buy` 组件内定义构造函数，其中状态变量为空，这样您就知道整个组件中将使用哪些变量，您可以使用以下代码完成此操作：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `render` page function will display some basic product information to inform
    the buyer of what they are getting, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render` 页面函数将显示一些基本的产品信息，以通知买家他们将获得什么，如下所示的代码：'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Include a block with the shipping information for the users to include their
    address so that they can receive the product with free shipping, as shown in the
    following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个区块，用于用户输入其地址以便可以免费获得产品的运输信息，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Export the component so that it can be imported into your router manager, as
    shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出组件，以便可以将其导入到您的路由管理器中，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We only need to display a form with the user address parameters, since that''s
    the only information we''ll need. The shipping costs we can assume will all be
    free, included in the price. We''ll update the state of this `Buy` component with
    the details so that we can later submit that data to the smart contract. Then
    import the `Buy` component at the beginning of your index file. I''ve highlighted
    the new import for you to see where the `Buy` component should be located, as
    shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要显示一个带有用户地址参数的表单，因为这是我们唯一需要的信息。我们可以假设运费都是免费的，已包含在价格中。我们将更新此`Buy`组件的状态以包含详细信息，以便稍后将这些数据提交给智能合约。然后在索引文件的开头导入`Buy`组件。我已经为您突出显示了新的导入位置，以便您看到`Buy`组件应该位于何处，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then add the new `Route` and `props` parameters to the `Buy` component that
    you just imported inside your `render` functions. The changes are highlighted
    so that you can find them quicker, as shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您的`render`函数中添加新的`Route`和`props`参数到刚刚导入的`Buy`组件中。更改已突出显示，以便您可以更快地找到它们，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We only need to send `state.product` to this component so that we can see which
    product is being purchased. Add some CSS code to make it look good by performing
    the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将`state.product`发送到此组件，以便我们可以看到正在购买的产品。添加一些 CSS 代码，通过执行以下步骤使其看起来好看：
- en: 'Add the CSS code for the product section of the `Buy` component using the following
    code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为`Buy`组件的产品部分添加 CSS 代码：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the CSS code of the shipping form of the `Buy` component, as shown in the
    following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Buy`组件的运输表单的 CSS 代码，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the Sell component
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`Sell`组件
- en: 'We''re building a decentralized marketplace where users all over the world
    can join with their own products that they will publish for free. No fees will
    be charged and purchases will be completed in cryptocurrency. Therefore, we need
    a dedicated page for those sellers, which we''ll make by creating a `Sell` component
    by going through the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个分散式市场，全世界的用户都可以通过发布自己的产品免费加入。不会收取任何费用，并且购买将以加密货币完成。因此，我们需要一个专门为这些卖家的页面，我们将通过以下步骤创建一个`Sell`组件：
- en: Import the essential libraries to create the React component and include `Header:`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库以创建 React 组件，并包含`Header：`
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the `Sell` class with an empty constructor that contains the `state`
    object with the `title`, `description`, `image`, and `price` of the product that
    the user will sell, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有空构造函数的`Sell`类，其中包含用户将出售的产品的`title`、`description`、`image`和`price`的`state`对象，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the `render()` function with a neat form that will allow users to access
    public products, as shown in the following code. Note how the image is a string,
    since we''ll use external URLs for images instead of hosting the files ourselves:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有整洁形式的`render()`函数，允许用户访问公共产品，如下面的代码所示。请注意，图像是一个字符串，因为我们将使用外部 URL 来提供图像，而不是自己托管文件：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Export this new component using the following code so that other files can
    import it:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导出此新组件，以便其他文件可以导入它：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After saving the `Sell` component, import it into your index JavaScript file.
    We'll have to add a function named `publishProduct` ,which will call the respective
    smart contract function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存`Sell`组件之后，将其导入到您的索引 JavaScript 文件中。我们将添加一个名为`publishProduct`的函数，它将调用相应的智能合约函数。
- en: 'The following steps show the changes that need to be made to the index file
    (highlighted for clarity) that are needed to import this `Sell` component:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的步骤显示了需要对索引文件进行的更改（以提高清晰度），以便导入此`Sell`组件：
- en: 'Import the `Sell` component right under the `Buy` component import, as shown
    in the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Buy`组件导入下面直接导入`Sell`组件，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Include the `Sell` component in the `render()` function with its own `route`
    object while also defining a `publishProduct()` function, as shown in the following
    function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render()`函数中包含`Sell`组件及其自己的`route`对象，同时定义一个`publishProduct()`函数，如下所示的函数：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add some CSS code to improve the design of this page, as shown in the function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些 CSS 代码以改善此页面的设计，如下所示的函数：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see how it looks by clicking on the `Sell` button in the header, which
    redirects to the `/sell` URL, loading the `Sell` component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击页眉中的`Sell`按钮来查看其外观，该按钮将重定向到`/sell`URL，加载`Sell`组件。
- en: Creating the Orders component
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建订单组件
- en: 'Add the final `Orders.js` component by going through the following steps. Try
    to do it yourself before seeing the solution so that you practice your skills
    with some `stylus` CSS to complete the design. You''ll find that it takes more
    time than expected, but it''s well worth the effort:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤添加最终的`Orders.js`组件。在看解决方案之前，试着自己做一下，以便你练习一下使用一些`stylus` CSS 完成设计的技能。你会发现这比预期的时间要长，但是一切都是值得的：
- en: 'Import the required libraries, as shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库，如下代码所示：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the constructor with some invented orders so that you can see how it
    will look, as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义构造函数并添加一些虚构的订单，以便你可以看到它的外观，如下代码所示：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll need a function to get users'' orders by getting the data from the smart
    contract while also marking orders as completed. We won''t implement those functions
    yet because we have to create the smart contract first, as shown in the following
    code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来通过从智能合约获取数据来获取用户的订单，同时标记订单为已完成。我们暂时不会实现这些函数，因为我们首先必须创建智能合约，如下代码所示：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add those empty functions, then create a function named `displayOrders()` ,which
    will take the state data to output the resulting HTML. Define the arrays used
    inside first, as shown in the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这些空函数，然后创建一个名为`displayOrders()`的函数，它将使用状态数据来输出生成的 HTML。首先定义内部使用的数组，如下代码所示：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Read the different order objects to loop through them and generate the resulting
    valid JSX. Classify the products based on the state of the product, as shown in
    the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读不同顺序的对象以循环遍历它们，并生成结果有效的 JSX。根据产品状态分类产品，如下代码所示：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the state of the sell order is completed, push it into the `completedSellOrders`
    array because we want to classify the orders based on their state, as shown in
    the following code. Create a new HTML block because it will be slightly different,
    since we want to use a button to mark products as completed:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果卖单的状态是已完成，将其推入`completedSellOrders`数组中，因为我们想要根据它们的状态分类订单，如下代码所示。创建一个新的 HTML
    块，因为它会略有不同，因为我们想要使用一个按钮来标记产品为已完成：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use the same process for the `buyOrders` array to design the HTML of each product
    while looping through the arrays, as shown in the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的过程来设计`buyOrders`数组的 HTML，以循环遍历数组，如下代码所示：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Update the state of the component with the generated HTML objects, as shown
    in the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的 HTML 对象更新组件的状态，如下代码所示：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create the `render()` function to display those generated orders, as shown
    in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`render()`函数来展示这些生成的订单，如下代码所示：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Export the `Orders` component object, as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出`Orders`组件对象，如下代码所示：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This one is big piece of code because we added some sample order data in the
    state object to display a realistic view of the orders page. You can see that
    we added a `state` property for each product, which shows us whether the order
    is pending or completed. This will be set up in the smart contract. The `displayOrders`
    function generates the HTML objects for each type of order because we want to
    separate the completed and pending and buy and sell orders so that you can see
    all the important information. The orders will come from the `getUserOrders` function
    when the smart contract is implemented. Add some CSS to make it look decent. You
    can check out my design on the official GitHub at [https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp)
    inside the `src/` folder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的代码，因为我们在状态对象中添加了一些样本订单数据，以显示订单页面的真实视图。你可以看到我们为每个产品添加了一个`state`属性，它显示了订单是待定还是已完成。这将在智能合约中设置。`displayOrders`函数生成每种类型订单的
    HTML 对象，因为我们想要分离已完成和待定以及买入和卖出的订单，以便你可以看到所有重要信息。当实现智能合约时，订单将来自`getUserOrders`函数。添加一些
    CSS 使其看起来不错。你可以在官方 GitHub 上检查到我的设计，网址为[https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp)，在`src/`文件夹内。
- en: 'Finally, you will get a cool-looking orders page, as shown in the following
    screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将会得到一个很酷的订单页面，如下截图所示：
- en: '![](img/ba46b011-54e5-4adb-91a0-c54aeaaae447.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba46b011-54e5-4adb-91a0-c54aeaaae447.png)'
- en: 'That''s about it when it comes to the User Interface in React! Just to make
    sure, you should have the following files inside your `src/` folder once all the
    components are created:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 React 中的用户界面就是这样了！只是为了确保，一旦所有组件创建完成，你应该在`src/`文件夹里有以下文件：
- en: '`components/`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components/`'
- en: '`Buy.js`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buy.js`'
- en: '`Header.js`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header.js`'
- en: '`Sell.js`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sell.js`'
- en: '`Product.js`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product.js`'
- en: '`Home.js`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Home.js`'
- en: '`Orders.js`'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Orders.js`'
- en: '`index.ejs`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.ejs`'
- en: '`index.js`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`'
- en: '`index.styl`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.styl`'
- en: Understanding ERC-721 tokens
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ERC-721 代币
- en: This new type of tokens is used to generate unique products in our smart contract.
    The ERC-721 standard has been approved by the official Ethereum team, meaning
    you'll be able to use it as it is for all sorts of applications, knowing that
    it will be compatible with tools and smart contracts that depend on this standard.
    Just as ERC-20 tokens gave birth to decentralized token exchanges, we can expect
    the creation of decentralized ERC-721 exchanges and marketplaces of digital as
    well as physical products.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新类型的代币用于在我们的智能合约中生成独特的产品。ERC-721 标准已被官方以太坊团队批准，这意味着您可以将其用于各种应用程序，而且知道它将与依赖于此标准的工具和智能合约兼容。就像
    ERC-20 代币催生了去中心化代币交易所一样，我们可以预期会创建去中心化 ERC-721 交易所和数字以及实物产品市场。
- en: Explaining the ERC-721 functions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 ERC-721 函数
- en: 'To understand how ERC-721 tokens work, it''s best to look at the functions
    that define an ERC-721 token so that you can understand how they work internally.
    These functions are described in the following list:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 ERC-721 代币的工作原理，最好查看定义 ERC-721 代币的函数，这样你就可以理解它们的内部工作方式。以下是描述这些函数的列表：
- en: '`balanceOf(owner)`: Returns the count of all the tokens a user has in their
    possession for the given address.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`balanceOf(owner)`: 返回给定地址所有代币数量的计数，该地址用户拥有的代币。'
- en: '`ownerOf(tokenId)`: Returns the address that owns a specific token ID.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ownerOf(tokenId)`: 返回拥有特定代币 ID 的地址。'
- en: '`safeTransferFrom(from, to, tokenId, data)`: Sends a token from one address
    to another after giving an allowance, just as this phrase does with ERC-20 tokens.
    It''s called safe because if the receiver is a contract, it checks that the contract
    is capable of receiving ERC-721 tokens, meaning that the receiver contract has
    implemented the `onERC721Received` function so that you don''t lose your tokens
    to a contract that can''t manage these types of tokens. The `data` parameter can
    be omitted, and it simply includes additional byte information that you may want
    to send to the `to` receiver address. The `from` address must be the current owner,
    so you can use this function as a normal `transfer` function or as a `transferFrom`
    function (which you may be familiar with from your use of ERC-20 tokens) with
    for approved sending tokens to another address.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`safeTransferFrom(from, to, tokenId, data)`: 给定授权后，将代币从一个地址发送到另一个地址，就像这个短语对
    ERC-20 代币所做的那样。它被称为安全，因为如果接收方是一个合约，它会检查合约是否能够接收 ERC-721 代币，这意味着接收合约已实现了`onERC721Received`函数，这样你就不会把代币丢失给不能管理这些类型代币的合约。`data`参数可以省略，它只是包含您可能想要发送到`to`接收方地址的额外字节信息。`from`地址必须是当前所有者，所以您可以将此函数用作普通的`transfer`函数或`transferFrom`函数（您可能熟悉使用
    ERC-20 代币）来批准向另一个地址发送代币。'
- en: '`transferFrom(from, to, tokenId)`: This is the same as the previous function,
    but it does not ensure that the receiver address, is capable of managing these
    types of tokens if it turns out to be a smart contract.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transferFrom(from, to, tokenId)`: 这与前一个函数相同，但它不确保接收地址能够管理这些类型的代币，如果它是一个智能合约的话。'
- en: '`approve(to, tokenId)`: This is used to approve a specific token to another
    owner so that they can use it however they want.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`approve(to, tokenId)`: 用于向另一个所有者批准特定代币，以便他们可以随意使用它。'
- en: '`setApprovalForAll(operator, approved)`: This is to create an allowance of
    all your tokens to another address, known as an `operator` address that can manage
    your entire balance. You can revoke access to a specific operator by setting the
    `approved` parameter to `false`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setApprovalForAll(operator, approved)`: 这是为另一个地址，即`operator`地址，创建您所有代币的授权，以便其管理您的整个余额。您可以通过将`approved`参数设置为`false`来撤销对特定操作员的访问权限。'
- en: '`getApproved(tokenId)`: Returns the address that has an allowance for this
    token.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getApproved(tokenId)`: 返回具有此代币授权的地址。'
- en: '`isApprovedForAll(owner, operator)`: Returns `true` if the `operator` has access
    to all the owner''s tokens.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isApprovedForAll(owner, operator)`: 如果`operator`可以访问所有所有者的代币，则返回`true`。'
- en: Note how they removed the `transfer` function that we're familiar with from
    the ERC-20 specification because it simplified the process by allowing the `transferFrom`
    and `safeTransferFrom` functions to be used as a normal transfer or as an approved
    transfer, removing the need for a standard `transfer` function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意他们从 ERC-20 规范中删除了我们熟悉的`transfer`函数，因为它通过允许使用`transferFrom`和`safeTransferFrom`函数作为普通转账或已批准的转账来简化了流程，从而省去了标准`transfer`函数的需要。
- en: The `_mint(owner, tokenId)` and `_burn(tokenId)` internal functions are used
    to generate and delete tokens; however, they are not usable in the standard `ERC721.sol`
    smart contract because they are internal, meaning they require you to create a
    new contract that inherits that ERC-721 contract and implements custom `mint(owner,
    tokenId)` and `burn(tokenId)` functions (without the underscore) with any modifications
    you may need because we want to limit who can create or delete tokens.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`_mint(owner, tokenId)` 和 `_burn(tokenId)` 内部函数用于生成和删除代币；然而，它们在标准的 `ERC721.sol`
    智能合约中不可用，因为它们是内部函数，这意味着你需要创建一个新合约，继承该 ERC-721 合约并实现自定义的 `mint(owner, tokenId)`
    和 `burn(tokenId)` 函数（去掉下划线），根据需要进行任何修改，因为我们希望限制谁能创建或删除代币。'
- en: Can you imagine everybody being able to generate tokens as they please? That
    would defeat the purpose of having valuable tokens, so that's why they force you
    to create your own minting functions with limited access, probably with an `onlyOwner`
    modifier. In our case, we'll allow sellers to mint new types of ERC-721 tokens
    for their products.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象每个人都能随心所欲地生成代币吗？那将违背拥有有价值代币的目的，所以他们强迫你使用有限访问权限创建自己的铸造函数，可能还带有 `onlyOwner`
    修饰符。在我们的案例中，我们将允许卖家为其产品铸造新类型的 ERC-721 代币。
- en: Each product in our decentralized e-commerce store will represent a unique ERC-721;
    that's why we don't want to add multiple quantities per product, because we'd
    have to create several unique instances of ERC-721\. On another note, NFT means
    that each token is unique in its differentiating properties. Compared to ERC-20,
    where each token is the same, the ERC-721 standard is meant to be used for unique
    items, such as household products, handmade products, art, or unique digital assets,
    such as skins for games. What's interesting is that you can combine both standards
    as you see fit to create unique tokens, while also being able to generate multiple
    instances of the same one.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去中心化电子商务商店中的每个产品将代表一个唯一的 ERC-721 代币；这就是为什么我们不想为每个产品添加多个数量，因为我们将不得不创建几个唯一的
    ERC-721 实例。另外，NFT 意味着每个代币在其不同的属性上都是独一无二的。与 ERC-20 相比，其中每个代币都是相同的，ERC-721 标准旨在用于唯一物品，如家庭产品、手工制品、艺术品或独特的数字资产，如游戏中的皮肤。有趣的是，你可以根据需要组合这两种标准以创建独特的代币，同时还能够生成相同的多个实例。
- en: The ERC-721 smart contract
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERC-721 智能合约
- en: 'Now that you understand how these types of NFTs work, let''s take a look at
    the ERC-721 contract interface. The implementation is available on GitHub at [https://github.com/merlox/ecommerce-dapp/blob/master/contracts/ERC721.sol](https://github.com/merlox/ecommerce-dapp/blob/master/contracts/ERC721.sol),
    since the full code is too large to display here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这些类型的 NFT 如何工作，让我们来看一下 ERC-721 合约接口。实现可在 GitHub 上找到 [https://github.com/merlox/ecommerce-dapp/blob/master/contracts/ERC721.sol](https://github.com/merlox/ecommerce-dapp/blob/master/contracts/ERC721.sol)，因为完整的代码太长无法在此显示：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This contract is pretty similar to the ERC-20 contract because the basic idea
    behind them is the same. This contract is used to generate many unique tokens
    with a mining function that has to be implemented separately, since you want to
    control who's able to create tokens and who's able to destroy them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个合约与 ERC-20 合约非常相似，因为它们背后的基本思想是相同的。该合约用于生成许多具有独特的代币，其挖矿功能必须单独实现，因为你想控制谁能够创建代币，谁能够销毁它们。
- en: 'Create a file named `ERC721.sol` inside your `contracts/` folder and add that
    code, as we''ll use it in a moment. We''ll create a contract that inherits the
    ERC-721 smart contract to implement the `mint()` function, since it''s not accessible
    by the default ERC-721 implementation. Create a new file named `Ecommerce.sol`
    and import the `ERC721.sol` contract there, using the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `contracts/` 文件夹中创建名为 `ERC721.sol` 的文件，并添加以下代码，我们马上就会用到它。我们将创建一个合约，该合约继承
    ERC-721 智能合约以实现 `mint()` 函数，因为默认的 ERC-721 实现不可访问。在那里创建一个名为 `Ecommerce.sol` 的新文件，并使用以下代码导入
    `ERC721.sol` 合约：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The Solidity version doesn''t matter as long as it''s the same functionality.
    Create a custom implementation of your own ERC-721 smart contract that inherits
    this one, like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 版本并不重要，只要功能相同即可。创建一个自定义实现你自己的 ERC-721 智能合约，继承这个合约，如下所示：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This token contract will only allow the e-commerce contract to generate new
    tokens, which will be moved to the buyer after the purchase is completed; the
    `setEcommerce` function must be set up before you will be able to mint tokens.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此代币合约将仅允许电子商务合约生成新代币，在购买完成后将其转移到买家名下；在你能够铸造代币之前，必须设置 `setEcommerce` 函数。
- en: Developing the e-commerce smart contract
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发电子商务智能合约
- en: Developing a smart contract that interacts with ERC-721 tokens is simple, because
    we only have to make sure that users have a token ID associated with their products.
    Users will be able to interact with their tokens independently if they wish to
    do so. For our marketplace, we'll focus on creating the buy and sell functions
    to create and burn tokens. As usual, we'll also create multiple getters to extract
    the data from the smart contract for the user interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 开发与ERC-721代币交互的智能合约很简单，因为我们只需确保用户的产品关联有一个代币ID。如果用户希望这样做，他们将能够独立与他们的代币进行交互。对于我们的市场，我们将专注于创建购买和销售功能，以创建和销毁代币。像往常一样，我们还将创建多个getter从智能合约中提取数据供用户界面使用。
- en: 'Let''s start to create the e-commerce contract, which will have all the market
    logic in the same file, since it doesn''t take up that much space:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建电子商务合同，将所有市场逻辑放在同一个文件中，因为它不会占用太多空间：
- en: 'Define the variables needed for the smart contract, starting with the structs
    that you''ll need, as shown in the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义智能合约所需的变量，从您需要的结构开始，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the mappings, arrays, variables, and constructors, as shown in the following
    code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加映射、数组、变量和构造函数，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have to set up the variables first by starting with the structs, in this
    case, `Product` and `Order`. Each order will reference a particular product through
    the ID, which will be the same in both cases, meaning that each product will have
    a corresponding order with the same ID. There will be mappings for pending orders
    that have not been fulfilled yet and other mappings for those that have been completed
    so that we have a reference of completed orders. The constructor will receive
    the token address so that the e-commerce contract can create new tokens.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先设置变量，从结构开始，这种情况下是`Product`和`Order`。每个订单都将通过ID引用特定的产品，在这两种情况下ID将是相同的，这意味着每个产品将与具有相同ID的订单对应。将有映射用于尚未完成的待处理订单，并有其他映射用于已完成的订单，以便我们有已完成订单的参考。构造函数将接收令牌地址，以便电子商务合约可以创建新的代币。
- en: Creating the publish function
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发布功能
- en: 'Create a function to publish new products so that users can sell products by
    themselves, using the following code. The image URL will be where the image is
    located:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个功能来发布新产品，以便用户可以通过以下代码自行出售产品。图像URL将是图像所在的位置：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function will check the parameters so that they are set up while also minting
    a new token.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能将检查参数，以便在设置参数的同时铸造新的代币。
- en: Creating the buy function
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建购买功能
- en: 'Now that users can publish products to sell, you can work on the `buy` function
    to purchase products:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以发布要出售的产品后，您可以开始编写`buy`功能来购买产品：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First of all, the `buy` function must be payable so that users can send the
    required price in Ethereum, which will be sent to the seller without any fees
    besides the gas costs. When purchasing a product, the buyer needs to send all
    the address details so that the seller can process the shipping; that's why there
    are so many parameters in the `buy` function where the phone number and the second
    address line is optional. The `products` array deletes the product so that the
    user interface displays the most recent ones. A new `order` struct instance will
    be created and the order will be added to the pending mappings.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`buy`功能必须是可支付的，以便用户可以用以太币发送所需的价格，这些价格将被发送给卖方，除了燃气成本之外没有任何费用。购买产品时，买方需要发送所有地址详细信息，以便卖方可以处理发货；这就是为什么`buy`功能中有这么多参数的原因，其中电话号码和第二地址行是可选的。`products`数组会删除产品，以便用户界面显示最新的产品。将创建一个新的`order`结构实例，并将订单添加到待处理映射中。
- en: Creating the mark orders function
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标记订单功能
- en: 'After the orders are created, we need a way to tell the customer that the product
    has been shipped. We can do so with a new function, called `markOrderCompleted`
    as shown in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建订单后，我们需要一种方法告诉客户产品已经发货。我们可以通过一个名为`markOrderCompleted`的新功能来做到这一点，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This function removes pending orders from the respective arrays and moves them
    to the `completedOrders` mapping. Instead of using the delete function, we reduce
    the length of the array to delete `Order` because the `delete` function doesn't
    really remove the user order from the array but leaves an empty order instance
    in its place. When we move the element that we want to `delete` to the last position
    of the array and reduce the length of it, we are completely deleting it without
    leaving any empty holes, since the `delete` function keeps the array intact.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从各自的数组中移除了待处理订单，并将它们移到 `completedOrders` 映射中。我们不使用 `delete` 函数，而是减少数组的长度来删除
    `Order`，因为 `delete` 函数实际上并不从数组中删除用户订单，而是留下一个空的订单实例。当我们将要 `delete` 的元素移动到数组的最后位置并减少其长度时，我们完全删除了它，而不会留下任何空洞，因为
    `delete` 函数保持数组完整。
- en: Creating the getter functions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 getter 函数
- en: 'What''s left is to add the required `getter` functions to return the length
    of those arrays because public array variables don''t expose the array length,
    and we need to know how many products and orders there are to show users the latest
    content, let set this up using the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是添加所需的 `getter` 函数来返回这些数组的长度，因为公共数组变量不会公开数组长度，我们需要知道有多少产品和订单以向用户显示最新内容，让我们使用以下代码来设置：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `getOrdersLength()` function will be used for all three types of orders,
    either seller, buyer, or completed, to avoid creating multiple similar functions.
    That''s the entire contract. If you want to see the updated version, check out
    my GitHub at: [https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrdersLength()` 函数将被用于卖家、买家或已完成的三种订单类型，以避免创建多个相似的函数。这就是整个合同。如果你想查看更新版本，请访问我的
    GitHub：[https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp)。'
- en: Deploying the smart contract
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署智能合约
- en: It's important to understand the deployment process to guarantee a successful
    execution, because, let's face it, Truffle can be confusing to set up. You saw
    in previous chapters what needs to be done to deploy a smart contract using this
    framework, but it doesn't hurt to go over the process once again just to make
    sure that you understand it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 了解部署过程是很重要的，以确保成功执行，因为，让我们面对现实吧，Truffle 可能会让人感到困惑。在之前的章节中，你已经看到了使用这个框架部署智能合约需要做什么，但再过一遍这个过程也无妨，只是为了确保你理解了它。
- en: 'First, open your `truffle-config.js` file and modify it for `ropsten`, which
    is the network that we''ll use to deploy this initial version of our dApp. Here''s
    how it should look, with your own INFURA key:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开你的 `truffle-config.js` 文件，并修改它以使用 `ropsten`，这是我们将用于部署我们 dApp 的初始版本的网络。以下是它的样子，使用你自己的
    INFURA 密钥：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'I left the development network available because you may need to check the
    deployment process on a local testnet generated with `ganache-cli` before deploying
    the contract to `ropsten`. Be sure that you have enough `ropsten` Ethereum in
    the first account generated with the seed phrase in your `.secret` file when doing
    so. Remember to install the Truffle wallet so that the deployment process works
    with the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了开发网络的可用性，因为在将合同部署到 `ropsten` 之前，你可能需要在使用 `ganache-cli` 生成的本地测试网络上检查部署过程。在这样做时，请确保你的
    `.secret` 文件中的种子短语的第一个帐户中有足够的 `ropsten` 以太币。记得安装 Truffle 钱包，以使以下代码的部署过程正常工作：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, create a `.secret` file with your seed phrase and create a file named
    `2_deploy_contracts.js` in your `migrations/` folder to tell Truffle what needs
    to be done when deploying the contracts, mainly for setting up constructor parameters,
    as shown in the following code. Truffle will fail without this file when deploying:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的 `migrations/` 文件夹中创建一个 `.secret` 文件，并创建一个名为 `2_deploy_contracts.js` 的文件，告诉
    Truffle 在部署合同时需要做什么，主要是设置构造函数参数，如下面的代码所示。如果没有这个文件，Truffle 将无法部署：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Your migrations folder should have the `1_initial_migrations.js` and `2_deploy_contracts.js`
    files. The syntax is a bit confusing, but what's important is that we're using
    the `deployer.deploy()` function, which returns a promise to get the token address
    and run the `setEcommerce()` function from the token contract so that we can start
    using the contracts right away. Note how we have access to the `accounts` by adding
    that third parameter to the main function; this is required to run the `setEcommerce()`
    function with the first Ethereum address. Finally, I'm checking whether the e-commerce
    contract has been properly set up in the token by calling the `isEcommerceSet()`
    public variable from the token.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您的迁移文件夹应该有`1_initial_migrations.js`和`2_deploy_contracts.js`文件。语法有点混乱，但重要的是我们使用了`deployer.deploy()`函数，该函数返回一个
    promise 来获取令牌地址，并从令牌合约运行`setEcommerce()`函数，以便我们可以立即开始使用合约。请注意，我们通过将第三个参数添加到主函数来访问`accounts`，这是运行`setEcommerce()`函数所必需的，第一个以太坊地址。最后，我通过调用令牌中的`isEcommerceSet()`公共变量来检查电子商务合约是否已正确设置。
- en: 'Run the following deployment command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下部署命令：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you want to test that everything runs properly without waiting for `ropsten`,
    you can spin up a `ganache-cli` private blockchain and deploy it there instantly
    by running the following command line:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要测试一切是否正常运行而无需等待`ropsten`，您可以通过运行以下命令快速在`ganache-cli`私有区块链上部署它：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After deploying your contract, you'll find the address and the ABI inside the
    `build/contract/Ecommerce.json` folder.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 部署您的合约后，您会在`build/contract/Ecommerce.json`文件夹中找到地址和 ABI。
- en: Finishing the dApp
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 dApp
- en: To complete the dApp, we have to modify the React code to integrate the smart
    contract changes while also making sense of the way we receive the information
    from the blockchain using the right methods to display that data properly. Before
    this, make sure that your contracts are deployed to `ropsten` , as shown in the
    previous steps.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 dApp，我们必须修改 React 代码以集成智能合约更改，同时理解我们如何使用正确的方法从区块链接收信息并正确显示该数据的方式。在此之前，请确保您的合约已部署到`ropsten`，如前几个步骤所示。
- en: Setting up the contract instance
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置合约实例
- en: 'Because we are using webpack, we have access to all the files inside the source
    folder from the React files, which means that we can get the deployed smart contract
    ABI and the deployed contract address, as well as the required parameters to create
    a contract instance. This is shown in the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '因为我们使用 webpack，所以我们可以从 React 文件中访问源文件夹中的所有文件，这意味着我们可以获取已部署的智能合约 ABI 和已部署的合约地址，以及创建合约实例所需的参数。这在以下代码中显示： '
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `build` folder will be created when you successfully deploy your smart
    contract with Truffle, and it contains important smart contract parameters that
    we may need for our dApp. Modify your setup function to have access to the contract
    object globally, making things easier for the external components. I''ve highlighted
    the contract instance in the following code for you to find the changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Truffle 成功部署您的智能合约时，将创建`build`文件夹，其中包含我们可能需要的重要智能合约参数。修改您的设置函数以全局访问合约对象，使外部组件更容易。我已经在下面的代码中突出显示了合约实例，供您查找更改：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note how we've reduced the `state` object to a few elements without any dummy
    data because we'll use the real smart contract data. The contract instance is
    created by using `abi` and the contract address, which is also contained in the
    build JSON file. At the end of the setup function, we're calling the `getLatestProducts()`
    and `displayProducts()` functions, which, as you will see in a moment, are necessary
    to get the data from the contract while displaying it properly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将`state`对象减少为几个元素，而没有任何虚拟数据，因为我们将使用真实的智能合约数据。合约实例是通过使用`abi`和合约地址创建的，这些信息也包含在构建的
    JSON 文件中。在设置函数的末尾，我们调用了`getLatestProducts()`和`displayProducts()`函数，正如您即将看到的，这些函数是必要的，以便从合约中获取数据并正确显示它。
- en: Updating the index file
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新索引文件
- en: 'Now that we have a working contract instance, we can work on the required functionality
    for the index file so that we are keeping the functionality contained inside smaller
    components as shown in the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作的合约实例，我们可以在索引文件中工作，以便将功能保持在较小的组件中，如下面的代码所示：
- en: 'Implement the `displayProducts()` function to display products sorted by properties:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`displayProducts()`函数以按属性排序显示产品：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the updated redirect function, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更新后的重定向功能，如下所示的代码所示：
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the function to get products from the smart contract by taking the
    length of those products and looping each one of them:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现从智能合约获取产品的功能，方法是获取这些产品的长度，并循环每一个：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In our home page, we''ll display the latest products added by other sellers
    so that you can start buying straight away. For this reason, we''ll use `getLatestProducts()`,
    which receives the number of products to display as the parameter while getting
    the data from the blockchain. How do we get all the product data without a `getter`
    function? Well, the process goes like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主页上，我们将展示其他卖家添加的最新产品，以便您可以立即开始购买。因此，我们将使用`getLatestProducts()`，它接收要显示的产品数量作为参数，同时从区块链获取数据。那么，我们如何在没有`getter`函数的情况下获取所有产品数据呢？好吧，流程是这样的：
- en: We get the length of the array of products. We use the `getProductsLength()`
    function because we can't get the length of an array without a proper `getter`
    function.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取产品数组的长度。我们使用`getProductsLength()`函数，因为如果没有适当的`getter`函数，我们无法获取数组的长度。
- en: Once we know how many products are available in the smart contract, we loop
    through that size to run the `products()` function, which is available because
    our products array is public, meaning that it has a `getter` function automatically
    created for it. Public arrays have to be accessed one by one; that's why we're
    using a reverse `for` loop.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道智能合约中有多少产品可用，我们就通过循环该大小来运行`products()`函数，该函数可用于我们的产品数组，这意味着它自动为其创建了`getter`函数。公共数组必须逐个访问；这就是为什么我们使用反向`for`循环的原因。
- en: We need a reverse loop to get the latest products first. How the `for` loop
    works because it could be the case that we run out of product to display, given
    that we start with exactly zero products when we want to display `9`, indicated
    at the end of the setup function. That's why we created the `condition` variable
    – it checks whether the amount of products requested to display is actually available;
    if not, we simply get all the products available, however few they are.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个反向循环来首先获取最新的产品。关于`for`循环的工作原理，因为可能出现我们要显示`9`时产品已用尽的情况，这是由于当我们想要显示`9`时，我们从零产品开始。这就是为什么我们创建了`condition`变量-它检查要求显示的产品数量是否实际可用；如果不可用，我们只需获取所有可用的产品，无论它们有多少。
- en: On the other hand, once the `state` object has been populated with the products
    contained in our smart contract, we use the `displayProducts()` function, which
    takes care of generating the proper HTML needed for each product while updating
    the `productsHtml` state array.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一旦`state`对象被填充了包含在我们的智能合约中的产品，我们就使用`displayProducts()`函数，该函数负责生成每个产品所需的正确HTML，同时更新`productsHtml`状态数组。
- en: 'Finally, we have the `render` function, which has been slightly modified for
    these new updated components, as shown in the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`render`函数，这些新更新的组件略有修改，如下所示的代码所示：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After making the implementation changes, take a look at the entire index file,
    available on GitHub at [https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行实现更改后，请查看整个索引文件，可在 GitHub 上找到，网址为 [https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp)。
- en: Updating the Buy component
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新购买组件
- en: 'Let''s move on to the `Buy.js` file since the `Home.js` and `Product.js` components
    will stay as they are without any required modifications, considering that the
    product data will have the same expected format. In the `Buy` component, we need
    to add a function to purchase products, which will send the transaction to the
    smart contract, here''s that function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向`Buy.js`文件，因为`Home.js`和`Product.js`组件将保持原样，无需任何必要的修改，考虑到产品数据将具有相同的预期格式。在`Buy`组件中，我们需要添加一个购买产品的函数，该函数将事务发送到智能合约，以下是该函数：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `buyProduct()` function takes all the state data regarding the user address
    and sends the transaction with the required product price as the transaction''s
    payment. The `bytes32` function is required to convert some string values to bytes32,
    saving gas costs. That''s the entire change required for this particular component.
    Check the final implementation of the entire component on the updated GitHub at:
    [https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Buy.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Buy.js).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`buyProduct()`函数获取与用户地址相关的所有状态数据，并将具有所需产品价格的交易作为交易的支付发送。`bytes32`函数是必需的，以将一些字符串值转换为`bytes32`，以节省
    gas 成本。这就是此特定组件所需的所有更改。在更新的 GitHub 上检查整个组件的最终实现：[https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Buy.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Buy.js)。'
- en: Updating the Sell component
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新出售组件
- en: 'Let''s work on creating the required functionality for the `Sell.js` function
    so that you can start adding purchasable products to the marketplace. In this
    case, we need to add a function that will call the `publishProduct()` function
    from the smart contract. Here''s how the updated `publish` function looks:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来创建`Sell.js`功能所需的功能，这样你就可以开始向市场添加可购买的产品了。在这种情况下，我们需要添加一个函数，该函数将从智能合约中调用`publishProduct()`函数。下面是更新后的`publish`函数的样子：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note how we check for all the required parameters to let the user know when
    something's missing. You could add some additional checks to make sure that the
    image URL provided is actually a valid picture that can be displayed on the marketplace.
    I'll leave that up to you. It shouldn't take you more than 10 minutes, and it's
    a great exercise to practice your JavaScript skills.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何检查所有必需的参数，以便让用户知道何时缺少某些内容。你可以添加一些额外的检查，以确保提供的图片 URL 实际上是一个可以在市场上显示的有效图片。这部分就交给你了。不应该花费你超过`10分钟`的时间，这是一个练习你的
    JavaScript 技能的好机会。
- en: 'The final updated version is available on GitHub at: [https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Sell.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Sell.js).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最终更新的版本在 GitHub 上可用：[https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Sell.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Sell.js)。
- en: Updating the Orders component
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新订单组件
- en: 'Now let''s update the `Orders.js` component, which is the most elaborate component,
    given that we have to generate multiple products. Let''s start by creating a function
    to get all the orders related to the current user, as shown in the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新`Orders.js`组件，这是最复杂的组件，因为我们必须生成多个产品。让我们从创建一个函数开始，以获取与当前用户相关的所有订单，如下所示：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''re generating three different arrays by following the same procedure we
    used for the products in the index file. We have the same condition operators
    but for different types of orders. We then run a `for` loop for each of the desired
    orders in reverse so that we get the most recent ones. Because the data returned
    by the smart contract is a bit messy, we''ve created a function named `generateOrderObject()`,
    which receives an order object and returns a cleaned object with converted hexadecimal
    values at that have been converted to readable text. Here''s how it looks:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遵循与索引文件中产品相同的程序生成了三个不同的数组。我们具有相同的条件运算符，但用于不同类型的订单。然后，我们为每个所需订单运行一个逆序的`for`循环，以便获得最近的订单。由于智能合约返回的数据有些混乱，我们创建了一个名为`generateOrderObject()`的函数，该函数接收一个订单对象，并返回一个已清理的对象，其中包含已转换为可读文本的十六进制值。下面是它的样子：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It's important to separate repetitive code in external functions to keep your
    code neat. As you can see, this function converts the byte types of variables
    to a readable `utf8` string while also converting BigNumbers to integers so that
    they can be displayed in our user interface properly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将重复的代码分离到外部函数中以保持代码整洁是很重要的。正如你所看到的，这个函数将变量的字节类型转换为可读的`utf8`字符串，同时将大数转换为整数，以便它们可以在我们的用户界面中正确显示。
- en: 'After updating the state object with the recent orders, we can create a function
    to generate the proper HTML for each element by going through the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用最新订单更新状态对象之后，我们可以创建一个函数，通过以下步骤生成每个元素的正确 HTML：
- en: 'Set up the required array variables, which in this case is simpler, since we
    want to create three blocks for the different types of orders:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置所需的数组变量，这种情况下更简单，因为我们要为不同类型的订单创建三个块：
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In case there aren''t orders for each type of order, we want to display a message
    to let the user know that there aren''t orders by using the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有每种类型订单，我们希望显示一条消息，让用户知道没有订单，使用以下代码：
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Update the pending orders by adding an address section using the following
    code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加地址部分来更新待处理订单：
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Right under the product data, add the address information so sellers can fulfill
    those orders using the following code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在产品数据下面，使用以下代码添加地址信息，以便卖家可以履行这些订单：
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We do the same thing with the pending buyer orders: we display the product
    data first, using the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于待处理买家订单，我们采取相同的做法：我们首先显示产品数据，使用以下代码：
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The address data will be exactly the same, so copy and paste it into this pending
    buyer orders loop. We''re using the same code because we need to update the appearance
    of each HTML block, but the class names have to be different. Add the `for` loop
    to the completed orders array using the following code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地址数据将完全相同，因此将其复制并粘贴到待处理买家订单循环中。我们使用相同的代码，因为我们需要更新每个 HTML 块的外观，但类名必须不同。使用以下代码将`for`循环添加到已完成订单数组中：
- en: '[PRE82]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Paste the address block right under the product data. Update the state of this
    component with the `setState()` method:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地址块粘贴到产品数据下方。使用`setState()`方法更新此组件的状态：
- en: '[PRE83]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It's a big function because we have repetitive functionality for the sake of
    keeping it simple. We have three loops for the three order arrays, so that we
    can put the order information at the user's disposal. Nothing too fancy, just
    the data in a clean design. We're adding that data to the `state` object so that
    we can display it easily.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大函数，因为我们为了保持简单而有重复的功能。我们有三个循环用于三个订单数组，这样我们可以将订单信息提供给用户。没有太多花哨的东西，只是干净的设计中的数据。我们将该数据添加到`state`对象中，以便我们可以轻松显示它。
- en: 'Create a `setup()` function to run both functions when the component loads,
    as shown in the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setup()`函数，在组件加载时运行这两个函数，如下所示：
- en: '[PRE84]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In this case, we''re requesting five orders per type, as we don''t want to
    overwhelm the user with information – this is easily changeable to your preferences.
    You can even add a slider in the UI so that the user changes how many items are
    displayed. The `render()` function has also been updated to reflect the buyer''s
    address data, as shown in the following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们每种类型请求五个订单，因为我们不想让用户被信息压倒，这很容易根据您的喜好进行更改。您甚至可以在UI中添加一个滑块，以便用户更改显示的项目数量。`render()`函数也已更新以反映买家的地址数据，如下所示：
- en: '[PRE85]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That''s the complete set of changes for the `Orders` component. Take a look
    at the updated implementation in the official GitHub link at: [https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Orders.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Orders.js).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Orders`组件的全部更改。请查看官方 GitHub 链接中的更新实现：[https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Orders.js](https://github.com/merlox/ecommerce-dapp/blob/master/src/components/Orders.js)。
- en: You can find the updated CSS code at [https://github.com/merlox/ecommerce-dapp/blob/master/src/index.styl](https://github.com/merlox/ecommerce-dapp/blob/master/src/index.styl),
    where you'll get the exact same design.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/merlox/ecommerce-dapp/blob/master/src/index.styl](https://github.com/merlox/ecommerce-dapp/blob/master/src/index.styl)找到更新后的
    CSS 代码，您将获得完全相同的设计。
- en: 'That''s the entire e-commerce dApp for you! Here''s how it looks, just so you
    can see the potential of this simple yet capable application:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个电子商务 dApp！这是它的外观，只是为了让您看到这个简单而又功能强大的应用程序的潜力：
- en: '![](img/a8ee1daa-a409-4dfd-b265-d3601939472b.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8ee1daa-a409-4dfd-b265-d3601939472b.png)'
- en: Remember to deploy your smart contract to `ropsten` and run `npm run dev` to
    start the webpack server so that you can interact with it. This is a prototype
    of what can be done in Ethereum in the e-commerce department; it's up to you to
    build upon this idea now that you understand how the smart contract interacts
    with the user interface.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将你的智能合约部署到`ropsten`并运行`npm run dev`来启动 webpack 服务器，以便您可以与其交互。这是以太坊电子商务部门的一个原型；现在您理解了智能合约如何与用户界面交互，您可以在此基础上构建自己的想法。
- en: 'Be sure to check out this chapter''s code on GitHub link at: [https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看本章节代码的 GitHub 链接：[https://github.com/merlox/ecommerce-dapp](https://github.com/merlox/ecommerce-dapp)。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you began by learning about the potential of using ERC-721
    tokens to create a marketplace of unique products using decentralized smart contract
    technology so that you can easily manage NFTs created by users freely. Then you
    built a clean interface to display the most important data so that users have
    a comfortable place in which to interact with the underlying smart contract. Next,
    you built the smart contract by learning how NFT tokens work, including all of
    their functions. You deployed your own version of the ERC-721 standard to then
    create the e-commerce smart contract that contained the logic required to publish
    products for the public so that others can purchase them with real Ethereum. Finally,
    you put everything together by creating the necessary functions to interact with
    the smart contract on the React user interface.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了使用 ERC-721 代币利用去中心化智能合约技术创建独特产品市场的潜力，以便你可以轻松管理用户自由创建的 NFT。然后，你建立了一个清晰的界面来显示最重要的数据，使用户有一个舒适的地方与底层智能合约进行交互。接下来，你通过学习
    NFT 代币的工作原理（包括所有功能）来构建了智能合约。你部署了你自己的 ERC-721 标准版本，然后创建了包含发布产品到公共市场所需逻辑的电子商务智能合约，以便其他人可以用真正的以太币购买它们。最后，你通过创建与
    React 用户界面交互所需的必要功能将所有内容整合在一起。
- en: In the next chapter, we'll go further by building a decentralized bank and lending
    platform that implements complex smart-contract systems to guarantee that people
    have access to a reserve of secure funds, with a user interface for them to interact
    with it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步构建一个去中心化银行和借贷平台，实现复杂的智能合约系统，以确保人们可以访问安全资金储备，并为他们提供用户界面进行交互。
