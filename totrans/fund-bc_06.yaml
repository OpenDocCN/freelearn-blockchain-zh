- en: Diving into Blockchain - Proof of Existence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we've looked at the fundamental concepts of blockchain
    technology, exploring topics such as cryptography and decentralized networking.
    We've also created a simple blockchain application and made ourselves familiar
    with the transactions used in the decentralized cryptocurrency application. Although
    the blockchain applications we created gave us an overview of blockchain technology,
    we haven't yet looked at any use cases other than those in cryptocurrency that
    require a decentralized network. By diving into blockchain, we'll introduce and
    become familiar with the blockchain framework, which will end with us building
    a blockchain application by constructing the use case featured.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The blockchain platform, specifically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why did we choose to go with MultiChain?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the basics of MultiChain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The functionalities contained within MultiChain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up the blockchain environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of Proof of Existence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a Proof of Existence application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we look into the varying aspects of the Multichain blockchain platform,
    it's important to understand the core blockchain platform.  Any user who wants
    to build a decentralized application will not be required to build all the components
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you'll find that it's always better to use an existing framework. Why?
    Because it will help you to build the application with considerably less effort.
    Existing blockchain platforms provide a framework for app development where you
    won't have to worry about the underlying blockchain concepts used, and instead
    offers you the ability to focus more on implementing the blockchain use case.
    A user wouldn't have to worry much about the scalability of a blockchain network
    built in this way because the platform has already been tested by thousands of
    developers and users. Thus the system should be resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Each blockchain platform comes with its own set of characteristics and features
    beyond the basics of building a decentralized network using the blockchain technology.
    Some blockchain platforms offer basic functionalities derived from the Bitcoin
    project, whereas others provide advanced scripting capabilities in order to deploy
    intelligent applications from within the blockchain network. You'll find that
    there are a vast number of platforms to choose from in order to both develop and
    deploy applications, but it is always best to select a framework based on the
    use case of the application you are creating. Some notable blockchain projects
    that provide a platform to develop applications are *Ethereum*, *Hyperledger*,
    *Neo, MultiChain*, *Corda*, and *BigchainDB*. The list is huge, and we will look
    into a few of these platforms in [Chapter 8](02eed23a-0a39-4a19-8d88-a72a810ddb0d.xhtml),
    *Blockchain Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a large number of options to choose from, it is difficult to find
    the best platform because most of them can be successfully used for the same use
    case we are going to use. However, each platform is designed for a specific purpose.
    We will point out the selection criteria for blockchain platforms in [Chapter
    12](55ed2989-ecca-46ca-8546-74a12da98715.xhtml), *Blockchain Use Cases*, where
    we will discuss several blockchain use cases. Throughout this chapter, we will
    discuss the use case of building a Proof of Existence application using MultiChain.
    We'll discuss the justification for choosing this platform in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: MultiChain blockchain platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MultiChain is one of the many platforms that help enable enterprises to both
    build and deploy blockchain applications with ease. As we already know, Bitcoin
    has a resilient public blockchain that can scale its network and handle transactions,
    which are ideal for public blockchains. This was achieved when the MultiChain
    project was created by taking inspiration from Bitcoin and creating a private
    blockchain platform.
  prefs: []
  type: TYPE_NORMAL
- en: A public blockchain maintained in Bitcoin does introduce a few restrictions,
    such as limited asset distribution, a transaction cost, lower transaction rates,
    and transparent transactions. Although it is difficult to escape these restrictions
    in the public blockchain, not all the use cases need to bear these restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: A use case that can be implemented in a private network shouldn't pay for each
    transaction, achieve a higher transaction speed, or even set access control for
    operation. MultiChain helps to achieve all of these from within a private network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below you''ll find some of the features of MultiChain that helped it to overcome
    the problems in Bitcoin that prevented it from implementing the general use cases
    in an enterprise as a private blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: There's no limit on blockchain asset creation. This is because it will be capped
    by the organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You won't encounter a transaction cost. This is because the internal nodes don't
    need to be rewarded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a removal in the delay of transaction confirmation, which is due to
    the Proof of Work consensus algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a mitigation of the lack of privacy in blockchain transactions. This
    is caused by providing access control to blockchain nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why choose MultiChain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned, there are several blockchain platforms to choose
    from when we implement a blockchain application. The choice of framework mostly
    depends on the use case of the application that we are going to implement.
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons for picking the MultiChain platform over other platforms.
    One of the biggest factors is the simplicity of implementing our Proof of Existence
    use case within the platform. MultiChain helps us to build our use case without
    needing to write any complex logic for deployment and execution, making it much
    more accessible. MultiChain also has a feature called data stream that will be
    used to store information in the blockchain without needing to alter the data
    structure. We will achieve this by looking into the stream concept later in this
    chapter, under the section, *Getting started with MultiChain*. Another factor
    to consider when selecting the MultiChain is that it's very similar to Bitcoin,
    which makes it easier for us to understand all its extended functionality.
  prefs: []
  type: TYPE_NORMAL
- en: All these factors influenced us to select MultiChain as a suitable platform
    to build our first blockchain application. We will cover some of the features
    of MultiChain in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of MultiChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MultiChain is a project that was forked from Bitcoin; therefore this makes it
    compatible with the Bitcoin ecosystem. It's a permissioned-based blockchain that
    implies that any operation performed on the blockchain is access controlled. Nodes
    on the network do not necessarily have the same permission on the blockchain.
    Whilst some nodes could be assigned basic permissions to read the blockchain,
    others could either be given write permission or even be made admins. MultiChain
    can also be configured without permissions, making every node in the network equal.
    The flexible nature of MultiChain makes it easy to implement blockchain use cases
    without investing many development resources.
  prefs: []
  type: TYPE_NORMAL
- en: MultiChain provides us with complete asset management cycle, which is similar
    to Bitcoin transactions. Assets provide us with a flexible way to work with their
    metadata. Since our Proof of Existence use case doesn't deal with identities,
    we will not be using asset management concepts to create our application. MultiChain
    also offers data storage and retrieval mechanisms with the help of data streams.
    In our example, we will be using the streams feature for data storage in the Proof
    of Existence application.
  prefs: []
  type: TYPE_NORMAL
- en: MultiChain functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've explained before, MultiChain inherits most of its functionalities from
    the Bitcoin project and helps developers to create applications without needing
    to learn a whole new ecosystem. MultiChain has a set of additional functionalities
    that makes building and deploying a blockchain application effortless for a developer.
    In this section, we're going to talk about a few of these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Permission management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a MultiChain blockchain is deployed in an enterprise as a private network,
    it could be configured so that each node has a different level of access control.
    When a permission mode is enabled in a blockchain network, each peer has to be
    given permission explicitly by using their public addresses. Some of the permission
    levels are connect, send, receive, issue, mine, activate, and admin. Permissions
    can also be assigned for a specific asset, making the permission management more
    granular. Access control can also be revoked at any time by the node. Permission
    management makes sure that none of the unknown peers are allowed inside the private
    blockchain or set up a hierarchy in the organization by deciding different levels
    of access control for different nodes. Permission management is an important functionality
    in a private blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Asset management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asset management is a concept derived from Bitcoin transactions. Bitcoin has
    a single asset that is validated by transactions. Although Bitcoin has the provision
    to store additional assets in its transaction metadata, they are not validated
    by the blockchain nodes. MultiChain solves this problem by providing functionality
    that enables you to create multiple types of asset and still validate all the
    assets' transactions. MultiChain has a complete asset management life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Stream management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream is a mechanism used to provide data storage in the MultiChain blockchain.
    It acts as a convenient way to store and retrieve data in key-value pairs. Multiple
    items can be published to a single data stream. A node has to subscribe to a stream
    before performing operations on it. Stream items could be indexed by key, signature,
    and block number, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a blockchain environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A blockchain network is a decentralized network, and each node should have similar
    information about the blockchain ledger. A decentralized network can be set up
    in an open network by allowing everyone to connect to and perform operations on
    the blockchain, or equally, it could be maintained in a private network. A public
    blockchain network is achieved by enabling connect permissions in every node.
    Enterprises typically prefer to establish a private network as it helps keep the
    bad actors away. This network configuration can be easily configured in MultiChain
    at each node.
  prefs: []
  type: TYPE_NORMAL
- en: Running MultiChain nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MultiChain can be installed on Linux, Windows, and Mac platforms with 64-bit
    processors that have at least 512 MB of RAM and 1 GB of storage. The installation
    involves the extraction of compressed compiled files that can be downloaded from
    the MultiChain site. MultiChain is an open source project developed in C++. Each
    node can use the open source code and compile it to gain more control over the
    program's logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation instructions for direct installation of MultiChain on machines,
    as well as building from the source code, can be found in the GitHub repository
    of the book or on MultiChain''s official site: [https://www.multichain.com/download-install](https://www.multichain.com/download-install).
    We''ll be using Linux distribution Ubuntu 16.04 for the demonstration in this
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: Each MultiChain node comes with three main binaries, called `multichaind`, `multichain-cli`,
    and `multichain-util`.
  prefs: []
  type: TYPE_NORMAL
- en: '`multichaind`: This is a process that runs on each node as a daemon. This process
    is the backbone of the node, and initiates all the tasks required to keep the
    local blockchain up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multichain-cli`: This provides a command-line interface that you can use to
    perform operations on the blockchain by executing the APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multichain-util`: This is a tool that you can use to perform operations such
    as creating a new blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with MultiChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are familiar with the MultiChain platform, and equally with the
    process of setting up a node in the private network, we need to create a blockchain
    so that the data can be published and shared among the peers in the network. The
    first step is to introduce all the functionalities before moving on to implementing
    our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a node has been set up, it can either join an existing network by connecting
    to a chain, or it can create its own chain. `multichain-util` is used to create
    a new chain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new local blockchain. The node then has to start a process by
    using `multichaind` to connect to the chain created. Multiple chains can be initialized
    on a single machine by starting multiple `multichaind` daemon processes. A `multichaind`
    process is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line instantiates a process and starts the server. The genesis
    block is then mined by the node for the created chain. This code will yield an
    address, which can then be used by other nodes to connect to the chain that was
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an existing chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a chain is created in a private network, other nodes can then connect to
    the created node and perform operations on the same blockchain. Any node can connect
    to the chain using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Any remote node in the network can connect to the chain using the IP address
    and the MultiChain port. Each MultiChain daemon process assigns a different port
    number to its server. If the connect permission of the chain configuration is
    not set to open, then each node in the network has to be explicitly given permission
    by the admin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Node-address is the public address, or wallet address, of the node, which is
    extracted from the public key of the public-private key pair of the wallet. The
    node can try to connect to the chain by restarting `multichaind` as follows, but
    only once permission is granted to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Checking the blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A node is completely set up in a private blockchain network after a successful
    connection to a blockchain is made. The local blockchain will be updated by accepting
    blocks from nodes in the network. The blockchain''s status can be verified by
    issuing the following command through the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command provides general information about the node, MultiChain, and several
    blockchain parameters in a key-value paired document, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: All the MultiChain commands can be run in an interactive mode by initially
    launching the shell with a `multichain-cli chain1` command. This opens up an interface
    where all the commands can be executed with the keyword and the required arguments.
    The full list of commands can be obtained by typing `help`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, streams are used to store data items as key-value pairs
    in a blockchain. Streams act as a convenient way to store data. They can be easily
    created and managed using the command-line interface. All the commands used here
    are executed after entering an interactive mode by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can check all the streams in the chain by issuing the `liststreams`
    command, which returns the details of all the streams along with a default stream
    called `root`. A new stream can then be created by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`stream1` is the name of the newly created stream. The stream items can only
    be created for `stream1` by the admins and nodes with explicit permissions if
    false is passed as an argument. Permission to publish stream items can be given
    to a specific node using the `grant` command if the `create` command is set to
    false initially.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A key-value pair data item can also be published to the created stream using
    the following `publish` command. The value of the stream item should always be
    specified as a hexadecimal string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a node wants to listen to the published stream items, it has to listen
    to the stream by subscribing to it; this can be effected via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing that command will result in all the items published to the stream
    being displayed, along with information such as the publisher address, block creation
    time, transaction ID, and a number of block confirmations. The published hexadecimal
    value is stored in the `data` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the basic functionalities provided by the MultiChain
    platform, we have all the key ingredients needed to build our own application.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Existence architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proof of Existence is a mechanism that proves whether a digital document exists
    at a specific time. A blockchain acts as a good substitute for a notary because
    it can prove the existence of a document without the need for a third party. Each
    document is identified by creating its digest using a hashing algorithm, such
    as SHA-256\. The identity of the document is then stored in the blockchain by
    timestamping the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain implementation of Proof of Existence was created in early 2013
    by developers Manuel Araoz and Esteban Ordano. It was released as an open source
    project. This service used Bitcoin's public network to store information about
    the document. The information about the document was stored in transaction metadata
    called `OP_RETURN`, which allowed the storage of arbitrary information in the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Existence architecture has two use cases during its life cycle. Any
    user who wants to prove the existence of a file performs publishing, and anyone
    can check this proof by performing verification. The architecture for the application
    will consist of a user interface, a backend interface to the blockchain node,
    and the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The owner of a document who wants to prove its existence at a specific time
    can upload the document to the Proof of Existence application. The owner can add
    additional information that needs to be retained along with the document, such
    as a document description, size, and user details. The user-facing part of the
    application will then accept this data along with the document. A digest of the
    document is then created using a hashing algorithm to uniquely identify the document
    and represent it in a fixed sized identity. The document information, along with
    the digest, will be sent to the web interface of the blockchain application.
  prefs: []
  type: TYPE_NORMAL
- en: The web interface of the blockchain application performs a specific operation
    on the MultiChain blockchain whenever required. When the publishing operation
    is invoked with all the required data, the application will create an item and
    request that the MultiChain node publishes it in the blockchain stream. Once the
    transaction reaches one of the nodes in the network, it will then be exchanged
    and included in one of the blocks, and finally, it will be embedded into the blockchain
    ledger.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be5465de-f947-4fc8-ba1e-70a6a49601b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The architecture diagram for the publication of the Proof of Existence
    of a document'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users who want to verify the existence of a document will follow a similar process
    to those publishing the document, as seen previously. However, they'll need to
    have access to the document in order to fetch its existence information. The user
    who wants to verify the document will perform a similar interaction with the web
    interface when the verification function is triggered. The verification operation
    in MultiChain blockchain will then verify whether the operation is invoked. The
    web interface will accept the digest of the document, and it will use this digest
    to query the MultiChain blockchain for the document information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The document information stored in the MultiChain stream can then be retrieved
    by submitting the digest of the document, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e57ae18-2e1f-4e27-aea2-b238461b2866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The architecture diagram for verifying the Proof of Existence of
    a document'
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain node will be able to find the item in the stream if it's included
    in one of the blocks. Verification of Proof of Existence is claimed to be successful
    if the item is found in the blockchain stream and acknowledges the user by providing
    more information about the document.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Proof of Existence application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed in the architecture of the Proof of Existence application,
    each blockchain node has a web interface through which its user will publish and
    verify the existence of a document.
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating a web interface that will communicate with the deployed
    MultiChain node. The user will then communicate with the web interface through
    the use of REST APIs. In our example, we'll be using the Python Sanic web server
    used in [Chapter 4](af1f1baa-57d2-4521-aca7-0df57908dc1c.xhtml), *Networking in
    Blockchain*, to create simple REST APIs. This web interface will then communicate
    with the MultiChain node's JSON-RPC server, which will allow the node to perform
    any operation on the MultiChain blockchain. All the functionality provided by
    the `multichain-cli` will be available in the JSON-RPC invocation. We will be
    using a Python driver called `Savoir` to communicate with the JSON-RPC server
    of the MultiChain node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll break down the server-side application into three parts
    to accommodate the architecture. These parts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MultiChain JSON-RPC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proof of Existence library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proof of Existence web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1a1abba9-5b4c-42fc-a91f-5984edf3cdda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The layered architecture of the server-side application'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding *Figure 6.3* depicts the layered architecture, by means of which
    the user communicates with the high-level web server interface, and the application
    interacts with the MultiChain node through a low-level JSON-RPC driver.
  prefs: []
  type: TYPE_NORMAL
- en: MultiChain JSON-RPC driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using a driver to communicate with the MultiChain node. MultiChain
    provides a JSON-RPC server that can be used to perform any blockchain operations
    that is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our use case, we''ll be using a Python driver called `Savoir`, which will
    connect to the JSON-RPC server of the MultiChain node and invoke the requisite
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will also create a MultiChain JSON-RPC client using `Savoir`. The client
    will require the RPC connection information, such as the username, password, host,
    port, and chain name, in order to establish a connection to the RPC server. Here,
    the command line, `multichainrpc`, is the default RPC username, and `4416` is
    the default RPC port. We will use the same chain, as `chain1`, created in the
    earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The RPC username and password can be configured in the configuration
    file of the created chain. It is located at `/home/user/.multichain/chainname/multichain.conf`
    in a Linux machine, or the equivalent installation directory of other platforms.
    Additional blockchain parameters, such as port numbers, can be configured in a
    params file located as follows: `/home/user/.multichain/chainname/params.dat`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The RPC connection object is then created using the connection information provided.
    This object is returned to the library layer to invoke the required MultiChain
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Existence library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Proof of Existence library is a collection of methods that perform high-level
    tasks on a blockchain. The library contains all the operations that can be performed
    on a document submitted by a user. There are two main ways of performing operations
    on the user document, according to the design of the architecture: publish and
    verify.'
  prefs: []
  type: TYPE_NORMAL
- en: The publish operation publishes the document digest, along with any other information
    passed by the user. Since we are using MultiChain streams for publishing, the
    data has to be formatted in a hexadecimal string, as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Document` class shows the `publish` and `verify` methods, along
    with some methods that can be used to fetch the stream items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding constructor initializes a connection to the MultiChain node using
    the RPC server. This connection object can be used to invoke any MultiChain API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two methods are used to fetch stream items according to their
    stream key and transaction ID respectively. The first uses the MultiChain API,
    `liststreamkeyitems`, passing the stream name and the key as arguments. In the
    second method, stream items are fetched using their transaction ID with the `getwallettransaction`
    API, which accepts the transaction ID of the published stream item as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Document information is stored in a key-value pair using the stream item publish
    API. The stream item is published in a key-value pair, where the key is the unique
    digest of the document and the value is an encoded hexadecimal string. The publish
    API will then create a transaction and insert that into the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `verify` method is invoked when the user wants to retrieve a published
    document''s information when verifying its existence. Verification is performed
    with the help of the `fetch_by_key` method, as described earlier, which accepts
    the stream key as the argument. This method either returns a list of stream items
    if the key exists, or it will return an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The latest published document information is then returned by the following
    method. A user can also query for a required number of documents by specifying
    the count. The `liststreamitems` API is used to retrieve all the items in the
    stream. The returned list is then reversed, and the specified number of items
    are retrieved. Only the requisite information is filtered from the stream item
    and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Proof of Existence web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Proof of Existence web server is an interface for communicating with the MultiChain
    blockchain. We will create a REST API to communicate with the blockchain application.
    Each user will be able to send requests to perform `publish` and `verify` operations
    through this web interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the packages required to encode the data and create the web server need
    to be imported. The default port number of the web server is set to `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is when the document object is created. This will be used to
    perform Proof of Existence operations. Three REST API endpoints are defined to
    verify, publish, and fetch the document information. We will create an implementation
    for all the defined API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Publishing the document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `publish` endpoint implementation will then be invoked when a user wants
    to prove the existence of a document. The `publish` implementation is an HTTP
    POST endpoint because it will create a new record in the blockchain through the
    web server interface. The user invokes this endpoint by passing the document digest,
    which is the hash value of the entire document. The user will also pass information
    such as the name, email, and message, which will be stored as metadata in the
    stream item. The requisite information is passed through the POST forms. The requisite
    values are extracted from the `request` object in order to create a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since stream items store values as hexadecimal strings, the dictionary is going
    to be converted to a string, then base64- encoded, and finally encoded into a
    hexadecimal string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Proof of Existence library `publish` method is invoked, along with the
    digest and the computed encoded value, in order to store it in the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Response data is then constructed to acknowledge the user''s request. The user
    is provided with information regarding the published item, such as the transaction
    ID, the block hash, the timestamp, and the number of confirmations. The timestamp
    information is crucial in the Proof of Existence use case because it is used to
    prove that the document existed at that particular point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user who needs to verify the existence of the document will invoke the `verify`
    implementation endpoint. `verify` is an HTTP GET method that accepts document
    digests as query strings and then responds with details regarding the document
    if it has already been published. By doing it this way, the user can be certain
    about the document's existence, provided it has already been published in the
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `digest` query string key is passed as an argument to the
    Proof of Existence library `verify` method. This will return a list of items if
    the document digest can be found in the blockchain ledger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The hexadecimal-encoded value stored is decoded back to a binary string. The
    resulting base64-encoded string is decoded back to fetch the metadata of the submitted
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Transaction and block information, along with the metadata of the document,
    is returned to the verifier of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This endpoint implementation fetches the details of the recently published
    document. It is an HTTP `GET` method that accepts the count of the document to
    be fetched as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Executing and deploying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server side of the application is executed by running the Python web server
    application. The server application can be executed on any blockchain node or
    on any machine that has access to the blockchain JSON-RPC server. The main function
    of the application instantiates a web server application at the specified port,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The user can access the REST interface once the server has been instantiated
    successfully. Let's publish and verify the existence of a document using the REST
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `curl` tool to invoke the `/publish` POST method, which runs
    in the local machine. We can generate the digest using any hash function. You
    can use the `sha256sum` tool in Linux to generate the hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `POST` request publishes the document through a MultiChain node. The server
    then responds with the following data if the publish operation was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The document's existence has successfully been published if the server responds
    with a transaction ID, as shown in the preceding output. `blockhash` and `blocktime`
    are set to null because the transaction is yet to be included in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user can invoke the `/verify` GET method endpoint and use the document''s
    digest to verify its existence, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding response proves that the document existed at the specified timestamp.
    It also gives the published details of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the latest published document information can also be fetched by invoking
    the `/details` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The details of the document show the latest published proof of the document.
    As we can see, the latest document information has fewer confirmations than the
    older information. This is due to the fact that the earlier published transactions
    are inserted deep in the blockchain. Unlike public blockchains, where transaction
    insertion depends on the priority of the transactions, MultiChain nodes treat
    all the transactions with high priority and are inserted in the order in which
    transactions arrive due to their fairly simple consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the architecture, the web server application communicates with
    the blockchain node that is connected to the MultiChain network. The web server
    application can either be deployed in a separate machine that is reachable by
    the MultiChain node, or it could be deployed in the same blockchain node. Although
    deploying the application in another server gives the same result, it introduces
    the problem of centralization due to the fact that there will only be one central
    web server application. Best practice is to run the application locally on the
    blockchain node whenever someone wishes to publish or verify the Proof of Existence
    of a document.
  prefs: []
  type: TYPE_NORMAL
- en: Every application needs a user interface to allow a good user experience. Our
    blockchain application could be integrated with a user interface in which the
    publish use case accepted a document and the requisite information pertaining
    to the document as arguments, and the verify use case only needs the document
    in order to check its existence. The frontend application computes the digest
    of the document in both scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The entire Proof of Existence project, along with integration with the
    frontend application, can be found in the GitHub repository of the book ([https://github.com/PacktPublishing/Foundations-of-Blockchain](https://github.com/PacktPublishing/Foundations-of-Blockchain)).
    It can be used to deploy a blockchain application in a private network.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we were introduced to the core concepts of blockchain in the earlier chapters
    of this book, in this chapter, we have dived into blockchain by creating a blockchain
    application to implement an existing use case. Throughout this chapter, we've
    carefully analyzed a blockchain use case and proposed an architecture to build
    a simple blockchain application using the MultiChain platform. The MultiChain
    platform's simplicity, along with other features that we discussed, allowed us
    to create and deploy the application with minimal effort. Getting familiar with
    the MultiChain platform has provided us with sufficient insights on architecting
    and developing a simple blockchain use case. This should serve as a foundation
    and motivate us to build and deploy blockchain applications within any other blockchain
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a strong background in blockchain technology by implementing
    a fairly simple blockchain use case, it will serve as a foundation for blockchain
    application development. We will now move on and dive deeper into blockchain development
    by familiarizing ourselves with decentralized smart contracts by implementing
    another blockchain use case.
  prefs: []
  type: TYPE_NORMAL
