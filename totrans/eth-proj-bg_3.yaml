- en: Creating Your Own Cryptocurrency on the Ethereum Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to have a look at how we can create our own ERC20
    token project. An ERC20 token is a cryptocurrency built on top of the Ethereum
    blockchain. We will have a look at its specifications, and how you can do an initial
    coin offering. We will also learn how to handle token transactions and transfer
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we''ll be covering in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cryptocurrency/ERC20 token project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC20 standard/specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial coin offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling token transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an ERC20 token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to create an ERC20 token. We will start
    by setting up a new project—we are going to use the OpenZeppelin Solidity framework
    to create our project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenZepplin Solidity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenZeppelin is basically just a collection of smart contracts that you can
    import into your own smart contracts in order to speed up your development. They
    can also make your smart contracts much more secure from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visit the OpenZeppelin GitHub page at [OpenZeppelin Github](http://www.github.com/OpenZeppelin/zeppelin-solidity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2675b021-a75e-44b5-bbd6-e3d3e05405f3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have been browsing through the Truffle website—[truffleframework.com](http://truffleframework.com)—then
    you have probably come across **Ganache**. We will be using it throughout this
    section. **Ganache** is a GUI that is basically easier to navigate with than TestRPC,
    but while doing all the same things as TestRPC. You can download it for Windows
    or any other OS if you go to Ganache's GitHub page at [Ganache GitHub](http://github.com/trufflesuite/ganache/releases).
  prefs: []
  type: TYPE_NORMAL
- en: The `ethereumjs-testrpc` has been deprecated and it has been renamed to `ganache-cli`.
    For detailed information you can visit the following link: [https://www.npmjs.com/package/ethereumjs-testrpc](https://www.npmjs.com/package/ethereumjs-testrpc).
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading it, you can run it. Upon opening the application, you will
    see a UI similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f00892a4-8f01-4998-9227-697dccd128e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Ganache
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be familiar: These are your 10 accounts that are generated by TestRPC.
    You can see your blocks, your transactions, and your logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a new project, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the console, run the truffle command, `truffle –cli unbox webpack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8620dd90-dfc1-4dc6-a3ea-5b6544fb21d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the `npm install –E` command. Because OpenZeppelin recommends specifying
    `–E` and will pull a specific version of OpenZeppelin, it will never update it,
    and will keep the same version. This is because it doesn't have semantic versioning
    yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install –E zeppelin-solidity`. OpenZeppelin is a lot more secure because
    it has been built with security in mind from the very start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's switch over to the editor now. Here, we will find our starter project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lets start by removing things that we don''t need. Under migrations, click
    on `deploy contracts` and remove the deployment of the `ConvertLib` by deleting
    the `ConvertLib` variable and the `deployer.deploy()` variable; allow to `deployer.link()`
    keep the `MetaCoin` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7429c1ca-f9ea-48a7-9506-25558992c97a.png)'
  prefs: []
  type: TYPE_IMG
- en: Go into the `contracts` folder and delete `ConvertLib.sol` by right-clicking
    on it and then clicking Delete File.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MetaCoin Solidity` file, remove `ConvertLib`. Remove all of the function
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the standard token from OpenZeppelin. OpenZeppelin is a basic ERC20
    interface that we can use by running the command `import ‘zeppelin-solidity/contracts/tokens/ERC20/StandardToken.sol'';`.
    This imports the `StandardToken` Solidity file from the OpenZeppelin framework,
    and it knows to look inside of your `node modules` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0536254-d545-44ac-aef0-3d01ffcb216f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now define MetaCoin for this. Ahead of `contract MetaCoin` add `is StandardToken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s migrate MetaCoin. Make sure that Ganache is running. Under RPC server,
    you should seethat Ganache runs on localhost or port number `7545`. Truffle by
    default runs on `7545`; you should be able to see this in the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccfd635f-3f4c-4ca5-bb24-88c1a17f0ff9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to migrate the `MetaCoin`, we can run the `truffle -cli migrate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e501bc0a-a5ed-4428-8d0f-fada8f6d6f35.png)'
  prefs: []
  type: TYPE_IMG
- en: You should now see that it's compiling your MetaCoin, migrations, and also a
    lot of files from the OpenZeppelin framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After performing all of these steps, our Ganache should look something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9448fa85-3e49-4d4e-9b07-1bca8b6d2a77.png)'
  prefs: []
  type: TYPE_IMG
- en: Ganache after making contract calls
  prefs: []
  type: TYPE_NORMAL
- en: You should now see that your transactions have gone through. Ganache has made
    a contract call, creating contracts. We are all set to proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing ERC20 tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will have a look at how we can deploy and test our ERC20
    token, or cryptocurrency. We will have a look at some of the pitfalls and security
    concerns that you may encounter when you are transferring tokens, and we will
    look at the Solidity and JavaScript that will be required to transfer those tokens.
    We will also be testing them out using Ganache and MetaMask.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ERC20 tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we need some data to enter into the editor. In the `MetaCoin.sol`,
    we need to define a name, a symbol, the number of decimal places, and `INITIAL_SUPPLY`.
    We will also assign our `INITIAL_SUPPLY` to the `totalSupply `in the constructor.
    We will also give the creator of the token the `INITIAL_SUPPLY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that we need `totalSupply` because if you go to `StandardToken`, found
    under `node modules` | `zeppelin-solidity` | `contracts` | `token` | `ERC20` |
    `StandardToken`, then you can see that this imports `ERC20` and `BasicToken`.
    Now, if we go to the `ERC20` folder, we can see that this is an interface, but
    `BasicToken.sol` implements this interface. So let''s go to the `BasicToken.sol`
    folder. It will have `totalSupply`, `balances`. I hope you remember this from
    the last chapter. It has a `Transfer` function that makes use of `SafeMath` from
    the `SafeMath.Solidity` file. This a little Solidity file that will make sure
    that whenever you perform a mathematical operation, your input and your output
    data will be correct, and that it won''t corrupt anything, because once data is
    inside the blockchain, it stays in the blockchain. So, after defining this, we
    can just go ahead and deploy it. Go through the following steps to deploy the
    ERC20 tokens, your first cryptocurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's make sure that Ganache is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Ganache is running, copy the mnemonic and paste it in the [metamask.io](http://metamask.io) Restore
    Vault. We have done this before, as you might remember.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can even reinstall MetaMask to reset everything. This makes it simpler,
    as MetaMask doesn't have this functionality yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press OK. You should see nothing, initially. Check for the network. If you
    are on your main network, you will have to connect to `http://localhost:7545`—this
    is the port that Ganache is listening on. You can do this by clicking the drop-down
    arrow beside the main network and selecting `Custom RPC`. Type in the localhost
    URL mentioned previously and click Save. You should see that MetaMask has instantly
    connected. You can have a look at your account; you should have some ether:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1191462-9f3b-48a1-83b3-bb8645ff3567.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to the `migrations`folder and make sure that it has `var MetaCoin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's go to `MetaCoin.sol`. Note that the `INITIAL_SUPPLY` will divided by the
    amount of decimals specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the terminal window. Type the `truffle-cli migrate` command. You
    should be able to see the transactions that have come up successfully. Copy the
    contract token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f17ab458-457d-4c1a-8085-de25ea7dd5c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Contract token
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying this, you can head over to MetaMask. Access the top-left icon,
    click on `Add Token`, and paste the token address in the token address section.
    It will automatically retrieve the token symbol and the specified number of decimals.
    Click on Add. You will see your first tokens, preceded by your symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd377721-d1c1-42d0-81d2-965bc375a56d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can create an account by clicking the user icon above. You will now
    have a second account. Get out of the token tab and you will see that you have
    0 tokens on the second account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6a8ed9f-7b4c-412b-b816-452215de7d9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, there is a little surprise here. You can just use the code you already
    had to send these tokens over. The difference between the MetaCoin from the last
    example and this one is that now the tokens are actually following a real standard,
    namely, the ERC20 standard. It states that you need a name, a token symbol, decimals,
    and an `INITIAL_SUPPLY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To transfer tokens run, the `npm run dev` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web browser and navigate to `localhost:8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b849bc8-624c-4dc8-86eb-2499e1042d9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the editor. The JavaScript function will still try to call the `getBalance`
    function, but this has been changed. You can see this if you go to the `BasicToken
    Solidity` file; you will see that you have `balanceOf`. So let''s go to the `app`
    | `JavaScripts` | `app.js` and then on to the `refreshBalance` function. Here,
    we change the `meta.getBalance` to `meta.balanceOf`. Also, go to the `sendCoin`
    function and change `meta.sendCoin` to `meta.transfer`. Make sure that you have
    the same kind of method signature in `BasicToken.sol`under the `ERC20` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e21aa84-39f6-4e3a-a43f-a6bce2c0001d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go to the browser on the `localhost:8080` page. Switch to the first account.
    There it is. You won''t see the decimals in place, but that is just a frontend
    stuff; we will look into that later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8151c1b8-5ca2-4118-afe7-0408e782920b.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing ERC20 tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now test on your second account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the address of your second account, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b668477c-2f1e-4fac-9298-7b03ff636a44.png)'
  prefs: []
  type: TYPE_IMG
- en: Copying the address of the second account
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to make the change in the `app.js` file in the `javascript` folder
    under the `app` directory of your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea3e3bf5-a511-4b6f-97a4-b26fca502392.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Switch to the first account and send your MetaCoin. Put in a value, such as
    5,000,000 units (equal to 5 tokens). This value should be less than the value
    specified in the `INITIAL_SUPPLY`. Remember that `INITIAL_SUPPLY` divided by the
    decimals will give 5 tokens, hence 5,000,000\. Paste the address and click Send
    MetaCoin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/690bbde6-e618-448a-8294-67a6b912c310.png)![](img/c6e9c514-620a-4d4f-8be8-102e41a36181.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On refreshing the page, you will see that both of your accounts will have tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e159a974-4452-49a9-991d-05173b43146e.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now created your first ERC20 standard cryptocurrency and deployed it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding token standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will have a deeper look into ERC20 tokens and why there
    was a need for other token standards, such as ERC721 and ERC827.
  prefs: []
  type: TYPE_NORMAL
- en: ERC20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go to [Ethereum wiki](https://theethereum.wiki/w/index.php/ERC20_Token_Standard) and
    have a look at the ERC20 token standards, you can see all the functions and events
    that you can implement. Moreover, most tokens are ERC20 compliant. You can see
    that the **Golem network token** (**GNT**) is only partially ERC20 compliant,
    but it is still a standard token; you don't exactly have to follow everything,
    but it is always better if you do. Among these functions, what we haven't seen
    before is `allowance` and `approve`. These functions can be useful in certain
    situations. If, for example, you have 20 MetaCoin tokens, you can say *I want
    my friend or another account to spend tokens in my name*. Well, you can do this
    with the `approve` function. With the `allowance` function, you can specify a
    spender and how many tokens you want them to be able to spend.
  prefs: []
  type: TYPE_NORMAL
- en: ERC721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets move on to [EIP GitHub](https://github.com/ethereum/EIPs/issues). EIP
    stands for Ethereum Improvement Protocol. Here, in the Issues tab, we can see
    a lot of discussions about improvements. If you feel that you can suggest an improvement,
    you can write it in a draft. It was through such discussions that somebody came
    up with [ERC: Non-Fungible Token Standard](https://github.com/ethereum/EIPs/issues/721).'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's define what a fungible token is. By definition, a fungible token
    is spendable for a set amount of goods or services or other tradeable items. In
    a similar manner, a dollar can be spent or a dollar can be traded for a euro.
    in that respect, non-fungible tokens are more like baseball cards, where you can
    have two of either can quote or unquote options on the same card, but one can
    have more value than the other because of the value that people attach to it.
    This is the case with ERC721 tokens. If you go to [ERC-721 definition](https://gist.github.com/aunyks/2d148a77150247f6f9745286ff46fc53#file-erc721-definitions-sol),
    you can see a brief definition. You can see the `name()`, `symbol()`, and `totalsupply()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this definition, you can have a token, and a token has an owner; you don''t
    have to give the token to the owner, you can just trade it. The token also has
    metadata, and this metadata specifies which properties a token has, which then
    means that it has a value. So this very much makes these tokens like baseball
    cards, or, if you''re familiar with them, Ethereum CryptoKitties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df67212d-e391-4eba-b8b2-9d986d380b3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'CryptoKitties is an example of this kind of token. It is a collectible, breedable,
    and adorable kind of token. Visit [cryptokitties.co](http://cryptokitties.co) for
    more information. At their marketplace, you can see CryptoKitties for sale. Some
    are being sold by people like you and me for ethers, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae32a3ef-3c26-4063-babf-6441c503a642.png)'
  prefs: []
  type: TYPE_IMG
- en: CryptoKitties Marketplace
  prefs: []
  type: TYPE_NORMAL
- en: Some of them are even exclusive CryptoKitties. They are really special tokens
    sold for a high number of ethers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can trade these CryptoKitties for ether, and the price will always vary
    according to what you want to set. These are some of my kitties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49bd4d93-e219-4130-a842-d120b2635664.png)'
  prefs: []
  type: TYPE_IMG
- en: My kitties
  prefs: []
  type: TYPE_NORMAL
- en: ERC827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, if you visit [EIP GitHub](http://github.com/ethereum/EIPs/issues/827),
    you will get an abstract, and an explanation as to why we need the ERC827 token
    standard. You can actually specify some data or a function that you want to be
    executed once a transfer has taken place. This can be done using the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find this function following link: [https://github.com/ethereum/EIPs/issues/827](https://github.com/ethereum/EIPs/issues/827).
  prefs: []
  type: TYPE_NORMAL
- en: You call the preceding function on the address of the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: This is all about the token standards. This is not the end—a lot of new token
    standards will surely be coming in the future. There are certainly a lot of proposals.
    Not all of them get accepted, but when they do, that is because they really bring
    something new to the table. You can even go ahead and place an improvement; who
    knows, it may turn out to be a new token standard! Now we can learn how to use
    our tokens to pay for the execution of some logic for a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Using tokens and executing logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering how a third person could execute a call upon receiving
    tokens. Actually, it is ridiculously easy. This can be done in JavaScript using
    the Web3 library provided by Ethereum. The following is a smart contract shown
    on remix. We have explored remix earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/583bedcc-f0c7-4b59-a921-23078441d362.png)'
  prefs: []
  type: TYPE_IMG
- en: A smart contract
  prefs: []
  type: TYPE_NORMAL
- en: This just increments an integer, checks whether it's less than 10, and returns
    true if it is; it returns false otherwise. You can just use JavaScript VM for
    this problem. On compiling and running, if you click the `SampleFunc`, there will
    be a new entry added in the gray area. If you click on Details, you will see an
    input entry—you can copy this. This will be your third parameter for this function.
    You can execute this like any other function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you send tokens using the ERC827 smart contract, this function will
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: But what is the use of this? In a word, security. A recipient can withdraw tokens,
    quote or unquote, and receive them. The reason for this the operation that in
    a smart contract, you don't want to just send tokens and assume that it has been
    successful. Assuming success like this has led to some pretty big hacks in the
    past. What you can do is go for some kind of withdrawal scheme where you send
    tokens and then make them available for withdrawal by the recipient.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create ERC20 tokens, and then deploy and
    test them. We also looked at different token standards, saw some examples of tokens,
    such as CryptoKitties, and saw the scope of new standards that may come in the
    future. We also learned how to use these tokens and execute logic when someone
    receives these tokens. In the next chapter, we will learn how to sign documents
    and work with bigger files, and then build an application using this knowledge!
  prefs: []
  type: TYPE_NORMAL
