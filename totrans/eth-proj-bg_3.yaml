- en: Creating Your Own Cryptocurrency on the Ethereum Blockchain
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在以太坊区块链上创建你自己的加密货币
- en: In this chapter, we are going to have a look at how we can create our own ERC20
    token project. An ERC20 token is a cryptocurrency built on top of the Ethereum
    blockchain. We will have a look at its specifications, and how you can do an initial
    coin offering. We will also learn how to handle token transactions and transfer
    value.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何创建我们自己的 ERC20 代币项目。ERC20 代币是建立在以太坊区块链之上的加密货币。我们将查看其规范，以及如何进行首次代币发行。我们还将学习如何处理代币交易和转移价值。
- en: 'The topics that we''ll be covering in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖的主题如下：
- en: Creating a cryptocurrency/ERC20 token project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个加密货币/ERC20 代币项目
- en: ERC20 standard/specification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ERC20 标准/规范
- en: Initial coin offerings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次代币发行
- en: Handling token transactions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理代币交易
- en: Creating an ERC20 token
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 ERC20 代币
- en: In this section, you will learn how to create an ERC20 token. We will start
    by setting up a new project—we are going to use the OpenZeppelin Solidity framework
    to create our project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建一个 ERC20 代币。我们将从设置一个新项目开始 —— 我们将使用 OpenZeppelin Solidity 框架来创建我们的项目。
- en: Installing OpenZepplin Solidity
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenZepplin Solidity
- en: OpenZeppelin is basically just a collection of smart contracts that you can
    import into your own smart contracts in order to speed up your development. They
    can also make your smart contracts much more secure from the get-go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenZeppelin 基本上只是一组智能合约，你可以导入到自己的智能合约中，以加快开发速度。它们还可以从一开始就使您的智能合约更加安全。
- en: 'You can visit the OpenZeppelin GitHub page at [OpenZeppelin Github](http://www.github.com/OpenZeppelin/zeppelin-solidity):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 OpenZeppelin 的 GitHub 页面，网址为 [OpenZeppelin Github](http://www.github.com/OpenZeppelin/zeppelin-solidity)：
- en: '![](img/2675b021-a75e-44b5-bbd6-e3d3e05405f3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2675b021-a75e-44b5-bbd6-e3d3e05405f3.png)'
- en: If you have been browsing through the Truffle website—[truffleframework.com](http://truffleframework.com)—then
    you have probably come across **Ganache**. We will be using it throughout this
    section. **Ganache** is a GUI that is basically easier to navigate with than TestRPC,
    but while doing all the same things as TestRPC. You can download it for Windows
    or any other OS if you go to Ganache's GitHub page at [Ganache GitHub](http://github.com/trufflesuite/ganache/releases).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在浏览 Truffle 网站 —— [truffleframework.com](http://truffleframework.com) ——
    那么你可能已经见过 **Ganache**。我们将在本节中一直使用它。**Ganache** 是一个 GUI，比 TestRPC 更容易导航，但做的事情和
    TestRPC 一样多。你可以在 Ganache 的 GitHub 页面上下载它，网址为 [Ganache GitHub](http://github.com/trufflesuite/ganache/releases)。
- en: The `ethereumjs-testrpc` has been deprecated and it has been renamed to `ganache-cli`.
    For detailed information you can visit the following link: [https://www.npmjs.com/package/ethereumjs-testrpc](https://www.npmjs.com/package/ethereumjs-testrpc).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ethereumjs-testrpc` 已被弃用，并更名为 `ganache-cli`。详细信息请访问以下链接：[https://www.npmjs.com/package/ethereumjs-testrpc](https://www.npmjs.com/package/ethereumjs-testrpc)。'
- en: 'After downloading it, you can run it. Upon opening the application, you will
    see a UI similar to the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您可以运行它。打开应用程序后，您将看到类似以下屏幕截图的界面：
- en: '![](img/f00892a4-8f01-4998-9227-697dccd128e5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f00892a4-8f01-4998-9227-697dccd128e5.png)'
- en: Ganache
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache
- en: 'This should be familiar: These are your 10 accounts that are generated by TestRPC.
    You can see your blocks, your transactions, and your logs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉：这些是由 TestRPC 生成的 10 个帐户。你可以看到你的区块、你的交易和你的日志。
- en: Setting up new project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目
- en: 'To set up a new project, go through the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个新项目，请按以下步骤操作：
- en: Create a new folder for the project.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目创建一个新文件夹。
- en: On the console, run the truffle command, `truffle –cli unbox webpack`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台上，运行 truffle 命令，`truffle –cli unbox webpack`。
- en: '![](img/8620dd90-dfc1-4dc6-a3ea-5b6544fb21d9.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8620dd90-dfc1-4dc6-a3ea-5b6544fb21d9.png)'
- en: Run the `npm install –E` command. Because OpenZeppelin recommends specifying
    `–E` and will pull a specific version of OpenZeppelin, it will never update it,
    and will keep the same version. This is because it doesn't have semantic versioning
    yet.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install –E` 命令。因为 OpenZeppelin 建议指定 `–E`，并将拉取一个特定版本的 OpenZeppelin，它永远不会更新它，并将保持相同的版本。这是因为它还没有语义化版本控制。
- en: Run `npm install –E zeppelin-solidity`. OpenZeppelin is a lot more secure because
    it has been built with security in mind from the very start.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install –E zeppelin-solidity`。OpenZeppelin 更加安全，因为它从一开始就考虑了安全性。
- en: Let's switch over to the editor now. Here, we will find our starter project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们切换到编辑器。在这里，我们将找到我们的起始项目。
- en: 'Lets start by removing things that we don''t need. Under migrations, click
    on `deploy contracts` and remove the deployment of the `ConvertLib` by deleting
    the `ConvertLib` variable and the `deployer.deploy()` variable; allow to `deployer.link()`
    keep the `MetaCoin` variable:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始删除我们不需要的东西。在迁移中，点击 `deploy contracts` 并删除 `ConvertLib` 的部署，即删除 `ConvertLib`
    变量和 `deployer.deploy()` 变量；但是让 `deployer.link()` 保留 `MetaCoin` 变量：
- en: '![](img/7429c1ca-f9ea-48a7-9506-25558992c97a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7429c1ca-f9ea-48a7-9506-25558992c97a.png)'
- en: Go into the `contracts` folder and delete `ConvertLib.sol` by right-clicking
    on it and then clicking Delete File.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `contracts` 文件夹，并通过右键单击删除 `ConvertLib.sol` 来删除它。
- en: In the `MetaCoin Solidity` file, remove `ConvertLib`. Remove all of the function
    code.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MetaCoin Solidity` 文件中，删除 `ConvertLib`。删除所有的函数代码。
- en: 'Import the standard token from OpenZeppelin. OpenZeppelin is a basic ERC20
    interface that we can use by running the command `import ‘zeppelin-solidity/contracts/tokens/ERC20/StandardToken.sol'';`.
    This imports the `StandardToken` Solidity file from the OpenZeppelin framework,
    and it knows to look inside of your `node modules` folder:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 OpenZeppelin 中导入标准代币。OpenZeppelin 是一个基本的 ERC20 接口，我们可以通过运行命令 `import ‘zeppelin-solidity/contracts/tokens/ERC20/StandardToken.sol'`
    来使用它。这导入了 OpenZeppelin 框架中的 `StandardToken` Solidity 文件，并且它知道要在您的 `node modules`
    文件夹中查找：
- en: '![](img/b0536254-d545-44ac-aef0-3d01ffcb216f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0536254-d545-44ac-aef0-3d01ffcb216f.png)'
- en: We can now define MetaCoin for this. Ahead of `contract MetaCoin` add `is StandardToken`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为此定义 MetaCoin。在 `contract MetaCoin` 之前添加 `is StandardToken`。
- en: 'Now let''s migrate MetaCoin. Make sure that Ganache is running. Under RPC server,
    you should seethat Ganache runs on localhost or port number `7545`. Truffle by
    default runs on `7545`; you should be able to see this in the editor:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们迁移 MetaCoin。确保 Ganache 正在运行。在 RPC 服务器下，你应该看到 Ganache 运行在本地主机或端口号为 `7545`。Truffle
    默认运行在 `7545`；您应该能够在编辑器中看到这一点：
- en: '![](img/ccfd635f-3f4c-4ca5-bb24-88c1a17f0ff9.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccfd635f-3f4c-4ca5-bb24-88c1a17f0ff9.png)'
- en: 'Now, to migrate the `MetaCoin`, we can run the `truffle -cli migrate` command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要迁移 `MetaCoin`，我们可以运行命令 `truffle -cli migrate`：
- en: '![](img/e501bc0a-a5ed-4428-8d0f-fada8f6d6f35.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e501bc0a-a5ed-4428-8d0f-fada8f6d6f35.png)'
- en: You should now see that it's compiling your MetaCoin, migrations, and also a
    lot of files from the OpenZeppelin framework.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该看到它正在编译您的 MetaCoin、迁移以及一堆来自 OpenZeppelin 框架的文件。
- en: 'After performing all of these steps, our Ganache should look something similar
    to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完所有这些步骤后，我们的 Ganache 应该看起来类似于以下内容：
- en: '![](img/9448fa85-3e49-4d4e-9b07-1bca8b6d2a77.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9448fa85-3e49-4d4e-9b07-1bca8b6d2a77.png)'
- en: Ganache after making contract calls
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行合同调用后的 Ganache
- en: You should now see that your transactions have gone through. Ganache has made
    a contract call, creating contracts. We are all set to proceed further.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到您的交易已经完成。Ganache 已经进行了合同调用，创建了合同。我们已经准备好继续进行了。
- en: Deploying and testing ERC20 tokens
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试 ERC20 代币
- en: In this section, we will have a look at how we can deploy and test our ERC20
    token, or cryptocurrency. We will have a look at some of the pitfalls and security
    concerns that you may encounter when you are transferring tokens, and we will
    look at the Solidity and JavaScript that will be required to transfer those tokens.
    We will also be testing them out using Ganache and MetaMask.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分，我们将看一下如何部署和测试我们的 ERC20 代币，或者加密货币。我们将看一下在转移代币时可能会遇到的一些潜在问题和安全问题，我们将查看所需的
    Solidity 和 JavaScript 来进行转移代币。我们也将使用 Ganache 和 MetaMask 进行测试。
- en: Deploying ERC20 tokens
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 ERC20 代币
- en: First of all, we need some data to enter into the editor. In the `MetaCoin.sol`,
    we need to define a name, a symbol, the number of decimal places, and `INITIAL_SUPPLY`.
    We will also assign our `INITIAL_SUPPLY` to the `totalSupply `in the constructor.
    We will also give the creator of the token the `INITIAL_SUPPLY`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些数据输入到编辑器中。在 `MetaCoin.sol` 中，我们需要定义一个名称、一个符号、小数点的数量和 `INITIAL_SUPPLY`。我们也将我们的
    `INITIAL_SUPPLY` 赋给构造函数中的 `totalSupply`。我们还将给予代币的创建者 `INITIAL_SUPPLY`。
- en: 'We know that we need `totalSupply` because if you go to `StandardToken`, found
    under `node modules` | `zeppelin-solidity` | `contracts` | `token` | `ERC20` |
    `StandardToken`, then you can see that this imports `ERC20` and `BasicToken`.
    Now, if we go to the `ERC20` folder, we can see that this is an interface, but
    `BasicToken.sol` implements this interface. So let''s go to the `BasicToken.sol`
    folder. It will have `totalSupply`, `balances`. I hope you remember this from
    the last chapter. It has a `Transfer` function that makes use of `SafeMath` from
    the `SafeMath.Solidity` file. This a little Solidity file that will make sure
    that whenever you perform a mathematical operation, your input and your output
    data will be correct, and that it won''t corrupt anything, because once data is
    inside the blockchain, it stays in the blockchain. So, after defining this, we
    can just go ahead and deploy it. Go through the following steps to deploy the
    ERC20 tokens, your first cryptocurrency:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要`totalSupply`，因为如果你去到 `StandardToken`，位于 `node modules` | `zeppelin-solidity`
    | `contracts` | `token` | `ERC20` | `StandardToken` 下，你会发现它导入了 `ERC20` 和 `BasicToken`。现在，如果我们去到
    `ERC20` 文件夹，我们会发现这是一个接口，但是 `BasicToken.sol` 实现了这个接口。所以让我们去到 `BasicToken.sol` 文件夹。它将拥有`totalSupply`，`balances`。我希望你还记得上一章的内容。它有一个
    `Transfer` 函数，使用了来自 `SafeMath.Solidity` 文件的 `SafeMath`。这是一个小的 Solidity 文件，它将确保每当你执行数学运算时，你的输入和输出数据都是正确的，并且不会损坏任何东西，因为一旦数据在区块链中，它就会保留在区块链中。所以，在定义了这一点之后，我们可以继续部署它。按照以下步骤部署
    ERC20 代币，你的第一个加密货币：
- en: Let's make sure that Ganache is running.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保 Ganache 正在运行。
- en: Once Ganache is running, copy the mnemonic and paste it in the [metamask.io](http://metamask.io) Restore
    Vault. We have done this before, as you might remember.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Ganache 运行起来了，复制助记词，粘贴到 [metamask.io](http://metamask.io) 的“恢复保险库”中。我们之前已经做过这个，你可能还记得。
- en: You can even reinstall MetaMask to reset everything. This makes it simpler,
    as MetaMask doesn't have this functionality yet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以重新安装 MetaMask 来重置所有内容。这会使事情变得更简单，因为 MetaMask 目前还没有这个功能。
- en: 'Press OK. You should see nothing, initially. Check for the network. If you
    are on your main network, you will have to connect to `http://localhost:7545`—this
    is the port that Ganache is listening on. You can do this by clicking the drop-down
    arrow beside the main network and selecting `Custom RPC`. Type in the localhost
    URL mentioned previously and click Save. You should see that MetaMask has instantly
    connected. You can have a look at your account; you should have some ether:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定。一开始你应该什么也看不到。检查网络。如果你在主网络上，你将不得不连接到 `http://localhost:7545` —— 这是 Ganache
    正在监听的端口。你可以通过点击主网络旁边的下拉箭头，并选择 `自定义 RPC` 来做到这一点。在上述本地主机 URL 中键入并保存。你应该看到 MetaMask
    已经立即连接上了。你可以查看你的账户；你应该有一些以太币：
- en: '![](img/d1191462-9f3b-48a1-83b3-bb8645ff3567.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1191462-9f3b-48a1-83b3-bb8645ff3567.png)'
- en: Go to the `migrations`folder and make sure that it has `var MetaCoin`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`migrations`文件夹，确保其中有`var MetaCoin`。
- en: Let's go to `MetaCoin.sol`. Note that the `INITIAL_SUPPLY` will divided by the
    amount of decimals specified.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们去`MetaCoin.sol`。请注意，`INITIAL_SUPPLY` 将被指定的小数位数除以。
- en: 'Switch to the terminal window. Type the `truffle-cli migrate` command. You
    should be able to see the transactions that have come up successfully. Copy the
    contract token:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到终端窗口。输入`truffle-cli migrate`命令。你应该能够看到成功出现的交易。复制合同代币：
- en: '![](img/f17ab458-457d-4c1a-8085-de25ea7dd5c9.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f17ab458-457d-4c1a-8085-de25ea7dd5c9.png)'
- en: Contract token
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 合同代币
- en: 'After copying this, you can head over to MetaMask. Access the top-left icon,
    click on `Add Token`, and paste the token address in the token address section.
    It will automatically retrieve the token symbol and the specified number of decimals.
    Click on Add. You will see your first tokens, preceded by your symbol:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制完这些内容后，你可以转到 MetaMask。访问左上角的图标，点击`添加代币`，并粘贴代币地址到代币地址部分。它将自动检索代币符号和指定的小数位数。点击添加。你将看到你的第一个代币，前面跟着你的符号：
- en: '![](img/bd377721-d1c1-42d0-81d2-965bc375a56d.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd377721-d1c1-42d0-81d2-965bc375a56d.png)'
- en: 'Now you can create an account by clicking the user icon above. You will now
    have a second account. Get out of the token tab and you will see that you have
    0 tokens on the second account:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以点击上方的用户图标创建一个账户。你现在会有一个第二个账户。退出代币标签页，你会发现你的第二个账户上有 0 个代币：
- en: '![](img/a6a8ed9f-7b4c-412b-b816-452215de7d9e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6a8ed9f-7b4c-412b-b816-452215de7d9e.png)'
- en: Now, there is a little surprise here. You can just use the code you already
    had to send these tokens over. The difference between the MetaCoin from the last
    example and this one is that now the tokens are actually following a real standard,
    namely, the ERC20 standard. It states that you need a name, a token symbol, decimals,
    and an `INITIAL_SUPPLY`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这里有一个小惊喜。你可以直接使用你已经有的代码来发送这些代币。与上一个示例中的MetaCoin的不同之处在于，现在这些代币实际上遵循了一个真正的标准，即ERC20标准。它规定你需要一个名称、一个代币符号、小数位数和一个`INITIAL_SUPPLY`。
- en: To transfer tokens run, the `npm run dev` commands.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要转移代币，请运行`npm run dev`命令。
- en: 'Open the web browser and navigate to `localhost:8080`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开网络浏览器并导航到`localhost:8080`：
- en: '![](img/9b849bc8-624c-4dc8-86eb-2499e1042d9a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b849bc8-624c-4dc8-86eb-2499e1042d9a.png)'
- en: 'Go to the editor. The JavaScript function will still try to call the `getBalance`
    function, but this has been changed. You can see this if you go to the `BasicToken
    Solidity` file; you will see that you have `balanceOf`. So let''s go to the `app`
    | `JavaScripts` | `app.js` and then on to the `refreshBalance` function. Here,
    we change the `meta.getBalance` to `meta.balanceOf`. Also, go to the `sendCoin`
    function and change `meta.sendCoin` to `meta.transfer`. Make sure that you have
    the same kind of method signature in `BasicToken.sol`under the `ERC20` folder:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到编辑器。JavaScript函数仍将尝试调用`getBalance`函数，但这已经改变了。如果你转到`BasicToken Solidity`文件，你会看到你有`balanceOf`。所以让我们去`app`
    | `JavaScripts` | `app.js`，然后到`refreshBalance`函数。在这里，我们将`meta.getBalance`改为`meta.balanceOf`。还要转到`sendCoin`函数并将`meta.sendCoin`更改为`meta.transfer`。确保你在`ERC20`文件夹下的`BasicToken.sol`中有相同类型的方法签名：
- en: '![](img/1e21aa84-39f6-4e3a-a43f-a6bce2c0001d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e21aa84-39f6-4e3a-a43f-a6bce2c0001d.png)'
- en: 'Now go to the browser on the `localhost:8080` page. Switch to the first account.
    There it is. You won''t see the decimals in place, but that is just a frontend
    stuff; we will look into that later:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`localhost:8080`页面的浏览器。切换到第一个账户。就是这样。你看不到小数点，但那只是一个前端的东西；我们以后会再看一下：
- en: '![](img/8151c1b8-5ca2-4118-afe7-0408e782920b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8151c1b8-5ca2-4118-afe7-0408e782920b.png)'
- en: Testing ERC20 tokens
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试ERC20代币
- en: We will now test on your second account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在你的第二个账户上进行测试。
- en: 'Copy the address of your second account, as shown in the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的第二个账户的地址，如下截图所示：
- en: '![](img/b668477c-2f1e-4fac-9298-7b03ff636a44.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b668477c-2f1e-4fac-9298-7b03ff636a44.png)'
- en: Copying the address of the second account
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 复制第二个账户的地址
- en: 'You need to make the change in the `app.js` file in the `javascript` folder
    under the `app` directory of your project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在项目的`app`目录下的`javascript`文件夹中的`app.js`文件中进行更改：
- en: '![](img/ea3e3bf5-a511-4b6f-97a4-b26fca502392.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea3e3bf5-a511-4b6f-97a4-b26fca502392.png)'
- en: 'Switch to the first account and send your MetaCoin. Put in a value, such as
    5,000,000 units (equal to 5 tokens). This value should be less than the value
    specified in the `INITIAL_SUPPLY`. Remember that `INITIAL_SUPPLY` divided by the
    decimals will give 5 tokens, hence 5,000,000\. Paste the address and click Send
    MetaCoin:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '切换到第一个账户并发送你的MetaCoin。输入一个值，比如5,000,000单位（等于5个代币）。这个值应该小于`INITIAL_SUPPLY`中指定的值。请记住，`INITIAL_SUPPLY`除以小数点将给出5个代币，因此是5,000,000。粘贴地址并点击发送MetaCoin:'
- en: '![](img/690bbde6-e618-448a-8294-67a6b912c310.png)![](img/c6e9c514-620a-4d4f-8be8-102e41a36181.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/690bbde6-e618-448a-8294-67a6b912c310.png)![](img/c6e9c514-620a-4d4f-8be8-102e41a36181.png)'
- en: 'On refreshing the page, you will see that both of your accounts will have tokens:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面后，你会看到你的两个账户都有代币：
- en: '![](img/e159a974-4452-49a9-991d-05173b43146e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e159a974-4452-49a9-991d-05173b43146e.png)'
- en: You have now created your first ERC20 standard cryptocurrency and deployed it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建了你的第一个ERC20标准加密货币并部署了它。
- en: Understanding token standards
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代币标准
- en: In this section, we will have a deeper look into ERC20 tokens and why there
    was a need for other token standards, such as ERC721 and ERC827.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地研究ERC20代币以及为什么需要其他代币标准，如ERC721和ERC827。
- en: ERC20
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERC20
- en: If you go to [Ethereum wiki](https://theethereum.wiki/w/index.php/ERC20_Token_Standard) and
    have a look at the ERC20 token standards, you can see all the functions and events
    that you can implement. Moreover, most tokens are ERC20 compliant. You can see
    that the **Golem network token** (**GNT**) is only partially ERC20 compliant,
    but it is still a standard token; you don't exactly have to follow everything,
    but it is always better if you do. Among these functions, what we haven't seen
    before is `allowance` and `approve`. These functions can be useful in certain
    situations. If, for example, you have 20 MetaCoin tokens, you can say *I want
    my friend or another account to spend tokens in my name*. Well, you can do this
    with the `approve` function. With the `allowance` function, you can specify a
    spender and how many tokens you want them to be able to spend.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去 [以太坊维基](https://theethereum.wiki/w/index.php/ERC20_Token_Standard) 查看 ERC20
    代币标准，你可以看到所有你可以实现的函数和事件。此外，大多数代币都符合 ERC20 标准。你可以看到 **Golem 网络代币** (**GNT**) 只是部分符合
    ERC20 标准，但它仍然是一个标准代币；你不一定要完全遵循所有规定，但如果你这样做总是更好。在这些函数中，我们以前没有见过的是 `allowance` 和
    `approve`。在某些情况下，这些函数可能很有用。例如，如果你有 20 个 MetaCoin 代币，你可以说*我希望我的朋友或另一个账户以我的名义花费代币*。嗯，你可以用
    `approve` 函数做到这一点。使用 `allowance` 函数，你可以指定一个花费者和你希望他们能够花费的代币数量。
- en: ERC721
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERC721
- en: 'Lets move on to [EIP GitHub](https://github.com/ethereum/EIPs/issues). EIP
    stands for Ethereum Improvement Protocol. Here, in the Issues tab, we can see
    a lot of discussions about improvements. If you feel that you can suggest an improvement,
    you can write it in a draft. It was through such discussions that somebody came
    up with [ERC: Non-Fungible Token Standard](https://github.com/ethereum/EIPs/issues/721).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们去 [EIP GitHub](https://github.com/ethereum/EIPs/issues)。EIP 指的是以太坊改进协议。在这里，在问题标签页，我们可以看到许多关于改进的讨论。如果你觉得你可以提出一个改进，你可以写成一份草案。正是通过这些讨论，有人提出了
    [ERC: 不可互换代币标准](https://github.com/ethereum/EIPs/issues/721)。'
- en: First, let's define what a fungible token is. By definition, a fungible token
    is spendable for a set amount of goods or services or other tradeable items. In
    a similar manner, a dollar can be spent or a dollar can be traded for a euro.
    in that respect, non-fungible tokens are more like baseball cards, where you can
    have two of either can quote or unquote options on the same card, but one can
    have more value than the other because of the value that people attach to it.
    This is the case with ERC721 tokens. If you go to [ERC-721 definition](https://gist.github.com/aunyks/2d148a77150247f6f9745286ff46fc53#file-erc721-definitions-sol),
    you can see a brief definition. You can see the `name()`, `symbol()`, and `totalsupply()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一下什么是可互换的代币。根据定义，可互换的代币可以用于购买一定数量的商品或服务或其他可交易物品。同样地，美元可以花费，或者美元可以用来交换欧元。在这方面，不可互换的代币更像是棒球卡片，你可以有两个同一张卡片的任意引号或非引号选项，但一个可能比另一个更有价值，因为人们给它的价值不同。这就是
    ERC721 代币的情况。如果你去 [ERC-721 定义](https://gist.github.com/aunyks/2d148a77150247f6f9745286ff46fc53#file-erc721-definitions-sol)，你可以看到一个简要定义。你可以看到
    `name()`，`symbol()` 和 `totalsupply()`。
- en: 'In this definition, you can have a token, and a token has an owner; you don''t
    have to give the token to the owner, you can just trade it. The token also has
    metadata, and this metadata specifies which properties a token has, which then
    means that it has a value. So this very much makes these tokens like baseball
    cards, or, if you''re familiar with them, Ethereum CryptoKitties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，你可以拥有一个代币，而且代币有一个所有者；你不必把代币交给所有者，你可以只是交易它。代币还有元数据，这个元数据指定了一个代币拥有哪些属性，这意味着它有一个价值。因此，这使得这些代币非常像棒球卡片，或者，如果你熟悉的话，以太坊
    CryptoKitties：
- en: '![](img/df67212d-e391-4eba-b8b2-9d986d380b3d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df67212d-e391-4eba-b8b2-9d986d380b3d.png)'
- en: 'CryptoKitties is an example of this kind of token. It is a collectible, breedable,
    and adorable kind of token. Visit [cryptokitties.co](http://cryptokitties.co) for
    more information. At their marketplace, you can see CryptoKitties for sale. Some
    are being sold by people like you and me for ethers, as shown in the following
    screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CryptoKitties 是这种类型代币的一个例子。它是一种可收集、可繁殖、可爱的代币。访问 [cryptokitties.co](http://cryptokitties.co)
    获取更多信息。在他们的市场上，你可以看到出售的 CryptoKitties。一些是由像你和我这样的人出售的，以太币，如下图所示：
- en: '![](img/ae32a3ef-3c26-4063-babf-6441c503a642.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae32a3ef-3c26-4063-babf-6441c503a642.png)'
- en: CryptoKitties Marketplace
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CryptoKitties 市场
- en: Some of them are even exclusive CryptoKitties. They are really special tokens
    sold for a high number of ethers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些甚至是独家的 CryptoKitties。它们是以高数量的以太币出售的非常特殊的代币。
- en: 'You can trade these CryptoKitties for ether, and the price will always vary
    according to what you want to set. These are some of my kitties:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这些CryptoKitties交易以太币，价格将会根据你所设置的内容而变化。这些是我的一些小猫：
- en: '![](img/49bd4d93-e219-4130-a842-d120b2635664.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49bd4d93-e219-4130-a842-d120b2635664.png)'
- en: My kitties
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的小猫
- en: ERC827
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERC827
- en: 'Again, if you visit [EIP GitHub](http://github.com/ethereum/EIPs/issues/827),
    you will get an abstract, and an explanation as to why we need the ERC827 token
    standard. You can actually specify some data or a function that you want to be
    executed once a transfer has taken place. This can be done using the following
    function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你访问[EIP GitHub](http://github.com/ethereum/EIPs/issues/827)，你将得到一个摘要，以及为什么我们需要ERC827代币标准的解释。你实际上可以指定一些数据或一个函数，在转账发生后执行。这可以通过以下函数完成：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find this function following link: [https://github.com/ethereum/EIPs/issues/827](https://github.com/ethereum/EIPs/issues/827).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到这个函数：[https://github.com/ethereum/EIPs/issues/827](https://github.com/ethereum/EIPs/issues/827)。
- en: You call the preceding function on the address of the receiver.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对接收方的地址调用上述函数。
- en: This is all about the token standards. This is not the end—a lot of new token
    standards will surely be coming in the future. There are certainly a lot of proposals.
    Not all of them get accepted, but when they do, that is because they really bring
    something new to the table. You can even go ahead and place an improvement; who
    knows, it may turn out to be a new token standard! Now we can learn how to use
    our tokens to pay for the execution of some logic for a smart contract.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都关于代币标准。这还不是结束——将来肯定会出现很多新的代币标准。肯定会有很多提案。并非所有提案都会被接受，但一旦被接受，那是因为它们确实为整个体系带来了一些新东西。你甚至可以提出改进；谁知道，它可能会变成一个新的代币标准！现在我们可以学习如何使用我们的代币为智能合约的一些逻辑支付。
- en: Using tokens and executing logic
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代币和执行逻辑
- en: 'You might be wondering how a third person could execute a call upon receiving
    tokens. Actually, it is ridiculously easy. This can be done in JavaScript using
    the Web3 library provided by Ethereum. The following is a smart contract shown
    on remix. We have explored remix earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道第三方是如何在收到代币后执行调用的。实际上，这非常容易。在JavaScript中，可以使用以太坊提供的Web3库来完成。以下是在remix上显示的智能合约。我们之前已经探索了remix：
- en: '![](img/583bedcc-f0c7-4b59-a921-23078441d362.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/583bedcc-f0c7-4b59-a921-23078441d362.png)'
- en: A smart contract
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个智能合约
- en: This just increments an integer, checks whether it's less than 10, and returns
    true if it is; it returns false otherwise. You can just use JavaScript VM for
    this problem. On compiling and running, if you click the `SampleFunc`, there will
    be a new entry added in the gray area. If you click on Details, you will see an
    input entry—you can copy this. This will be your third parameter for this function.
    You can execute this like any other function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是递增一个整数，检查它是否小于10，并且如果是，则返回true；否则返回false。你可以使用JavaScript VM解决这个问题。编译和运行后，如果点击`SampleFunc`，灰色区域会增加一个新的条目。如果点击详情，你会看到一个输入条目——你可以复制这个。这将是你为这个函数的第三个参数。你可以像执行其他函数一样执行它。
- en: Now, if you send tokens using the ERC827 smart contract, this function will
    be executed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用ERC827智能合约发送代币，这个函数将被执行。
- en: But what is the use of this? In a word, security. A recipient can withdraw tokens,
    quote or unquote, and receive them. The reason for this the operation that in
    a smart contract, you don't want to just send tokens and assume that it has been
    successful. Assuming success like this has led to some pretty big hacks in the
    past. What you can do is go for some kind of withdrawal scheme where you send
    tokens and then make them available for withdrawal by the recipient.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这有什么用呢？总的来说，安全性。接收方可以提取代币，引用或取消引用，并收到它们。原因在于智能合约中，你不希望仅仅发送代币并假设操作成功。像这样假设成功过去曾导致一些相当大的黑客攻击。你可以采用某种提取方案，在其中发送代币，然后使其可供接收方提取。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to create ERC20 tokens, and then deploy and
    test them. We also looked at different token standards, saw some examples of tokens,
    such as CryptoKitties, and saw the scope of new standards that may come in the
    future. We also learned how to use these tokens and execute logic when someone
    receives these tokens. In the next chapter, we will learn how to sign documents
    and work with bigger files, and then build an application using this knowledge!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何创建 ERC20 代币，然后部署和测试它们。我们还研究了不同的代币标准，看到了一些代币的示例，比如 CryptoKitties，并了解了可能在未来出现的新标准的范围。我们还学习了如何使用这些代币，并在有人收到这些代币时执行逻辑。在下一章中，我们将学习如何签署文件和处理更大的文件，然后利用这些知识构建一个应用程序！
