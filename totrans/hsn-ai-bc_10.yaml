- en: Development Life Cycle of a DIApp*“Fast. Good. Cheap. Choose any two.**”**-
    Unknown; used by many software project managers*
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore a broad set of new patterns that can be used
    in the **Software Development Life Cycle** (**SDLC**) of blockchain and AI-enabled
    applications. It will help you to build modern applications addressing the problems
    faced by various industries discussed in the previous chapters. Before introducing
    the SDLC aspects, we will also compare traditional blockchain applications with
    the next wave of intelligent decentralized applications. We will also explore
    the architectural aspects of the new types of applications that can be built under
    the revised SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying SDLC practices in blockchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to DIApps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing DIApps and DApps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a DIApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a DIApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a DIApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a DIApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a DIApp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires you to be capable of analyzing the benefits of the application
    of AI techniques along with the application of blockchain technology in the software
    development process across several application domains.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SDLC practices in blockchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With more than 10 years since the advent of blockchain technology, there is
    a need for newer emerging patterns that can apply blockchain technology and AI
    techniques to address the growing demands from the ever-expanding internet, and
    effectively manage the software development practices across various industry
    verticals.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore all the major aspects of SDLC step by step in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Ideation to productization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many ideas for building new applications on top of blockchain exist. However,
    fewer ideas are converted into designs. Although efforts are made to design decentralized
    applications, only a few designs are practical enough for the real world. This
    is due to the mismatch between product expectations and the readiness of technology
    at the developer’s disposal. In some cases, the technology and features may become
    available, but they may not be supported well enough due to the recent and unstable
    growth of these blockchains. Hence, it is a commonly perceived problem that not
    all ideas in blockchain can be converted into a product.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the limitations of the platforms themselves, there is also a tendency
    to **blockchain-ify** every existing solution, due to the **Fear of Missing Out**
    (**FOMO**) on opportunities. Some companies want to try it even when it may be
    unsuitable for their purpose, and this can lead to issues as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on my experience from the past three years of active development in the
    blockchain and AI spaces, these issues could be resolved by taking some of the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand the business process**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In most of the blockchain-based use cases I have come across, a clear understanding
    of the business process is crucial since a majority of blockchain solutions will
    be affecting the operational as well as financial aspects of a business. Therefore,
    it is important to educate all stakeholders about the business process in greater
    detail before dangerous assumptions can be made on the intricate steps involved
    or the method required.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a new solution is being developed to digitally transform a dairy
    firm using blockchain and AI, everyone on the team must have a comfortable understanding
    of the end-to-end process of bringing milk from the cattle farm to the table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish** **clear requirements**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a common observation in any emerging technology that most of the efforts
    are often hyped, thereby lacking the objective clarity needed to build apps. Before
    we can identify potential points of integration, we must have clarity on what
    pain points are being addressed by the application of blockchain or AI in the
    solution. All stakeholders must do their best here to clearly communicate the
    functional and non-functional requirements. This can be helpful in managing expectations
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the decision makers or owners of the organization may establish
    the need to achieve better transparency and accountability from the local cattle
    centers that produce raw unprocessed milk. The owners may also identify the need
    to analyze the current sales trends for all their dairy products in order to ensure
    that milk is made available for further processing to manufacture the necessary
    dairy products according to demand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify** **critical checkpoints in the business processes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the requirements have been identified and clarified, it is crucial to not
    jump straight into design in the case of blockchain. We must identify the current
    implementations and understand the critical business components and the checkpoints
    where technology must be applied and integrated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, identifying each cow in the cattle herd could be one of the most
    basic and foundational checkpoints for the team. Also, it is crucial to understand
    whether the volumes of raw milk collected at the local producers are manually
    inputted into the system or automated through a digital weight scale. In the case
    of maintaining a certain amount of milk as a reserve for other dairy products,
    it is important to understand who makes the decision or approves the manufacture
    of dairy goods out of the reserve milk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Check** **whether technology integration is feasible**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the checkpoints are identified, we can now identify various technical approaches
    to solve the problem and check whether the approach fits in the larger process.
    A lot of the time, unlike traditional solutions, blockchain developers are limited,
    either by the infrastructure and platforms, or by the lack of technical stability
    of the features supported by a given blockchain platform.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's assume that we want to identify each cow in the cattle herd
    by a **Radio Frequency Identification** (**RFID**) tag. Now, each cow tagged with
    an RFID tag must be virtually represented in the blockchain through a state variable.
    Here, it is imperative that the developers do not assume that the value of the
    RFID tag will be persistable on a blockchain. Most blockchain platforms have serious
    constraints on the type of data that can be stored. They also impose serious restrictions
    on the length and range of the data types that could be persisted in a blockchain
    through a smart contract, due to the blockchain's decentralized nature. In this
    case, we may want to identify the structure of an RFID tag and try to store it
    in a secondary storage network such as MóiBit to identify all cows in the herd.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in the case of measuring the volume of milk produced, it is imperative
    to identify whether a digital weight scale is capable of making a smart contract
    call in the blockchain. If the milk is collected from very remote areas, it is
    important to identify such operational impediments also.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is also very crucial to identify how the application of AI models
    on the information gathered on the blockchain can be harnessed to address user
    requirements. That is, designers, architects, and developers must be aware of
    the blockchain's transactional information and its data structure. Initial efforts
    must be made to understand that the transactional information can be processed
    in such a way as to ensure that an AI model can be trained sufficiently to predict
    the sales trends and set aside necessary milk reserves for milk-based dairy products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish technical dependency across affected components**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we identify potential integration points, we should carefully establish
    the technical dependencies. These dependencies can be either internal dependencies
    or external dependencies. Technical dependencies are internal if the development
    of a solution depends on its design, architecture, user stories, or acceptance
    criteria. The poor design of a given solution or information flow can cause many
    issues. Incomplete architectural decisions can also lead to issues in implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the need for better clarity in all aspects
    to build the ideal solution using blockchain and AI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f86358d-7d13-4528-8f36-6e049aa9281e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 7.1: A diagram representing various outcomes and the quality of solutions'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, as mentioned in the preceding diagram, ideal solutions can be
    achieved only when the requirements are very clear and specific, along with having
    the upper hand in technical capabilities. However, if the requirements are not
    fully documented, understood, nor communicated, the outcome is a partial solution
    that does not propose addressing the complete set of problems. The two other types
    of solutions in the left-side quadrants are poor and ineffective due to the lack
    of technical capabilities in establishing the dependencies with some room for
    ineffective documentation of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic understanding of what must be considered before the development
    of blockchain or AI solutions, let's now move forward and understand how these
    solutions are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to DIApps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before understanding what we mean by a **DIApp**, let's first understand what
    a decentralized application really is. **Decentralized applications** or **dApps**
    (also written as **DApp** or **Dapp**) are user applications that run on a platform
    hosted by a number of nodes in a distributed manner. DApps emerged as a solution
    architecture on top of blockchains wherein custom business logic could be programmed
    in a particular language of support. Once the logic is interpreted into code,
    we deploy this code on the respective blockchain platforms. Once the logic is
    deployed on the platform, we further integrate the logical program with frontend
    applications for user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to DApps, a **Decentralized Intelligent Application** (**DIApp**)
    is an enhanced pattern of a DApp that facilitates the application of AI wherever
    applicable, on top of a blockchain platform, in a much more robust manner that
    provides value to all stakeholders. Although the concept of slapping AI on top
    of solutions is not an unusual thing, **DIApps **are an understandable approach
    and a novel pattern that makes more sense for future generations of solutions
    built using both blockchain and AI.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, a DIApp is an application offering both decentralized
    and intelligent capabilities. Since it is a pattern inherited from DApps, it is
    decentralized by default, thanks to the implementation currently followed by all
    the blockchain platforms. However, DIApps have the exclusive capability of being
    more intelligent. This is made possible by an intermediary off-chain database
    that gives DIApps the ability to store big data from an application or the users
    through the application running on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram providers a general schematic of a DIApp as explained
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/929978be-070d-45ab-bc42-b9602ed25403.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 7.2: Composite view of the DIApp pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram depicts the composite view of a DApp within a DIApp pattern.
    The pattern is depicted in this fashion to help you understand the enhancements
    that are made to the existing pattern such that the application of AI can be facilitated.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic understanding of both the DApp and DIApp design patterns, let's
    now contrast them, weighing the pros and cons between the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparing DIApps and DApps**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will outline the issues faced by enterprises in developing
    and using DApps. Further, we will outline the solution architecture of both the
    DApp and DIApp patterns in the enterprise scenario and outline the key differences.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges in the enterprise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although several blockchain platforms represented new waves of experimental
    approaches, most of these approaches radically focused on the full disintermediation
    of all the entities involved in a business process, thereby making the solutions
    purely peer-to-peer. The reason for the full disintermediation in most of the
    emerging patterns is due to the maximalist nature of blockchain to decentralize
    the world. In contrast to this ideology, enterprise solutions fundamentally rely
    on maintaining accountability among key stakeholders without full disintermediation.
    Hence, there is a need for an enhanced pattern that is fit for adoption by enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Solution architecture of a DApp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution architecture of a DApp primarily comprises the following key points:'
  prefs: []
  type: TYPE_NORMAL
- en: The business logic is written in a **Domain-Specific Language** (**DSL**) in
    a smart contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smart contract is deployed on a blockchain network, identified by an address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smart contract will acquire a new address if the business logic is to be
    updated in a majority of the blockchain platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web or mobile application is developed as a client to access and carry out
    operations on the business logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all the critical data is stored on top of the blockchain, with little
    or no scope for analytical capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution architecture of a DIApp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution architecture of a DIApp primarily comprises adding technical capabilities
    to make the pattern more approachable by enterprises. Here are the key highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: Business logic is usually written in any high-level language such as C, Python,
    Java, or Golang, among others supported by the **Low-Level Virtual Machine** (**LLVM**)
    compiler. Also, normal smart contract languages can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of smart contracts are upgradeable, meaning that the code can be
    updated without having to change its address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional client applications can also integrate with these types of smart
    contracts as there is less need for integrating it with newer middleware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical business data is not only stored in blockchain networks but also in
    decentralized data storage systems to ensure better integrity of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a deeper dive into the aspects of the DIApp pattern, let's now identify
    some of the key differences between the two patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table offers a high-level comparison of both the patterns that
    you must be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **DApp** | **DIApp ** |'
  prefs: []
  type: TYPE_TB
- en: '| An application deployed on a blockchain platform with all the core logical
    elements. | Core logical elements are deployed on a blockchain platform, but are
    also powered by AI-driven insights in parallel. |'
  prefs: []
  type: TYPE_TB
- en: '| Data is mostly sitting on the blockchain platform, making it costly in terms
    of expense and time for retrieval. | Critical provenance data resides on the blockchain,
    but the remaining data is persisted on a cheaper off-chain storage system. |'
  prefs: []
  type: TYPE_TB
- en: '| Not all DApps are upgradeable, hence a new address is required for every
    update to the logic. This could break systems. | Most applications can easily be upgraded
    without making changes to the address, hence nothing breaks in the system. |'
  prefs: []
  type: TYPE_TB
- en: '| Data is rarely analyzed due to the cost of read-writes in a blockchain platform,
    and also due to the lack of structured data required to train AI models. | Data
    can be easily structured in an off-chain storage system and tightly coupled back
    to the blockchain platform as well as the AI models. |'
  prefs: []
  type: TYPE_TB
- en: With a detailed understanding of both the patterns, let's now explore the life
    cycle of DIApps across the stages of design, development, testing, and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a DIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design aspects of DIApps have been often considered to be somewhat challenging
    and dictated by the technical complications introduced in the constant waves of
    change seen in almost all blockchain platforms. It is also a common perception
    that the solution space lacks a common structure to define key components, resulting
    in an inconsistent design strategy for applications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the tools required by the user of an Ethereum-based DIApp are very
    distinct from that of Hyperledger Fabric, and subsequently, that of EOS. This
    is due to the distinct design of the respective blockchain’s UI/UX framework,
    which is deeply dependent on its own design paradigms. Hence, it is important
    to identify the design constraints of the application before commencing the future
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Before carving out a design for the DIApp, we must understand the research efforts
    explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before choosing which blockchain technology or platform you will use, it is
    critical to understand the user requirements, analyze them, and perform better
    research at an early stage of design. Instead of asking which blockchain technology
    can help address the requirements, consider these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the solution demand full decentralization over a public network for peer-to-peer
    interactions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the solution need to be implemented in a private network due to the extreme
    sensitivity of the data and minimal exposure of the business logic?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the solution be implemented on a public network with all the sensitive data
    encrypted on a public decentralized storage system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the same solution be implemented on a public network with all the sensitive
    data stored in a private virtual decentralized storage service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the solution require a permissioned network of authorized nodes across
    multiple stakeholders of a consortium?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the preceding pointers, we can undertake the following analysis. For
    scenario 5 in the preceding list, you are better off choosing a blockchain such
    as Hyperledger Fabric. However, in the cases of scenarios 3 and 4, you will need
    the **InterPlanetary File System** (**IPFS**) or an IPFS-based service provider
    who will encrypt the data and store it in a safe medium, offering security and
    redundancy with a secondary network. In scenario 2, you may be better off again
    with Hyperledger Fabric. Finally, in scenario 1, which might be the majority of
    cases, Ethereum might best fit your solution requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Formulating the **Proof of Concept** is an essential step in the development
    of solutions using emerging technologies. The development of proof of concepts
    for decentralized applications is also important, as they ensure alignment between
    the requirements and delivery of the solution. This helps maintain functional
    and design conformity right from the early days of development.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is notable that the proof of concept specifications may change due
    to the waves of design and architectural change in the blockchain landscape. Hence,
    proof of concepts should focus more on the functional viability of compatible
    patterns available to the developers.
  prefs: []
  type: TYPE_NORMAL
- en: Product-market fit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing the proof of concepts and prototyping the critical aspects of an
    application form a recursive practice until we are able to see a product-market
    fit. The definition and constraints of the product-market fit for DIApps cannot
    be general since each DIApp may target a specific problem in a specific domain.
    However, a few common attributes could help assert the product-market fit of a
    DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the DIApp solve a unique problem faced by various stakeholders in the industry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the DIApp disintermediate a current entity that is inefficient in the current
    process, or bring more order to the process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the benefits of DIApps be achieved only by utilizing the combination of
    blockchain and AI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the DIApp facilitate users to derive insights by using the DIApp with the
    help of AI models?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By answering the preceding questions, we may be able to identify whether the
    DIApp has achieved a suitable product-market fit. It is also important for you
    to identify other key indicators apart from the preceding general attributes to
    identify the product-market fit for your DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: With the basic knowledge and key points on the design aspects under our belts,
    let's now understand the key highlights of the development aspects of the SDLC
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a DIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of a DIApp can be tricky. Since AI and blockchain are yet to
    see the limelight in development, some practices in the industry are not yet visible
    to all. In this section, we will highlight the key development aspects of a DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring the technical aspects, let's understand a fundamental aspect
    of development capabilities in an organization. As blockchain and AI are on the
    bleeding edge of innovation, it is an open truth that many organizations are still
    in the process of building combined expertise in the respective technologies.
    Having said that, it is also essential to set up a team of members with complementary
    skill sets in smart contract development, web or mobile application development,
    and finally AI or data science modeling. The following section provides an overview
    of an ideal DIApp team.
  prefs: []
  type: TYPE_NORMAL
- en: Team formation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a corporate setup, I recommend the following team format for proof of concept
    development. It is assumed that the team members are enabled with regular technical
    and solution expertise:'
  prefs: []
  type: TYPE_NORMAL
- en: Two smart contract developers with good hands-on knowledge of the Solidity,
    Rust, and Golang programming languages are essential. Knowledge of Haskell is
    also preferred, since a few blockchains offer smart contracts based on functional
    programming languages. One smart contract developer may be able to focus on feature
    development and another smart contract developer could work on bug fixes, internal
    auditing, code quality reviews, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One full-stack web developer with basic knowledge of blockchain to develop the
    frontend web application. If the target audience is on mobile, you might choose
    a mobile application developer accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One SMACK-stack developer may be required to set up the analytics platform needed
    for building AI capabilities in the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One machine learning or deep learning engineer may be required to build the
    required models. If an application requires deep learning or a neural network,
    you should make your choice accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you may need one DevOps engineer to orchestrate the infrastructure
    and deploy all the necessary components across vendors or cloud platforms through
    a well-defined **Continuous Integration/Continuous Delivery** (**CI/CD**) pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An all-star team of six members with complementary skill sets can help develop
    the proof of concept and establish the needed technical features. The two smart
    contract developers can be replaced by one senior smart contract developer with
    end-to-end experience.
  prefs: []
  type: TYPE_NORMAL
- en: With a proper team setup, we shall discuss one of the best project management
    practices for delivering the proof of concept in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Agile development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the team is set up and the requirements are neatly documented, I recommend
    establishing a clear release plan for the proof of concept and the subsequent
    builds as much as possible. As mentioned earlier in the *Designing a DIApp *section,
    the technical aspects of blockchain technologies change very frequently. In order
    to match the pace of change, it is important to manage client expectations. Otherwise,
    it could lead to another level of complication on top of technical issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62732ef4-0ca0-489f-8e38-0fe577a316b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 7.3: Schematic of breaking down the release plan into workable tasks for
    the team'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, the requirements need to be documented very
    specifically and broken down into items across three levels. Managers and product
    owners both work on features in a release plan, whereas the product owner alone
    specifies the requirements for each aspect of the proof of concept or any release
    in the form of a user story. Once the user story is documented with an expected
    output, the team can collectively break it down into many work items or tasks.
    You can also break down the task into multiple sub-tasks for a large project beyond
    the proof of concept release for a better and more granular documentation of efforts.
    The tasks can be assigned to individuals and can be either blockchain-related
    or AI-related.
  prefs: []
  type: TYPE_NORMAL
- en: If the requirements are documented clearly, you can organize **sprint planning**.
    As per agile development, you can organize a sprint for at least 2 to 3 weeks.
    A proof of concept release can be planned across one or many sprints. At the end
    of each sprint, the team must organize a **retrospective meeting** to review the
    progress and reflect on the current practices.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to retrospectives of traditional apps, you could also identify the
    risks or issues created by the components. Since the ecosystem is still under
    development, the observed deficiencies can be converted into issues. The issues
    can be segregated and filed at the repositories on the respective dependencies.
    Most of the dependencies reside on GitHub. So, the developers must have sufficient
    awareness of the platform to navigate it, collaborate with others, and resolve
    the issues.
  prefs: []
  type: TYPE_NORMAL
- en: The process repeats across many sprints until all the features, requirements,
    and bug fixes have been addressed in alignment with the release plan.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic understanding and overview of the key aspects of developing a DIApp,
    let's now consider testing DIApps.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a DIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since these applications will most likely manage high-value assets and sensitive
    information, testing DIApps is a crucial step in the process before and after
    the deployment of all the modules in the network. Ensuring the correctness and
    lasting service of the application is critical for businesses and hence, it is
    a very important aspect of the development life cycle to bring back rigorous testing
    practices into the process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now go through the key highlights of the testing and deployment processes
    for a DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: Authoring the test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the software can be deployed, we can try to ensure the correctness of
    the software and also confirm the fitness of the runtime environment by running
    a few crucial tests. Usually, these tests are implemented within the source code, in
    the form of unit test files containing dummy input values being passed to the
    functions, later checked through assertion to ensure the correctness of the software
    in the relatively new environment. Each test case represents a scenario for the
    logic to perform and provide a predetermined output scenario. We will explore
    more about the generation of unit test cases in [Chapter 8](2642decc-1e7e-44f4-84a4-4b7a42ddda25.xhtml), *Implementing
    DIApps*, in a hands-on practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test cases are executed across two levels of testing: unit testing and integration
    testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each component in the DIApp pattern delivers an exclusive value to the solution.
    Hence, it is important to ensure the correctness of each component in the solution.
    This can be made possible by performing **unit testing**. Under unit testing,
    we can test the core functionalities of each module before integrating it with
    the other modules. Unit testing helps in formally verifying the correctness of
    these modules by comparing the real output to the desired output. This process
    repeats for each change made to the module, thereby preserving the correctness
    of the module each time a change has been made.
  prefs: []
  type: TYPE_NORMAL
- en: Once the modules are unit tested and integrated, we can perform integration
    testing, as explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the previous sections, a DIApp is a hybrid composition of many
    technologies. Hence, it is important to test the behavior of each heterogeneous
    component in order to ensure that they provide accurate results. This is achieved
    by performing **integration testing**. Once the components are integrated, we
    can run a few test cases that can formally verify the correctness of a few critical
    components that rely upon one or more heterogeneous components to provide output.
  prefs: []
  type: TYPE_NORMAL
- en: Testing AI models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although traditional software can be tested by unit tests and integrations tests,
    we need different measures and methods to test AI systems. Testing AI models and
    capabilities can be split into two phases. One phase of the testing is before
    the model reaches production. The other phase of the testing is applied post-production.
    Before bringing the AI model to production, testing can be performed by verifying
    the correctness and completeness of the training data. Similarly, once the AI
    models are deployed, we can test them frequently for accuracy and availability.
    Turing tests can also be performed to understand whether the AI model has sufficiently
    been able to replace a human response to the task.
  prefs: []
  type: TYPE_NORMAL
- en: With a fundamental understanding of testing in DIApp development under our belts,
    let's now go through the deployment process for a DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a DIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the common practices for deploying blockchain-based
    applications in hybrid environments. Unlike other emerging technologies, blockchain
    platforms demand a relatively larger stretch of time to set up the network and
    make the whole ecosystem functional. Accordingly, several blockchain platforms
    have understood the need for DevOps as an integral part of developing those platforms.
    Hence, it is also important to note that DevOps knowledge is also essential in
    using these platforms for developing applications and deploying solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the application for production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployment of the DIApp is the final crucial step in the life cycle. Apart from
    correctness, it is imperative that the application is designed, architected, and
    developed in a manner supportive for the deployment of the application in a scalable
    manner. The scale is not only measured in terms of the number of users, but also
    depends on the cost, form factors, and other economic attributes that may directly
    affect the operations.
  prefs: []
  type: TYPE_NORMAL
- en: Several tools such as Docker, Kubernetes, Ansible, Terraform, and Mesos are
    available for deploying DIApps and their dependencies. We will be exploring DevOps
    tools further in [Chapter 8](2642decc-1e7e-44f4-84a4-4b7a42ddda25.xhtml), *Implementing
    DIApps*, with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a DIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the common practices used by many to monitor
    transactions of applications in blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Explorers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the decentralized solutions are deployed on a public blockchain network
    or digital ledger. In most of the public networks, blockchain explorers are available
    to look up information concerning a transaction or block. However, if the DIApp solution
    is implemented in a private or permissioned environment, these public blockchain
    explorers may not be able to provide information on transactions belonging to
    a private network or private ledgers. Hence, we must be able to deploy existing
    blockchain explorers and plug them into the endpoints of a private service. This
    is the only way to facilitate users' monitoring of their transactions in a private
    environment. Several open source implementations of blockchain explorers are available,
    which could be downloaded and connected to private services.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of public blockchain explorers include Etherscan, EthStats, and
    BlockScout. We will discuss them in our next chapter. For example, BlockScout
    is an open source explorer that you can use to create a specific explorer for
    your private Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic definition of a DApp and a DIApp. We
    also contrasted both the solution architectures and design patterns of these two
    technologies. Based on the advantages of DIApps, we further explored the SDLC
    aspects of DIApps from ideation to release or deployment. The new economy of blockchain
    and AI requires a redefined SDLC that is inclusive of the new technologies involved.
    We have outlined the steps and processes to be considered before developing a
    DIApp.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on applying the development aspects of the
    SDLC by developing sample applications on various blockchain platforms, along
    with common AI techniques.
  prefs: []
  type: TYPE_NORMAL
