- en: Writing Smart Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how Quorum works and how the various consensus
    protocols safeguard it. Let's move on to writing smart contracts, now that we
    understand how Quorum works. Quorum smart contracts can be written using many languages;
    the most popular one is **Solidity**. In this chapter, we will learn Solidity,
    and build a DApp that enterprises can use to sign documents digitally.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The layout of Solidity source files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Solidity data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special variables and contract functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure and features of contracts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and deploying contracts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is same as chapter present in author's previous book *Blockchain
    for Projects*. This is not a second edition book,it is used to explain fundamental
    concepts to the readers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Solidity source files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can identify a Solidity source file by the `.sol` extension. It has various
    versions, as programming languages usually do. The latest version at the time
    of writing this book is `0.4.17`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'In the source file, you can use the `pragma Solidity` directive to mention
    the compiler version for which the code is written. For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is important to note that the source file will not compile with compiler
    versions earlier than `0.4.17` and later than `0.5.0` (this second condition is
    added using `^`). Compiler versions between `0.4.17` and `0.5.0` are most likely
    to include bug fixes and less likely to break anything.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We can specify more complex rules for the compiler version; the expression follows
    those used by `npm`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a smart contract
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A is akin to a class. It can functions, modifiers, state variables, events,
    structures, and enums. Contracts also support inheritance. You can implement inheritance
    by copying code during compiling. Smart contracts can also be polymorphic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following an example of a smart contract:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see how the aforementioned code works:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `contract` keyword to declare a contract.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared two state variables: `data` holds some data; and `owner`
    holds address of their Ethereum Wallet, that is, the address in which the contract
    was deployed. State variables form the state of the smart contract and it is stored
    in the storage of the smart contract. The storage of a smart contract is in the database.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we defined the event. Events are used for client notification. Our event
    will be triggered whenever data changes. All events are kept in the blockchain.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a modifier function. Modifiers automatically check a condition
    before executing a function. Our modifier checks whether the contract owner is
    the one invoking the function. If not, then it will throw an exception.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we have the contract constructor. It is invoked while deploying
    the contract. The constructor is used to initialize the state variables.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined two methods. The first method gets the value of the data
    state variable and the second changes the data value.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了两种方法。第一种方法获取数据状态变量的值，第二种方法更改数据值。
- en: Before delving more deeply into smart contract features, there are some important
    things related to Solidity we must learn. After that, we will come back to contracts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入研究智能合约功能之前，我们必须学习与 Solidity 相关的一些重要事项。之后，我们将回到合约。
- en: Data locations in Solidity
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity 中的数据位置
- en: Unlike other programming languages, Solidity's variables are stored in the memory
    and the database, depending on the context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，Solidity 的变量根据上下文存储在内存和数据库中。
- en: There is always a default location, but it can be overridden for complex types
    of data, such as strings, arrays, and structs, by appending storage or memory to
    the type. Memory is the default for function parameters (including `return` parameters),
    and storage is for local and state variables (obviously).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个默认位置，但可以通过附加 storage 或 memory 来覆盖复杂类型的数据，例如字符串、数组和结构体。Memory 是函数参数（包括 `return`
    参数）的默认值，而 storage 适用于局部和状态变量（显然）。
- en: 'Data locations are important because they change the behavior of assignments:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据位置很重要，因为它们会改变赋值的行为：
- en: An independent copy is always created for assignments between storage variables
    and memory variables. No copy is created, however, for assignments from one memory-stored
    complex type to another.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储变量和内存变量之间的赋值中，始终会创建独立的副本。但是，从一个内存存储的复杂类型赋值给另一个内存存储的复杂类型时，不会创建副本。
- en: An independent copy is always created for an assignment to a state variable
    (even from other state variables).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对状态变量进行赋值时，始终会创建独立的副本（即使来自其他状态变量）。
- en: Memory-stored complex types cannot be assigned to local storage variables.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在内存中的复杂类型不能赋值给局部存储变量。
- en: If state variables are assigned to local storage variables, the local storage
    variables point to the state variables; basically, local storage variables act
    as pointers.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态变量赋给局部存储变量，那么局部存储变量将指向状态变量；基本上，局部存储变量充当指针。
- en: The different types of data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的数据
- en: Solidity is a statically-typed language; the type of data the variable holds
    needs to be predefined. All the bits of the variables are assigned to zero by
    default. In Solidity, variables are function-scoped; that is, a variable declared
    anywhere within a function will be in scope for the entire function regardless
    of where it is declared.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是一种静态类型语言；变量持有的数据类型需要预定义。所有变量的位默认都被赋值为零。在 Solidity 中，变量是在函数范围内生效；也就是说，无论在函数的任何地方声明的变量都将在整个函数范围内生效。
- en: 'The following are the data types provided by Solidity:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 提供了以下数据类型：
- en: The most simple data type is `bool`. It can hold either `true` or `false`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的数据类型是 `bool`。它可以存储 `true` 或 `false`。
- en: '`uint8`, `uint16`, `uint24`, up to `uint256` are used to hold unsigned integers
    of 8 bits, 16 bits, 24 bits, up to 256 bits, respectively. Similarly, `int8`,
    `int16` up to `int256` are used to hold signed integers of 8 bits, 16 bits up
    to 256 bits, respectively. `uint` and `int` are aliases for `uint256` and `int256`. `ufixed`
    and `fixed` represent fractional numbers. `ufixed0x8`, `ufixed0x16` up to `ufixed0x256`
    are used to hold unsigned fractional numbers of 8 bits, 16 bits up to 256 bits,
    respectively. Similarly, `fixed0x8`, `fixed0x16` up to `fixed0x256` are used to
    hold signed fractional numbers of 8 bits, 16 bits up to 256 bits, respectively.
    If we have a number that requires more than 256 bits, then the 256 bits data type
    is used, in which case the approximation of the number is stored.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint8`、`uint16`、`uint24`，一直到 `uint256` 用于存储 8 位、16 位、24 位，一直到 256 位的无符号整数。同样地，`int8`、`int16`
    一直到 `int256` 用于存储 8 位、16 位，一直到 256 位的有符号整数。`uint` 和 `int` 是 `uint256` 和 `int256`
    的别名。`ufixed` 和 `fixed`代表分数。`ufixed0x8`、`ufixed0x16`，一直到 `ufixed0x256` 用于存储 8 位、16
    位，一直到 256 位的无符号分数。类似地，`fixed0x8`、`fixed0x16`，一直到 `fixed0x256` 用于存储 8 位、16 位，一直到
    256 位的有符号分数。如果我们有一个需要超过 256 位的数字，那么将使用 256 位数据类型，此时将存储数字的近似值。'
- en: Address is used to store up to a 20-byte value by assigning a hexadecimal literal.
    It is used to store Ethereum addresses. You can use the `0x` prefix in Solidity
    to assign a hexadecimal encoded representation of values to variables.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址（Address）用于存储最多 20 字节的值，通过分配十六进制字面量。它用于存储以太坊地址。您可以在 Solidity 中使用 `0x` 前缀，将十六进制编码的值赋给变量。
- en: Arrays
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Solidity supports generic and byte arrays, fixed-size and dynamic arrays, as
    well as multidimensional arrays.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '`bytes1`, `bytes2`, `bytes3`, up to , `bytes32` are types of byte arrays. We
    will use byte to represent `bytes1`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of generic array syntaxes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are some important things you should know about arrays:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Arrays also possess a `length` property that can be used to find the length
    of an array. `value` can also be assigned to the `length` property to change the
    array size. However, an array in memory or a non-dynamic array cannot be resized.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception is thrown if an unset `index` of a dynamic array is accessed.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings can be created in Solidity in two ways: using `bytes` and `string`.
    `bytes` is used to create a raw string, whereas `string` is used to create a UTF-8
    string. The length of the string is always dynamic.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows `string` syntaxes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Structs
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity structs. Here is an shows `struct` syntaxes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Enums
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity enums. Here is an shows `enum` syntaxes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Mappings
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **hash table** is a mapping data type. As mappings can only live in storage,
    they are declared as state variables. You can think of a mapping as having `key`
    and `value` pairs. `key` is not actually stored; instead, the **keccak256** hash
    of `key` is used to look up for `value`. Mappings don't have a length and cannot
    be assigned to another mapping.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of creating and using `mapping`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The delete operator
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `delete` operator can be applied to any variable to reset it to its default
    value. The default value is all bits assigned to zero.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: If we apply `delete` to a dynamic array, it will delete all its elements and
    the length becomes zero. And if we apply it to a static array, all its indices
    are reset. We can also apply `delete` to specific indices, to reset them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Nothing happens, though, if you apply `delete` to a map type. However, if you
    apply `delete` to `key` of a map, the value associated with `key` is deleted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `delete` operator at work, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Conversion between elementary types
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything apart from arrays, strings, structs, enums, and maps is called **elementary
    types**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply an operator to different types, the compiler tries to implicitly
    convert one of the operands into the type of the other. Generally speaking, an
    implicit conversion between value types is possible if it makes sense semantically
    and no information is lost: `uint8` is convertible to `uint16`, and `int128` to
    `int256`, but `int8` is not convertible to `uint256` (because `uint256` cannot
    hold, for example, `-1`). Furthermore, an unsigned integer can be converted into
    a byte of the same or a larger size, but not the reverse. Any type that can be
    converted into `uint160` can also be converted into an address.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Solidity also supports explicit conversion. You can opt for explicit conversion
    if the compiler does not allow implicit conversion between two data types. We
    recommend avoiding an explicit conversion as it may give you unexpected results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example of explicit conversion, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are converting the `uint32` type to `uint16` explicitly, that is, converting
    a large type to a smaller type; therefore, higher-order bits are cut off.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Using var
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To declare variables, Solidity provides the `var` keyword. The type of variable
    in this case is decided dynamically, depending on the first value assigned to
    it. Once a value is assigned, the type is fixed; if you assign another type to
    it, it will lead to type conversion.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `var` works, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `var` cannot be used when defining arrays and maps. It also cannot
    be used to define function parameters and state variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity supports `if...else`, `do...while`, `for`, `break`, `continue`, `return`,
    and `?:` control structures.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Here a of structures:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating contracts using the new operator
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A contract can create a new contract using the `new` keyword . The complete
    code for the contract being created must be known.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exceptions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, exceptions are thrown automatically. You can use `assert()`,
    `revert()`, and `require()` to throw manual exceptions. Exceptions stop and revert
    any currently-executing calls (that is, all changes to the state and balances
    are undone). In Solidity, it is not yet possible to catch exceptions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three lines are all different ways of throwing exceptions in
    Solidity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`assert()` will take away all the gas, whereas `require()` and `revert()` will
    refund the remaining gas.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Solidity doesn't support returning a reason for exceptions but is expected to
    soon. You can visit the [https://github.com/ethereum/solidity/issues/1686](https://github.com/ethereum/solidity/issues/1686) issue
    for an update. Then you will be able to write `revert("Something bad happened")` and `require(condition,
    "Something bad happened")`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: External function calls
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity has two kinds of function calls: internal and external. An internal
    function call is when a function calls another function in the same contract. An
    external function call is when a function calls a function of another contract.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calls made using the `this` keyword are called external calls. The `this` keyword
    inside functions represents the current contract instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Features of contracts
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to delve more deeply into contracts. Let's start with some new features
    and then we will go deeper into the features we have already seen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The visibility of a state variable or a function defines who can see it. There
    are four kinds of visibility: `external`, `public`, `internal`, and `private`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the visibility of functions is `public` and the visibility of state
    variables is `internal`. Let''s see what these visibility functions mean:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`external`: External functions can only be called from other contracts or via
    transactions. For example, we cannot call an `f` external function internally: `f()`
    will not work but `this.f()` will. We also cannot apply `external` visibility
    to state variables.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: Public functions and state variables can be accessed in every possible
    way. Compiler-generated accessor functions are all `public` state variables. It
    is not possible to create our own accessors. Actually, it generates only **getters**,
    not **setters**.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal`: Internal functions and state variables can only be accessed internally,
    that is, from within the current contract and the contracts inheriting it. We
    cannot use `this` to access it.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: Private functions and state variables are similar to internal ones,
    except they cannot be accessed by the inheriting contracts.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate visibility and accessors:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Function modifiers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen what a function modifier is, and we wrote a basic version
    of it. Now let's look at it in detail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers are inherited by child contracts, and they can also be overridden
    by child contracts. Multiple modifiers can be applied to a function by specifying
    them in a whitespace-separated list and they will be evaluated in order. You can
    also pass arguments to modifiers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Inside the modifier, the next modifier body or function body, whichever comes
    next, is inserted where `_;` appears.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a complex code example of function modifiers, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is how `myFunction()` is executed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, when you call the `myFunction` method, it will return `0`. But after that,
    when you try to access the state variable, `a`, you will get `8`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`return` in a modifier or function body immediately leaves the whole function,
    and the return value is assigned to whatever variable it needs to be.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In the case of functions, the code after `return` is executed after the caller's
    code-execution is completed. And in the case of modifiers, the code after `_;`
    in the previous modifier is executed after the caller's code-execution is completed.
    In the aforementioned example, line numbers five, six, and seven are never executed.
    After line number four, the execution starts directly from line numbers eight
    to ten.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`return` inside modifiers cannot have a value associated with it. It always
    returns zero bits.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The fallback function
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **fallback function** is the only unnamed function a contract can have.
    This function cannot have arguments and cannot return anything. It is executed
    on a call to the contract if none of the other functions match the given function
    identifier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This function is also executed whenever the contract receives Ether without
    any function call; that is, the transaction sends Ethereum to the contracts and
    doesn't invoke any method. In such a context, there is usually very little gas
    available for the function call (precisely 2,300 gas), so it is important to make
    fallback functions as cheap as possible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Contracts throw an exception when they receive Ether but do not have a defined
    fallback function, thereby sending back the Ether. So if you want your contract
    to receive Ethereum, you must implement a fallback function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a fallback function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inheritance
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity supports multiple inheritance by copying code, including polymorphism.
    Even if a contract inherits from multiple other contracts, only a single contract
    will be created on the blockchain. Moreover, the code from the parent contracts
    will always be copied into the final contract.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example of inheritance:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The super keyword
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `super` keyword is used to refer to the next contract in the final inheritance
    chain. The following is  an example to help you understand it better:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The final inheritance chain with respect to the `sample6` contract is `sample6`,
    `sample5`, `sample4`, `sample2`, `sample3`, `sample1`. The inheritance chain starts
    with the most-derived contracts and ends with the least-derived contract.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Abstract contracts
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract contracts are those that only contain the prototype of functions instead
    of the implementation. They cannot be compiled (even if they contain implemented
    functions alongside non-implemented functions). If a contract inherits from an
    abstract contract and does not implement all non-implemented functions by overriding,
    it will itself become abstract.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The reason abstract contracts are provided is to make the interface known to
    the compiler. This is useful for referring to a deployed contract and calling
    its functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Libraries
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries are similar to contracts, but they are deployed just once at a specific
    address and their code is reused by various contracts. This means that if library
    functions are called, their code is executed in the context of the calling contract;
    So, `this` points to the calling contract, and specifically, allows access to
    the storage from the calling contract. As a library is an isolated piece of source
    code, it can only access state variables of the calling contract if they are explicitly
    supplied (it would have no way to name them otherwise).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can contain structs and enums, but they cannot have state variables.
    They don't support inheritance and they cannot receive Ethereum.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Once a Solidity library is deployed to the blockchain, it can be used by anyone,
    assuming one knows its address and has the source code (with only prototypes or
    complete implementation). The source code is required by the Solidity compiler
    so it can ensure that the methods being accessed actually exist in the library.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The address of the library cannot be added in the contract source code. We need
    to provide the library address to the compiler during compilation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 库的地址无法添加到合约源代码中。我们需要在编译期间向编译器提供库地址。
- en: 'Libraries have many use cases. The two major use cases are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 库有许多用例。两个主要用例如下：
- en: If you have several contracts with some common code, you can deploy that common
    code as a library. This will save gas, which also depends on the contract size.
    Therefore, we can think of a library as a base contract of the contract that uses
    it. Using a base contract instead of a library to split the common code will not
    save gas, because inheritance in Solidity works by copying code. Because libraries
    are thought of as base contracts, functions with internal visibility in a library
    are copied to the contract that uses it. Otherwise, functions with the `internal`
    visibility of a library cannot be called by the contract that uses the library,
    as an external call would be required. Functions with the `internal` visibility
    cannot be invoked using the external call. In addition, structs and enums in a
    library are copied to the contract that uses the library.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有几个合约具有一些公共代码，你可以将该公共代码作为库部署。这将节省燃气，这也取决于合约的大小。因此，我们可以将库视为使用它的合约的基础合约。使用基础合约而不是库来拆分公共代码将不会节省燃气，因为
    Solidity 中的继承是通过复制代码实现的。因为库被认为是基础合约，所以库中具有内部可见性的函数会被复制到使用它的合约中。否则，具有库内部可见性的函数无法被使用库的合约调用，因为需要进行外部调用。具有内部可见性的函数无法使用外部调用调用。此外，库中的结构和枚举会被复制到使用库的合约中。
- en: Libraries can be used to add member functions to data types.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库可以用来为数据类型添加成员函数。
- en: A library containing only internal functions and/or structs/enums does not need
    to be deployed, as everything that's in the library is copied to the contract
    that uses it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含内部函数和/或结构/枚举的库不需要部署，因为库中的所有内容都会复制到使用它的合约中。
- en: using for
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `for`
- en: The `using A for B;` directive can be used to attach library functions (from
    the library, `A`, to any type, `B`). These functions will receive the object they
    are called on as their first parameter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`using A for B;` 指令可用于将库函数（来自库 `A`）附加到任何类型 `B` 上。这些函数将以调用它们的对象作为第一个参数。'
- en: The effect of `using A for *;` is that the functions from the library, `A`,
    are attached to all types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`using A for *;` 的效果是将库 `A` 的函数附加到所有类型上。'
- en: 'Here is an example to demonstrate `for`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示 `for` 的示例：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Returning multiple values
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'Solidity allows functions to return multiple values. Let''s demonstrate  this,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 允许函数返回多个值。让我们演示一下，如下所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Importing other Solidity source files
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入其他 Solidity 源文件
- en: 'Solidity allows a source file to import other source files. Here is an example
    to demonstrate this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 允许一个源文件导入其他源文件。下面是一个示例来演示这一点：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Globally-available variables
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局可用变量
- en: There are special variables and functions that always exist globally. We will
    discuss them in upcoming sections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的变量和函数总是全局存在。我们将在接下来的章节中讨论它们。
- en: Block and transaction properties
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块和交易属性
- en: 'The block and transaction properties are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 区块和交易属性如下所示：
- en: '`block.blockhash(uint blockNumber) returns (bytes32)`: The hash of the given
    block only works for the 256 most recent blocks.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block.blockhash(uint blockNumber) returns (bytes32)`: 给定区块的哈希仅适用于最近的 256 个区块。'
- en: '`block.coinbase (address)`: The current block''s miner''s address.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block.coinbase (address)`: 当前区块的矿工地址。'
- en: '`block.difficulty (uint)`: The current block''s difficulty.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block.difficulty (uint)`: 当前区块的难度。'
- en: '`block.gaslimit (uint)`: The current block''s gas limit. It defines the maximum
    amount of gas that all transactions in the whole block combined are allowed to
    consume. Its purpose is to keep the block-propagation and processing time low,
    thereby allowing a sufficiently decentralized network. Miners have the right to
    set the gas limit for the current block to be within ~0.0975% (1/1,024) of the
    gas limit of the last block, so the resulting gas limit should be the median of
    the miners'' preferences.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block.gaslimit (uint)`: 当前区块的燃气限制。它定义了整个区块中所有交易允许消耗的最大燃气量。其目的是保持区块传播和处理时间低，从而使网络足够去中心化。矿工有权将当前区块的燃气限制设置为上一个区块燃气限制的~0.0975%（1/1,024），因此结果燃气限制应该是矿工偏好的中位数。'
- en: '`block.number (uint)`: The current block''s number.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block.number (uint)`: 当前区块的编号。'
- en: '`block.timestamp (uint)`: The current block''s timestamp.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.data (bytes)`: The complete call data holds the function and its arguments
    that the transaction invokes.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.gas (uint)`: The remaining gas.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.sender (address)`: The sender of the message (the current call).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.sig (bytes4)`: The first four bytes of the call data (the function identifier).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.value (uint)`: The number of wei sent with the message.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now (uint)`: The current block''s timestamp (alias for block.timestamp).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx.gasprice (uint)`: The gas price of the transaction.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx.origin (address)`: The sender of the transaction (full call chain).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address-type-related variables
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Address-type-related variables are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`<address>.balance (uint256)`: The balance of the address in wei.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<address>.send(uint256 amount) returns (bool)`: Sends the given amount of
    wei to `address`; returns `false` on failure. Even if the execution fails, the
    current contract will not stop with an exception.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<address>.transfer(uint256 amount)`: Sends wei to an address. If that execution
    runs out of gas or fails, the Ether transfer will be reversed and the current
    contract will stop with an exception.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract-related variables
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contract-related variables are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: The current contract, explicitly convertible to the address type'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selfdestruct(address recipient)`: Destroys the current contract, sending its
    funds to the given address'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether units
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A literal number can take a suffix of `wei`, `finney`, `szabo`, or `ether` to
    convert between the sub-denominations of Ether, where Ether currency numbers without
    a postfix are assumed to be wei. For example, `2 Ether == 2000 finney` evaluates
    to `true`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Proof of existence, integrity, and ownership contract
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, enterprises are using electronic signature solutions to sign agreements.
    However, the details of such files are stored in databases that can be changed
    easily, so they cannot be trusted for auditing purposes. Blockchain can solve
    this issue by integrating blockchain as a solution for these electronic signature
    systems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a Solidity contract that can prove file ownership without revealing
    the actual file. It can prove that the file existed at a particular time and check
    for file integrity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises can use this solution to store a hash of their agreements on blockchain.
    The advantage of doing this on blockchains is that the agreement date/time, the
    actual terms of the agreement, and so on can be proven.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve proof of ownership by storing the hash of the file and the owner's
    name as pairs. The owner can be the enterprise that created the agreement. On
    the other hand, we will achieve proof of existence by storing the hash of the
    file and the block timestamp as pairs. Finally, storing the hash itself proves
    the integrity of the file. If the file is modified, its hash will change and the
    contract won't be able to find the file, thereby proving that the file was modified.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: We will use Quorum's private transactions because agreements signed between
    entities are private to them and details are not exposed to other entities. Although
    only the hash of the file will be exposed, it's still not a good idea for other
    entities to know how many agreements an entity is signing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the smart contract to achieve all this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compiling and deploying contracts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum provides the solc compiler, which provides a command-line interface
    to compile `.sol` files. Visit [http://solidity.readthedocs.io/en/develop/installing-solidity.html#binary-packages](http://solidity.readthedocs.io/en/develop/installing-solidity.html#binary-packages) to
    find instructions on how to install it and visit [https://Solidity.readthedocs.io/en/develop/using-the-compiler.html](https://Solidity.readthedocs.io/en/develop/using-the-compiler.html) to
    find instructions on how to use it. We won't be using the solc compiler directly;
    instead, we will be using browser Solidity. Browser Solidity is an IDE, which
    is suitable for small contracts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's just compile the preceding contract using browser Solidity. Learn
    more about it at [https://Ethereum.github.io/browser-Solidity/](https://ethereum.github.io/browser-solidity/).
    You can also download the browser Solidity source code for offline use: [https://github.com/Ethereum/browser-Solidity/tree/gh-pages](https://github.com/Ethereum/browser-Solidity/tree/gh-pages).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of using browser Solidity is that it provides an editor and
    also generates code to deploy the contract.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the editor, copy and paste the preceding contract code. You will see that
    it compiles and gives you the web3.js code to deploy it using the Geth interactive
    console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following output without the `privateFor` property:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`data` represents the compiled version of the contract (bytecode) that the
    EVM understands. The source code is first converted into opcodes, which are then
    converted into bytecode. Each opcode has `gas` associated with it.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `web3.eth.contract` is the ABI definition. The ABI definition
    contains the prototype of all the methods and is used when creating transactions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to deploy the smart contract. Before going further, make sure
    that you start the raft network we created in the last chapter with three nodes.
    We will assume the three nodes are of three different enterprises. Also make sure
    you have constellation enabled, and copy the public keys of all the constellation
    members. In the `privateFor` array, replace the public keys with the ones you
    generated. Here I am making the private smart contract visible to all the three
    network members.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`privateFor` is only used when sending a private transaction. It''s assigned
    to an array of the recipients'' base64-encoded public keys. In the preceding code,
    in the `privateFor` array, I only have two public keys. That''s because the sender
    doesn''t have to add its public key to the array. If you add it, then it will
    throw an error.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In the interactive console of the first node, unlock the Ethereum account, indefinitely,
    using `personal.unlockAccount(web3.eth.accounts[0], "", 0)`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand panel of browser Solidity, copy everything that's there in
    the web3 deploy textarea, then add `privateFor` and paste it in the interactive
    console of the first node. Now press *Enter*. You will first get the transaction
    hash, and after waiting for some time, you will get the contract address after
    the transaction is mined. The transaction hash is the hash of the transaction,
    which is unique for every transaction. Every deployed contract has a unique contract
    address to identify the contract in the blockchain.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The contract address is deterministically computed from the address of its creator
    (the `from` address) and the number of transactions the creator has sent (the
    transaction nonce). These two are RLP-encoded and then hashed using the keccak256
    hashing algorithm. We will learn more about the transaction nonce later. You can
    learn more about **Recursive Length Prefix** (**RLP**) at [https://github.com/Ethereum/wiki/wiki/RLP](https://github.com/Ethereum/wiki/wiki/RLP).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s store the file details and retrieve them. Assume that the first
    two entities have signed an agreement and want to store the file''s details on
    the blockchain. Place this code to broadcast a transaction to store a file''s
    details:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, replace the contract address with the contract address you got. The first
    argument of the `proofContract.at` method is the contract address. Here, we didn't
    provide the gas, in which case it's automatically calculated. And finally, as
    this is an agreement between first two entities and the first entity is sending
    the transaction with the second entity's public key,  we have the public key of
    the second entity in the `privateFor` property.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run this code in order to find the file''s details:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get this output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call method is used to call a contract's method on EVM with the current
    state. It doesn't broadcast a transaction. To read data, we don't need to broadcast
    because we will have our own copy of the blockchain.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: And if you run the preceding code in node 3, then you will not get any details
    because the data is not visible to the third entity. But the first and second
    node can read the details. We will learn more about web3.js in the coming chapters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Solidity programming language. We learned
    about data location, data types, and advanced features of contracts. We also learned
    the quickest and easiest way to compile and deploy a smart contract. Now you should
    be comfortable with writing smart contracts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Solidity编程语言。我们学习了数据位置，数据类型以及合约的高级特性。我们还学习了编译和部署智能合约的最快最简单的方法。现在你应该能够轻松编写智能合约了。
- en: In the next chapter, we will build a frontend for the smart contract, which
    will make it easy to deploy the smart contract and run transactions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为智能合约构建一个前端，这将使得部署智能合约和运行交易变得容易。
