- en: Writing Smart Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how Quorum works and how the various consensus
    protocols safeguard it. Let's move on to writing smart contracts, now that we
    understand how Quorum works. Quorum smart contracts can be written using many languages;
    the most popular one is **Solidity**. In this chapter, we will learn Solidity,
    and build a DApp that enterprises can use to sign documents digitally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The layout of Solidity source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Solidity data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special variables and contract functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure and features of contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and deploying contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is same as chapter present in author's previous book *Blockchain
    for Projects*. This is not a second edition book,it is used to explain fundamental
    concepts to the readers.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can identify a Solidity source file by the `.sol` extension. It has various
    versions, as programming languages usually do. The latest version at the time
    of writing this book is `0.4.17`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the source file, you can use the `pragma Solidity` directive to mention
    the compiler version for which the code is written. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the source file will not compile with compiler
    versions earlier than `0.4.17` and later than `0.5.0` (this second condition is
    added using `^`). Compiler versions between `0.4.17` and `0.5.0` are most likely
    to include bug fixes and less likely to break anything.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify more complex rules for the compiler version; the expression follows
    those used by `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A is akin to a class. It can functions, modifiers, state variables, events,
    structures, and enums. Contracts also support inheritance. You can implement inheritance
    by copying code during compiling. Smart contracts can also be polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following an example of a smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the aforementioned code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `contract` keyword to declare a contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared two state variables: `data` holds some data; and `owner`
    holds address of their Ethereum Wallet, that is, the address in which the contract
    was deployed. State variables form the state of the smart contract and it is stored
    in the storage of the smart contract. The storage of a smart contract is in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we defined the event. Events are used for client notification. Our event
    will be triggered whenever data changes. All events are kept in the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a modifier function. Modifiers automatically check a condition
    before executing a function. Our modifier checks whether the contract owner is
    the one invoking the function. If not, then it will throw an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we have the contract constructor. It is invoked while deploying
    the contract. The constructor is used to initialize the state variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined two methods. The first method gets the value of the data
    state variable and the second changes the data value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before delving more deeply into smart contract features, there are some important
    things related to Solidity we must learn. After that, we will come back to contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Data locations in Solidity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other programming languages, Solidity's variables are stored in the memory
    and the database, depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: There is always a default location, but it can be overridden for complex types
    of data, such as strings, arrays, and structs, by appending storage or memory to
    the type. Memory is the default for function parameters (including `return` parameters),
    and storage is for local and state variables (obviously).
  prefs: []
  type: TYPE_NORMAL
- en: 'Data locations are important because they change the behavior of assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: An independent copy is always created for assignments between storage variables
    and memory variables. No copy is created, however, for assignments from one memory-stored
    complex type to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An independent copy is always created for an assignment to a state variable
    (even from other state variables).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-stored complex types cannot be assigned to local storage variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If state variables are assigned to local storage variables, the local storage
    variables point to the state variables; basically, local storage variables act
    as pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity is a statically-typed language; the type of data the variable holds
    needs to be predefined. All the bits of the variables are assigned to zero by
    default. In Solidity, variables are function-scoped; that is, a variable declared
    anywhere within a function will be in scope for the entire function regardless
    of where it is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the data types provided by Solidity:'
  prefs: []
  type: TYPE_NORMAL
- en: The most simple data type is `bool`. It can hold either `true` or `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint8`, `uint16`, `uint24`, up to `uint256` are used to hold unsigned integers
    of 8 bits, 16 bits, 24 bits, up to 256 bits, respectively. Similarly, `int8`,
    `int16` up to `int256` are used to hold signed integers of 8 bits, 16 bits up
    to 256 bits, respectively. `uint` and `int` are aliases for `uint256` and `int256`. `ufixed`
    and `fixed` represent fractional numbers. `ufixed0x8`, `ufixed0x16` up to `ufixed0x256`
    are used to hold unsigned fractional numbers of 8 bits, 16 bits up to 256 bits,
    respectively. Similarly, `fixed0x8`, `fixed0x16` up to `fixed0x256` are used to
    hold signed fractional numbers of 8 bits, 16 bits up to 256 bits, respectively.
    If we have a number that requires more than 256 bits, then the 256 bits data type
    is used, in which case the approximation of the number is stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address is used to store up to a 20-byte value by assigning a hexadecimal literal.
    It is used to store Ethereum addresses. You can use the `0x` prefix in Solidity
    to assign a hexadecimal encoded representation of values to variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity supports generic and byte arrays, fixed-size and dynamic arrays, as
    well as multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '`bytes1`, `bytes2`, `bytes3`, up to , `bytes32` are types of byte arrays. We
    will use byte to represent `bytes1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of generic array syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some important things you should know about arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays also possess a `length` property that can be used to find the length
    of an array. `value` can also be assigned to the `length` property to change the
    array size. However, an array in memory or a non-dynamic array cannot be resized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception is thrown if an unset `index` of a dynamic array is accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings can be created in Solidity in two ways: using `bytes` and `string`.
    `bytes` is used to create a raw string, whereas `string` is used to create a UTF-8
    string. The length of the string is always dynamic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows `string` syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity structs. Here is an shows `struct` syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity enums. Here is an shows `enum` syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **hash table** is a mapping data type. As mappings can only live in storage,
    they are declared as state variables. You can think of a mapping as having `key`
    and `value` pairs. `key` is not actually stored; instead, the **keccak256** hash
    of `key` is used to look up for `value`. Mappings don't have a length and cannot
    be assigned to another mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of creating and using `mapping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The delete operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `delete` operator can be applied to any variable to reset it to its default
    value. The default value is all bits assigned to zero.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply `delete` to a dynamic array, it will delete all its elements and
    the length becomes zero. And if we apply it to a static array, all its indices
    are reset. We can also apply `delete` to specific indices, to reset them.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing happens, though, if you apply `delete` to a map type. However, if you
    apply `delete` to `key` of a map, the value associated with `key` is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `delete` operator at work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Conversion between elementary types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything apart from arrays, strings, structs, enums, and maps is called **elementary
    types**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply an operator to different types, the compiler tries to implicitly
    convert one of the operands into the type of the other. Generally speaking, an
    implicit conversion between value types is possible if it makes sense semantically
    and no information is lost: `uint8` is convertible to `uint16`, and `int128` to
    `int256`, but `int8` is not convertible to `uint256` (because `uint256` cannot
    hold, for example, `-1`). Furthermore, an unsigned integer can be converted into
    a byte of the same or a larger size, but not the reverse. Any type that can be
    converted into `uint160` can also be converted into an address.'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity also supports explicit conversion. You can opt for explicit conversion
    if the compiler does not allow implicit conversion between two data types. We
    recommend avoiding an explicit conversion as it may give you unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example of explicit conversion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are converting the `uint32` type to `uint16` explicitly, that is, converting
    a large type to a smaller type; therefore, higher-order bits are cut off.
  prefs: []
  type: TYPE_NORMAL
- en: Using var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To declare variables, Solidity provides the `var` keyword. The type of variable
    in this case is decided dynamically, depending on the first value assigned to
    it. Once a value is assigned, the type is fixed; if you assign another type to
    it, it will lead to type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `var` works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that `var` cannot be used when defining arrays and maps. It also cannot
    be used to define function parameters and state variables.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity supports `if...else`, `do...while`, `for`, `break`, `continue`, `return`,
    and `?:` control structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here a of structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating contracts using the new operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A contract can create a new contract using the `new` keyword . The complete
    code for the contract being created must be known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, exceptions are thrown automatically. You can use `assert()`,
    `revert()`, and `require()` to throw manual exceptions. Exceptions stop and revert
    any currently-executing calls (that is, all changes to the state and balances
    are undone). In Solidity, it is not yet possible to catch exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three lines are all different ways of throwing exceptions in
    Solidity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`assert()` will take away all the gas, whereas `require()` and `revert()` will
    refund the remaining gas.'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity doesn't support returning a reason for exceptions but is expected to
    soon. You can visit the [https://github.com/ethereum/solidity/issues/1686](https://github.com/ethereum/solidity/issues/1686) issue
    for an update. Then you will be able to write `revert("Something bad happened")` and `require(condition,
    "Something bad happened")`.
  prefs: []
  type: TYPE_NORMAL
- en: External function calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity has two kinds of function calls: internal and external. An internal
    function call is when a function calls another function in the same contract. An
    external function call is when a function calls a function of another contract.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Calls made using the `this` keyword are called external calls. The `this` keyword
    inside functions represents the current contract instance.
  prefs: []
  type: TYPE_NORMAL
- en: Features of contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to delve more deeply into contracts. Let's start with some new features
    and then we will go deeper into the features we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The visibility of a state variable or a function defines who can see it. There
    are four kinds of visibility: `external`, `public`, `internal`, and `private`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the visibility of functions is `public` and the visibility of state
    variables is `internal`. Let''s see what these visibility functions mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`external`: External functions can only be called from other contracts or via
    transactions. For example, we cannot call an `f` external function internally: `f()`
    will not work but `this.f()` will. We also cannot apply `external` visibility
    to state variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: Public functions and state variables can be accessed in every possible
    way. Compiler-generated accessor functions are all `public` state variables. It
    is not possible to create our own accessors. Actually, it generates only **getters**,
    not **setters**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal`: Internal functions and state variables can only be accessed internally,
    that is, from within the current contract and the contracts inheriting it. We
    cannot use `this` to access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: Private functions and state variables are similar to internal ones,
    except they cannot be accessed by the inheriting contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate visibility and accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Function modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen what a function modifier is, and we wrote a basic version
    of it. Now let's look at it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers are inherited by child contracts, and they can also be overridden
    by child contracts. Multiple modifiers can be applied to a function by specifying
    them in a whitespace-separated list and they will be evaluated in order. You can
    also pass arguments to modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the modifier, the next modifier body or function body, whichever comes
    next, is inserted where `_;` appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a complex code example of function modifiers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `myFunction()` is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, when you call the `myFunction` method, it will return `0`. But after that,
    when you try to access the state variable, `a`, you will get `8`.
  prefs: []
  type: TYPE_NORMAL
- en: '`return` in a modifier or function body immediately leaves the whole function,
    and the return value is assigned to whatever variable it needs to be.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of functions, the code after `return` is executed after the caller's
    code-execution is completed. And in the case of modifiers, the code after `_;`
    in the previous modifier is executed after the caller's code-execution is completed.
    In the aforementioned example, line numbers five, six, and seven are never executed.
    After line number four, the execution starts directly from line numbers eight
    to ten.
  prefs: []
  type: TYPE_NORMAL
- en: '`return` inside modifiers cannot have a value associated with it. It always
    returns zero bits.'
  prefs: []
  type: TYPE_NORMAL
- en: The fallback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **fallback function** is the only unnamed function a contract can have.
    This function cannot have arguments and cannot return anything. It is executed
    on a call to the contract if none of the other functions match the given function
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: This function is also executed whenever the contract receives Ether without
    any function call; that is, the transaction sends Ethereum to the contracts and
    doesn't invoke any method. In such a context, there is usually very little gas
    available for the function call (precisely 2,300 gas), so it is important to make
    fallback functions as cheap as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Contracts throw an exception when they receive Ether but do not have a defined
    fallback function, thereby sending back the Ether. So if you want your contract
    to receive Ethereum, you must implement a fallback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a fallback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity supports multiple inheritance by copying code, including polymorphism.
    Even if a contract inherits from multiple other contracts, only a single contract
    will be created on the blockchain. Moreover, the code from the parent contracts
    will always be copied into the final contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The super keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `super` keyword is used to refer to the next contract in the final inheritance
    chain. The following is  an example to help you understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The final inheritance chain with respect to the `sample6` contract is `sample6`,
    `sample5`, `sample4`, `sample2`, `sample3`, `sample1`. The inheritance chain starts
    with the most-derived contracts and ends with the least-derived contract.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract contracts are those that only contain the prototype of functions instead
    of the implementation. They cannot be compiled (even if they contain implemented
    functions alongside non-implemented functions). If a contract inherits from an
    abstract contract and does not implement all non-implemented functions by overriding,
    it will itself become abstract.
  prefs: []
  type: TYPE_NORMAL
- en: The reason abstract contracts are provided is to make the interface known to
    the compiler. This is useful for referring to a deployed contract and calling
    its functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries are similar to contracts, but they are deployed just once at a specific
    address and their code is reused by various contracts. This means that if library
    functions are called, their code is executed in the context of the calling contract;
    So, `this` points to the calling contract, and specifically, allows access to
    the storage from the calling contract. As a library is an isolated piece of source
    code, it can only access state variables of the calling contract if they are explicitly
    supplied (it would have no way to name them otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can contain structs and enums, but they cannot have state variables.
    They don't support inheritance and they cannot receive Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Once a Solidity library is deployed to the blockchain, it can be used by anyone,
    assuming one knows its address and has the source code (with only prototypes or
    complete implementation). The source code is required by the Solidity compiler
    so it can ensure that the methods being accessed actually exist in the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The address of the library cannot be added in the contract source code. We need
    to provide the library address to the compiler during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries have many use cases. The two major use cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have several contracts with some common code, you can deploy that common
    code as a library. This will save gas, which also depends on the contract size.
    Therefore, we can think of a library as a base contract of the contract that uses
    it. Using a base contract instead of a library to split the common code will not
    save gas, because inheritance in Solidity works by copying code. Because libraries
    are thought of as base contracts, functions with internal visibility in a library
    are copied to the contract that uses it. Otherwise, functions with the `internal`
    visibility of a library cannot be called by the contract that uses the library,
    as an external call would be required. Functions with the `internal` visibility
    cannot be invoked using the external call. In addition, structs and enums in a
    library are copied to the contract that uses the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries can be used to add member functions to data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library containing only internal functions and/or structs/enums does not need
    to be deployed, as everything that's in the library is copied to the contract
    that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: using for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `using A for B;` directive can be used to attach library functions (from
    the library, `A`, to any type, `B`). These functions will receive the object they
    are called on as their first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of `using A for *;` is that the functions from the library, `A`,
    are attached to all types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Returning multiple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity allows functions to return multiple values. Let''s demonstrate  this,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Importing other Solidity source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solidity allows a source file to import other source files. Here is an example
    to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Globally-available variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are special variables and functions that always exist globally. We will
    discuss them in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Block and transaction properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The block and transaction properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`block.blockhash(uint blockNumber) returns (bytes32)`: The hash of the given
    block only works for the 256 most recent blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block.coinbase (address)`: The current block''s miner''s address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block.difficulty (uint)`: The current block''s difficulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block.gaslimit (uint)`: The current block''s gas limit. It defines the maximum
    amount of gas that all transactions in the whole block combined are allowed to
    consume. Its purpose is to keep the block-propagation and processing time low,
    thereby allowing a sufficiently decentralized network. Miners have the right to
    set the gas limit for the current block to be within ~0.0975% (1/1,024) of the
    gas limit of the last block, so the resulting gas limit should be the median of
    the miners'' preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block.number (uint)`: The current block''s number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block.timestamp (uint)`: The current block''s timestamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.data (bytes)`: The complete call data holds the function and its arguments
    that the transaction invokes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.gas (uint)`: The remaining gas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.sender (address)`: The sender of the message (the current call).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.sig (bytes4)`: The first four bytes of the call data (the function identifier).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg.value (uint)`: The number of wei sent with the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now (uint)`: The current block''s timestamp (alias for block.timestamp).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx.gasprice (uint)`: The gas price of the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx.origin (address)`: The sender of the transaction (full call chain).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address-type-related variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Address-type-related variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<address>.balance (uint256)`: The balance of the address in wei.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<address>.send(uint256 amount) returns (bool)`: Sends the given amount of
    wei to `address`; returns `false` on failure. Even if the execution fails, the
    current contract will not stop with an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<address>.transfer(uint256 amount)`: Sends wei to an address. If that execution
    runs out of gas or fails, the Ether transfer will be reversed and the current
    contract will stop with an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract-related variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contract-related variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: The current contract, explicitly convertible to the address type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selfdestruct(address recipient)`: Destroys the current contract, sending its
    funds to the given address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ether units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A literal number can take a suffix of `wei`, `finney`, `szabo`, or `ether` to
    convert between the sub-denominations of Ether, where Ether currency numbers without
    a postfix are assumed to be wei. For example, `2 Ether == 2000 finney` evaluates
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of existence, integrity, and ownership contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, enterprises are using electronic signature solutions to sign agreements.
    However, the details of such files are stored in databases that can be changed
    easily, so they cannot be trusted for auditing purposes. Blockchain can solve
    this issue by integrating blockchain as a solution for these electronic signature
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a Solidity contract that can prove file ownership without revealing
    the actual file. It can prove that the file existed at a particular time and check
    for file integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises can use this solution to store a hash of their agreements on blockchain.
    The advantage of doing this on blockchains is that the agreement date/time, the
    actual terms of the agreement, and so on can be proven.
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve proof of ownership by storing the hash of the file and the owner's
    name as pairs. The owner can be the enterprise that created the agreement. On
    the other hand, we will achieve proof of existence by storing the hash of the
    file and the block timestamp as pairs. Finally, storing the hash itself proves
    the integrity of the file. If the file is modified, its hash will change and the
    contract won't be able to find the file, thereby proving that the file was modified.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Quorum's private transactions because agreements signed between
    entities are private to them and details are not exposed to other entities. Although
    only the hash of the file will be exposed, it's still not a good idea for other
    entities to know how many agreements an entity is signing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the smart contract to achieve all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and deploying contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum provides the solc compiler, which provides a command-line interface
    to compile `.sol` files. Visit [http://solidity.readthedocs.io/en/develop/installing-solidity.html#binary-packages](http://solidity.readthedocs.io/en/develop/installing-solidity.html#binary-packages) to
    find instructions on how to install it and visit [https://Solidity.readthedocs.io/en/develop/using-the-compiler.html](https://Solidity.readthedocs.io/en/develop/using-the-compiler.html) to
    find instructions on how to use it. We won't be using the solc compiler directly;
    instead, we will be using browser Solidity. Browser Solidity is an IDE, which
    is suitable for small contracts.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's just compile the preceding contract using browser Solidity. Learn
    more about it at [https://Ethereum.github.io/browser-Solidity/](https://ethereum.github.io/browser-solidity/).
    You can also download the browser Solidity source code for offline use: [https://github.com/Ethereum/browser-Solidity/tree/gh-pages](https://github.com/Ethereum/browser-Solidity/tree/gh-pages).
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of using browser Solidity is that it provides an editor and
    also generates code to deploy the contract.
  prefs: []
  type: TYPE_NORMAL
- en: In the editor, copy and paste the preceding contract code. You will see that
    it compiles and gives you the web3.js code to deploy it using the Geth interactive
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following output without the `privateFor` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`data` represents the compiled version of the contract (bytecode) that the
    EVM understands. The source code is first converted into opcodes, which are then
    converted into bytecode. Each opcode has `gas` associated with it.'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `web3.eth.contract` is the ABI definition. The ABI definition
    contains the prototype of all the methods and is used when creating transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to deploy the smart contract. Before going further, make sure
    that you start the raft network we created in the last chapter with three nodes.
    We will assume the three nodes are of three different enterprises. Also make sure
    you have constellation enabled, and copy the public keys of all the constellation
    members. In the `privateFor` array, replace the public keys with the ones you
    generated. Here I am making the private smart contract visible to all the three
    network members.
  prefs: []
  type: TYPE_NORMAL
- en: '`privateFor` is only used when sending a private transaction. It''s assigned
    to an array of the recipients'' base64-encoded public keys. In the preceding code,
    in the `privateFor` array, I only have two public keys. That''s because the sender
    doesn''t have to add its public key to the array. If you add it, then it will
    throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: In the interactive console of the first node, unlock the Ethereum account, indefinitely,
    using `personal.unlockAccount(web3.eth.accounts[0], "", 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand panel of browser Solidity, copy everything that's there in
    the web3 deploy textarea, then add `privateFor` and paste it in the interactive
    console of the first node. Now press *Enter*. You will first get the transaction
    hash, and after waiting for some time, you will get the contract address after
    the transaction is mined. The transaction hash is the hash of the transaction,
    which is unique for every transaction. Every deployed contract has a unique contract
    address to identify the contract in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The contract address is deterministically computed from the address of its creator
    (the `from` address) and the number of transactions the creator has sent (the
    transaction nonce). These two are RLP-encoded and then hashed using the keccak256
    hashing algorithm. We will learn more about the transaction nonce later. You can
    learn more about **Recursive Length Prefix** (**RLP**) at [https://github.com/Ethereum/wiki/wiki/RLP](https://github.com/Ethereum/wiki/wiki/RLP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s store the file details and retrieve them. Assume that the first
    two entities have signed an agreement and want to store the file''s details on
    the blockchain. Place this code to broadcast a transaction to store a file''s
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, replace the contract address with the contract address you got. The first
    argument of the `proofContract.at` method is the contract address. Here, we didn't
    provide the gas, in which case it's automatically calculated. And finally, as
    this is an agreement between first two entities and the first entity is sending
    the transaction with the second entity's public key,  we have the public key of
    the second entity in the `privateFor` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run this code in order to find the file''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The call method is used to call a contract's method on EVM with the current
    state. It doesn't broadcast a transaction. To read data, we don't need to broadcast
    because we will have our own copy of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: And if you run the preceding code in node 3, then you will not get any details
    because the data is not visible to the third entity. But the first and second
    node can read the details. We will learn more about web3.js in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Solidity programming language. We learned
    about data location, data types, and advanced features of contracts. We also learned
    the quickest and easiest way to compile and deploy a smart contract. Now you should
    be comfortable with writing smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a frontend for the smart contract, which
    will make it easy to deploy the smart contract and run transactions.
  prefs: []
  type: TYPE_NORMAL
