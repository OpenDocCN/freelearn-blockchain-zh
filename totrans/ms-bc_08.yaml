- en: Chapter 8. Ethereum Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the concepts, techniques, and tools related to Ethereum
    development. Several examples will be introduced in this chapter to complement
    the theoretical concepts provided in earlier chapters. This chapter will mainly
    cover the setup of the development environment and how to create smart contracts
    using Ethereum blockchain. Detailed walkthrough examples will be provided that
    will help you understand how Ethereum and other supporting tools can be used to
    develop and deploy smart contracts on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first task is to set up a development environment. The upcoming section
    introduces the ethereum setup for Test Net and Private Net. Test Net is called
    Ropsten and is used by developers or users as a test platform to test smart contracts
    and other blockchain-related proposals. The Private Net option in Ethereum allows
    the creation of an independent private network that can be used as a distributed
    ledger between participating entities and for the development and testing of smart
    contracts. While there are other clients available for Ethereum, such as Parity,
    which was discussed in the previous chapter, geth is the leading client for Ethereum
    and the common tool of choice, as such this chapter will use `geth` in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Test Net (Ropsten)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ethereum Go client, `geth`, can be connected to the test network using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A sample output is shown in the following screenshot. The screenshot shows the
    type of the network chosen and various other pieces of information regarding the
    blockchain download.
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain explorer for test net is located at [https://testnet.etherscan.io/](https://testnet.etherscan.io/)
    and can be used to trace transactions and blocks on the Ethereum test network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Test Net (Ropsten)](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the geth command connecting to Ethereum test net
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Private Net
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Private Net allows the creation of an entirely new blockchain. This is different
    from Test Net or Main Net in the sense that it uses its on-genesis block and Network
    ID. In order to create Private Net, three components are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Network ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Genesis file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data directory to store blockchain data. Even though data directory is not strictly
    required to be mentioned, if there is more than one blockchain already active
    on the system, then data directory should be specified so that a separate directory
    is used for the new blockchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Private Net allows the creation of an entirely new blockchain. This is different
    from Test Net or Main Net in the sense that it uses its own unique genesis block
    and Network ID. On Main Net, geth knows about peers by default and connects automatically,
    but on Private Net, geth needs to be configured by specifying appropriate flags
    and configuration in order for it to be able to be discoverable by other peers
    or to discover other peers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the previously mentioned three components, it is desirable that
    you disable **node discovery** so that other nodes on the Internet cannot discover
    your private network and is truly private. If other networks happen to have the
    same genesis file and Network ID, they may connect to your Private Net. The chance
    of having the same Network ID and genesis block is very low, but, nevertheless,
    disabling node discovery is good practice, and is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, all these parameters are discussed in detail with
    a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: Network ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Network ID can be any positive number except 1 and 3, which are already in use
    by Ethereum Main Net and Test Net (Ropsten), respectively. Network ID 786 has
    been chosen for the example private network discussed later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The genesis file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The genesis file contains necessary fields required for a custom genesis block.
    This is the first block in the network and does not point to any previous block.
    The Ethereum protocol performs rigorous checking in order to ensure that no other
    node on the Internet can participate in the consensus mechanism, unless they have
    the same genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom genesis file that will be used later in the example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This file can be saved in a text file with the JSON extension; for example,
    `privategenesis.json`. Optionally, ether can be preallocated by specifying beneficiary
    addresses and the amount of Wei in `alloc`, but it is usually not necessary as,
    being on the private network, ether can be mined very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Data directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the directory where the blockchain data for the private Ethereum network
    will be saved. For example, in the following example, it is `~/.ethereum/privatenet`.
  prefs: []
  type: TYPE_NORMAL
- en: In the geth client, a number of parameters are specified in order to launch,
    further fine-tune the configuration, and launch the private network. These flags
    are listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Flags and their meaning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`--nodiscover`: Th`i`s flag ensures that the node is not automatically discoverable
    if it happens to have the same genesis file and Network ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--maxpeers`: This flag is used to specify the number of peers allowed to be
    connected to the private net. If it is set to 0, then no one will be able to connect,
    which might be desirable in a few scenarios, such as private testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rpc`: This is used to enable the RPC interface in geth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rpcapi`: This flag takes a list of APIs to be allowed as a parameter. For
    example, `eth,web3` will enable the web3 and eth interface over RPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rpcport`: This sets up the TCP RPC port; for example: 9999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rpccorsdomain`: This flag specifies the URL that is allowed to connect to
    the private geth node and perform RPC operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--port`: This specifies the TCP port that will be used to listen to the incoming
    connections from other peers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--identity`: This flag is a string that specifies the name of a private node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there is a need to connect to a specific set of peers, then these nodes
    can be added to a file where the `chaindata` and `keystore` files are saved, for
    example, in the `~/.ethereum/privatenet` directory. The filename should be `static-nodes.json`.
    This can be valuable in a private network. An example of the json file is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `xxx` is the public IP address and `TCP_PORT` can be any valid and available
    TCP port on the system. The long hex string is the node ID.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the private network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial command to start the private network is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Private network initialization
  prefs: []
  type: TYPE_NORMAL
- en: 'This output indicates that a genesis block has been created successfully. In
    order for `geth` to start, the following command can be issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting geth for a private network
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `geth` can be attached via IPC to the running geth client on a private
    network using the following command. This will allow you to interact with the
    running `geth` session on the private network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, this will open the interactive JavaScript console for the running
    Private Net session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting geth to attach with Private Net 786
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that a warning message appears when `geth` starts up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: No etherbase set and no accounts found as default'
  prefs: []
  type: TYPE_NORMAL
- en: This message appears because there are no accounts currently available in the
    new test network and no account is set as etherbase to receive mining rewards.
    This issue can be addressed by creating a new account and setting that account
    as etherbase. This will also be required when mining is carried out on the test
    network. This is shown in the following commands. Note that these commands are
    entered in the geth JavaScript console, as shown in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates a new account. In this context, the account will
    be created on the Private Network ID 786:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the account is created, the next step is to set it as an Etherbase/coinbase
    account so that the mining reward goes to this account. This can be achieved using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, the etherbase account has no balance, as can be seen using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, mining can start by simply issuing the following command. This command
    takes one parameter that is a number of threads. In the following example, two
    threads will be allocated to the mining process by specifying 2 as an argument
    to the start function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After mining starts, the first DAG generation is carried out and output similar
    to the following is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DAG generation
  prefs: []
  type: TYPE_NORMAL
- en: Once DAG generation is finished and mining starts, `geth` will produce output
    similar to that shown in the following screenshot. It can be clearly seen that
    blocks are being mined successfully with the `Mined 5 blocks . . .` message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mining output
  prefs: []
  type: TYPE_NORMAL
- en: 'Mining can be stopped using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JavaScript console, the current balance of total ether can be queried,
    as shown here. After mining, a significant amount can be seen in the following
    example. Mining is extremely fast as it is a private network and in the genesis
    file, the network difficulty has also been set quite low:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If two spaces and two tabs are pressed in a sequence, a complete of list of
    the available objects will be displayed. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Available objects
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, when a command is typed, it can be autocompleted by pressing tab
    twice. If two tabs are pressed, then the list of available methods is also displayed.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Available methods
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the previously mentioned command, in order to get a list of
    available methods, after typing any command,`;` (semicolon) is entered. An example
    is shown in the next screenshot, which shows a list of all the methods available
    for `net`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up the private network](img/image_08_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List of methods
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other commands that can be used to query the private network.
    Some examples are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the current gas price:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the latest block number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Debug can come in handy when debugging issues. A sample command is shown here;
    however, there are many methods available. The following method will return the
    RLP of block `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encode using RLP**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Unlock the account before sending transactions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Send transactions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to use `listAccounts[]` method, this can be done as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a list of compilers. Note that if no output is shown, it means that no
    solidity compiler is installed; solidity compiler installation details are provided
    later in the chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running Mist on Private Net
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to run Mist on Private Net by issuing the following command.
    This binary is usually available in the `home` folder after the installation of
    `/opt/Ethereum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will allow a connection to the running Private Net `geth` session, and
    it provides all features, such as wallet, account management, and contract deployment
    on Private Net via Mist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Mist on Private Net](img/image_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running Ethereum Wallet to connect to Private Net
  prefs: []
  type: TYPE_NORMAL
- en: Once Ethereum is launched, it will show the interface shown here, indicating
    clearly that it's running in the **PRIVATE-NET** mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Mist on Private Net](img/image_08_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mist on Private Net
  prefs: []
  type: TYPE_NORMAL
- en: 'Mist can also run over the network using RPC. This is useful if `geth` is running
    on a different node and Mist on another. This can be achieved by running Mist
    with the flag shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Deploying contracts using Mist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very easy to deploy new contracts using Mist. Mist provides an interface
    where contracts can be written in solidity and then deployed on the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the exercise, a simple contract that can perform various simple arithmetic
    calculations on the input parameter will be used. Steps on how to use Mist to
    deploy this contract are shown here. As solidity has not been introduced yet,
    the aim here is to allow users to experience the contract deployment and interaction
    process. More information on coding and solidity will be provided later in the
    chapter, after which it will become easy to understand the code shown. Those of
    you who are already familiar with JavaScript or any other similar language will
    find the code almost self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example contract source code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code can simply be copied into Mist under the contracts section, as shown
    here. On the left-hand side, the source code can be copied; once verified and
    when no syntax errors are detected, the option to deploy the contract will appear
    in the drop-down menu on the right-hand side where it says **SELLECT CONTRACT
    TO DEPLOY**. Simply select the contract and press the D**eploy** button at the
    bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying contracts using Mist](img/image_08_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mist browser contract deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Mist will ask for the password of the account and will show a window similar
    to the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying contracts using Mist](img/image_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a contract using Mist
  prefs: []
  type: TYPE_NORMAL
- en: Enter the password and click on **SEND TRANSACTION** to deploy the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once deployed and mined successfully, it will appear in the list of transactions
    in Mist, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying contracts using Mist](img/image_08_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List of transactions after creation in Mist
  prefs: []
  type: TYPE_NORMAL
- en: Once the contract is available, it can be interacted with using the execute
    transaction and calling available functions via Mist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying contracts using Mist](img/image_08_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction with the contract using read and write options in Mist
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the **READ FROM CONTRACT** and **WRITE TO CONTRACT**
    options are available. Also, the function that has been exposed by the contract
    can be seen on the right-hand side. Once the required function is selected, the
    appropriate value is entered for the function and the account (execute from) is
    selected; press execute in order to execute the transaction, which will result
    in calling the selected function of the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying contracts using Mist](img/image_08_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Contract execution in Mist
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the screenshot, enter the appropriate password for the account and
    then press **SEND TRANSACTION** to send the transaction to the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Development tools and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of tools available for Ethereum development. The following
    diagram shows the taxonomy of various development tools, clients, IDEs, and development
    frameworks for Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Development tools and clients](img/B05975_08_14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taxonomy of Ethereum ecosystem components
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the main focus will be on `geth`, browser solidity, solidity,
    solc, and truffle. Rest of the elements will be discussed briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Contracts can be programmed in a variety of languages. There are four languages
    that can be used in order to write contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutan**: This is a Go-style language, which was deprecated in early 2015
    and is no longer used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLL**: This is a Lisp-like language, hence the name LLL. This is also not
    used anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serpent**: This is a simple and clean Python-like language. It is actively
    used for contract development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solidity**: This language has now become almost a standard for contract writing
    for Ethereum. This language is the focus of this chapter and is discussed in detail
    in later sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compilers are used to convert high-level contract source code into the format
    that the Ethereum execution environment understands. The solidity compiler is
    the most common one in use and is discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Solc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solidity compiler converts from a high-level solidity language into **Ethereum
    Virtual Machine** (**EVM**) bytecode so that it can be executed on the blockchain
    by EVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solidity compiler on a Linux Ubuntu operating system can be installed using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If PPAs are not already installed, those can be installed by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to verify the existing version of the solidity compiler and verify
    that it is installed, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Solc supports a variety of functions. A few examples are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Display contract in a binary format.![Solc](img/image_08_018.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solidity compiler binary output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Estimate gas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that `contrat1.sol` is shown as an example only; the file can contain any
    smart contract solidity code. The code of the file is not shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solc is used internally by web3 from the `geth` console in order to compile
    the contract. The syntax is shown here, and `contractsourcecode` is the solidity
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is discussed in detail later in the chapter when you will be introduced
    to contract development.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environments (IDEs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various IDEs available for solidity development. Most of the IDEs
    are available online and are presented via web interfaces. Browser solidity is
    most commonly used for smaller contracts and is discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Browser solidity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Browser solidity is the web-based environment for the development and testing
    of contracts using solidity. It does not run on a live blockchain; in fact, it
    is a simulated environment in which contracts can be deployed, tested, and debugged.
    It is available at [https://ethereum.github.io/browser-solidity](https://ethereum.github.io/browser-solidity).
    An example interface is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browser solidity](img/image_08_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Browser solidity
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, there is a code editor with syntax highlighting and code
    formatting, and on the right-hand side, there are a number of tools available
    that can be used to deploy, debug, test, and interact with the contract. Various
    features, such as transaction interaction, options to connect to JavaScript VM,
    configuration of execution environment, debugger, formal verification, and static
    analysis, are available. They can be configured to connect to execution environments
    such as JavaScript VM, injected Web3--where Mist or a similar environment has
    provided the execution environment--or Web3 provider, which allows connection
    to the locally running Ethereum client (for example, `geth`) via IPC or RPC over
    HTTP (web3 provider endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the Mix IDE was discontinued in August 2016, the Remix project was started.
    Remix is a browser-based IDE that is under heavy development currently and only
    the debugger part of it is available as of now. This debugger is very powerful
    and can be used to perform detailed level tracing and analysis of the EVM byte
    code. In the following section, installation and usage examples of Remix are presented.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remix is available at [https://github.com/ethereum/remix](https://github.com/ethereum/remix).
    The first step is to clone the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding steps are completed successfully, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, either `npm run start_node` can be run, or `geth` can be started
    up using the appropriate flags. Once `geth` is up and running, a simple web server
    can be run in order to serve the remix web page. Now `geth` can be started up
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `--rpcapi` flag; it is required in order to allow `web3`, `eth`,
    `debug` over RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `npm run start_node` is run, the following message may appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming `geth` is required, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If `geth` was opted to be run, then a simple web server is required to browse
    to the remix web page. This can be achieved simply by issuing a Python command,
    as follows. This should be run from the `remix` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Python quick web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command is successful and the web server is running, remix can be
    browsed using the `http://localhost:7777` URL, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Web browser showing remix running and served via TCP 7777
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix is also available as part of browser solidity (browser solidity has been
    discussed separately earlier). It can be connected to the local Private Net by
    providing the web3 provider endpoint. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Web3 Provider** option on browser solidity to connect to the local `geth`
    node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remix Debugger in browser solidity
  prefs: []
  type: TYPE_NORMAL
- en: Tools and libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various tools and libraries available for Ethereum. The most common
    ones are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js version 7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As Node js is required for most of the tools and libraries, it can be installed
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Local Ethereum block explorer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Local Ethereum block explorer is a useful tool that can be used to explore
    the local blockchain. This can be installed by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Linux Ubuntu machine, run the following command in order to install the
    local Ethereum block explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to change the directory to the explorer and run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is finished, output similar to the following will be
    shown, where the HTTP server for Ethereum explorer starts up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local Ethereum block explorer](img/image_08_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ethereum explorer HTTP server
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the web server is up, `geth` should be started up using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After a successful start up of `geth`, navigate to the localhost on TCP `port
    8000`, as shown here, in order to access the local Ethereum block explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Local Ethereum block explorer](img/image_08_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Block explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the web server can be started up using Python or any other appropriate
    provider. In Python, a quick web server can started, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `geth` client will need to be started up with appropriate parameters. If
    not, an error like that shown in the following screenshot can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local Ethereum block explorer](img/image_08_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Error message Ethereum local block explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart `geth` to allow `rpccorsdomain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: EthereumJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At times, it is not possible to test on the Test Net and Main Net is obviously
    not a place to test the contracts. Private Net can be time consuming to set up
    at times. EthereumJS testrpc comes in handy when quick testing is required and
    no proper test net is available. It uses EthereumJS to simulate the Ethereum `geth`
    client behavior and allows for faster development testing. Testrpc is available
    via npm as a node package.
  prefs: []
  type: TYPE_NORMAL
- en: Before installing testrpc, Node.js should already have been installed and the
    npm package manager should also be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testrpc can be installed using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In order to start testrpc, simply issue this command and keep it running in
    the background and open another terminal to work on contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Contract development and deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various steps that need to be taken in order to develop and deploy
    the contracts. Broadly, these can be divided into four steps: writing, testing,
    verification, and deployment. After deployment, the next step is to create the
    user interface and present it to the end users via a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: The writing step is concerned with writing the contract source code in solidity.
    This can be done in any text editor. There are various plugins and add-ons available
    for Vim in Linux, Atom, and other editors that provide syntax highlighting and
    formatting for solidity source code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is usually performed by automated means. Later in the chapter, you will
    be introduced to truffle, which uses the Mocha framework to test contracts. However,
    manual testing can be performed as well. Once the contract is verified, working,
    and tested on a simulated environment (for example, EthereumJS testrpc) or on
    Private Net, it can be deployed to Ropsten Test Net and finally to live blockchain
    (Homestead).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be introduced to language solidity. This is a
    brief introduction to solidity, which should provide the base knowledge required
    in order to write the contracts. The syntax is very similar to C and JavaScript,
    and it is quite easy to program.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing solidity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solidity is a domain-specific language of choice for programming contracts in
    Ethereum. There are, however, other languages, such as serpent, Mutan, and LLL
    but solidity is the most popular at the time of writing this. Its syntax is closer
    to JavaScript and C. Solidity has evolved into a mature language over the last
    few years and is quite easy to use, but it still has a long way to go before it
    can become advanced and feature-rich like other well-established languages. Nevertheless,
    this is the most widely used language available for programming contracts currently.
  prefs: []
  type: TYPE_NORMAL
- en: It is a statically typed language, which means that variable type checking in
    solidity is carried out at compile time. Each variable, either state or local,
    must be specified with a type at compile time. This is beneficial in the sense
    that any validation and checking is completed at compile time and certain types
    of bugs, such as interpretation of data types, can be caught earlier in the development
    cycle instead of at run time, which could be costly, especially in the case of
    the blockchain/smart contracts paradigm. Other features of the language include
    inheritance, libraries, and the ability to define composite data types.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is also a called contract-oriented language. In solidity, contracts
    are equivalent to the concept of classes in other object-oriented programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solidity has two categories of data types: value types and reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are explained in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This data type has two possible values, true or false, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This statement assigns the value `true` to `v`.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This data type represents integers. A table is shown here, which shows various
    keywords used to declare integer data types.
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Types | Details |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Signed integer | int8 to int256, which means that keywords are available
    from int8 up to int256 in increments of 8, for example, int8, int16, int24. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | Unsigned integer | uint8 to uint256 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, in this code, note that `uint` is an alias for `uint256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These types can also be declared with the `constant` keyword, which means that
    no storage slot will be reserved by the compiler for these variables. In this
    case, each occurrence will be replaced with the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: State variables are declared outside the body of a function, and they remain
    available throughout the contract depending on the accessibility assigned to them
    and as long as the contract persists.
  prefs: []
  type: TYPE_NORMAL
- en: Address
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This data type holds a 160-bit long (20 byte) value. This type has several
    members that can be used to interact with and query the contracts. These members
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balance**'
  prefs: []
  type: TYPE_NORMAL
- en: The balance member returns the balance of the address in Wei.
  prefs: []
  type: TYPE_NORMAL
- en: '**Send**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This member is used to send an amount of ether to an address (Ethereum''s 160-bit
    address) and returns true or false depending on the result of the transaction,
    for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Call functions**'
  prefs: []
  type: TYPE_NORMAL
- en: The `call`, `callcode`, and `delegatecall` are provided in order to interact
    with functions that do not have **Application Binary Interface** (**ABI**). These
    functions should be used with caution as they are not safe to use due to the impact
    on type safety and security of the contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Array value types (fixed size and dynamically sized byte arrays)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solidity has fixed size and dynamically sized byte arrays. Fixed size keywords
    range from `bytes1` to `bytes32`, whereas dynamically sized keywords include bytes
    and strings. `bytes` are used for raw byte data and string is used for strings
    encoded in UTF-8\. As these arrays are returned by the value, calling them will
    incur gas cost. `length` is a member of array value types and returns the length
    of the byte array.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a static (fixed size) array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a dynamically sized array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Get `length` of trades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are used to represent a fixed value.
  prefs: []
  type: TYPE_NORMAL
- en: Integer literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Integer literals are a sequence of decimal numbers in the range of 0-9\. An
    example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: String literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'String literals specify a set of characters written with double or single quotes.
    An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Hexadecimal literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Hexadecimal literals are prefixed with the keyword hex and specified within
    double or single quotation marks. An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This allows the creation of user-defined types. An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Explicit conversion to and from all integer types is allowed with enums.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two function types: internal and external functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These can be used only within the context of the current contract.
  prefs: []
  type: TYPE_NORMAL
- en: External functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: External functions can be called via external function calls.
  prefs: []
  type: TYPE_NORMAL
- en: A function in solidity can be marked as a constant. Constant functions cannot
    change anything in the contract; they only return values when they are invoked
    and do not cost any gas. This is the practical implementation of the concept of
    *call* as discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to declare a function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, these types are passed by reference and are discussed
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays represent a contiguous set of elements of the same size and type laid
    out at a memory location. The concept is the same as any other programming language.
    Arrays have two members named `length` and `push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These constructs can be used to group a set of dissimilar data types under
    a logical group. These can be used to define new types, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Data location
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data location specifies where a particular complex data type will be stored.
    Depending on the default or annotation specified, the location can be storage
    or memory. This is applicable to arrays and structs and can be specified using
    the **storage** or **memory** keywords. As copying between memory and storage
    can be quite expensive, specifying a location can be helpful to control the gas
    expenditure at times. **Calldata** is another memory location that is used to
    store function arguments. Parameters of external functions use **calldata** memory.
    By default, parameters of functions are stored in **memory**, whereas all other
    local variables make use of **storage**. State variables, on the other hand, are
    required to use **storage**.
  prefs: []
  type: TYPE_NORMAL
- en: Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mappings are used for a key to value mapping. This is a way to associate a
    value with a key. All values in this map are already initialized with all zeroes,
    for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows that `offers` is declared as a mapping. Another example
    makes this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is basically a dictionary or a hash table where string values are mapped
    to integer values. The mapping named `bids` has a `packt` string value mapped
    to value `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Solidity provides a number of global variables that are always available in
    the global namespace. These variables provide information about blocks and transactions.
    Additionally, cryptographic functions and address-related variables are available
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subset of available functions and variables is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is used to compute the `keccak256` hash of the argument provided
    to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the associated address of the public key from the elliptic
    curve signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This returns the current block number.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Control structures available in solidity are `if - else`, `do`, `while`, `for`,
    `break`, `continue`, `return`. They work in a manner similar to how they work
    in C-language or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Events in solidity can be used to log certain events in EVM logs. These are
    quite useful when external interfaces are required to be notified of any change
    or event in the contract. These logs are stored on the blockchain in transaction
    logs. Logs cannot be accessed from the contracts but are used as a mechanism to
    notify change of state or the occurrence of an event (meeting a condition) in
    the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simple example here, the `valueEvent` event will return true if the `x`
    parameter passed to `function Matcher` is equal to or greater than `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inheritance is supported in solidity. The `is` keyword is used to derive a
    contract from another contract. In the following example, `valueChecker2` is derived
    from the `valueChecker` contract. The derived contract has access to all nonprivate
    members of the parent contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if `uint8 price = 10` is changed to `uint8 private
    price = 10`, then it will not be accessible by the `valuechecker2` contract. This
    is because now the member is declared as private, it is not allowed to be accessed
    by any other contract.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Libraries are deployed only once at a specific address and their code is called
    via CALLCODE/DELEGATECALL Opcode of the EVM. The key idea behind libraries is
    code reusability. They are similar to contracts and act as base contracts to the
    calling contracts. A library can be declared as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This library can then be called in the contract, as shown here. First, it needs
    to be imported and it can be used anywhere in the code. A simple example is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There are a few limitations with libraries; for example, they cannot have state
    variables and cannot inherit or be inherited. Moreover, they cannot receive Ether
    either; this is in contrast to contracts that can receive Ether.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Functions in solidity are modules of code that are associated with a contract.
    Functions are declared with a name, optional parameters, access modifier, optional
    constant keyword, and optional return type. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `function` is the keyword used to declare the function.
    `orderMatcher` is the function name, `uint x` is an optional parameter, `private`
    is the **access modifier/specifier** that controls access to the function from
    external contracts, `constant` is an optional keyword used to specify that this
    function does not change anything in the contract but is used only to retrieve
    values from the contract instead, and `returns (bool returnvalue)` is the optional
    return type of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to define a function**: The syntax of defining a function is shown as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function signature**: Functions in solidity are identified by its signature,
    which is the first four bytes of the keccak-256 hash of its full signature string.
    This is also visible in browser solidity, as shown in the following screenshot.
    **D99c89cb** is the first four bytes of 32 byte keccak-256 hash of the function
    named **Matcher**.![Functions](img/image_08_027.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function hash as shown in browser solidity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example function, **Matcher** has the signature hash of **d99c89cb**.
    This information is useful in order to build interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input parameters of a function**: Input parameters of a function are declared
    in the form of <data type> <parameter name>. This example clarifies the concept
    where `uint x` and `uint y` are input parameters of the `checkValues` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Output parameters of a function**: Output parameters of a function are declared
    in the form of <data type> <parameter name>. This example shows a simple function
    returning a `uint` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A function can return multiple values. In the preceding example function, `getValue`
    only returns one value, but a function can return up to 14 values of different
    data types. The names of the unused return parameters can be omitted optionally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Internal function calls**: Functions within the context of the current contract
    can be called internally in a direct manner. These calls are made to call the
    functions that exist within the same contract. These calls result in simple JUMP
    calls at the EVM byte code level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External function calls**: External function calls are made via message calls
    from a contract to another contract. In this case, all function parameters are
    copied to the memory. If a call to an internal function is made using the `this`
    keyword, it is also considered an external call. The `this` variable is a pointer
    that refers to the current contract. It is explicitly convertible to an address
    and all members for a contract are inherited from the address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fall back functions**: This is an unnamed function in a contract with no
    arguments and return data. This function executes every time ether is received.
    It is required to be implemented within a contract if the contract is intended
    to receive ether; otherwise, an exception will be thrown and ether will be returned.
    This function also executes if no other function signatures match in the contract.
    If the contract is expected to receive ether, then the fall back function should
    be declared with the `payable`**modifier**. The `payable` is required; otherwise,
    this function will not be able to receive any ether. This function can be called
    using the `address.call()` method as, for example, in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, if the `fallback` function is called according to the conditions
    described earlier; it will call throw, which will roll back the state to what
    it was before making the call. It can also be some other construct than throw;
    for example, it can log an event that can be used as an alert to feed back the
    outcome of the call to the calling application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Modifier functions**: These functions are used to change the behavior of
    a function and can be called before other functions. Usually, they are used to
    check some conditions or verification before executing the function. `_`(underscore)
    is used in the modifier functions that will be replaced with the actual body of
    the function when the modifier is called. Basically, it symbolizes the function
    that needs to be *guarded*. This concept is similar to guard functions in other
    languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor function**: This is an optional function that has the same name
    as the contract and is executed once a contract is created. Constructor functions
    cannot be called later on by users, and there is only one constructor allowed
    in a contract. This implies that no overloading functionality is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function visibility specifiers (access modifiers)**: Functions can be defined
    with four access specifiers as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External**: These functions are accessible from other contracts and transactions.
    They cannot be called internally unless the `this` keyword is used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: By default, functions are public. They can be called either internally
    or using messages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Internal functions are visible to other derived contracts from
    the parent contract.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: Private functions are only visible to the same contract they are
    declared in.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other important keywords/functions throw**: `throw` is used to stop execution.
    As a result, all state changes are reverted. In this case, no gas is returned
    to the transaction originator because all the remaining gas is consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout of a solidity source code file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Version pragma**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to address compatibility issues that may arise from future versions
    of the solidity compiler version, pragma can be used to specify the version of
    the compatible compiler as, for example, in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the source file does not compile with versions smaller
    than `0.5.0` and versions starting from 0.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Import**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import in solidity allows the importing of symbols from the existing solidity
    files into the current global scope. This is similar to import statements available
    in JavaScript, as for example, in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**Comments**'
  prefs: []
  type: TYPE_NORMAL
- en: Comments can be added in the solidity source code file in a manner similar to
    C-language. Multiple line comments are enclosed in `/*` and `*/`, whereas single
    line comments start with `//`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example solidity program is as follows, showing the use of pragma, import,
    and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of a solidity source code file](img/image_08_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample solidity program as shown in browser solidity
  prefs: []
  type: TYPE_NORMAL
- en: This completes a brief introduction to the solidity language. The language is
    very rich and under constant improvement. Detailed documentation and coding guidelines
    are available online.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Web3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web3 is a JavaScript library that can be used to communicate with an Ethereum
    node via RPC communication. Web3 works by exposing methods that have been enabled
    over RPC. This allows the development of user interfaces that make use of the
    web3 library in order to interact with the contracts deployed over the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to expose the methods via `geth`, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note the `--rpcapi` flag that allows the `web3, eth` and `debug` methods.
  prefs: []
  type: TYPE_NORMAL
- en: This is a powerful library and can be explored further by attaching a `geth`
    instance. Later in the section, you will be introduced to the concepts and techniques
    of making use of web3 via JavaScript/HTML frontends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `geth` instance can be attached using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `geth` JavaScript console is running, web3 can be queried, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Web3](img/image_08_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: web3 via geth
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple contract can be deployed using `geth` and interacted with using web3
    via the command-line interface that `geth` provides (console or attach). The following
    are the steps to achieve that. As an example, the following source code will be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `geth` console that has been opened previously and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a variable named `simplecontractsource` and assign the program code
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the source code is required to be in a single line, which means that
    there should be no line breaks. This can be achieved in Linux using the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, `valuechecker.sol` is the file that has the new line
    `\n` character, and `valuecheckersingleline.sol` is the output file produced after
    removing the new line character from the file. The code can then be copied and
    pasted from the file into the `geth` JavaScript console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now verify that the solidity compiler is available, and if it''s not available,
    then refer to the section in the chapter where solidity installation is explained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable and assign and compile the code using solidity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter `simplecontractcompiled`; it will display output similar to the following.
    as `simplecontractcompiled` has been assigned the data from preceding step 3.![Introducing
    Web3](img/image_08_030.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: simplecontractcompiled output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a variable to interact with the contract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the **ABI** (**Application Binary Interface**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the code of `valueChecker` in the hexadecimal format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following output. It can be slightly different for you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now enter the following piece of code; note that the data field contains the
    code for `simplecontractcompiled:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assume that it returns an error message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If so, then unlock the account using the following commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, list the accounts using the following command to get the account IDs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command with the account to be unlocked, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the password of the account:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After unlocking the account, enter the preceding code again; say, an error
    message appears:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, try to increase the gas. If too great a gas value is entered,
    then an error message will appear, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the account is successfully unlocked, start the miner so that the contract
    can be mined (it is not necessary to unlock the account to start mining. Account
    unlocking is necessary to mine the contract and create it on the blockchain):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the contract is created correctly, it will show output similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows the address of the newly created contract after the contract has
    been mined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to make interaction with the contract easier, the address of the account
    can be assigned to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a number of methods that are now exposed, and the contract can be
    further queried now, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this , an object can be created named `simplecontractinstance`, which
    will be used to call methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are various methods that have been exposed now, and a list can be seen
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The contract can be further queried as shown here. In the following example,
    the `Matcher` function is called with the arguments. Remember that in the code,
    there is a condition that checks that, if the value is equal to or greater than
    10, then the function returns `true`; otherwise, it returns `false`. This can
    be seen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: POST requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to interact with `geth` via jsonrpc over HTTP. For this purpose,
    curl can be used. Some examples are shown here in order to familiarize you with
    the POST request and show how to make post requests using curl. Curl is available
    at [https://curl.haxx.se/](https://curl.haxx.se/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the JsonRPC interface over HTTP, `geth` should be started up with
    appropriate switches, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This switch will enable the `web3` interface over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux command curl can be used for the purpose of communicating over HTTP,
    as shown here in a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieve the list of accounts**: For example, in order to retrieve the list
    of accounts using the `personal_listAccounts` method, the following command can
    be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the output, a JSON object with the list of accounts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding `curl` command, the `--request` is used to specify the request
    command, POST is the request, and `--data` is used specify the parameters and
    values and, finally, `localhost:8001` is where the HTTP endpoint from `geth` is
    opened.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML and JavaScript frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is desirable to interact with the contracts in a user-friendly manner via
    a web page. It is possible to interact with the contracts using the web3.js library
    from HTML/JS/CSS-based web pages. The HTML content can be served using any HTTP
    web server, whereas web3.js can connect via local **RPC** to the running Ethereum
    client (`geth`) and provide an interface to the contracts on the blockchain. This
    architecture can be visualized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTML and JavaScript frontend](img/B05975_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: web3.js, frontend, and blockchain interaction architecture
  prefs: []
  type: TYPE_NORMAL
- en: If web3.js is not already installed, use these steps; otherwise, move to the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: Installing web3.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Web3 can be installed via `npm` by simply issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: It can also be directly downloaded from [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js).
  prefs: []
  type: TYPE_NORMAL
- en: '`web3.min.js`, downloaded via `npm`, can be referred in the HTML files. This
    can be found under node_modules, for example, `/home/drequinox/netstats/node_modules/web3/dist/web3.min.js`.
    The file can optionally be copied into the directory where the main application
    is and can be used from there. Once the file is successfully referred in HTML
    or JS, web3 needs to be initialized by providing an HTTP provider. This is usually
    the link to the localhost HTTP endpoint exposed by the running `geth` client.
    This can be achieved using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Once the provider is set, further interaction with the contracts and blockchain
    can be done using the `web3` object and its available methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `web3` object can be created using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following section, an example will be presented that will make use of
    web3.js to allow interaction with the contracts via a web page served over a simple
    HTTP web server. This can be achieved by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a directory named `/simplecontract/app` in the home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a file named `simplecontractcompiled.js`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file contains various elements. The most important is **ABI** (**Application
    Binary Interface**), which can be queried using `geth`, as shown earlier in step
    6 during the contract deployment process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a file named `simplecontract.js`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is the main JavaScript file that contains the code to create a `web3`
    object. It also provides methods that are used to interact with the contract on
    the blockchain. An explanation of the code is given here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Creating a web3 object**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This code first checks whether there is already an available provider; if yes,
    then it will set the provider to the current provider. Otherwise, it sets the
    web3 provider to `localhost: 8001`; this is where the local instance of `geth`
    is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking availability by calling any web3 method**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This line of code simply uses `console.log` to print the coinbase by calling
    the `web3.eth.coinbase` method. Once this call is successful, it means that the
    `web3` object has been created correctly and `HttpProvider` is available. Any
    other call can be used to verify the availability, but as a simple example, `web3.eth.coinbase`
    has been used in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assigning contract address to a variable**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This statement will assign the value of the address of the contract deployed
    on the blockchain. After successful execution of the statement variable, `simplecontractaddress`
    will contain the address of the contract. This is the address of the contract
    created in step 9 in the preceding example when the contract is deployed. Simply
    use that address in the code here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the main contract object**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code will create an object that will be used later in the code
    to interact with the contract on the blockchain. `simplecontractinstance` will
    expose functions of the contract. `web3.eth.contract` takes the ABI array as an
    argument. This can be passed using `simplecontractcompiled.valueChecker.info.abiDefinition`.
    Finally, `.at` takes the address of the contract as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the code of the contract address (optional)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown as an example here and is entirely optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statements are used to query the code of the contract. This is
    a simple `web3.eth.getCode` call that takes the address of the contract on the
    blockchain as an argument. Finally, `console.log` is used to print the code of
    the contract by printing the code variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract balance**'
  prefs: []
  type: TYPE_NORMAL
- en: console.log("Contract balance:" +web3.eth.getBalance(simplecontractaddress));The
    preceding code will call `web3.eth.getBalance` and take the contract address as
    an argument and will print the balance of the contract, which is 0 at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `web3` object is correctly created and `simplecontractinstance` is
    created, calls to the contract functions can be made easily as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Calls can be made using `simplecontractinstance.Matcher.call` and then by passing
    the value for the argument. Recall the function matcher in solidity code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: It takes one argument `x` of type `uint8` and returns a Boolean value, either
    true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the call is made to the contract, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `console.log` is used to print the value returned
    by the function call. Once the result of the call is available in the `txn` variable,
    it can be used anywhere throughout the program, for example, as a parameter for
    another JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the HTML file named `index.html` is created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that an appropriate web server be running in order to serve
    the HTML content (`index.html` as an example). Alternatively, the file can browsed
    from the filesystem but that can cause some issues with larger projects; as good
    practice, always use a web server. A quick web server in Python can be started
    using the following command. This server will serve the HTML content from the
    same directory that it has been run from. Python is not necessary; it can even
    be an Apache server or any other web container.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple web server in Python
  prefs: []
  type: TYPE_NORMAL
- en: Now any browser can be used to view the web page served over TCP `port 7777`.
    This is shown in the following example. It should be noted that the output shown
    here is in the browser's console window. The browser's console must be enabled
    in order to see the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction with the contract
  prefs: []
  type: TYPE_NORMAL
- en: As the values are hardcoded in the code for simplicity, two buttons have been
    created in index.html. Both of these buttons call functions with hardcoded values.
    This is just to demonstrate that parameters are being passed to the contract via
    web3 and values are being returned accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions being called behind the preceding buttons. The `callMatchertrue()`
    method has a hardcoded value of 12, which is sent to the contract using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is printed in the console using the following code, which
    first invokes the `Matcher` function and then assigns the value to the `txn` variable
    to be printed later in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `callMatcherfalse()` function works by passing a hardcoded value
    of `1` to the contract using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is printed accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates how the web3 library can be used to interact with
    the contracts on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Development frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various development frameworks now available for Ethereum. As seen
    in the examples discussed earlier, it can be quite time consuming to deploy the
    contract via the usual manual means. This is where truffle and similar frameworks
    such as embark can be used to make the process simpler and quicker. The most widely
    used framework is called truffle. In the next section, you will be introduced
    to the truffle framework.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Truffle is a development environment that makes it easier and simpler to test
    and deploy Ethereum contracts. Truffle provides contract compilation and linking
    along with an automated testing framework using Mocha and Chai. It also makes
    it easier to deploy the contracts to any PrivateNet, public, or Test Net Ethereum
    blockchain. Also, asset pipeline is provided, which makes it easier for all JavaScript
    files to be processed, making them ready for use by a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before installation, it is assumed that the node is available, which can be
    queried as shown here. If the node is not available, then the installation of
    the node is required first in order to install truffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation of truffle is very simple and can be done using the following
    command via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This will take a while; once it is installed, `truffle` can be used to display
    help and make sure that it is installed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Truffle help
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the repository is available at [https://github.com/ConsenSys/truffle](https://github.com/ConsenSys/truffle),
    which can be cloned locally to install truffle. Git can be used to clone the repository
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '**Initializing truffle**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Truffle can be initialized by running the following command. First, create
    a directory for the project, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change to `testdapp` and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command is successful, it will create the directory structure shown
    here. This can be viewed using the `tree` command in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This command creates four main directories, named `app`, `contracts`, `migrations`,
    and `test`. As seen in the preceding example, a total of 7 directories and 10
    files have been created. In the following section, an explanation of all these
    files and directories will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: '`App`: This directory contains all application files including HTML files,
    images, style sheets and JavaScript files. This folder contains further subdirectories,
    `images`, `javascripts`, and `stylesheets` that contain relevant application files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contracts`: This directory contains solidity contract source code files. This
    is where truffle will look for solidity contract files during migration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Migration`: This directory has all the deployment scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test`: As the name suggests, this directory contains relevant test files for
    applications and contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, truffle configuration is stored in the `truffle.js` file, which is
    created in the root folder of the project from where `truffle init` was run. When
    `truffle init` is run, it will create a sample project named MetaCoin. As an example,
    you will first be introduced to how to use various commands in truffle in order
    to test and deploy MetaCoin. Later, further examples will be shown on how to use
    truffle for custom projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilation using truffle**'
  prefs: []
  type: TYPE_NORMAL
- en: Both libraries and contracts can be compiled using truffle. It is expected that
    the name of the contract file will be the same as the contract name within the
    file. For example, from the sample MetaCoin project created earlier, the file
    named `MetaCoin.sol` under the `contracts` directory has the same name as the
    MetaCoin contract in the file. This applies to library files too and it is case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filename:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Contract name within the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Compilation can be run as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the compilation is finished successfully, all objects will be written
    in to the `build` directory. The output directory looks like what is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, the `build` directory is created automatically
    with the `contracts` subdirectory, which contains three JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the process by which truffle deploys contracts to the blockchain. This
    process relies on the files available under the `migrations` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process works as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding output, there are two files that contain the code
    that specifies which contracts are required to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filenames follow a convention where they are required to be prefixed by
    a number. This prefix is required in order to keep a record of all migrations.
    The suffix in the filename can be any descriptive name. First, it is important
    to change the `truffle.js` file in order to point to the appropriate network.
    The `truffle.js` file contains valuable information about the build and rpc for
    the application. In this case, `geth` is already running and it can simply be
    pointed to use the available client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding file, `rpc` needs to be changed to point to the appropriate
    network. Once `rpc` is changed (in the example, `geth` is running on port 8001
    as opposed to usual 8545), truffle migration can be run using the following command.
    It is also important that mining be running on the Ethereum node to which `rpc`
    has been pointed; otherwise, the contract will not be mined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract can be deployed using the command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'It might show an error message, as shown here. If this occurs, then it means
    that the account that truffle is using to deploy a contract to the blockchain
    is locked and is required to be unlocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The account can be unlocked by using the following commands in the `geth` JavaScript
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, list the accounts to see all accounts and then select the account that
    needs to be unlocked. Truffle assumes the coinbase account by default. Select
    the appropriate account, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The account can be unlocked using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the account is unlocked, migration can be run again using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show output similar to that shown here. It should be noted that mining
    must be started for the migration to finish. Migration will perform various steps
    by finding the files available in the `migrations` directory. As shown in the
    example, `1_initial_migration.js` and `2_deploy_contracts.js` have been used to
    provide migration steps and requirements to truffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Once the command is completed successfully, it will return a command prompt
    displaying the message `saving artefacts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployment can be verified using a few commands shown here via the `geth` JavaScript
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the address of the newly deployed contract has been taken from the
    truffle migrate command output shown earlier. `(MetaCoin: 0x0be9c5de978fa927b93a5c4faab31312cea5704a)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interaction with the contract**: Truffle also provides a console (command-line
    interface) that allows interaction with the contracts. All deployed contracts
    are already instantiated and ready to use in the console. This is an REPL-based
    interface that means Read, Evaluate, and Print Loop. Similarly, in the geth client
    (via attach or console), REPL is used via exposing **JSRE** (**JavaScript runtime
    environment**). The console can be accessed by issuing the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will open a command-line interface, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_035.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Truffle console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the console is available, various methods can be run in order to query
    the contract. A list of methods can be displayed by typing the following command
    and tab-completing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installation](img/image_08_036.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Exposed methods
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Other methods can also be called in order to interact with the contract; for
    example, in order to retrieve the address of the contract, the following method
    can be called in the truffle console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Query the balance of the contract**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output returns a string with the value `8750`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Transfer the balance**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will return the hash of the transaction and, when successful, it will result
    in increasing the balance of the target by 50\. The target account is the argument
    passed in the `sendCoin` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Balance of the target account**: It can be retrieved using the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to exit from the truffle console, the `.exit` command is used.
  prefs: []
  type: TYPE_NORMAL
- en: Testing using truffle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing is a powerful feature of truffle and can be invoked by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This will read the tests from `test` directory and perform tests accordingly.
    The testing framework used by truffle is called Mocha, and it uses an assertion
    framework named Chai.
  prefs: []
  type: TYPE_NORMAL
- en: A sample test run is shown as follows. This test only runs two tests. In the
    original file, there are three tests, but for simplicity, only two are used here.
    Also, the test may fail on most of the systems; therefore, it has been removed
    from the file for simplicity. A failed test case will be discussed later. Also,
    it should be noted that mining should be running for the tests to run.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing using truffle](img/image_08_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Truffle test output showing two successful tests
  prefs: []
  type: TYPE_NORMAL
- en: 'These two tests are based on the file produced by truffle init. In the following
    file, only one test is shown for simplification, when truffle creates three tests
    for the default MetaCoin project. Tests can be removed from the file by editing
    the `metacoin.js` file in a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: All test files are required to be present in the `tests` directory under the
    `project` directory. Tests are specified within `it` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing using truffle](img/image_08_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test based on the file shown earlier with only one test
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding test case, when the contract is, it should have a balance
    of 10000 in it. This test basically tests whether the balance of 10000 is available
    after deploying the contract or not. In order to explain the concept, the error
    can be simulated, for example, if the `metacoin.js` file is by changing the assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: This will induce an artificial assertion failure because in assert, the expected
    amount is 1000, whereas, when the contract is deployed, it has a balance of 10,000\.
    When the test is run, the following output is shown indicating that the tests
    have failed. This change is made for demonstration purposes only in order to allow
    you to see that tests can fail and, if so, what type of outputs are produced.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing using truffle](img/image_08_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Truffle test failing output
  prefs: []
  type: TYPE_NORMAL
- en: The `truffle test` command takes few optional parameters, especially `--verbose-rpc`,
    which can be very helpful in understanding the RPC communication between the Ethereum
    client and truffle.
  prefs: []
  type: TYPE_NORMAL
- en: 'At times during test execution, an error message like the one shown here can
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This error occurs when either the Ethereum node is not mining, or deploying
    the contracts is taking longer than 2 minutes. This is why timeout occurs; therefore,
    it is important that tests are run through a mining node if on PrivateNet. Also
    on Ropsten, it can sometimes take longer than 2 minutes. Alternatively, `ethereumjs-testrpc`
    can be used, which is commonly used with truffle and provides fast simulated Ethereum
    RPC client.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Build in truffle is used to bootstrap the frontend for browsers. It works by
    importing compiled contracts and relevant deployed contract and Ethereum client
    configurations. All objects, after building, are saved in the `./build` directory.
    All build configurations are present in the `truffle.js` file, which guides truffle
    on what to build. By default, this file comes only with `build:` and `rpc:` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build can be started by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is completed, the `build` directory will be created if doesn''t
    exist already and a tree structure similar to the one shown here will be created.
    This is created based on the `truffle.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Once the build is completed successfully, all frontend files will be ready.
    This can then be viewed in the browser using truffle's `serve` command. The `serve`
    command creates a web server in order to present the HTML content. The command
    can be run as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the command is run with the `-p` flag to specify port TCP 7777\. This
    is required as `geth`, in the example provided previously, is running with the
    `--rpccorsdomain 'http://localhost:7777'` option. This means that only the content
    served over TCP 7777 is allowed. By default, `serve` runs on port 8080, which
    might be in use by some other process on the system as TCP 8080 is a very common
    port to be used for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Build](img/image_08_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Truffle serve
  prefs: []
  type: TYPE_NORMAL
- en: Once the truffle server is up and running on an appropriate port, the content
    can be browsed using a browser and pointing to URL `http://localhost:7777`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Build](img/image_08_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example MetaCoin frontend
  prefs: []
  type: TYPE_NORMAL
- en: Another example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An example is shown here, where a simple contract in solidity is created with
    migrations and tests. The contract is very simple and performs only addition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory named `simpleTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize truffle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove files from directories. This is required in order to remove the default
    MetaCoin project files create by truffle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the two files `Addition.sol` and `Migrations.sol` in the contracts directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Addition.sol`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the `Addition.js` file in the `test` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `migrations` folder, place two files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`        1_initial_migration.js`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`        2_deploy_contracts.js`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once all the files are in place, compile all contracts using truffle compile.
    Optionally, use the `--compile-all` flag in order to recompile the contracts even
    if they have already been compiled. This is required only if the contracts need
    to be recompiled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Migrate to the Ethereum test network using truffle migrate. This will deploy
    the contract on the network. Note that, at this point, `truffle.js` will need
    to be updated again with port 8001 to point to the Private Net:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, tests can be performed using the following command. These tests are
    based on the `Addition.js` file shown earlier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will first deploy the contract on the Ethereum network (PrivateNet
    in this example).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Another example](img/image_08_042.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Sample output showing successful truffle test
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to interact with the contract, the following methods can be used. As
    the Addition contract is already instantiated and available in the truffle console,
    it becomes quite easy to interact with the contract using various methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, in order to retrieve the address of the deployed contract, the
    following method can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the functions from within the contract, the deployed method is used
    with contract functions. An example is shown here, in which the `addx` function
    is called and two parameters are passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `retrievex` function from the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Example project: Proof of Idea'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea behind this program is to provide a service to notarize a document.
    This can then be used as proof that, at a certain time in the past, the claimant
    has had access to a certain piece of information. This can be very useful for
    patent documents. For example, if someone has come up with an idea, he or she
    can then create a hash of that document and save it on the blockchain. Due to
    the immutable nature of blockchain, it can serve as permanent proof that a certain
    idea (documents) existed at a certain time. There are many ways in which this
    can be achieved, but the key idea is the same and it works on the principle that
    hash functions provide a digest of the text or document and are unique.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved in several ways; the key idea is to create a hash of the
    document or text string and save it on the blockchain. Once the text is hashed
    and saved, further requests to save that same text can be disallowed by comparing
    the hash of the document with the already stored hash.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, browser solidity, truffle, and TestNet (already running Network
    ID 786, created earlier) will be used. First, the code for the contract will be
    written. This can be done using any appropriate text editor or integrated development
    environment. Browser solidity can also be used as that too provides a simulated
    environment for the test. This example will provide you with the opportunity to
    learn how a contract project can be developed from an idea into a solidity contract
    source code and finally to deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement ensures that the minimum compiler version is 0.4.0 and the maximum
    version cannot be greater than 0.4.9\. This ensures compatibility between programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement is the start of the contract with name `PatentIdea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a mapping is defined, which maps byte32 to Boolean, and this is basically
    a `hashmap` (dictionary) of bytes32 mapping to the Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable declared with the `alreadyStored` name, which is a Boolean
    type and can have a true or false value. This variable is used to hold the return
    value from the `SaveIdeaHash` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: An event is declared as well, which will be used to capture the failure or success
    of the hashing function (`SaveIdeaHash`). When the event is triggered, it will
    return a true or false Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function named `saveHash` is declared, which takes the hash variable of type
    bytes32 as parameters and saves it in the hash map. This will result in a change
    of the state of the contract. Note that the function accessibility is changed
    to private as it is only required internally in the contract and does not need
    to be exposed publicly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function, `saveIdeaHash`, is declared, and it takes the variable idea
    of type string and returns a Boolean (true or false) depending on the outcome
    of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This function has a variable declared `hashedIdea`, which is assigned a value
    after calling the `HashtheIdea` function described later. Note that this function
    can also return a value if saved, but it is not shown here for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is the `alreadyHashed` function, which is declared to take
    the variable named hash of type bytes32 and returns a Boolean (either true or
    false) after checking the hash in the hash map. This is again declared as a constant
    and accessibility is set to private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function is `isAlreadyHashed`, which checks whether the idea is already
    hashed. This takes the input parameter idea of type string, also declared as a
    constant, which means that it cannot change the state of the contract and returns
    either true or false based on the outcome of the execution of the function named
    `alreadyHashed`. This function then calls the `alreadyHashed` function described
    earlier to check from the hashes map whether the hash is already stored there.
    This would mean that the same string (`idea`) has already been hashed and stored
    (patented):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `HashtheIdea` function is shown here, which takes the `idea` variable
    of type string and is of `constant` type, which means that it cannot change the
    state of the contract. It is also declared as `private` as there is no need to
    expose this function publicly because it is used only internally in the contract.
    This function returns the bytes32 type value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: This function calls solidity's built-in function `sha3` and passes a string
    to it in a variable idea. This function returns the sha3 hash of the string. The
    `sha3` function is an alias for the `keccak256()` function available in solidity,
    which computes the Keccak-256 hash of the string passed to it. Note that this
    is not NIST standard SHA-3; instead, it is Keccak-256, which is the original proposal
    to NIST for the SHA-3 standard competition. It was later modified slightly and
    standardized as the SHA-3 standard by NIST. The actual SHA-3 standard hash function
    will return a different hash compared to Keccak-256 (Ethereum's `sha3` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete contract source code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This source code can be simulated in browser solidity in order to verify that
    it is working correctly. Some examples are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Once the contract source code is typed and syntax verification is complete,
    on the right-hand side panel, a screen similar to the following one will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: This code can be improved in many ways. For example, the date can also be stored
    in a mapping with the document hash and can be returned when queried. It can be
    expanded by adding structures and more information related to the patent, but
    this example was intended to be simple and easy to understand; therefore, too
    much complexity was avoided. Further enhancements to this code are left to you
    as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create contract using browser solidity
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Create**, two functions from the contract will be exposed,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relevant costs and exposes two methods
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can now be invoked as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Invoking the SaveIdeaHash function
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `isAlreadyHashed` can be called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Execute function isAlreadyHashed
  prefs: []
  type: TYPE_NORMAL
- en: 'If the same string is passed to the function again, it will not be saved, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Execute function SaveIdeaHash
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the event has returned false, indicating that the hash could
    not be saved and the function returned true, further indicating that the same
    hash is already saved.
  prefs: []
  type: TYPE_NORMAL
- en: Once the contract is written and simulated in browser solidity, the next step
    is to use truffle to initialize a new project and deploy and test it on the PrivateNet
    (ID 786), already created in earlier sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a separate directory for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to initialize truffle and create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the sample project is created, remove the sample contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Under the `contracts` folder, create a file named `PatentIdea.sol` and put the
    source code in the file shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `truffle.js` to point to the localhost HTTP endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `~/ideapatent/migrations` folder, edit the `2_deploy_contracts.js`
    file so that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: This file is changed in order to specify the name of the contract to be deployed.
    Take note of `deployer.deploy(PatentIdea);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the compilation using truffle, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that mining is running the background and deploy to the network, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Once the contract is deployed, it can be interacted with using the truffle console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the truffle console by issuing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Once the console is up and running, functions from the deployed contract can
    be called as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, register a new idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether `MyIdea` is hashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether another idea is hashed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrated how a contract can be created from scratch, simulated,
    and deployed on the private net. In order to deploy this on TestNet (Ropsten)
    or live blockchain, a similar exercise can be performed. Simply point to the appropriate
    RPC and use truffle migrate to deploy on the blockchain of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, various advanced concepts will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracles**'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 6](ch05.html "Chapter 5. Alternative Coins"), *Smart
    Contracts*, Oracles are real-world data feeds into smart contracts. There are
    various services available in order to provide Oracles for smart contracts. A
    rather prominent one is Oraclize, which is available at [http://www.oraclize.it/](http://www.oraclize.it/).
    This is especially useful if the smart contract needs, for example, live prices
    from a third-party source or any other real-life data, such as weather conditions
    in a particular city. There are many use cases where oracles can provide a trusted
    data feed to smart contracts in order to enable them to make decisions according
    to real-life events. Oraclize makes it easier for smart contracts to access the
    Internet in order to get the required data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to utilize Oraclize on Ethereum, a transaction needs to be sent to
    the Oraclize contract along with the appropriate payment and the query. As a result,
    Oraclize will retrieve the results based on the query provided in the request
    transaction and send it back to the contract address. Once the transaction is
    sent back to the contract, the call-back method or fall back function will be
    called.
  prefs: []
  type: TYPE_NORMAL
- en: At a practical level in solidity, first, the Oraclize library needs to be imported
    and then all methods that have been inherited from it can be used. Currently,
    oraclize is available to be used only on the PrivateNet (Ropsten) and Live Main
    Net Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oraclize processing can be visualized as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example project: Proof of Idea](img/image_08_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oraclize data flow
  prefs: []
  type: TYPE_NORMAL
- en: 'The skeleton structure of a solidity contract using oraclize looks like the
    one shown here. Note that import works only on the development environment provided
    on the Web by oraclize; usually, this file needs to be imported manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample request looks like what is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Oraclize can also make use of the TLS notary in order to ensure that the feed
    is secure and provably honest.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment on decentralized storage using IPFS**'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Blockchain 101"), *Blockchain
    101*, in order to fully benefit from decentralized platforms, it is desirable
    that you decentralize the storage and communication layer. Traditionally, the
    web content is served via centralized servers, but that part can also be decentralized
    using distributed file systems.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML content shown in the earlier examples can be stored on a distributed
    and decentralized IPFS network in order to achieve enhanced decentralization.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS is available at [https://ipfs.io/](https://ipfs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing IPFS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'IPFS can be installed by following this process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the IPFS package using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decompress the `gz` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move the `ipfs` file to an appropriate folder in order to make it available
    in the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the IPFS node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command to ensure that **IPFS** has been successfully installed:![Example
    project: Proof of Idea](img/image_08_049.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successful IPFS installation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the IPFS daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy files onto IPFS using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it can be accessed in the browser as follows:![Example project: Proof of
    Idea](img/image_08_050.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browser accessing web pages via IPFS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the URL is pointing to the IPFS filesystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in order to make the changes permanent, the following command can
    be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding example demonstrated how IPFS can be used to provide decentralized
    storage for the web part (user interface) of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS can be used with blockchains in another way. As storage is a big issue
    for blockchains, it is desirable that you are able to save large amounts of data
    somewhere else and place the links to that data in the blockchain transaction.
    This way, there will be no need to store large amounts of data on the blockchain
    and bloat it as a result. IPFS can be used to achieve exactly that by placing
    the data on IPFS and then storing the IPFS links in blockchain transactions to
    reference the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum's own swarm protocol is also under heavy development and works on similar
    principles. However, Swarm is currently under development and IPFS is more developed
    comparatively and seems a better choice at the moment. IPFS works very well and
    may well become the platform of choice for the decentralized storage of deployments.
    Swarm allows users to run a light client by storing all the blockchain data on
    it. This is available with the current version of `geth`, and a detailed guide
    is available at [https://swarm-guide.readthedocs.io/en/latest/introduction.html](https://swarm-guide.readthedocs.io/en/latest/introduction.html).
    As this is under heavy development, only a light introduction has been given for
    this technology as it is likely to evolve very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: For decentralized communication in Ethereum, the Whisper protocol provides the
    decentralized communication layer. This will serve as an identity-based messaging
    layer for Ethereum. Both swarm and whisper are envisaged to be enabling technologies
    for Web 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned distributed ledgers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The concept of permissioned distributed ledgers is fundamentally different to
    a public blockchain. The key idea behind distributed ledgers is that they are
    permissioned as opposed to an open public blockchain. DLTs do not perform any
    mining as all the participants are already vetted and known to the network and
    there is no requirement for mining to secure the network. There is also no concept
    of digital currency on private permissioned distributed ledgers because the aim
    of the permissioned blockchain is different from a public blockchain. In a public
    blockchain, access is open to everyone and requires some form of incentive and
    network effect in order to grow; on the contrary, in permissioned DLTs, there
    are no such requirements. It is possible to build permissioned DLTs using Ethereum
    in private consortium settings, especially to work within existing financial systems.
    The key benefit of distributed ledger systems is that they are much faster, governable,
    and possibly interoperable with the existing financial systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided detailed and in-depth practical examples on how to set
    up an Ethereum development environment and create smart contracts. This chapter
    started with an introduction to various methods that can be used to create Private
    Ethereum networks for testing and development purposes. After this, an introduction
    to the solidity language was presented in order to enable you to understand the
    language fundamentals and syntax. Practical deployment techniques using technologies
    and tools such as `geth` and web3 were discussed in detail. Moreover, detailed
    step-by-step examples of smart contract development and deployments were presented.
    Additionally, development frameworks were discussed with practical examples so
    that you can experience the smart contract development life cycle of the Ethereum
    blockchain. This is a lengthy chapter and by following exercises closely, you
    will gain an in-depth understanding of contract development, testing, and deployment
    on Ethereum. Finally, various concepts and tools related to decentralized storage,
    decentralized communication, and oracles were discussed. As Ethereum and related
    technologies and frameworks are under constant and fast development, it is envisaged
    that more advanced tools and techniques will evolve over time; however, the fundamentals
    discussed in this chapter are likely to remain the same. Also, it is not possible
    to discuss each and every tool and framework available for Ethereum in this chapter,
    but all tools and techniques discussed are in mainstream use and should provide
    a solid basis for you to make a transition to a more advanced level. There are
    a few topics that have not been discussed on purpose in this chapter, such as
    smart contract security, formal verification of smart contracts, blockchain as
    a service on cloud, and specific use cases for smart contracts for various industries.
    All these concepts will be discussed in later chapters. I hope you enjoyed reading
    this chapter as much as I enjoyed writing it.
  prefs: []
  type: TYPE_NORMAL
