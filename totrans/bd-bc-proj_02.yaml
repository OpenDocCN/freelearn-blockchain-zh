- en: Understanding How Ethereum Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw what DApps are. We also saw an overview of some
    of the popular DApps. One of them was Ethereum. At present, Ethereum is the most
    popular DApp after bitcoin. In this chapter, we will learn in depth about how
    Ethereum works and what we can develop using Ethereum. We will also see the important
    Ethereum clients and node implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are smart contracts and how do they work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does mining work in the proof-of-work consensus protocol?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the geth command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Ethereum Wallet and Mist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Whisper and Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The future of Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is a decentralized platform, which allows us to deploy DApps on top
    of it. Smart contracts are written using the solidity programming language. DApps
    are created using one or more smart contracts. Smart contracts are programs that
    run exactly as programmed without any possibility of downtime, censorship, fraud,
    or third party interface. In Ethereum, smart contracts can be written in several
    programming languages, including Solidity, LLL, and Serpent. Solidity is the most
    popular of those languages. Ethereum has an internal currency called ether. To
    deploy smart contracts or to call their methods, we need ether. There can be multiple
    instances of a smart contract just like any other DApp, and each instance is identified
    by its unique address. Both user accounts and smart contracts can hold ether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum uses blockchain data structure and proof-of-work consensus protocol.
    A method of a smart contract can be invoked via a transaction or via another method.
    There are two kinds of nodes in the network: regular nodes and miners. Regular
    nodes are the ones that just have a copy of the blockchain, whereas miners build
    the blockchain by mining blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an Ethereum account, we just need an asymmetric key pair. There are
    various algorithms, such as RSA, ECC, and so on, for generating asymmetric encryption
    keys. Ethereum uses **elliptic curve cryptography** (**ECC**). ECC has various
    parameters. These parameters are used to adjust speed and security. Ethereum uses
    the `secp256k1` parameter. To go in depth about ECC and its parameters will require
    mathematical knowledge, and it's not necessary to understand it in depth for building
    DApps using Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses 256-bit encryption. An Ethereum private/public key is a 256-bit
    number. As processors cannot represent such big numbers, it's encoded as a hexadecimal
    string of length 64.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every account is represented by an address. Once we have the keys we need to
    generate the address, here is the procedure to generate the address from the public
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: First, generate the `keccak-256` hash of the public key. It will give you a
    256-bit number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the first 96 bits, that is, 12 bytes. You should now have 160 bits of binary
    data, that is, 20 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now encode the address as a hexadecimal string. So finally, you will have a
    bytestring of 40 characters, which is your account address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now anyone can send ether to this address.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **transaction** is a signed data package to transfer ether from an account
    to another account or to a contract, invoke methods of a contract, or deploy a
    new contract. A transaction is signed using **ECDSA** (**Elliptic Curve Digital
    Signature Algorithm**), which is a digital signature algorithm based on ECC. A
    transaction contains the recipient of the message, a signature identifying the
    sender and proving their intention, the amount of ether to transfer, the maximum
    number of computational steps the transaction execution is allowed to take (called
    the gas limit), and the cost the sender of the transaction is willing to pay for
    each computational step (called the gas price). If the transaction's intention
    is to invoke a method of a contract, it also contains input data, or if its intention
    is to deploy a contract, then it can contain the initialization code. The product
    of gas used and gas price is called transaction fees. To send ether or to execute
    a contract method, you need to broadcast a transaction to the network. The sender
    needs to sign the transaction with its private key.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is said to be confirmed if we are sure that it will always appear
    in the blockchain. It is recommended to wait for 15 confirmations before assuming
    a transaction to be confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every node in the Ethereum network holds a copy of the blockchain. We need to
    make sure that nodes cannot tamper with the blockchain, and we also need a mechanism
    to check whether a block is valid or not. And also, if we encounter two different
    valid blockchains, we need to have a way to find out which one to choose.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses the proof-of-work consensus protocol to keep the blockchain tamper-proof.
    A proof-of-work system involves solving a complex puzzle to create a new block.
    Solving the puzzle should require a significant amount of computational power
    thereby making it difficult to create blocks. The process of creating blocks in
    the proof-of-work system is called mining. Miners are the nodes in the network
    that mine blocks. All the DApps that use proof-of-work do not implement exactly
    the same set of algorithms. They may differ in terms of what the puzzle miners
    need to solve, how difficult the puzzle is, how much time it takes to solve it,
    and so on. We will learn about proof-of-work with respect to Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone can become a miner in the network. Every miner solves the puzzle individually;
    the first miner to solve the puzzle is the winner and is rewarded with five ether
    and transaction fees of all the transactions in that block. If you have a more
    powerful processor than any other node in the network, that doesn't mean that
    you will always succeed because the parameters for the puzzle are not exactly
    same for all the miners. But instead, if you have a more powerful processor than
    any other node in the network, it gives you a higher chance at succeeding. Proof-of-work
    behaves like a lottery system, and processing power can be thought as the number
    of lottery tickets a person has. Networks security is not measured by total number
    of miners; instead, it's measured by the total processing power of the network.
  prefs: []
  type: TYPE_NORMAL
- en: There is no limit to the number of blocks the blockchain can have, and there
    is no limit to the total ether that can be produced. Once a miner successfully
    mines a block, it broadcasts the block to all other nodes in the network. A block
    has a header and a set of transactions. Every block holds hash of the previous
    block, thereby creating a connected chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the puzzle the miners need to solve is and how it''s solved
    at a high level. To mine a block, first of all, a miner collects the new un-mined
    transactions broadcasted to it, and then it filters out the not-valid transactions.
    A transaction to be valid must be properly signed using the private key, the account
    must have enough balance to make the transaction, and so on. Now the miner creates
    a block, which has a header and content. Content is the list of transactions that
    the block contains. The header contains things such as the hash of the previous
    block, block number, nonce, target, timestamp, difficulty, address of the miner,
    and so on. The timestamp represents the time at the block''s inception. Then nonce
    is a meaningless value, which is adjusted in order to find the solution to the
    puzzle. The puzzle is basically to find such nonce values with which when the
    block is hashed, the hash is less than or equal to the target. Ethereum uses ethash
    hashing algorithm. The only way to find the nonce is to enumerate all possibilities.
    The target is a 256-bit number, which is calculated based on various factors.
    The difficulty value in the header is a different representation of the target
    to make it easier to deal with. The lower the target, the more time it takes to
    find the nonce, and the higher the target, the less time it takes to find the
    nonce. Here is the formula to calculate the difficulty of the puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now any node in the network can check whether the blockchain they have is valid
    or not by first checking whether the transactions in the blockchain are valid,
    the timestamp validation, then whether the target and nonce of all the blocks
    are valid, a miner has assigned a valid reward itself, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If a node in the network receives two different valid blockchains, then the
    blockchain whose combined difficulty of all blocks is higher is considered to
    be the valid blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for example, if a node in the network alters some transactions in a block,
    then the node needs to calculate the nonce of all the succeeding blocks. By the
    time it re-finds the nonce of the succeeding blocks, the network would have mined
    many more blocks and therefore reject this blockchain as its combined difficulty
    would be lower.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The formula to calculate the target of a block requires the current timestamp,
    and also every block has the current timestamp attached to its header. Nothing
    can stop a miner from using some other timestamp instead of the current timestamp
    while mining a new block, but they don't usually because timestamp validation
    would fail and other nodes won't accept the block, and it would be a waste of
    resources of the miner. When a miner broadcasts a newly mined block, its timestamp
    is validated by checking whether the timestamp is greater than the timestamp of
    the previous block. If a miner uses a timestamp greater than the current timestamp,
    the difficulty will be low as difficulty is inversely proportional to the current
    timestamp; therefore, the miner whose block timestamp is the current timestamp
    would be accepted by the network as it would have a higher difficulty. If a miner
    uses a timestamp greater than the previous block timestamp and less than the current
    timestamp, the difficulty would be higher, and therefore, it would take more time
    to mine the block; by the time the block is mined, the network would have produced
    more blocks, therefore, this block will get rejected as the blockchain of the
    malicious miner will have a lower difficulty than the blockchain the network has.
    Due to these reasons, miners always use accurate timestamps, otherwise they gain
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Nonce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nonce is a 64-bit unsigned integer. The nonce is the solution to the puzzle.
    A miner keeps incrementing the nonce until it finds the solution. Now you must
    be wondering if there is a miner who has hash power more than any other miner
    in the network, would the miner always find nonce first? Well, it wouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: The hash of the block that the miners are mining is different for every miner
    because the hash depends on things such as the timestamp, miner address, and so
    on, and it's unlikely that it will be the same for all miners. Therefore, it's
    not a race to solve the puzzle; rather, it's a lottery system. But of course,
    a miner is likely to get lucky depending on its hash power, but that doesn't mean
    the miner will always find the next block.
  prefs: []
  type: TYPE_NORMAL
- en: Block time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The block difficulty formula we saw earlier uses a 10-second threshold to make
    sure that the difference between the time a parent and child block mines is in
    is between 10-20 seconds. But why is it 10-20 seconds and not some other value?
    And why there such a constant time difference restriction instead of a constant
    difficulty?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have a constant difficulty, and miners just need to find a nonce
    to get the hash of the block less and equal to the difficulty. Suppose the difficulty
    is high; then in this case, users will have no way to find out how long it will
    take to send ether to another user. It may take a very long time if the computational
    power of the network is not enough to find the nonce to satisfy the difficulty
    quickly. Sometimes the network may get lucky and find the nonce quickly. But this
    kind of system will find it difficult to gain attraction from users as users will
    always want to know how much time it should take for a transaction to be completed,
    just like when we transfer money from one bank account to another bank account,
    we are given a time period within which it should get completed. If the constant
    difficulty is low, it will harm the security of the blockchain because large miners
    can mine blocks much faster than small miners, and the largest miner in the network
    will have the ability to control the DApp. It is not possible to find a constant
    difficulty value that can make the network stable because the network's computational
    power is not constant.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know why we should always have an average time for how long it should
    take for the network to mine a block. Now the question is what the most suitable
    average time is as it can be anything from 1 second to infinite seconds. A smaller
    average time can be achieved by lowering the difficulty, and higher average time
    can be achieved by increasing the difficulty. But what are the merits and demerits
    of a lower and higher average time? Before we discuss this, we need to first know
    what stale blocks are.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if two miners mine the next block at nearly the same time? Both
    the blocks will be valid for sure, but the blockchain cannot hold two blocks with
    the same block number, and also, both the miners cannot be awarded. Although this
    is a common issue, the solution is simple. In the end, the blockchain with the
    higher difficulty will be the one accepted by the network. So the valid blocks
    that are finally left out are called stale blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The total number of stale blocks produced in the network is inversely proportional
    to the average time it takes to generate a new block. Shorter block generation
    time means there would be less time for the newly mined block to propagate throughout
    the network and a bigger chance of more than one miner finding a solution to the
    puzzle, so by the time the block is propagated through the network, some other
    miner would have also solved the puzzle and broadcasted it, thereby creating stales.
    But if the average block generation time is bigger, there is less chance that
    multiple miners will be able to solve the puzzle, and even if they solve it, there
    is likely to be time gap between when they solved it, during which the first solved
    block can be propagated and the other miners can stop mining that block and proceed
    towards mining the next block. If stale blocks occur frequently in the network,
    they cause major issues, but if they occur rarely, they do no harm.
  prefs: []
  type: TYPE_NORMAL
- en: But what's the problem with stale blocks? Well, they delay the confirmation
    of a transaction. When two miners mine a block at nearly the same time, they may
    not have the same set of transactions, so if our transactions appears in one of
    them, we cannot say that it's confirmed as the block in which the transaction
    appeared may be stale. And we should wait for a few more blocks to be mined. Due
    to stale blocks, the average confirmation time is not equal to average block generation
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Do stale blocks impact blockchain security? Yes, they do. We know that the network's
    security is measured by the total computation power of the miners in the network.
    When computation power increases, the difficulty is increased to make sure that
    blocks aren't generated earlier than the average block time. So more difficulty
    means a more secure blockchain, as for a node to tamper, the blockchain will need
    much more hash power now, which makes it more difficult to tamper with the blockchain;
    therefore, the blockchain is said to be more secure. When two blocks are mined
    at nearly the same time, we will have the network parted in two, working on two
    different blockchains, but one is going to be the final blockchain. So the part
    of the network working on the stale block mines the next block on top of the stale
    block, which ends up in loss of hash power of the network as hash power is being
    used for something unnecessary. The two parts of the network are likely to take
    longer than the average block time to mine the next block as they have lost hash
    power; therefore, after mining the next block, there will be decrease in difficulty
    as it took more time than the average block time to mine the block. The decrease
    in difficulty impacts the overall blockchain security. If the stale rate is too
    high, it will affect the blockchain security by a huge margin.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum tackles the security issue caused by stale blocks using something known
    as ghost protocol. Ethereum uses a modified version of the actual ghost protocol.
    The ghost protocol covers up the security issue by simply adding the stale blocks
    into the main blockchain, thereby increasing the overall difficulty of the blockchain,
    as overall difficulty of the blockchain also includes the sum of difficulties
    of the stale blocks. But how are stale blocks inserted into the main blockchain
    without transactions conflicting? Well, any block can specify 0 or more stales.
    To incentivize miners to include stale blocks, the miners are rewarded for including
    stale blocks. And also, the miners of the stale blocks are rewarded. The transactions
    in the stale blocks are not used for calculating confirmations, and also, the
    stale block miners don't receive the transaction fees of the transactions included
    in the stale blocks. Note that Ethereum calls stale blocks uncle blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the formula to calculate how much reward a miner of a stale block receives.
    The rest of the reward goes to the nephew block, that is, the block that includes
    the orphan block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As not rewarding the miners of stale blocks doesn't harm any security, you must
    be wondering why miners of stale blocks get rewarded? Well, there is another issue
    caused when stale blocks occur frequently in the network, which is solved by rewarding
    the miners of stale blocks. A miner should earn a percentage of reward similar
    to the percentage of hash power it contributes to the network. When a block is
    mined at nearly the same time by two different miners, then the block mined by
    the miner with more hash power is more likely to get added to the final blockchain
    because of the miner's efficiency to mine the next block; therefore, the small
    miner will lose reward. If the stale rate is low, it's not a big issue because
    the big miner will get a little increase in reward; but if the stale rate is high,
    it causes a big issue, that is, the big miner in the network will end up taking
    much more rewards than it should receive. The ghost protocol balances this by
    rewarding the miners of stale blocks. As the big miner doesn't take all the rewards
    but much more than it should get, we don't award stale block miners the same as
    the nephew block; instead, we award a lesser amount to balance it. The preceding
    formula balances it pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: Ghost limits the total number of stale blocks a nephew can reference so that
    miners don't simply mine stale blocks and stall the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: So wherever a stale block appears in the network, it somewhat affects the network.
    The more the frequency of stale blocks, the more the network is affected by it.
  prefs: []
  type: TYPE_NORMAL
- en: Forking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fork is said to have happened when there is a conflict among the nodes regarding
    the validity of a blockchain, that is, more than one blockchain happens to be
    in the network, and every blockchain is validated for some miners. There are three
    kinds of forks: regular forks, soft fork, and hard fork.'
  prefs: []
  type: TYPE_NORMAL
- en: A regular fork is a temporary conflict occurring due to two or more miners finding
    a block at nearly the same time. It's resolved when one of them has more difficulty
    than the other.
  prefs: []
  type: TYPE_NORMAL
- en: A change to the source code could cause conflicts. Depending on the type of
    conflict, it may require miners with more than 50% of hash power to upgrade or
    all miners to upgrade to resolve the conflict. When it requires miners with more
    than 50% of hash power to upgrade to resolve the conflict, its called a soft fork,
    whereas when it requires all the miners to upgrade to resolve the conflict, its
    called a hard fork. An example of a soft fork would be if update to the source
    code invalidates subset of old blocks/transactions, then it can be resolved when
    miners more than 50% of hash power have upgraded so that the new blockchain will
    have more difficulty and finally get accepted by the whole network. An example
    of a hard fork would be an if update in the source code was to change the rewards
    for miners, then all the miners needs to upgrade to resolve the conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has gone through various hard and soft forks since its release.
  prefs: []
  type: TYPE_NORMAL
- en: Genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A genesis block is the first block of the blockchain. It's assigned to block
    number 0\. It's the only block in the blockchain that doesn't reference to a previous
    block because there isn't any. It doesn't hold any transactions because there
    isn't any ether produced yet.
  prefs: []
  type: TYPE_NORMAL
- en: Two nodes in a network will only pair with each other if they both have the
    same genesis block, that is, blocks synchronization will only happen if both peers
    have the same genesis block, otherwise they both will reject each other. A different
    genesis block of high difficulty cannot replace a lower difficult one. Every node
    generates its own genesis block. For various networks, the genesis block is hardcoded
    into the client.
  prefs: []
  type: TYPE_NORMAL
- en: Ether denominations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ether has various denominations just like any other currency. Here are the
    denominations:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Ether = 1000000000000000000 Wei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 1000000000000000 Kwei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 1000000000000 Mwei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 1000000000 Gwei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 1000000 Szabo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 1000 Finney
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 0.001 Kether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 0.000001 Mether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 0.000000001 Gether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Ether = 0.000000000001 Tether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum virtual machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EVM (or Ethereum virtual machine) is the Ethereum smart contracts byte-code
    execution environment. Every node in the network runs EVM. All the nodes execute
    all the transactions that point to smart contracts using EVM, so every node does
    the same calculations and stores the same values. Transactions that only transfer
    ether also require some calculation, that is, to find out whether the address
    has a balance or not and deduct the balance accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Every node executes the transactions and stores the final state due to various
    reasons. For example, if there is a smart contract that stores the names and details
    of everyone attending a party, whenever a new person is added, a new transaction
    is broadcasted to the network. For any node in the network to display details
    of everyone attending the party, they simply need to read the final state of the
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Every transaction requires some computation and storage in the network. Therefore,
    there needs to be a transaction cost, otherwise the whole network will be flooded
    with spam transactions, and also without a transaction cost, miners will have
    no reason to include transactions in blocks, and they will start mining empty
    blocks. Every transaction requires different amount of computation and storage;
    therefore, every transaction has different transaction costs.
  prefs: []
  type: TYPE_NORMAL
- en: There are two implementations of EVM, that is, byte-code VM and JIT-VM. At the
    time of writing this book, JIT-VM is available for use, but its development is
    still not completed. In either case, the Solidity code is compiled to byte code.
    In the case of JIT-VM, the byte code is further compiled. JIT-VM is more efficient
    than it's counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Gas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gas is a unit of measurement for computational steps. Every transaction is required
    to include a gas limit and a fee that it is willing to pay per gas (that is, pay
    per computation); miners have the choice of including the transaction and collecting
    the fee. If the gas used by the transaction is less than or equal to the gas limit,
    the transaction processes. If the total gas exceeds the gas limit, then all changes
    are reverted, except that the transaction is still valid and the fee (that is,
    the product of the maximum gas that can be used and gas price) can still be collected
    by the miner.
  prefs: []
  type: TYPE_NORMAL
- en: The miners decide the gas price (that is, price per computation). If a transaction
    has a lower gas price than the gas price decided by a miner, the miner will refuse
    to mine the transaction. The gas price is an amount in a wei unit. So, a miner
    can refuse to include a transaction in a block if the gas price is lower than
    what it needs.
  prefs: []
  type: TYPE_NORMAL
- en: Each operation in EVM is assigned a number of how much gas it consumes.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction costs affect the maximum ether an account can transfer to another
    account. For example, if an account has an ether balance of five, it cannot transfer
    all five ethers to another account because if all ethers are transferred, there
    would be no balance in the account to deduct transaction fees from.
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction invokes a contract method and the method sends some ether or
    invokes some other contract method, the transaction fee is deducted from the account
    that invoked the contract method.
  prefs: []
  type: TYPE_NORMAL
- en: Peer discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a node to be part of the network, it needs to connect to some other nodes
    in the network so that it can broadcast transactions/blocks and listen to new
    transactions/blocks. A node doesn't need to connect to every node in the network;
    instead, a node connects to a few other nodes. And these nodes connect to a few
    other nodes. In this way, the whole network is connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: But how does a node find some other nodes in the network as there is no central
    server that everyone can connect to so as to exchange their information? Ethereum
    has its own node discovery protocol to solve this problem, which is based on the
    Kadelima protocol. In the node discovery protocol, we have special kind of nodes
    called Bootstrap nodes. Bootstrap nodes maintain a list of all nodes that are
    connected to them over a period of time. They don't hold the blockchain itself.
    When peers connect to the Ethereum network, they first connect to the Bootstrap
    nodes ,which share the lists of peers that have connected to them in the last
    predefined time period. The connecting peers then connect and synchronize with
    the peers.
  prefs: []
  type: TYPE_NORMAL
- en: There can be various Ethereum instances, that is, various networks, each having
    its own network ID. The two major Ethereum networks are mainnet and testnet. The
    mainnet one is the one whose ether is traded on exchanges, whereas testnet is
    used by developers to test. Until now, we have learned everything with regards
    to the mainnet blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Bootnode is the most popular implementation of an Ethereum Bootstrap node. If
    you want to host your own Bootstrap node, you can use bootnode.
  prefs: []
  type: TYPE_NORMAL
- en: Whisper and Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whisper and Swarm are a decentralized communication protocol and a decentralized
    storage platform respectively, being developed by Ethereum developers. Whisper
    is a decentralized communication protocol, whereas Swarm is a decentralized filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Whisper lets nodes in the network communicate with each other. It supports broadcasting,
    user-to-user, encrypted messages, and so on. It's not designed to transfer bulk
    data. You can learn more about Whisper at [https://github.com/ethereum/wiki/wiki/Whisper](https://github.com/ethereum/wiki/wiki/Whisper),
    and you can see a code example overview at [https://github.com/ethereum/wiki/wiki/Whisper-Overview](https://github.com/ethereum/wiki/wiki/Whisper-Overview).
  prefs: []
  type: TYPE_NORMAL
- en: Swarm is similar to Filecoin, that is, it differs mostly in terms of technicalities
    and incentives. Filecoin doesn't penalize stores, whereas Swarm penalizes stores;
    therefore, this increases the file availability further. You must be wondering
    how incentive works in swarm. Does it have an internal currency? Actually, Swarm
    doesn't have an internal currency, rather it uses ether for incentives. There
    is a smart contract in Ethereum, which keeps track of incentives. Obviously, the
    smart contract cannot communicate with Swarm; instead, swarm communicates with
    the smart contract. So basically, you pay the stores via the smart contract, and
    the payment is released to the stores after the expiry date. You can also report
    file missing to the smart contract, in which case it can penalize the respective
    stores. You can learn more about the difference between Swarm and IPFS/Filecoin
    at [https://github.com/ethersphere/go-ethereum/wiki/IPFS-&-SWARM](https://github.com/ethersphere/go-ethereum/wiki/IPFS-&-SWARM) 
    and see the smart contract code at [https://github.com/ethersphere/go-ethereum/blob/bzz-config/bzz/bzzcontract/swarm.sol](https://github.com/ethersphere/go-ethereum/blob/bzz-config/bzz/bzzcontract/swarm.sol).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Whisper and Swarm are still under development;
    so, many things are still not clear.
  prefs: []
  type: TYPE_NORMAL
- en: Geth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geth (or called as go-ethereum) is an implementation of Ethereum, Whisper, and
    Swarm nodes. Geth can be used to be part of all of these or only selected ones.
    The reason for combining them is to make them look like a single DApp and also
    so that via one node, a client can access all three DApps.
  prefs: []
  type: TYPE_NORMAL
- en: Geth is a CLI application. It's written in the go programming language. It's
    available for all the major operating systems. The current version of geth doesn't
    yet support Swarm and supports whisper a some of the features of Whisper. At the
    time of writing this book, the latest version of geth was 1.3.5.
  prefs: []
  type: TYPE_NORMAL
- en: Installing geth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geth is available for OS X, Linux, and Windows. It supports two types of installation:
    binary and scripted installation. At the time of writing this book, the latest
    stable version of geth is 1.4.13\. Let''s see how to install it in various operating
    systems using the binary installation method. Scripted installation is used when
    you have to modify something in the geth source code and install it. We don''t
    want to make any changes to the source code, therefore, we will go with binary
    installation.'
  prefs: []
  type: TYPE_NORMAL
- en: OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recommended way of installing geth in OS X is using brew. Run these two
    commands in the terminal to install geth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recommended way to install geth in Ubuntu is to use `apt-get`. Run these
    commands in Ubuntu terminal to install geth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geth comes as an executable file for Windows. Download the zip file from [https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows](https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows),
    and extract it. Inside it, you will find the `geth.exe` file.
  prefs: []
  type: TYPE_NORMAL
- en: To find more about installing geth on various operating systems, visit [https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum).
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC and JavaScript console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geth provides JSON-RPC APIs for other applications to communicate with it.
    Geth serves JSON-RPC APIs using HTTP, WebSocket, and other protocols. The APIs
    provided by JSON-RPC are divided into these categories: admin, debug, eth, miner,
    net, personal, shh, txpool, and web3\. You can find more information about it
    these [https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console).'
  prefs: []
  type: TYPE_NORMAL
- en: Geth also provides an interactive JavaScript console to interact with it programmatically
    using JavaScript APIs. This interactive console uses JSON-RPC over IPC to communicate
    with geth. We will learn more about the JSON-RPC and the JavaScript APIs in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-commands and options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn some of the important sub-commands and options of the geth command
    using examples. You can find the list of all sub-commands and options by using
    the help sub-command. We will see a lot more about geth and its commands throughout
    the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the mainnet network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nodes in the Ethereum network, by default, communicate using `30303` port. But
    nodes are also free to listen on some other port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the mainnet network, you just need to run the `geth` command.
    Here is an example of how to specify the network ID explicitly and specify a custom
    directory where geth will store the downloaded blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `--datadir` option is used to specify where to store the blockchain. If
    it's not provided, the default path is `$HOME/.ethereum`.
  prefs: []
  type: TYPE_NORMAL
- en: '`--networkid` is used to specify the network ID. 1 is the ID of the mainnet
    network. If it''s not provided, the default value is 1\. The network ID of testnet
    is 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a private network, you just need to give a random network ID. Private
    networks are usually created for development purposes. Geth also provide various
    flags related to logging and debugging, which are useful during development. So,
    instead of giving a random network ID and putting the various logging and debugging
    flags, we can simply use the `--dev` flag, which runs a private network with various
    debugging and logging flags enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Creating accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geth also lets us create accounts, that is, generate keys and addresses associated
    with them. To create an account, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you run this command, you will be asked to enter a password to encrypt
    your account. If you forget your password, there is no way to access your account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of all accounts in your local Wallet, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will print a list of all the addresses of the accounts.
    Keys are, by default, stored in the `--datadir` path, but you can use the `--keystore`
    option to specify a different directory.
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, geth doesn''t start mining. To instruct geth to start mining, you
    just need to provide the `--mine` option. There are a few other options related
    to mining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, along with the `--mine` option, we have provided various other options.
    The `--minerthreads` option specifies the total number of threads to use while
    hashing. By default, eight threads are used. Etherbase is the address to which
    the reward earned by mining is deposited. By default, accounts are encrypted.
    So to access the ether in the account, we need to unlock it, that is, decrypt
    the account. Decryption is used to decrypt the private key associated with the
    account. To start mining, we don't need to unlock it because only the address
    is required to deposit the mining rewards. One or more accounts can be unlocked
    using the -unlock option. Multiple addresses can be provided by separating the
    addresses using comma.
  prefs: []
  type: TYPE_NORMAL
- en: '`--minergpus` is used to specify the GPUs to use for mining. To get the list
    of GPUs, use the `geth gpuinfo` command. For each GPU, you need to have 1-2 GB
    of RAM. By default, it doesn''t use GPUs, instead only CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: Fast synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, the blockchain size is around 30 GB. Downloading
    it may take several hours or days if you have a slow Internet connection. Ethereum
    implements a fast synchronization algorithm, which can download the blockchain
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Fast synchronization doesn't download the entire blocks; instead, it only downloads
    the block headers, transactions receipts, and the recent state database. So, we
    don't have to download and replay all transactions. To check blockchain integrity,
    the algorithm downloads a full block after every defined number of blocks. To
    learn more about fast synchronization algorithm, visit [https://github.com/ethereum/go-ethereum/pull/1889](https://github.com/ethereum/go-ethereum/pull/1889).
  prefs: []
  type: TYPE_NORMAL
- en: To use fast sync while downloading the blockchain, you need to use the `--fast`
    flag while running geth.
  prefs: []
  type: TYPE_NORMAL
- en: Due to security reasons, fast sync will only run during an initial sync (that
    is, when the node's own blockchain is empty). After a node manages to successfully
    sync with the network, fast sync is forever disabled. As an additional safety
    feature, if a fast sync fails close to or after the random pivot point, it is
    disabled as a safety precaution, and the node reverts to full, block-processing-based
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Wallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum Wallet is an Ethereum UI client that lets you create account, send
    ether, deploy contracts, invoke methods of contracts, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Wallet comes with geth bundled. When you run Ethereum, it tries to
    find a local geth instance and connects to it, and if it cannot find geth running,
    it launches its own geth node. Ethereum Wallet communicates with geth using IPC.
    Geth supports file-based IPC.
  prefs: []
  type: TYPE_NORMAL
- en: If you change the data directory while running geth, you are also changing the
    IPC file path. So for Ethereum Wallet to find and connect to your geth instance,
    you need to use the `--ipcpath` option to specify the IPC file location to its
    default location so that Ethereum Wallet can find it; otherwise Ethereum Wallet
    won't be able to find it and will start its own geth instance. To find the default
    IPC file path, run geth help, and it will show the default path next to the `--ipcpath`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases) 
    to download Ethereum Wallet. It''s available for Linux, OS X, and Windows. Just
    like geth, it has two installation modes: binary and scripted installation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an image that shows what Ethereum Wallet looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Mist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mist is a client for Ethereum, Whisper, and Swarm. It lets us send transactions,
    send Whisper messages, inspect blockchains, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The relation between Mist and geth is similar to the relation between Ethereum
    Wallet and geth.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular feature of Mist is that it comes with a browser. Currently,
    the frontend JavaScript running in the browser can access the web3 APIs of the
    geth node using the `web3.js` library (a library that provides Ethereum console's
    JavaScript APIs for other applications to communicate with geth).
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of Mist is to build the third generation web (Web 3.0), which
    would wipe out the need to have servers by using Ethereum, Whisper, and Swarm
    as replacements for centralized servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an image, showing what Mist looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Weaknesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system has some weaknesses. Similarly, Ethereum also has some weaknesses.
    Obviously, just like any other application, Ethereum source code can have bugs.
    And also just like any other network-based application, Ethereum is also exposed
    to DoS attacks. But let's see the unique and most important weaknesses of Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Sybil attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An attacker can attempt to fill the network with regular nodes controlled by
    him; you would then be very likely to connect only to the attacker nodes. Once
    you have connected to the attacker nodes, the attacker can refuse to relay blocks
    and transactions from everyone, thereby disconnecting you from the network. The
    attacker can relay only blocks that he creates, thereby putting you on a separate
    network, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 51% attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the attacker controls more than half of the network hashrate, the attacker
    can generate blocks faster than the rest of the network. The attacker can simply
    preserve his private fork until it becomes longer than the branch built by the
    honest network and then broadcast it.
  prefs: []
  type: TYPE_NORMAL
- en: With more than 50% of hash power, the miner can reverse transactions, prevent
    all/some transactions from getting mined, and prevent other miners' mined blocks
    from getting inserted to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Serenity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serenity is the name of the next major update for Ethereum. At the time of writing
    this book, serenity is still under development. This update will require a hard
    fork. Serenity will change the consensus protocol to casper, and will integrate
    state channels and sharding. Complete details of how these will work is still
    unclear at this point of time. Let's see a high level overview of what these are.
  prefs: []
  type: TYPE_NORMAL
- en: Payment and state channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into state channels, we need to know what payment channels are.
    A payment channel is a feature that allows us to combine more than two transactions
    of sending ether to another account into two transactions. Here is how it works.
    Suppose X is the owner of a video streaming website, and Y is a user. X charges
    one ether for every minute. Now X wants Y to pay after every minute while watching
    the video. Of course, Y can broadcast a transaction every minute, but there are
    few issues here, such as X has to wait for confirmation, so the video will be
    paused for sometime, and so on. This is the problem payment channels solve. Using
    payment channels, Y can lock some ether (maybe 100 ether) for a period of time
    (maybe 24 hours) for X by broadcasting a lock transaction. Now after watching
    a 1 minute video, Y will send a signed record indicating that the lock can be
    unlocked and one ether will go to X''s account and the rest to Y''s account. After
    another minute, Y will send a signed record indicating that the lock can be unlocked,
    and two ether will go to X''s account, and the rest will go to Y''s account. This
    process will keep going as Y watches the video on X''s website. Now once Y has
    watched 100 hours of video or 24 hours of time is about to be reached, X will
    broadcast the final signed record to the network to withdraw funds to his account.
    If X fails to withdraw in 24 hours, the complete refund is made to Y. So in the
    blockchain, we will see only two transactions: lock and unlock.'
  prefs: []
  type: TYPE_NORMAL
- en: Payment channel is for transactions related to sending ether. Similarly, a state
    channel allows us to combine transactions related to smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-stake and casper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into what the casper consensus protocol is, we need to understand
    how the proof-of-stake consensus protocol works.
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-stake is the most common alternative to proof-of-work. Proof-of-work
    wastes too many computational resources. The difference between POW and POS is
    that in POS, a miner doesn't need to solve the puzzle; instead the miner needs
    to prove ownership of the stake to mine the block. In the POS system, ether in
    accounts is treated as a stake, and the probability of a miner mining the block
    is directly proportional to the stake the miner holds. So if the miner holds 10%
    of the stake in the network, it will mine 10% of the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: But the question is how will we know who will mine the next block? We cannot
    simply let the miner with the highest stake always mine the next block because
    this will create centralization. There are various algorithms for next block selection,
    such as randomized block selection, and coin-age-based selection.
  prefs: []
  type: TYPE_NORMAL
- en: Casper is a modified version of POS that tackles various problems of POS.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At present, every node needs to download all transactions, which is huge. At
    the rate at which blockchain size is increasing, in the next few years, it will
    be very difficult to download the whole blockchain and keep it in sync.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with distributed database architecture, you must be familiar
    with sharding. If not, then sharding is a method of distributing data across multiple
    computers. Ethereum will implement sharding to partition and distribute the blockchain
    across nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about sharding a blockchain at [https://github.com/ethereum/wiki/wiki/Sharding-FAQ](https://github.com/ethereum/wiki/wiki/Sharding-FAQ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned in detail about how Ethereum works. We learned how
    block time affects security and about the weaknesses of Ethereum. We also saw
    what Mist and Ethereum Wallet are and how to install them. We also saw some of
    the important commands of geth. Finally, we learned what is going to be new in
    Serenity updates for Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the various ways to store and protect
    ether.
  prefs: []
  type: TYPE_NORMAL
