- en: Blockchain Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain architecture covers the fundamentals when it comes to understanding
    how the blockchain works internally. It is essential to be able to work on different
    projects that use different areas of Ethereum, because once you have a solid understanding
    about how everything works together, your mind will begin to see things differently.
    You will get a high-level overview of what happens in the blockchain when you
    use it and when you program for it. The moving parts of this complex ecosystem
    will begin to make so much sense once you go through this chapter, because you'll
    receive a high-level overview of how smart contracts work and how they are related
    to the underlying structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Ethereum
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EEA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Ethereum blockchain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-level overview of how smart contracts work
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential smart contract programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond Ethereum
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably understand what Ethereum is, but just to make sure that we are
    on the same page, it's important that you have some background knowledge about
    what Ethereum really is in order to progress further without too many distractions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Ethereum
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethereum is, first and foremost, a blockchain. Ethereum is a technology that
    runs on many computers and provides its consumers with a guarantee that they are
    trusting a solid system that will work as expected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '"Ethereum is the world computer."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: -Vitalik Buterin
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the core Ethereum ideas, check their official website:
    [https://ethereum.org](https://ethereum.org).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A web of thousands of computers connected all over the world are called **nodes**
    and they allow others to get the information they need while trusting the code
    with the goal of decentralizing the internet as we know it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Why is decentralization so important for the internet? Because we have come
    to a point where a few big companies control the information that you and I can
    produce or consume.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Governments have so much power that they are getting out of control with their
    rules. They are biased toward what benefits them and their governors. And it's
    understandable—whenever some entity is at the top of the food chain, it is inevitable
    that they end up controlling the entire system below it sooner or later.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum's goal is to create a censorship-resistant and open platform that allows
    people to trust smart contracts that enforce rules that cannot be controlled by
    third-party entities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When you publish a smart contract, you have a 100% guarantee that the code will
    run at any point and nobody will be able to interfere with it, unless the rules
    of it say so.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum's history
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ethereum was described in Vitalik Buterin''s 2013 whitepaper, which can be
    found at: [https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)[.](https://github.com/ethereum/wiki/wiki/White-Paper)
    He talked about the need of a scripting language that would run on top of Bitcoin,
    since he was involved in *Bitcoin Magazine* and he understood the limitations
    of the Bitcoin blockchain.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊在Vitalik Buterin的2013年白皮书中进行了描述，可以在此处找到：[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)。他谈到了需要一种脚本语言，可以在比特币之上运行，因为他参与了*比特币杂志*，并且他了解比特币区块链的限制。
- en: He saw an opportunity to create a platform that would run on decentralized technology
    to create new types of applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 他看到了创造一个运行在去中心化技术上的平台的机会，以创建新类型的应用程序。
- en: Not many believed in his vision, so he decided to create an entire new blockchain
    by himself with a small team that saw the potential in Vitalik's ideas. He founded
    the Ethereum Switzerland group and decided to run an **Initial Coin Offering**
    (**ICO**) in July 2014, where he sold Ether in exchange for Bitcoin, raising a
    total of about $18 million dollars.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不多的人相信他的愿景，所以他决定自己和一个小团队创建一个全新的区块链，他们看到了Vitalik的想法的潜力。他成立了以太坊瑞士集团，并决定在2014年7月举行一次**首次代币发行**（**ICO**），在那里他以以太币换取比特币，共筹集了约1800万美元。
- en: He created the smart contracts technology, which is basically programs that
    run by themselves without requiring a trusted entity to execute them. They are
    always available, and they run without failure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 他创建了智能合约技术，基本上是无需信任实体执行的程序。它们始终可用，并且无故障运行。
- en: The fact that Ethereum provided a system that allows people to create their
    own applications on top of a blockchain is what made it successful. Before Ethereum,
    there was no simple way to create **decentralized** **applications** (**dApps**)
    in a decentralized platform. Bitcoin has a protocol to create simple applications
    using opcodes with a programming language called Script, but it's not capable
    of much since it is very low level and it's limited by the block size.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊提供了一个允许人们在区块链上创建自己应用程序的系统，这是它成功的原因。在以太坊之前，没有一种简单的方法在去中心化平台上创建**去中心化应用程序**（**dApps**）。比特币有一个使用操作码的协议，使用一种名为Script的编程语言创建简单的应用程序，但它的能力有限，因为它是非常低级的，并且受到区块大小的限制。
- en: Ethereum's development
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊的发展
- en: 'The development of Ethereum was planned to be done in four different stages,
    with major changes in each one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的发展计划分为四个不同阶段，每个阶段都有重大变化：
- en: Frontier
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frontier
- en: Homestead
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homestead
- en: Metropolis
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大都会
- en: Serenity
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宁静
- en: It was used to deliver and research innovative solutions as they were required,
    with a hard fork for functionality that is not backward compatible. In 2015, Frontier
    was launched as the first version of Ethereum. A year later, Homestead was launched,
    which included many improvements and made Ethereum a capable system with enough
    power to process smart contracts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它被用来在需要时交付和研究创新解决方案，并通过硬分叉实现了不向后兼容的功能。2015年，Frontier作为以太坊的第一个版本推出。一年后，推出了Homestead，其中包括许多改进，使以太坊成为一个功能强大、能够处理智能合约的系统。
- en: One of the biggest ICOs conducted on top of Ethereum was the decentralized autonomous
    organization ICO, also known as **the DAO,** which raised $150 million dollars
    with contributions from more than 11,000 people. The problem is that it got hacked
    by an unknown group of individuals that moved the funds to a different DAO. Interestingly
    enough, a group of programmers known as **the White Hat Group** saw the hack happening
    and extracted as many funds as possible into a separate decentralized organization
    known as the **White Hat DAO**, where they stored people's money to distribute
    them later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊之上进行的最大的ICO之一是去中心化自治组织ICO，也被称为**DAO**，它筹集了来自11000多人的1.5亿美元。问题在于，它被一个未知的个人组织攻击了，他们将资金转移到了另一个DAO。有趣的是，一个名为**白帽子组织**的程序员团队看到了这次黑客攻击正在发生，并尽可能多地将资金转移到了一个名为**白帽子DAO**的独立去中心化组织中，他们在那里存放着人们的资金以供以后分配。
- en: This event originated a heated debate in the community that caused Ethereum
    to be divided in two groups, where some believed in the fact that Ethereum must
    be immutable and shouldn't be modified, while others believed in a hard fork to
    revert the damage done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事件引发了社区内的激烈争论，导致以太坊分为两个派别，一些人认为以太坊必须是不可变的，不应该被修改，而另一些人则认为应该进行硬分叉以恢复所造成的损失。
- en: 'That was the beginning of Ethereum Classic and Ethereum as we know it. Ethereum
    Classic has a noticeable smaller user base, but it preserves the initial immutability
    ideals that they consider essential for a blockchain. In March 2017, several companies
    joined efforts to create the **Ethereum Enterprise Alliance** (**EEA**), which
    is currently a non-profit organization made of more than 500 members whose goal
    is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是以太坊经典和我们所知的以太坊的开端。以太坊经典的用户群明显较小，但它保留了他们认为区块链必不可少的初始不可变性理念。 2017年3月，几家公司联合努力创建了目前超过500名成员的非营利组织**以太坊企业联盟**（**EEA**），其目标如下：
- en: '"To create open-source, standards-based blockchain specifications."'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建基于开源和标准的区块链规范。"'
- en: -Ethereum Enterprise Alliance
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: -以太坊企业联盟
- en: In other words, they created a group of people collaborating on solutions for
    future blockchains to come, so that they are better, faster, and more capable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，他们创建了一个合作解决未来区块链技术的人群，以使其更好、更快和更有能力。
- en: It suffered from several hacks, where millions of dollars were stolen. They
    had to do a hard fork to save people's funds and have a notorious price volatility,
    but the future looks bright and it continues, improve as demand increases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它遭受了几次黑客攻击，数百万美元被盗。他们不得不进行硬分叉来拯救人们的资金，并且价格的波动性非常大，但未来看起来光明，随着需求的增长而不断改进。
- en: The EEA
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA
- en: The **EEA** ([entethalliance.org](http://entethalliance.org)) is one of the
    most exciting projects being developed by the core Ethereum team, because they
    intend to help companies from all over the world to benefit from decentralized
    technology. By learning about this project, you'll be well positioned when it
    comes to working as an EEA expert.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**EEA** ([entethalliance.org](http://entethalliance.org))是由以太坊核心团队开发的最令人振奋的项目之一，因为他们打算帮助来自世界各地的公司从去中心化技术中受益。通过了解这个项目，当您成为EEA专家时，您将处于良好的位置。'
- en: 'In this section, we will cover the following topics:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下主题：
- en: The EEA's vision
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA的愿景
- en: The EEA membership
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA的会员资格
- en: The EEA architecture
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA架构
- en: Vitalik funded the organization because he received a huge demand from executives
    to create software that could be used in big companies to handle demanding dApps.
    Those companies now want to build a private version of Ethereum to fulfill their
    research and development needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Vitalik资助了组织，因为他收到了来自高管的巨大需求，希望创建可以在大公司中使用来处理要求严格的dApps的软件。这些公司现在希望建立以太坊的私有版本，以满足其研发需求。
- en: What's interesting about this initiative is that they work with hundreds of
    companies to research and develop solutions that are shared across them. For instance,
    if a company member of the EEA creates a new implementation protocol for better
    and faster dApps, they will share it with the other members so that they can also
    benefit from this cutting-edge research, while together growing the Ethereum ecosystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个倡议的有趣之处在于，他们与数百家公司合作研究和开发解决方案，并将其共享。例如，如果EEA的公司成员为更好、更快的dApps创建了新的实施协议，他们将与其他成员分享，以便他们也能从这一最尖端的研究中受益，同时共同发展以太坊生态系统。
- en: The EEA's vision
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA的愿景
- en: 'The EEA''s four big public goals that they envision they will achieve in the
    longer term are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: EEA在较长期内设想实现的四个重要公共目标如下：
- en: '**Be an open source standard, not a product**:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成为一个开源标准，而不是产品**：'
- en: They only work with open source code that can be shared with anybody publicly
    without restrictions in order to spread development advances that may or may not
    help others improve their blockchain products. You see, they are a non-profit
    organization that wants to move blockchain (as we know it) further by combining
    the efforts of many companies interested in private blockchain solutions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 他们只与可以公开分享给任何人而没有限制的开源代码合作，以便传播可能有助于改进他们的区块链产品的开发进展。你看，他们是一个非营利组织，希望通过结合许多对私有区块链解决方案感兴趣的公司的努力，推动区块链（我们知道的）进一步发展。
- en: '**Address enterprise development requirements**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决企业开发需求**：'
- en: The EEA helps companies incorporate the new innovations that are being discovered
    by others for free, so that they can enjoy the benefits of the latest requirements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: EEA帮助公司免费整合其他人发现的新创新，以便享受最新需求的好处。
- en: '**Share improvements between public and private Ethereum**:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在公共和私有以太坊之间分享改进建议**：'
- en: They want to improve what they are building by taking improvements from the
    public blockchain so that they can evolve faster while keeping a great product
    in mind.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 他们希望通过从公共区块链获取改进来改善他们正在构建的东西，以便在保持一个伟大的产品的同时更快地发展。
- en: '**Leverage existing standards**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用现有标准**：'
- en: When it comes to the blockchain technology, much is left to research and discover.
    Many problems regarding scalability, security, and transparency are being studied,
    since this type of decentralized structure is new to modern computing. So, the
    idea is to learn from existing standards, such as **proof-of-stake** (**PoS**),
    to improve faster than anyone else.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到区块链技术时，还有很多需要研究和发现的地方。许多关于可伸缩性、安全性和透明度的问题正在研究中，因为这种去中心化的结构对现代计算来说是新的。因此，想法是借鉴现有标准，例如**权益证明**（**PoS**），以便比其他人更快地提升。
- en: In essence, they are trying to fulfill the demands that many companies are making
    regarding private enterprise and fast blockchains for their personal applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，他们试图满足许多公司对私有企业和快速区块链为其个人应用提出的要求。
- en: The EEA membership
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA 成员资格
- en: What's interesting about the EEA is that any company is free to join by just
    filling a form on their website to become a member of the group for a yearly cost.
    This openness helps many individuals stay relevant with the new improvements on
    the Ethereum blockchain.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何公司都可以通过在他们的网站上填写一个表格免费加入 EEA 成为该团体的成员，每年需支付一定费用。这种开放性有助于许多个人跟上以太坊区块链的新改进。
- en: 'Here''s the breakdown in yearly costs to become a member:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是成为会员的年度费用的分解：
- en: 'Less than 50 employees: $3,000 per year'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不到 50 名员工：每年 3000 美元
- en: 'Between 51 and 500 employees: $10,000 per year'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 51 到 500 名员工：每年 10000 美元
- en: 'Between 501 and 5,000 employees: $15,000 per year'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 501 到 5000 名员工：每年 15000 美元
- en: 'More than 5,000 employees: $25,000 per year'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5000 名以上的员工：每年 25000 美元
- en: Non-profit organizations only pay $3,000 dollars per year, regardless of company
    size. By becoming a member of the Alliance, you can enjoy a series of general
    benefits, such as being able to participate in discussions, voting, open source
    code, meetups, and the prestige that you get from having the EEA logo in your
    website. As a big blockchain company, it makes sense to become a member just for
    the reputation that you'll get by becoming a member with the EEA logo on your
    website.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非营利组织每年只需支付 3000 美元，无论公司规模如何。通过加入联盟，你可以享受一系列普通好处，比如参与讨论、投票、开源代码、见面会，以及在你的网站上展示
    EEA 徽标所带来的声望。作为一家大型区块链公司，成为成员只为了在你的网站上展示 EEA 徽标所带来的声誉是有道理的。
- en: 'The benefits depend on the type of company you are in, and you can see them
    in the following section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好处取决于你所在公司的类型，你可以在下一节中看到它们：
- en: Class A members are the directors that run the companies associated with the
    Alliance. They have priorities when reaching decisions and have access to all
    the benefits.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class A 成员是联盟关联公司的董事，他们在做决定时有优先权，并且可以享受所有的好处。
- en: Class B members are those that have a normal company, so they get standard benefits
    without exclusiveness.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class B 成员是拥有一家普通公司的人，因此他们会获得标准好处而没有独家权利。
- en: Class C members are lawyers and legal firms that are in charge of the legal
    challenges when it comes to the research done in the EEA.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class C 成员是负责 EEA 研究中的法律挑战的律师和法律公司。
- en: Class D members are non-profit companies and academic institutions. They get
    basic benefits for the lowest price without voting rights.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class D 成员是非营利组织和学术机构。他们以最低价格获得基本好处，但没有投票权。
- en: The EEA has a powerful pool of about 500 companies, including giants such as
    Intel, Microsoft, and J.P. Morgan. If you run a decent-sized company, you may
    be interested in becoming a member of the EEA just to be a part of this revolution
    when it comes to enterprise blockchains.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EEA 拥有大约 500 家公司的强大联盟，其中包括英特尔、微软和摩根大通等巨头。如果你经营一家体量不小的公司，你可能会有兴趣成为 EEA 的成员，因为这意味着你将成为企业区块链革命的一部分。
- en: The EEA architecture
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA 架构
- en: The enterprise grade applications built with EEA's tools have a very interesting
    structure that builds on top of the existing Ethereum structure. They developed
    the **Enterprise Ethereum Architecture Stack** (**EEAS**), which is a design that
    specifies how this new type of Ethereum blockchain should work in a private setting,
    with features designed for privacy. The team working on the Ethereum Enterprise
    project details functions of this type of private blockchain without regard to
    the underlying technology below it, such as software code, APIs, and communication
    protocols. What the EEA intends to do is focus on creating what's described in
    their specification so that people can enjoy private blockchains for their companies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EEA 工具构建的企业级应用具有非常有趣的结构，建立在现有以太坊结构之上。他们开发了**企业以太坊架构堆栈**（**EEAS**），这是一个设计，指定了这种新类型的以太坊区块链应如何在私有环境中运作，具有专为隐私设计的功能。致力于以太坊企业项目的团队详细说明了这种私有区块链的功能，而不考虑其下层技术，如软件代码、API
    和通信协议。EEA 的意图是专注于创建他们规范中描述的内容，以便人们可以为其公司享受私有区块链。
- en: 'The tooling will benefit from innovative solutions exclusive to the Enterprise
    Ethereum blockchain, such as the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 包括以下独家于企业以太坊区块链的创新解决方案：
- en: '**Hardware security module** (**HSM**): This is a physical computing device
    that safely stores digital keys, such as your private cryptocurrency keys, with
    maximum security features. For instance, Ledger and Trezor are hardware wallets
    that are also called HSMs, because they provide security in a physical device
    for your blockchain private keys.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件安全模块**（**HSM**）：这是一种安全存储数字密钥的物理计算设备，例如您的私人加密货币密钥，具有最大的安全功能。例如，Ledger 和
    Trezor 是也被称为 HSM 的硬件钱包，因为它们为您的区块链私钥提供了物理设备的安全性。'
- en: '**Permissioning and authentication**: This is useful in order to give users
    specific roles with limited access to certain areas in a more structured fashion.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限和认证**：这对于以更加结构化的方式为用户赋予特定角色并限制对某些区域的访问非常有用。'
- en: '**Enterprise management systems**: This is used to help companies control their
    private blockchain internal workings.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业管理系统**：这用于帮助公司控制其私有区块链的内部工作。'
- en: '**Oracles**: These are helpful for communicating with external services for
    custom smart contracts written on top of the enterprise private blockchain. They
    are essential to exchange key information with the outer world.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预言机**：这对于与构建在企业私有区块链之上的自定义智能合约进行通信的外部服务非常有帮助。它们是与外部世界交换关键信息的必要手段。'
- en: 'Regarding privacy and scaling, we know that many different teams are working
    on creating unique solutions that could benefit the entire community. However,
    we know that, initially, the blockchain will use two main systems to scale the
    capacity of existing dApps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隐私和扩展性，我们知道许多不同的团队正在努力创建独特的解决方案，这些解决方案可能会使整个社区受益。然而，我们知道，最初，区块链将使用两个主要系统来扩展现有
    dApps 的容量：
- en: '**Off-chain transactions with trusted execution**: Protocols such as plasma
    and state channels are being developed to leverage off-chain transactions that
    can be executed locally by users'' computers to reduce the computing load of the
    main blockchain.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与可信执行的离链交易**：诸如 plasma 和状态通道等协议正在开发中，以利用可以由用户的计算机本地执行的离链交易，从而减少主区块链的计算负载。'
- en: '**Private transactions**: Transactions that use zero-knowledge proofs, ring
    signatures, and many other famous protocols to guarantee the privacy of the data
    being exchanged with the public blockchain. This is an important aspect that companies
    demand because they have private data and internal processes that can''t be shared
    publicly. We cannot know which solution they will choose, so it''s up to them
    to decide. They will also implement private code execution that will allow companies
    to execute certain smart contract transactions in a secure environment, where
    the users will see an encoded hash.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私密交易**：使用零知识证明、环签名和许多其他著名协议来保证与公共区块链交换的数据的隐私的交易。这是公司需求的一个重要方面，因为它们拥有不能公开共享的私有数据和内部流程。我们无法知道他们将选择哪种解决方案，所以这取决于他们自己的决定。他们还将实现私有代码执行，使公司能够在安全环境中执行某些智能合约交易，用户将看到一个编码的哈希。'
- en: 'The EEA is building three additional elements on top of the existing core blockchain:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: EEA 正在现有核心区块链之上构建三个额外的元素：
- en: '**On-chain private state**: This is a separate storage compartment where they
    will store private states of smart contracts. It will provide us, the developers,
    truly private variables and store functions that we''ll be able to use for keeping
    information secure and unseen by the public. It''s very powerful for enterprise-grade
    dApps.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链上私有状态**：这是一个单独的存储区，用于存储智能合约的私有状态。它将为我们，开发人员，提供真正的私有变量和存储函数，我们将能够使用这些函数来保持信息安全，不被公众所见。这对企业级
    dApp 非常强大。'
- en: '**Trusted execution**: These are systems that will provide a trusted execution
    environment where the code will be executed without interfering with public processes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可信执行**：这些系统将提供可信执行环境，在此环境中，代码将被执行，而不会干扰公共流程。'
- en: '**Private consensus**: Companies will have the ability to reach agreements
    using their own private blockchain for their own systems, similar to voting systems
    that we can see in the *Decentralized autonomous organizations* section in: [Chapter
    3](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml), *Ethereum Assets*.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有共识**：公司将能够使用自己的私有区块链为其自身系统达成协议，类似于我们可以在[第三章](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml)的*去中心化自治组织*部分看到的投票系统。*以太坊资产*。'
- en: Lastly, the blockchain network layer will benefit from Enterprise P2P, which
    will be used to exchange transactions in smaller networks of nodes that are set
    up by the company, so that they enjoy the benefits of faster processing speeds
    and confirmation times. Enterprise blockchains will be able to interact with other
    networks, including the public blockchain to exchange information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，区块链网络层将受益于企业 P2P，该层将用于在公司设置的更小的节点网络中交换交易，以便它们享受更快的处理速度和确认时间带来的好处。企业区块链将能够与其他网络进行交互，包括公共区块链，以交换信息。
- en: Understanding the Ethereum blockchain
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解以太坊区块链
- en: The Ethereum blockchain is a complex system made of several important components
    that work together to achieve an impressive platform that everybody can use to
    create unstoppable applications. You'll learn the intricacies of the internal
    workings of the blockchain to gain a greater understanding about how it's made.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链是一个由几个重要组件组成的复杂系统，这些组件共同工作，形成一个令人印象深刻的平台，每个人都可以用来创建不可阻止的应用程序。您将学习区块链内部工作的复杂性，以更深入地了解它的构造方式。
- en: The reasoning behind a decentralized blockchain
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化区块链的原理
- en: At the most basic level, the Ethereum blockchain is a set of connected blocks
    that contain information that many nodes share so that there's an unchangeable
    data structure to keep information permanently. The goal of any blockchain is
    to preserve information without the possibility of changing it or deleting it
    to avoid censorship or manipulation by external entities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，以太坊区块链是一组连接的块，其中包含许多节点共享的信息，以便保持不可改变的数据结构，永久保存信息。任何区块链的目标都是保留信息，而不可能更改或删除它，以避免外部实体的审查或操纵。
- en: As such, the Ethereum blockchain builds upon that concept by implementing several
    well-known tools, thanks to Bitcoin and previous research to create programs that
    run on top of those blocks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以太坊区块链通过实施几种众所周知的工具，借助比特币和先前的研究创建了运行在这些区块之上的程序，从而建立在该概念基础上。
- en: To understand how the Ethereum blockchain works internally, we have to understand
    each component that makes up a blockchain. First, I'll give you a high-level overview
    of the blockchain as a set of nodes, and then we'll go through each component
    from higher to lower levels in the pyramid that makes the blockchain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解以太坊区块链的内部工作原理，我们必须了解构成区块链的每个组件。首先，我将为您概述区块链作为一组节点，然后我们将逐个从金字塔形成的较高到较低级别的每个组件进行介绍。
- en: The blockchain as a set of nodes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链作为一组节点
- en: Ethereum is a decentralized platform, which means that two or more nodes work
    together in a coordinated fashion to achieve a common outcome in a way that the
    end user sees as a single operation. A node performs various types of functions
    depending on the role it decides to take. It can propose and validate transactions
    with mining software to achieve consensus while securing the blockchain using
    the **proof-of-work** (**PoW**) protocol or be a light-weight node that performs
    payment verification and many other tasks that can be done with limited resources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain is based on Bitcoin, since the system created by Satoshi
    Nakamoto is a very robust decentralized solution. In fact, it uses a system to
    execute decentralized code using opcodes that can process basic instructions on
    top of a network of hundreds of thousands of computers in a safe manner. They
    must be simple to preserve security above all.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Although both blockchains are quite similar in their systems, they have noticeable
    differences, such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin and Ethereum use PoW to generate blocks, while Ethereum intends to move
    to PoS as the block generation system in the future to avoid wasting computational
    power.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum uses the Ethash algorithm, while Bitcoin uses SHA256 for processing
    transactions and generating blocks.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum's block time is about 15 seconds, which is about 100 times faster than
    Bitcoin's. This gives people better confirmation times.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Ethereum blockchain is decentralized and distributed, which means that
    the connected nodes have several relationships with each other independently,
    while running the same software at different locations. This is very important
    to guarantee the unstoppable aspect of the blockchain. Here what each term means:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized network**: This is a network of computers running without a
    single point of control, no entity controls the entire system, and each node is
    connected to other nodes directly in a **peer-to-peer** (**P2P**) relationship.
    If the blockchain wasn''t decentralized, some government or entity could locate
    the main controller node and stop the entire system immediately.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed network**: This is a network where many different computers run
    on different locations with the same software. If the blockchain wasn''t distributed,
    some entity could go to where all the nodes are located and stop the entire operation
    because they are all in the same place, so none are safe from such an attack.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see in the following diagram how the structure of these types of technologies
    connect nodes together so that they can communicate with complete security, in
    their own way, since it''s often a confusing point when trying to understand the
    differences between distributed and decentralized systems:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe07ba80-1398-4356-b5b1-34642bd7d179.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Those two characteristics give the Ethereum network the capacity to work without
    having to rely on anybody, because thousands of nodes are able to communicate
    between each other in a secured and independent fashion. Notice that Ethereum
    is a completely open blockchain, meaning that anybody is free to join and participate
    in the decisions that take place, such as block creation and transaction processing.
    It allows people to join the network of nodes as a participant without any requirements,
    since the entire structure is secured by cryptographically-safe algorithms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征使得以太坊网络有能力不必依赖任何人即可运行，因为成千上万的节点能够在受保护且独立的方式之间相互通信。请注意，以太坊是完全开放的区块链，这意味着任何人都可以自由加入并参与其中的决策，比如区块创建和交易处理。它允许人们以参与者的身份加入节点网络，而不需要任何要求，因为整个结构都由密码安全算法保护。
- en: Nodes can work together or become malicious by executing unexpected code. Those
    that exhibit arbitrary behavior are known as **Byzantine nodes**. The main goal
    is to create a system where nodes cooperate even in the worst situations, with
    fault-tolerance protections in place to avoid breaking the entire structure. But
    how do they work together if the nodes making the blockchain can behave randomly
    because they are Byzantine nodes?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以共同工作，也可以通过执行意外代码而变得恶意。那些表现出任意行为的被称为**拜占庭节点**。主要目标是创建一个系统，即使在最坏的情况下节点也能合作，在那里它们存在容错保护以避免破坏整个结构。但是如果做出区块链的节点可以因为是拜占庭节点而随机行事，它们怎么能一起工作呢？
- en: At the end of the day, it's a group of computers working voluntarily toward
    the same objective. Nothing stops them from doing unexpected actions. That's where
    one of the most interesting problems that blockchain is facing lies. There are
    several solutions, but research is still being done to obtain a perfect balance
    between performance and security in a decentralized system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一组计算机志愿地朝着同一个目标工作。没有什么能阻止它们执行意外的动作。这正是区块链面临的最有趣的问题之一。有几种解决方案，但仍在进行研究，以在分散式系统中在性能和安全性之间获得完美平衡。
- en: The CAP theorem
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAP理论
- en: 'The CAP theorem, introduced originally by Eric Brewer in 1998, states that
    any distributed system cannot have all three of these properties simultaneously:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CAP理论最初由Eric Brewer在1998年提出，指出任何分布式系统不能同时具有这三个属性之一：
- en: '**Consistency**: This is a capability of the network of nodes to keep a consistent
    copy of the blockchain data in their computers at the same time.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这是节点网络在同一时间保持一致的区块链数据副本的能力。'
- en: '**Availability**: This means that the system of connected nodes is online and
    available at all times while being accessible by all users to respond to requests
    without failure when required to do so.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这意味着连接节点的系统在线并且始终可用，同时可以在需要时响应所有用户的请求，而无故障。'
- en: '**Partition tolerance**: If a group of nodes of the entire network stops working
    or loses connection for any reason, the system should not be affected, and it
    should continue working properly as if nothing happened.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容忍性**：如果整个网络中的一组节点因任何原因停止工作或失去连接，系统不应受影响，应该继续正常工作，就好像什么都没有发生一样。'
- en: It has been proven that a distributed or decentralized system cannot have all
    three of these properties at the same time, which is interesting because Ethereum,
    just like Bitcoin, achieves all of them at what appears to be the same time. The
    truth is that consistency is not achieved at the same time as partition tolerance
    and availability, but at a later time. You see, in order to have order in such
    a diverse variety of computers, we can only hope to achieve the same level of
    data over time whenever the blockchain grows at an established pace. It lags behind
    the others. This is called **eventual consistency**, where the goal is achieved
    as a result of validating multiple nodes over time. For this reason, the concept
    of mining was introduced in Bitcoin and Ethereum to agree on a consensus with
    the PoW protocol.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 已经证明分布式或分散式系统不能同时具有这三个属性，这很有趣，因为以太坊，就像比特币一样，在看似同时实现了所有这些属性。事实上，一致性并不是与分区容忍性和可用性同时实现的，而是在稍后的时间实现的。你看，为了在这样多样化的计算机中有秩序，我们只能希望在区块链以已建立的速度增长时随着时间达到相同的数据水平。这就是称为**最终一致性**的概念，其中的目标是通过随时间验证多个节点来实现。因此，在比特币和以太坊中引入了挖矿的概念，以
    PoW 协议达成共识。
- en: Eventually, Ethereum plans to move to PoS, which consists of the idea that a
    node or user maintains a stake, a certain number of Ether or any type of valuable
    investment in the system, so that the negative consequences of any malicious activity
    would outweigh the benefits of attacking the network.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，以太坊计划转向PoS，其核心思想是，节点或用户维持一定数量的以太或任何类型的有价值的投资，并使得任何恶意活动的负面后果都超过攻击网络的好处。
- en: For instance, if I want to become a miner to earn some Ether in exchange for
    my time and resources, I have to lock 100 Ether in a smart contract that runs
    the PoS protocol. If I decide to validate invalid blocks or transactions, and
    someone notices my malicious behavior via several security mechanisms, I would
    lose all those 100 Ether and wouldn't be able to attack again. The reward for
    processing a block successfully would be a percentage of the resources invested,
    for example, 0.1 ETH. This forces nodes to cooperate and act responsibly to avoid
    losing a big stake, even if they agree to attack the system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想成为矿工以换取一些以太币作为我的时间和资源，我必须在运行PoS协议的智能合约中锁定100个以太币。 如果我决定验证无效的区块或交易，而某人通过多个安全机制注意到我的恶意行为，我将失去所有这100个以太币，并且无法再次发动攻击。
    成功处理一个块的奖励将是投入的资源的一部分，例如0.1 ETH。 这迫使节点合作并负责行事，以避免失去大笔赌注，即使他们同意攻击系统。
- en: Alternatively, **delegated proof-of-stake** (**DPoS**) could be used in later
    versions of Ethereum. It consists of delegating the validation of a transaction
    to other nodes by voting. It is used in the BitShares blockchain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，**委托权益证明**（**DPoS**）可以在以太坊的后续版本中使用。 它涉及通过投票将交易的验证委托给其他节点。 它在BitShares区块链中使用。
- en: Introducing the Ethereum Virtual Machine
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍以太坊虚拟机
- en: The **Ethereum Virtual Machine** (**EVM**) is a virtual machine that allows
    code to be executed with limitations regarding gas costs and price, where each
    individual interacting with it must pay a fee to protect the network from spamming
    attacks, so that many decentralized nodes can interact with each other using the
    same software. It processes bytecode that gets generated with assembly code, which,
    in turn, uses instruction called **operational codes** (**opcodes**). It's a **Turing
    complete** computer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊虚拟机**（**EVM**）是一台虚拟机，允许执行带有有关燃气成本和价格的限制的代码，每个与之交互的个体都必须支付费用以保护网络免受垃圾邮件攻击，以便许多去中心化节点可以使用相同的软件进行交互。
    它处理使用汇编代码生成的字节码，汇编代码又使用称为操作码的指令（**opcodes**）。 这是一台**图灵完备**的计算机。'
- en: 'When I say Turing complete, I mean that the smart contract programming languages
    running on top of Ethereum have the following properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说图灵完备时，我的意思是在以太坊上运行的智能合约编程语言具有以下特性：
- en: They have unlimited access to **random access memory** (**RAM**)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以无限访问**随机存取内存**（**RAM**）
- en: They can make decisions based on the information available in memory
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以根据内存中的可用信息做出决策
- en: They can run forever with the help of `while`, `for`, and `recursive` loops
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在`while`、`for`和`递归`循环的帮助下永久运行
- en: They can use functions
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用函数
- en: What this means, is that smart contracts are capable of executing any operation
    that you give them, given enough time and resources. This is important to understand
    to avoid confusions when someone says that Ethereum is a Turing complete blockchain.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着智能合约能够执行您给予它们的任何操作，只要有足够的时间和资源。 这一点很重要，以避免有人说以太坊是图灵完备的区块链时产生混淆。
- en: Introducing the state machine
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: The state machine is a mechanism that keeps track of the state changes that
    occur on the blockchain. For instance, a normal day has two simple states, either
    day or night. A state machine would record the situation of each day at every
    moment so that when the sun goes down, the state of the day changes to night.
    It is the same thing with the days of the week. Each day can be one out of seven
    different states, such as Monday or Friday. Whenever it changes at 12 am, the
    state that keeps track of the day of the week gets updated in the state machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一种机制，用于跟踪区块链上发生的状态更改。 例如，一个正常的一天有两种简单状态，要么白天要么晚上。 状态机将记录每天的情况，以便当太阳下山时，白天的状态变为晚上。
    这与一周中的日子一样。 每天可以是七种不同的状态之一，例如星期一或星期五。 每当在午夜时分发生变化时，跟踪一周中日期的状态将在状态机中更新。
- en: 'The state machine enforces consensus rules to make sure that users are processing
    valid transactions in a Byzantine resistant system:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**A P2P network**: It connects the participants and propagates the transactions
    and blocks of verified transactions. This is the network used by the nodes of
    the blockchain to propagate information between them to achieve consensus.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An incentivization scheme**: In the case of Ethereum, that scheme is PoW
    for creating an economically secure state machine. Ethereum developers plan to
    move to a PoS system where the users will process transactions using a passive
    system of transaction verification based on the number of ETH that the miner locks
    at that moment.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An open source client**: This client is the one used by the nodes to interact
    with the blockchain. In Ethereum, we have Geth, Parity, and many others that allow
    you to connect to the blockchain for mining and processing transactions and all
    sorts of tasks after downloading the blockchain.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download a light version of the blockchain by downloading the client
    Geth and running `geth --fast`, which only keeps track of the reference numbers
    of each block to limit the download size of the blockchain, since it can reach
    several hundreds of gigabytes. The purpose of the light client is to make the
    Ethereum blockchain available for low-spec computers with limited storage and
    computing power.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The P2P network
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blockchain runs on top of a P2P network, where nodes are connected to each
    other to exchange data and state updates. Because of this technology, we are able
    to interact directly with other computers in order to process orders so that we
    all agree on the block generation system. It allows miners to be rewarded for
    completing PoW challenges.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Consensus rules
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say consensus, we talk about a group of techniques used in systems with
    many participants to agree on decisions that benefit the whole underlying system.
    While voting gives the power to decide to a few selected individuals that fulfill
    a set of requirements, consensus takes in consideration each and every one of
    the participants to agree on the global way of thinking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Each algorithm that implements any form of consensus when it comes to blockchain
    technology must provide the following features:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**To agree on decisions that benefit the whole system**: The idea is to take
    choices that not only benefit the individual, but the entire network, so that
    everybody has a better platform.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To allow open participation**: Every person should be completely free to
    join and make decisions that they believe will be positive.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To be secure enough so that malicious actors can''t prejudice the system**:
    All the consensus agreements have to be toward the betterment of the systems,
    where malicious users can''t have enough power to decide for many others.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with reaching consensus started with what's known as the **Byzantine
    Generals Problem**, a problem that consists on the fact that many computers can't
    easily agree on a predetermined order. Some computers will receive the order late,
    others will ignore it because they don't benefit from fulfilling it, while others
    will follow the order as best as they can.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 达成共识的问题始于所谓的**拜占庭将军问题**，这个问题在于许多计算机不容易达成预定顺序的一致性。一些计算机会迟收到指令，其他一些会因为不能从中受益而忽略它，而其他一些会尽量按照指令执行。
- en: In essence, consensus rules are mandatory to achieve a global state that all
    agree with, while being rewarded for participating in a beneficial manner in the
    decision-making process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，共识规则是必须实现全球认可的全球状态的，同时也是为了以有益的方式参与决策过程而获得奖励。
- en: Proof-of-work
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作量证明
- en: 'This is a method to guarantee that the result of a task was hard to achieve.
    Why do we want to make processing tasks difficult? To reward those that are best
    at completing it. In a blockchain, it costs processing power, which is just hardware,
    energy, and time, to process transactions made by individuals using the network.
    It is used to generate blocks in a simple process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种保证任务的结果很难完成的方法。为什么我们希望使处理任务变难？为了奖励那些最擅长完成它的人。在区块链中，处理来自使用网络的个人的交易需要处理能力，即硬件，能量和时间。它被用来以简单的过程生成区块：
- en: The miner proposes a new block that contains a hash number made of the header
    of the most recent block and the nonce counter.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖矿者提出一个包含最近区块头和nonce计数器的哈希数字的新区块。
- en: Then, the miner compares the hash to the target value which is determined by
    the mining difficulty.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，挖矿者将哈希与由挖矿难度确定的目标值进行比较。
- en: If the hash is of the target difficulty, the user gets rewarded with the solution
    by getting ETH. If not, the nonce gets incremented until a hash is generated with
    the desired solution.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果哈希达到目标难度，用户将通过获得ETH来获得解决方案的奖励。如果没有，nonce将被递增，直到生成具有期望解决方案的哈希。
- en: Since the miner will be competing with many others, there must be a system to
    make sure that the block times are consistent, because we want to keep generating
    blocks with the same periodicity even when new nodes join the mining network.
    To guarantee similar block times, the mining difficulty was created.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于挖矿者将与许多其他人竞争，所以必须有一个系统来确保区块时间的一致性，因为我们希望即使新节点加入挖矿网络，也能保持以相同周期生成区块。为了保证相似的区块时间，挖矿难度被创建了。
- en: Proof-of-stake
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股权证明
- en: 'PoS is a new algorithm to reach consensus between nodes in a decentralized
    blockchain that focuses on removing the high computing performance requirements
    from PoW while still keeping the network safe from attacks and malicious behavior.
    The way it works is based on locking Ether as a stake and validating blocks with
    the risk of losing your stake if you misbehave. Here''s the process:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PoS是一种新的算法，用于在去中心化区块链中节点之间达成共识，重点是在保持网络免受攻击和恶意行为的同时，消除PoW对高计算性能的要求。它的工作方式是基于锁定Ether作为押注，并验证可能失去押注的区块，如果你行为不端。以下是该过程：
- en: People that want to participate in the PoS process are called **validators**.
    They start by locking a specific number of coins as their stake (for instance,
    100 Ether) that they can't touch while they are mining. It should be expensive
    enough to guarantee that groups of people don't agree on attacking the system
    with the risk of losing their stake if they're unsuccessful.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想参与PoS过程的人被称为**验证者**。他们首先将一定数量的代币锁定为他们的押注（例如，100个Ether），在他们挖矿时不能触及。这应该足够昂贵，可以确保一群人不会同意以攻击系统的方式冒险，如果他们不成功会失去他们的押注。
- en: Then, they start receiving transactions from people using the Ethereum blockchain.
    Validators run programs to validate that the transactions they are receiving are
    valid so that they can create new blocks by grouping transactions in order. When
    they have enough transactions to cover the gas limit per block, they place bets
    on those blocks – for instance, 20 Ether from the initial 100 Ether staked.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，他们开始接收使用以太坊区块链的交易。验证者运行程序来验证他们收到的交易是否有效，以便可以按顺序将交易分组创建新的区块。当他们有足够的交易来覆盖每个区块的gas限制时，他们将对这些区块下注
    - 例如，从最初押注的100 Ether中押注20 Ether。
- en: The block with the most bets is selected as the winner.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下注最多的区块被选为赢家。
- en: When the winning block is selected from the pool of generated blocks, the miners
    that bet on that valid block get a percentage of the total gas used in that block
    based on their bets. They are not paid in block rewards but in transaction fees.
    For instance, if the block selected has 100 transactions accumulating a total
    of 0.5 Ether in transaction costs, that 0.5 Ether will have to be distributed
    between all the validators that bet on that block. If that block has a sum bet
    of 1,000 Ether from 10 users and you bet 20 ether, you'd get a 2% of 0.5 Ether,
    since that's how much you bet for that block. In total, you'd earn 0.01 Ether.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't lose any money when betting for blocks, it's just an indicator of
    how much you trust the validity of that block. It may seem a small reward considering
    that there aren't block rewards, just fees, but you must consider that these blocks
    are being generated in a matter of seconds. Maybe even one second per block, which
    ends up generating a lot of money over the day.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks great in theory, but there''s a major roadblock that''s stopping PoS
    from being completely viable. It''s called the **Nothing at Stake** problem and
    is shown in the following scenario, where there is a main chain and a new chain
    being created with PoS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3268e2-6d03-422b-b546-606c9804d9bd.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: When it comes to PoW, you can mine on any fork that you desire without any risk,
    since you can place bets on every block that looks good to you. What's stopping
    you from deciding to put all your eggs in a new chain, thus generating a hard
    fork?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: If we were using PoW, you couldn't move to a new chain without having to spend
    lots of processing power and time generating new blocks for as long as people
    decide to accept it as a new blockchain. You'd be mining for many months with
    a very slim chance of creating a new chain that could be accepted as a new coin,
    worth much less money because of its reduced use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: But with PoS, you can simply diversify your portfolio and bet on all the blocks
    that look appealing without consequences, since you won't be losing your stake
    as long as you're validating good transactions. You'd be generating blocks on
    several different blockchains without risks. This kind of possibility could end
    up creating hundreds of different blockchains, since people could be mining on
    all of them simultaneously. That's why it's called the **Nothing at Stake** problem,
    because you don't lose anything when participating in the mining process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the main reasons why Ethereum has been unable to switch fully
    to PoS in recent times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Researchers at Ethereum have been working on solving this problem for a long
    time. One of the proposals, known as **Casper**, intends to solve it by punishing
    users that mine on new chains mindlessly by taking their stake out of them, so
    that users focus on betting for the longest chain. Casper also punishes nodes
    that don't actively participate on the network so that they don't start consuming
    resources without providing value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, PoW has to improve or change completely to become sustainable,
    given that many large mining pools are starting to gain too much power. We are
    at a point where four mining companies can achieve about 60% of the total transaction
    power, giving them the choice to run a 51% attack and force all users to mine
    on their own terms with their own corrupted blockchains. PoS is here to stay and
    bring balance back once again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Workings of smart contracts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart contracts are blockchain applications that can execute code and do a diverse
    variety of tasks. These are programs that the miners execute when mining blocks.
    They are secure and unstoppable agreements that are automatically executed and
    enforced. You are probably familiar with them, since this book is aimed at Ethereum
    developers; however, if you don't know how to use them or if you want to learn
    more about them, you can rest assured that you'll understand everything because
    of detailed explanations that you'll be given at the appropriate times.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional paper contracts, smart contracts don't have real-world legal
    consequences on Ethereum, and they can't be enforced by a legal entity when they
    break. Instead, they rely on the principle that code is law, which means that
    the code is the one governing the behaviors of the contract. You can't execute
    functions that are not defined in the smart contract and you must respect each
    function's requirements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: What's interesting about smart contracts is that they allow the creation of
    unstoppable applications that will keep the data and functionalities running on
    top of the blockchain regardless of whether the underlying web interface is not
    available or is censured for whatever reasons. Smart contracts open the world
    to a new type of application that you can deploy and forget, knowing that it will
    work under any circumstances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There's an ongoing debate about whether the code is acceptable as a real contract
    in a court of law. One side thinks that smart contracts have to go further and
    be enforced legally for a more general view of applications, while the other side
    thinks that the code as law is enough to guarantee the security and enforcement
    of the agreements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are programs that run on top of the blockchain in the software
    layer. They allow developers to create decentralized trustless programs that have
    certain functions for managing transactions between individuals. Instead of relying
    on a centralized server, they are the database and the server in decentralized
    applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Inherently, smart contracts must be limited in their capacity given that we
    are executing code that will stay as a transaction on the blockchain permanently,
    meaning that every function you execute gets registered in the blockchain without
    having the option to undo what's been done. This imposes some natural limitations,
    since you can't just modify the public database that every node of the Ethereum
    will have to download without some restrictions. Every change has to be downloaded
    by all the peers of the network.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，智能合约在其容量上必须受到限制，因为我们正在执行的代码将永久地作为区块链上的一笔交易，这意味着您执行的每个函数都会在区块链上注册，而没有撤消已完成的操作的选项。这就施加了一些自然的限制，因为您不能只是修改每个以太坊节点都必须下载的公共数据库而不受任何限制。每次更改都必须由网络的所有节点下载。
- en: The purpose of them is to solve the trust problem that many companies are facing
    when dealing with voting, banking, and situations where people are expected to
    blindly trust companies without disclosing what they do with your data and money.
    They also provide accessibility, since anybody with an internet connection will
    be able to access them and retrieve the data stored inside.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的目的是解决许多公司在处理投票、银行业务以及人们在不公开他们对你的数据和金钱做了什么的情况下所面临的信任问题。它们还提供了可访问性，因为任何有互联网连接的人都能够访问它们并检索存储在内部的数据。
- en: 'However, smart contracts are limited in what they can do. They are not a great
    solution for many cases, such as the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能合约在其所能做的事情上受到限制。对于许多情况来说，它们并不是一个很好的解决方案，比如以下情况：
- en: Applications that require a performing backend that is able to process information
    at a rapid pace, such as creating users and interacting with an application. They
    are slow by nature, since they depend on the block times of Ethereum and they
    cannot work in real-time situations.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个能够以快速速度处理信息的高效后端的应用程序，比如创建用户和与应用程序交互。它们天生就慢，因为它们依赖于以太坊的区块时间，并且它们无法在实时情况下工作。
- en: Applications that store large amounts of data on a database. Smart contracts
    work like a database, since they allow anybody to store certain information on
    top of the blockchain, but they are limited and it's costly to do so.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储大量数据的应用程序在数据库上。智能合约的工作原理类似于数据库，因为它们允许任何人在区块链上存储特定信息，但它们受限且成本高昂。
- en: Gas is another concept that is important to understand properly. It was created
    because smart contracts are Turing complete, which means that they can execute
    loops such as `while` or `for` endlessly until a task is done. It could happen
    that developers create endless loops that are stuck in the same state forever.
    To avoid a situation where thousands of nodes are stuck processing one transaction
    with no limit, each transaction has a gas cost that depends on the processing
    power required to execute it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 是另一个很重要的概念，适当地理解它至关重要。它的创建是因为智能合约是图灵完备的，这意味着它们可以执行无限循环的`while`或`for`，直到完成任务。开发者可能会创建永远停留在相同状态的无限循环。为了避免成千上万的节点被困在处理一笔交易而没有限制的情况，每笔交易都有一个取决于执行它所需的处理能力的
    gas 成本。
- en: 'So, they created a system where you have to pay for every action you take using
    the blockchain. You can store information on the blockchain, but you''ll have
    to pay an important cost, because every single node using it will have to download
    your changes. The way it calculates the gas cost is simple:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们创建了一个系统，你在使用区块链进行每一项操作时都需要付费。你可以在区块链上存储信息，但你将不得不支付重要的成本，因为使用它的每一个单节点都将不得不下载你的更改。它计算
    gas 成本的方式很简单：
- en: You pay a certain maximum gas that you're willing to spend for your transaction.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你支付了你愿意为你的交易花费的最大 gas。
- en: Your local Ethereum node calculates how much it will cost to execute your transaction
    by checking the opcodes used to generate a precise approximation of the computing
    power needed. You see, every small operation using the blockchain can be measured
    because we use a sort of assembly language that tells us when this super computer
    is being used and how.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的本地以太坊节点通过检查用于生成所需计算能力的操作码来计算执行您的交易将花费多少。您知道，使用区块链的每个小操作都可以被测量，因为我们使用一种告诉我们何时正在使用这台超级计算机以及如何使用的一种汇编语言。
- en: The right amount of gas is used, and the rest is refunded to you.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用了正确数量的 gas，并且剩余的部分会退还给您。
- en: You also have to determine a gas price ranging from 1 to usually 100 or more
    to tell miners which transactions to process first, since they get paid more the
    more expensive each gas is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要确定一个从 1 到通常 100 或更高范围的燃气价格，以告诉矿工首先处理哪些交易，因为每个燃气越昂贵，他们就可以得到更多报酬。
- en: Smart contract deployment process
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约部署过程
- en: Smart contracts run on top of the Ethereum blockchain in a similar way to how
    a server-side web application works. However, the process of deploying a smart
    contract to it is vastly different. In order to be an expert Ethereum developer,
    you must understand how the smart contract code is processed and stored in the
    blockchain blocks for you to be able to use them, because it will give you an
    understanding of why and how things can go wrong when pushing your newly written
    smart contract code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约类似于在以太坊区块链上运行的服务器端 Web 应用程序。然而，部署智能合约的过程却大不相同。要成为一名专业的以太坊开发者，你必须理解智能合约代码是如何在区块链块中处理和存储的，以便你能够使用它们，因为这将让你了解在推送你新编写的智能合约代码时可能出现问题的原因和方法。
- en: It's not uncommon to receive errors when trying to deploy your code to the blockchain,
    so to be able to debug it successfully, you need to understand what happens under
    the hood.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试部署代码到区块链时收到错误并不罕见，所以要成功调试它，你需要理解底层发生了什么。
- en: Ethereum transactions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊交易
- en: To understand how smart contracts are deployed on the network, it's important
    to understand first how transactions work, since when you deploy a smart contract,
    what you're actually doing is generating a transaction with the bytecode of the
    application that you just built.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解智能合约如何部署到网络上，首先要了解交易的工作原理是很重要的，因为当你部署一个智能合约时，你实际上是生成了一个带有你刚刚构建的应用程序的字节码的交易。
- en: 'The message that makes up a transaction on Ethereum is made up of the following
    encoded components:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上组成交易的消息由以下编码组件组成：
- en: '**Recipient**: This is the receiver Ethereum address that will get the transaction.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：这是将接收交易的以太坊地址。'
- en: '**Value**: This represents the amount of ether to transfer to the recipient
    address. This value can be zero, and you can access it in Solidity with the global
    `msg.value` variable. The value is always in **wei**, the smallest unit in Ethereum.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价值**：这表示要转移到收件人地址的以太量。这个值可以是零，并且你可以在 Solidity 中使用全局 `msg.value` 变量来访问它。该值始终以以太为单位，是以太坊中的最小单位。'
- en: '**Data**: This is a hexadecimal bytecode string that is mostly used to call
    a specific function with the required parameters. This is specific information
    that you need your smart contract to execute. When smart contracts communicate
    with each other, they need a way to tell when to execute a specific function with
    a given set of variables. Thanks to this data parameter, we can encode the functions
    that we want to call in the contract when the transaction is processed. On the
    other hand, when the smart contract is deployed to the blockchain for the first
    time, the data parameter contains the smart contract converted to bytecode so
    that machines can understand it. In general, it contains the smart contract functions
    to be executed in the next block by the miners.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是一个十六进制的字节码字符串，主要用于调用具有所需参数的特定函数。这是你需要智能合约执行的具体信息。当智能合约彼此通信时，它们需要一种方式来告诉何时以给定的一组变量执行特定函数。由于这个数据参数，我们可以在交易处理时编码我们想要在合约中调用的函数。另一方面，当智能合约首次部署到区块链时，数据参数包含了智能合约转换为字节码的内容，以便机器能够理解它。总的来说，它包含了智能合约函数将由矿工在下一个区块中执行的信息。'
- en: '**Gas limit**: This represents the gas limit, which is how much gas you''re
    willing to spend to process your function transactions. The gas limit is represented
    in wei, and it''s mandatory to give miners as much gas as possible to process
    your code.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃气限额**：这代表了燃气限额，即你愿意为处理你的函数交易支付多少燃气。燃气限额以 wei 表示，给矿工尽可能多的燃气来处理你的代码是强制性的。'
- en: '**Gas price**: The gas price determines how much each gas you provide will
    cost. If your gas cost is one, you''ll pay one wei per gas. If it''s 20, you''ll
    pay 20 wei per 1 gas. It''s used to help miners process the transactions, since
    they will be rewarded partially with the transaction fees.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃气价格**：燃气价格决定了你提供的每个燃气的成本。如果你的燃气成本为 1，你将支付每个燃气 1 wei。如果是 20，你将支付每 1 个燃气 20
    wei。它用于帮助矿工处理交易，因为他们将部分通过交易费用获得奖励。'
- en: '**Nonce**: The nonce is a unique counter number that is used to identify transactions.
    This unique counter is used to identify each block, and it helps miners to identify
    invalid blocks, since the nonce must always be one number bigger than the previous
    block.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nonce**：Nonce是一个用于标识交易的唯一计数器号码。这个唯一计数器用于标识每个区块，并帮助矿工识别无效区块，因为Nonce必须始终比上一个区块的数字大一个数。'
- en: '**Signature**: This is a parameter made of three independent variables known
    as *v*, *r*, and *s*. These variables are used to sign transactions with your
    unique Ethereum address data so that people can confirm that you''re the one that
    created it.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：这是由三个独立变量组成的参数，称为*v*、*r*和*s*。这些变量用于使用你的唯一以太坊地址数据签署交易，以便人们可以确认你是创建者。'
- en: When a user makes a transaction to a smart contract, it's called a **message**
    instead of a transaction. This difference between transaction and message exists,
    because messages don't have signature data since they don't have to be signed
    by the other party. The nonce is required to prevent replay attacks where an external
    user could take the same transaction data and execute it again for his own benefit.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向智能合约发出交易时，称为**消息**而不是交易。交易和消息之间的区别存在，因为消息没有签名数据，因为它们不需要被对方签名。Nonce是必需的，以防止重放攻击，其中外部用户可以获取相同的交易数据并为自己的利益再次执行它。
- en: When you deploy a smart contract, you're actually sending a transaction to the
    address `0x0` with a special bytecode identifier, so that miners understand that
    you're creating a new smart contract. The data parameter in this case contains
    all the smart contract logic, including function names and parameters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署一个智能合约时，实际上你是向地址`0x0`发送一个交易，带有一个特殊的字节码标识符，以便矿工理解你正在创建一个新的智能合约。在这种情况下，数据参数包含所有智能合约逻辑，包括函数名称和参数。
- en: In summary, creating and working with smart contracts is a transparent process,
    where you tell miners to process your data. They will then understand the bytecode
    behind it and make the required changes to the blockchain with the needed parameters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，创建和使用智能合约是一个透明的过程，你告诉矿工处理你的数据。然后他们将理解其背后的字节码，并使用所需的参数对区块链进行必要的更改。
- en: Essential smart contract programming
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的智能合约编程
- en: After understanding how smart contracts are created and where they integrate
    in the blockchain system, you will now get a more practical insight about how
    to create smart contracts using the two most popular languages for it—**Solidity**
    and **Vyper**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了智能合约是如何创建的以及它们如何融入区块链系统后，你现在将更加实际地了解如何使用两种最流行的语言——**Solidity**和**Vyper**来创建智能合约。
- en: Solidity
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity
- en: Solidity is the most advanced programming language created for developing smart
    contracts on the Ethereum network. Its syntax is similar to JavaScript, but with
    statically typed variables and functions. It provides simple features, such as
    functions, loops, and several types of variables, as well as complex functions,
    such as assembly, encryption functions, and signature verification systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是为在以太坊网络上开发智能合约而创建的最先进的编程语言。它的语法类似于JavaScript，但具有静态类型的变量和函数。它提供了简单的功能，如函数、循环和几种类型的变量，以及复杂的功能，如汇编、加密函数和签名验证系统。
- en: It's been used in many projects, especially ICOs, with great success, so it's
    mature enough to be used by any kind of developer interested in developing decentralized
    applications and secure smart contracts.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经在许多项目中被使用，特别是ICO，在取得了巨大成功，因此足够成熟，可以被任何对开发去中心化应用程序和安全智能合约感兴趣的开发者使用。
- en: The main drawback of it is that it's harder to secure, given that it provides
    a more complete set of features that could lead to security issues if not audited.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其主要缺点是它更难以保护，因为它提供了更完整的功能集，这可能导致安全问题，如果不经过审核。
- en: File structure
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件结构
- en: We'll use the 0.5.0 version of Solidity for all the examples in this book. A
    smart contract in Solidity always starts with the version that is used in the
    file to ensure that the contract is not compatible with newer versions that could
    break the contract because of newly added functionalities.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的所有示例中使用Solidity的0.5.0版本。Solidity中的智能合约始终从文件中使用的版本开始，以确保合约与可能因新增功能而破坏合约的新版本不兼容。
- en: 'Let''s look at the structure of a contract in Solidity using the following
    steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来看一下Solidity合约的结构：
- en: 'You define the version at the beginning of the file with the `pragma` statement:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在文件开始使用`pragma`语句来定义版本：
- en: '[PRE0]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you can start writing your contracts. All statements in Solidity must
    end with a semicolon (`;`) to be valid. After defining the version used in the
    file, you have to create the contracts, as shown here:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你可以开始编写你的合同。Solidity中的所有语句必须以分号(`;`)结尾才能有效。在文件中定义了使用的版本后，你必须创建合同，就像这样：
- en: '[PRE1]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can define multiple contracts in one single file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在一个文件中定义多个合同：
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the contract, you''ll have state variables, functions, modifiers, and
    a single constructor. I''ll explain later how they are used in detail:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合同内，你将拥有状态变量，函数，修改器和一个构造函数。稍后我会详细解释它们的用法：
- en: '[PRE3]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The variables that are defined directly in the contract, meaning that they
    are outside functions, are called **state variables**. These are special variables
    that store their value even after executing the contract. Think of them as special
    permanent variables that you can always read and modify:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在合同中定义的变量，即在函数之外定义的变量，被称为**状态变量**。这些都是特殊的变量，即使在执行合同之后也会保留它们的值。把它们想象成特殊的永久性变量，你可以随时读取和修改它们：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, they are outside functions but inside the contract, and they
    are defined at the top of the file, right when the contract begins. As I said,
    they keep their value forever, even after making changes to your contract. So,
    if your `myStateVariable` has a value of `5`, you'll be able to read the value
    of that variable days or months after it has been modified, as long as you don't
    modify it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它们位于函数之外但是在合同之内，并且它们是在文件顶部定义的，就在合同开始的地方。正如我所说，它们永远保持它们的值，即使在修改合同之后也是如此。所以，如果你的`myStateVariable`的值为`5`，你可以在修改它之后的几天或几个月后读取该变量的值，只要你不修改它。
- en: They store their value directly on the blockchain storage, not in memory. In-memory
    variables, as you'll learn later, lose their value and are reset after the contract
    execution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它们直接存储在区块链存储中，而不是在内存中。如你稍后所学，内存变量会在合同执行后失去值并被重置。
- en: Finally, Solidity files use the `.sol` extension, for instance, `example.sol`.
    You will learn how to deploy them with the **Remix IDE** and `Truffle` in *`Chapter
    3`*, *Mastering Smart Contracts,* and *`Chapter 9`*, *Decentralized Exchanged
    Workflow*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Solidity文件使用`.sol`扩展名，例如，`example.sol`。你将学习如何使用**Remix IDE**和`Truffle`部署它们，在*`第3章`*，*`掌握智能合同`*和*`第9章`*，*`去中心化交易工作流`*中。
- en: Variables
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Solidity is a statically typed language, which means that you have to define
    the type of every variable that you create.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种静态类型的语言，这意味着你必须为你创建的每个变量定义类型。
- en: Let's define the types of variables available in this programming language to
    later understand how to use them, but before that, you need to understand the
    visibility of variables.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义这种编程语言中可用的变量类型，以便后来理解如何使用它们，但在此之前，你需要了解变量的可见性。
- en: Visibility of variables
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的可见性
- en: 'Every variable and function in Solidity has a specific visibility. The visibility
    is a keyword you use after the variable type to define who should have access
    to it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的每个变量和函数都有特定的可见性。可见性是你在变量类型后使用的关键字，用来定义谁可以访问它：
- en: '**Public**: This means that the variable can be read or written by any contract,
    including external ones, as long as there''s a function to update them.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：这意味着该变量可以被任何合同读取或写入，包括外部合同，只要有一个函数来更新它们。'
- en: '**Private**: Private variables can''t be accessed by a derived smart contract,
    those that implement your contract with the `is` keyword; for example, `contract
    Example is Another {}`, where `Another` is a smart contract with private variables
    that can''t be accessed by `Example`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：私有变量无法被派生的智能合同访问，那些用`is`关键字实现你的合同的智能合同；例如，`contract Example is Another
    {}`，其中`Another`是一个带有私有变量的智能合同，无法被`Example`访问。'
- en: '**External**: These variables and functions are not accessible by the contract
    containing them. Only external contracts and users can use them.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：这些变量和函数不能被包含它们的合同访问。只有外部合同和用户可以使用它们。'
- en: '**Internal**: These are variables and functions that can''t be read or written
    by external entities, only by the contract itself or by inherited contracts, as
    you saw in the example for the private variable.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：这些是无法被外部实体读取或写入的变量和函数，只能被合同本身或继承的合同访问，就像你在私有变量的例子中看到的那样。'
- en: To keep things simple, I recommend you to always write `public` for your variables
    unless it's a special variable, which doesn't happen that often. If you don't
    define any visibility, the variable will be `public` by default, although it's
    better to just write the `public` keyword in every variable to make sure that
    you understand the visibility of the variable and it's not a mistake.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Uints
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uints are unsigned integers, which means that they are numbers starting from
    zero that can't be negative.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'You define them as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, you first define the type of the variable, then the visibility,
    and then the name of the variable. Remember that if you don't define the visibility
    of the variable, the variable will be `public`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Uints can be of the following types:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`uint8`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint16`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint24`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint64`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint128`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint256`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number for each variable means the size of the `uint`. A `uint8` type of
    variable will be able to store up to 256\. So, the maximum variable of a `uint8`
    variable is `256`. If you want to store the number 255, the variable will work
    properly, but, if you want to store the number `256` as follows, then the variable
    will overflow, and it will reset to zero instead of `256`, because it exceeds
    the capacity of that type of variable:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you try to store a value `256`, the variable resets because it starts at
    zero, so the capacity is the calculated number minus one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when you try to store another number that exceeds the capacity
    of the variable, such as `300`? Then, the value of the variable will be `44`.
    So, input the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It will become the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that you can't assign a value that is bigger than the variable's capacity,
    because you'll get a compilation error in some cases when trying to deploy your
    contract. The overflow problem can happen when you have a function that receives
    a `uint8`, but the user inputs a value bigger than 255.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: This is the same thing with `uint16`, which has a maximum value of *65536*-*1*.
    Likewise, `uint24` has a maximum value of *16777216*-*1*. The `uint32` variable
    has a maximum value of *4294967296*-*1*. The `uint64` variable has a maximum value
    of *1844674407370955e19*-*1*. The `uint128` variable has a maximum value of *3402823669209385e38*-*1*.
    The `uint256` variable has a maximum value of *1157920892373163e77*-*1*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the maximum number grows pretty quickly. This is great to avoid
    overflows when you are dealing with big numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you have the problem of underflows. These happen when you
    try to store a negative number into a `uint`. For instance, try to do this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''ll get the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This happens for the same reason as overflows; you are going from zero to the
    biggest number possible that that variable can hold.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Those problems can result in heavy vulnerabilities. That's why it's important
    that you check that the values that the user inputs in your functions are within
    the range of acceptable numbers. You'll later see how to verify inputs from functions
    with a global function called `require()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能导致严重的漏洞。这就是为什么重要的是检查用户在函数中输入的值是否在可接受数字范围内。稍后你将看到如何使用一个名为`require()`的全局函数来验证函数的输入。
- en: Addresses
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址
- en: In Solidity 0.4.0, there was only one type of address. Now, we have two types
    to define whether an Ethereum address should be payable or not.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity `0.4.0`中，只有一种地址类型。现在，我们有两种类型来定义以太坊地址是否应该是`payable`的。
- en: 'An **address** contains the account number of each user in Ethereum. It''s
    a 42-character piece of hexadecimal text, such as this one:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**地址**包含每个以太坊用户的账号编号。它是一个由`42`个十六进制文本字符组成的文本，例如这样一个：
- en: '[PRE11]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create an `address` variable in your contract, you have to define it as
    follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的合同中创建一个`地址`变量，您必须定义如下：
- en: '[PRE12]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Addresses don''t have quotes because they are not strings of text. In this
    version of Solidity, you must define the type of address, which could be one of
    the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 地址没有引号，因为它们不是文本字符串。在这个版本的Solidity中，你必须定义地址的类型，它可以是以下之一：
- en: '**Address** `payable`**:** A payable address is a new type of variable introduced
    in Solidity `0.5` that allows the address to receive and store Ether inside. Previously,
    all addresses were `payable`, now only those explicitly marked as `payable` will
    be able to receive or send Ether and use functions that deal with Ether, such
    as `.transfer()` or `.send()`.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址** `payable`**：** 可支付地址是在Solidity `0.5`中引入的一种新的变量类型，允许该地址接收和存储以太币。以前，所有地址都是`payable`，现在只有那些明确标记为`payable`的地址才能接收或发送以太币，并且使用处理以太币的函数，如`.transfer()`或`.send()`。'
- en: '**Address:** A normal address that can''t receive or send Ether to prevent
    users from doing so.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址：** 一个普通地址，无法接收或发送以太币，以防止用户这样做。'
- en: 'You define the `payable` addresses as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`payable`地址定义如下：
- en: '[PRE13]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s useful to have payable addresses when you want to send Ether to that
    address. For instance, let''s say that user A wants to receive 10 ether from the
    balance stored in the smart contract. They would do something like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要向该地址发送以太币时，拥有`payable`地址将非常有用。例如，假设用户A想从智能合约存储的余额中收到`10`个以太币。他们将执行以下操作：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, user A would receive 10 ether from the funds stored in this smart contract.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户A将从存储在此智能合约中的资金中收到`10`个以太币。
- en: Another important aspect of the addresses is that you sometimes need to access
    the address of the current smart contract, because, as you know, smart contracts
    can hold Ether inside.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的另一个重要方面是，有时您需要访问当前智能合约的地址，因为，正如您所知，智能合约可以在内部持有以太币。
- en: 'To get the address of your smart contract, use the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您的智能合约地址，请使用以下代码：
- en: '[PRE15]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `this` is the special keyword used to reference the active smart contract
    being used at that moment. But because it is an instance of a smart contract,
    you need to convert that instance to an address with the type conversion function,
    which essentially gets the address of this smart contract.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this`是一个特殊关键词，用于引用当前正在使用的活动智能合约。但因为它是智能合约的一个实例，您需要使用类型转换函数将该实例转换为地址，该函数本质上是获取本智能合约的地址。
- en: 'You can also access the balance of this smart contract with the `.balance`
    function as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`.balance`函数访问此智能合约的余额，如下所示：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That will return the number of wei in the smart contract, useful for making
    transfers with the `transfer()` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回智能合约中的 wei 数量，可用于使用`transfer()`函数进行转账：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That will send `myUserAddress` all the Ether stored inside this contract.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向`myUserAddress`发送存储在此合约中的所有以太币。
- en: You can convert payable addresses to normal addresses, but not the other way
    around, based on the fact that payable addresses are an augmented version with
    additional functions that can't be passed easily.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`payable`地址转换为普通地址，但反之则不行，基于`payable`地址是具有额外函数的增强版本，无法轻松传递。
- en: Strings and bytes
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: 'Strings and bytes hold pieces of text in single or double quotes, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和字节以单引号或双引号形式存储文本片段，如下所示：
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: They allow you to store about 1,000 words and they are essentially the same.
    You can have smaller variations of bytes, such as `bytes1`, `bytes2`, and `bytes3`,
    up to `bytes32`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它们允许您存储大约`1,000`个字，并且它们本质上是相同的。您可以有更小的字节变体，比如`bytes1`，`bytes2`和`bytes3`，一直到`bytes32`。
- en: 'Now, `bytes32` is an interesting type of variable, because it allows you to
    store about 32 characters of text in a very compact and efficient way. They are
    used in many cases where short text is required:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They are used in many other advanced uses cases, such as checking if a string
    or byte''s text is empty. For instance, if you have a function that receives text,
    you may want to make sure that the text is not empty. Here''s how you''d do it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Don''t worry about the technicalities of the function. If you don''t know or
    remember them yet, to check if a string is empty, you must do the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This tells the contract to make sure that the first letter of the string is
    not empty. That's the right way to check for empty strings. We do the same thing
    with bytes, but without the conversion to bytes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Use them whenever you need to add special characters to your strings in Ethereum.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are familiar with JavaScript, you can think of structs as objects with
    properties and values. A `struct` looks similar to the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Enums
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums are fixed size lists with unique names that you define. You can use them
    as custom modifiers for specific objects, or to hold a specific state in your
    smart contract. This is ideal for controlling the state of ICOs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare them as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you create the `enum` variable:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you don't have to add a semicolon at the end of the `enum` declaration,
    but you do have to add it for the variable with the `enum` type that you just
    created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Boolean variable can either be `true` or `false`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Arrays
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays allow you to store large amounts of the same type of variable in one
    place. They are used as lists that contain a specific type of information for
    your smart contracts so that you can store your data in an orderly manner. They
    can be accessed with a simple `for` loop by getting the length of them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create arrays of uints, strings, structs, addresses, and pretty much
    any other type:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also delete elements from an array with the following keyword:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also use `.push()` and `.pop()` to add or remove elements from the array
    in dynamically-sized arrays.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Mappings
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mappings are a special type of variable in the sense that they can hold an
    endless amount of data. It''s like a combination of an array and a struct. You
    can add elements to it for a set of types:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mappings store information as an unlimited array. They work similar to objects
    in JavaScript, where each key has a value associated and they can be accessed
    randomly. They don't have a fixed length, nor can you get the length of them,
    as with arrays, for looping their values. What you must do instead is save the
    latest updated key of your mapping and go from there.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set values for mappings as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our example, all values of `validStrings` will be `false` until you set them
    to `true`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Data location
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Solidity, you have the option to define where your variables will be stored.
    You can decide to store them in the following places:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，您可以选择定义变量存储的位置。您可以决定将它们存储在以下位置：
- en: '**Storage**: This is a permanent place that gets written on the blockchain,
    therefore it''s expensive to use'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：这是在区块链上写入的永久位置，因此使用起来很昂贵'
- en: '**Memory**: This is a non-permanent place where variables are held for only
    as long as the smart contract is running'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：这是一个非永久的地方，变量只在智能合约运行的时间内保存。'
- en: '**Calldata**: This is where the `msg` object data information is stored, a
    place dedicated to global variables'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用数据**：这是`msg`对象数据信息存储的地方，一个专门的全局变量'
- en: 'An example of this is in the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种例子在以下代码中可以看到：
- en: '[PRE30]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Events
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Events are a special type of function. Their purpose is to log data on the blockchain
    and actions that you want to retrieve at a later date. They can be **subscribed
    to** to receive an update whenever a new event is generated, almost in real time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种特殊类型的函数。它们的目的是在区块链上记录数据和您希望在以后检索的操作。它们可以**订阅**以在产生新事件时接收更新，几乎是实时的。
- en: Essentially, you want them to keep a registry of the things that are happening
    inside your smart contract to later analyze them in order to fix bugs and to understand
    what happened if you need to read the past in an easy way.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，您希望它们保留智能合约内部发生的事情的注册表，以便以后分析它们以修复错误，并了解如果需要以轻松的方式阅读过去发生了什么。
- en: 'Here''s how you declare events inside your smart contract in Solidity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Solidity智能合约中声明事件的方式：
- en: '[PRE31]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, you can see how an event is declared and emitted. When you
    declare your event, you have to decide the parameters that it will be able to
    receive; all of them are always optional, so you can omit them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到如何声明和发出一个事件。当您声明事件时，您必须决定它能够接收的参数；它们始终是可选的，因此您可以省略它们。
- en: 'When you emit the event inside a function, you must make sure that they are
    of the right type. In the declaration, you can add a name for each parameter,
    or you can leave it with just the type, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在函数内部发出事件时，必须确保它们是正确的类型。在声明中，您可以为每个参数添加名称，或者只留下类型，如下所示：
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's good practice to name the parameters inside the event, to help others understand
    the purpose of each of those parameters.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 好的做法是在事件内部命名参数，以帮助他人理解每个参数的目的。
- en: 'You can also add an optional keyword called `indexed`. It''s a modifier to
    the parameter of the event that allows you to search past events for that specific
    event. Think of `indexed` parameters as searchable entries in a database:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加一个名为`indexed`的可选关键字。它是事件参数的修饰符，允许您搜索过去的事件以获得特定事件。将`indexed`参数视为数据库中可搜索的条目：
- en: '[PRE33]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that you must name the parameters that are `indexed`. Later you'll see
    how to retrieve those events and search for specific ones with web3.js.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须为`indexed`的参数命名。稍后您将看到如何使用web3.js检索这些事件并搜索特定事件。
- en: Modifiers
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'Modifiers are a special type of function that are used to verify data or execute
    something before the current function execution as a middleware. They are mostly
    used to verify that the user executing the function has the required permissions
    and to verify the parameters:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符是一种特殊类型的函数，用于在当前函数执行之前验证数据或执行某些操作作为中间件。它们主要用于验证执行函数的用户是否具有所需权限，并验证参数：
- en: '[PRE34]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the `onlyOwner` modifier is used to check if the `doSomething`
    function is being executed by the owner of the contract or by another user. If
    the caller is the owner, the functions gets executed, and if it's an external
    address, the contract will revert, and an exception will be thrown.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`onlyOwner`修饰符用于检查`doSomething`函数是由合同所有者执行还是由其他用户执行。如果调用者是所有者，则函数被执行，如果是外部地址，则合同将恢复，抛出异常。
- en: Note that the `require()` function is a global assert function to verify that
    the condition inside it it's true or not. If not, it will throw, and it will stop
    executing the smart contract.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`require()`函数是一个全局断言函数，用于验证其中的条件是否为真。如果条件不为真，它将抛出异常，停止执行智能合约。
- en: 'The underscore statement inside the `_` modifier is used to indicate where
    the code of the function will be executed. Sometimes, you want to execute the
    function before the modifier''s checks. The underscore statement is mandatory
    in modifiers. Also note that the modifier can have parameters optionally. If none
    are required, you can remove the brackets as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modifiers are very powerful tools that you'll often use whenever you see repetitive
    code doing the same verifications for several functions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll see the types of special modifiers that functions
    can take for visibility and payments.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Solidity are pretty similar in syntax to those in JavaScript,
    but they have some key differences that you must understand, such as the fact
    that you must specify return types, the visibility of the function, and the modifiers
    that apply to each particular function, if any. The syntax is the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Functions have visibility just as variables do, where public functions can be
    executed by external users, contracts, and in the contract itself. External functions
    can only be by external entities, not by the contract itself. Internal functions
    can only be executed by the containing contract. Private functions can be executed
    only inside the current contract, or by inherited contracts.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a function can have special modifiers that determine the type of function
    it is. This includes modifiers such as the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: A view function is one that doesn''t modify state variables but can
    read them. Remember that state variables are declared at the beginning of the
    contract, and they are used to store information directly on the blockchain. So,
    if your function doesn''t modify any state variable, you have to mark it as `view`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure**: A pure function is even more restrictive. It applies to those functions
    that don''t even read state variables. Pure functions are normally functions that
    make some type of calculation inside them without relying on external data. This
    usually includes mathematical functions or formatting functions.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payable**: A `payable` function is able to receive Ether when it is executed.
    It will store that Ether inside the contract, so it''s very important that you
    create systems to extract the Ether that gets sent to the smart contract, otherwise
    the money will be stuck inside there forever. If your function is not marked as
    `payable`, when you send Ether alongside the function execution, you''ll receive
    an error and the transaction will revert.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how it looks:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In that function, we are simply reading and returning the `myStateString` state
    variable, so we can mark it as `view`. Note that we must use the `memory` keyword
    for string types, since they are a type of array internally like an array of each
    individual character.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This `pure` function is simply adding two numbers and returning the result to
    the caller. It doesn't modify the state and it doesn't read the state variables.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `payable` function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `receiveDonation` function is empty because we only need to receive the
    Ether. We don't have to do anything with it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The fallback function
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special type of function that doesn't have a name. It is executed
    whenever someone uses the `.send()` or `.transfer()` function to this contract
    address, similar to a default function. It is often used in ICOs to receive Ether
    and return the specified number of tokens for the Ether received. This allows
    anybody to buy tokens without having to understand and deploy the contract instance,
    with just the address of the contract.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it looks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Fallback functions must be marked `external` to help people understand that
    it shouldn't be executed inside this contract by mistake. If you don't add the
    `payable` modifier, it will reject all the transactions sending it Ether.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you should write and try different functions using the `remix.ethereum.org`
    IDE, which will show you errors and notifications about things that must be verified.
    That way, you'll be able to write your own contract securely.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Vyper
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vyper is a new programming language for smart contracts that has a syntax similar
    to Python. It was created by Vitalik himself and it's one of the most interesting
    choices for new decentralized applications, given that it provides a different
    approach to traditional Solidity smart contracts.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Its goal is to be a simple programming language that has increased security
    based on simplicity, where the code should be easily understandable, even by non-developers.
    That's why the syntax is so minimalistic. They also wanted it to be a programming
    language where it's increasingly hard to write buggy or vulnerable code, so that
    developers don't spend countless hours analyzing the security of every single
    application while avoiding unexpected vulnerabilities by default.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the main reason Vyper added several interesting features, such as the
    following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowing how much gas each function call will cost every time**: Having a
    precise indication of gas costs is important, because you want users to be able
    to calculate precisely how much Ether they will invest per transaction. It saves
    people''s money while making the program predictable.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic vulnerability checking**: Overflows, underflows, reentrancy attacks,
    and many other well-known vulnerabilities are automatically fixed in Vyper, without
    having to manually pay attention to every single function of your smart contracts.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, they removed important characteristics found in other smart
    contract programming languages, such as Solidity:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '**No more modifiers:** Modifiers are not allowed in Vyper, because they make
    code confusing to read, given that you have to jump back and forth between the
    modifier definition and its use. Also, they can be used maliciously by executing
    code unexpectedly; for instance, creating a modifier called `onlyOwner` but then
    executing a `transfer()` function totally unrelated to what''s expected from its
    name.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No more assembly:** Assembly code is hard to understand, even to experienced
    developers, because you''re dealing with very low-level functions that can be
    misleading. This means that you won''t be able to create smart contracts that
    use signatures, state channels, and similar applications relying on assembly.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No more recursive functions:** To avoid reentrancy attacks while guaranteeing
    a precise calculation of gas costs, they removed recursive functionality where
    functions can call themselves an uncertain amount of times.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, Vyper is a powerful language that's great for smaller projects and
    won't require advanced functionality, such as assembly. You can quickly create
    an easy-to-maintain smart contract that your users will be able to understand
    within a few minutes for its light syntax and minimalistic code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Vyper by example
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get up to speed with this new exciting language, we'll go through a simple
    smart contract so that you can see the full complexity of Vyper. We'll see all
    the types of variables and functions in one single smart contract.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a new `example.vy` file. As you can see, Vyper smart contracts
    have the `.vy` termination. Inside it, type down the following code; we''ll later
    explain what every variable means and how they are used. This is just a quick
    exercise to get your programming hands familiar with how Vyper is written. This
    code will be your go-to guide to familiarize yourself with Vyper''s syntax:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These are some clarifications to help you understand what is going on:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Events must be declared at the top of the Vyper file, and they have to come
    inside curly brackets, like these: `({})`.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsigned integers can only be positive, and their maximum value is 2**256\.
    You can't have `uint8` or equivalent; all uints must be `uint256`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed integers, normal integers, can be positive or negative with a maximum
    value of 2**128 from both sides. They can only be `int128`, so you can't have
    smaller sizes.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimals have a precision of 10 decimal places, meaning that you can have up
    to 10 characters after the dot, for instance, `1.2394837662`.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings can either be `bytes32` or `byte` arrays with a custom size, such as
    `bytes[2000]`. Note that you don't have the `string` type of variable, so your
    strings will be stored as hexadecimal texts after you upload them. Also, you can't
    have variable-size bytes, such as `bytes[]`, because they create uncertainty when
    calculating gas costs.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mappings must be declared with the `map()` function and they can be accessed
    with brackets, for instance, `todoList[3] = "Start something"`.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timestamp` is a fixed date for events such as your birthday, or a specific
    time in the future. This is mostly used as date containers. `timedelta` is more
    like a counter without a precise date in the calendar. For instance, `timedelta`
    could store `2 months`, while timestamp could store `January 1 2019`, all in numerical
    format.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wei value is the type used for storing Ether in wei.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom unit types are personalized types that you define at the top of the file
    and you can then use for your variables. They must be casted as uints, ints, or
    decimals.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be public or private. Public functions must have the `@public`
    decorator on top of them. The return value of functions is specified with the
    arrow sign, `->`.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payable functions must use the `@payable` decorator and they can access the
    Ether sent (if any) with `msg.value`.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To update state variables inside functions, you must use the `self.` keyword
    in front of them to update them as state variables. In Vyper, you don't need to
    add the underscore `_` in front of parameter names, because you can easily reference
    the variable with the same name in state, while in Solidity you can't, so you
    had to use underscores to differentiate them.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor is called `__init__()`, while the fallback function is called
    `__default__()`.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it! The fastest way you can master Vyper in a few pages. Make sure that
    you keep this guide in a special place for whenever you write Vyper contracts
    to save you hours of headaches and uncomfortable moments.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by getting a high-level overview of Ethereum's history
    to understand where it came from and where it's headed. Then, we moved to specific
    topics, such as the EEA, since it's great to know how the Ethereum technology
    is being applied in different real-world scenarios. After that, we covered many
    different topics regarding the specifics of the Ethereum blockchain to understand
    it more on a technical level that makes sense as a developer, since we'll be dealing
    with all aspects related to its blockchain. Next, we moved to more technical topics
    regarding smart contracts, since they are at the core of what an Ethereum developer
    does, so that you get a clear vision of how they are implemented in the grand
    scheme of things. Finally, we moved to essential smart contract programming with
    Solidity and Vyper to kick-start your understanding of how the most popular languages
    are used in the real world, setting up a solid foundation for future projects
    to start your journey to become a master Ethereum developer.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'If you weren''t familiar with Vyper, you should now be able to program simple
    contracts using the online compiler, which can be found at: [https://vyper.online/](https://vyper.online/).
    Make sure that you practice the functions described in this chapter by yourself
    and continue reading once you have an intuitive understanding on the concepts
    explained.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore the Ethereum architecture in depth
    to understand how each component works at a fundamental level and the main driving
    forces behind blockchain technology.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
