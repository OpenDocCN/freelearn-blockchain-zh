- en: Blockchain Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链架构
- en: Blockchain architecture covers the fundamentals when it comes to understanding
    how the blockchain works internally. It is essential to be able to work on different
    projects that use different areas of Ethereum, because once you have a solid understanding
    about how everything works together, your mind will begin to see things differently.
    You will get a high-level overview of what happens in the blockchain when you
    use it and when you program for it. The moving parts of this complex ecosystem
    will begin to make so much sense once you go through this chapter, because you'll
    receive a high-level overview of how smart contracts work and how they are related
    to the underlying structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及理解区块链的内部工作时，区块链架构涵盖了基本原理。能够在使用不同领域的以太坊的不同项目上工作是至关重要的，因为一旦你对一切是如何协同工作有了扎实的了解，你的思维就会开始以不同的方式看待事物。当你使用区块链并为其编程时，你将会对区块链中发生的事情有一个高层次的概览。一旦你阅读了本章，这个复杂生态系统的移动部分将变得非常清晰，因为你将会对智能合约的工作原理和它们与底层结构的关系有一个高层次的概览。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Beyond Ethereum
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越以太坊
- en: The EEA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA
- en: Understanding the Ethereum blockchain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解以太坊区块链
- en: A high-level overview of how smart contracts work
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约工作原理的高层概览
- en: Essential smart contract programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的智能合约编程
- en: Beyond Ethereum
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越以太坊
- en: You probably understand what Ethereum is, but just to make sure that we are
    on the same page, it's important that you have some background knowledge about
    what Ethereum really is in order to progress further without too many distractions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经了解了以太坊是什么，但为了确保我们在同一个页面上，重要的是你对以太坊的真实本质有一些背景知识，以便在进一步学习时不会分散太多注意力。
- en: Explaining Ethereum
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释以太坊
- en: Ethereum is, first and foremost, a blockchain. Ethereum is a technology that
    runs on many computers and provides its consumers with a guarantee that they are
    trusting a solid system that will work as expected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊首先是一个区块链。以太坊是一项在许多计算机上运行的技术，它向其消费者提供了一个保证，即他们信任的是一个可靠的系统，该系统将按预期工作。
- en: '"Ethereum is the world computer."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “以太坊是世界计算机。”
- en: -Vitalik Buterin
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: -维塔利克·布特林
- en: 'To learn more about the core Ethereum ideas, check their official website:
    [https://ethereum.org](https://ethereum.org).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于核心以太坊理念的内容，请查看他们的官方网站：[https://ethereum.org](https://ethereum.org)。
- en: A web of thousands of computers connected all over the world are called **nodes**
    and they allow others to get the information they need while trusting the code
    with the goal of decentralizing the internet as we know it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在世界各地的数千台计算机形成的网络被称为**节点**，它们允许其他人获取他们所需的信息，同时信任代码以实现去中心化的互联网。
- en: Why is decentralization so important for the internet? Because we have come
    to a point where a few big companies control the information that you and I can
    produce or consume.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么去中心化对互联网如此重要？因为我们已经到了一个时候，少数几家大公司控制着你和我可以生产或消费的信息。
- en: Governments have so much power that they are getting out of control with their
    rules. They are biased toward what benefits them and their governors. And it's
    understandable—whenever some entity is at the top of the food chain, it is inevitable
    that they end up controlling the entire system below it sooner or later.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 政府有太多的权力，以至于他们正在失控地制定他们的规则。他们偏向于有利于他们和他们的统治者的事物。这是可以理解的——每当某个实体处于食物链的顶端时，迟早他们会控制位于它下面的整个系统。
- en: Ethereum's goal is to create a censorship-resistant and open platform that allows
    people to trust smart contracts that enforce rules that cannot be controlled by
    third-party entities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的目标是创建一个抗审查和开放的平台，使人们能够信任智能合约，这些合约强制执行的规则不能被第三方实体控制。
- en: When you publish a smart contract, you have a 100% guarantee that the code will
    run at any point and nobody will be able to interfere with it, unless the rules
    of it say so.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发布一个智能合约时，你有100%的保证，即代码将在任何时候运行，除非它的规则规定了其他情况。
- en: Ethereum's history
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊的历史
- en: 'Ethereum was described in Vitalik Buterin''s 2013 whitepaper, which can be
    found at: [https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)[.](https://github.com/ethereum/wiki/wiki/White-Paper)
    He talked about the need of a scripting language that would run on top of Bitcoin,
    since he was involved in *Bitcoin Magazine* and he understood the limitations
    of the Bitcoin blockchain.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊在Vitalik Buterin的2013年白皮书中进行了描述，可以在此处找到：[https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)。他谈到了需要一种脚本语言，可以在比特币之上运行，因为他参与了*比特币杂志*，并且他了解比特币区块链的限制。
- en: He saw an opportunity to create a platform that would run on decentralized technology
    to create new types of applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 他看到了创造一个运行在去中心化技术上的平台的机会，以创建新类型的应用程序。
- en: Not many believed in his vision, so he decided to create an entire new blockchain
    by himself with a small team that saw the potential in Vitalik's ideas. He founded
    the Ethereum Switzerland group and decided to run an **Initial Coin Offering**
    (**ICO**) in July 2014, where he sold Ether in exchange for Bitcoin, raising a
    total of about $18 million dollars.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不多的人相信他的愿景，所以他决定自己和一个小团队创建一个全新的区块链，他们看到了Vitalik的想法的潜力。他成立了以太坊瑞士集团，并决定在2014年7月举行一次**首次代币发行**（**ICO**），在那里他以以太币换取比特币，共筹集了约1800万美元。
- en: He created the smart contracts technology, which is basically programs that
    run by themselves without requiring a trusted entity to execute them. They are
    always available, and they run without failure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 他创建了智能合约技术，基本上是无需信任实体执行的程序。它们始终可用，并且无故障运行。
- en: The fact that Ethereum provided a system that allows people to create their
    own applications on top of a blockchain is what made it successful. Before Ethereum,
    there was no simple way to create **decentralized** **applications** (**dApps**)
    in a decentralized platform. Bitcoin has a protocol to create simple applications
    using opcodes with a programming language called Script, but it's not capable
    of much since it is very low level and it's limited by the block size.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊提供了一个允许人们在区块链上创建自己应用程序的系统，这是它成功的原因。在以太坊之前，没有一种简单的方法在去中心化平台上创建**去中心化应用程序**（**dApps**）。比特币有一个使用操作码的协议，使用一种名为Script的编程语言创建简单的应用程序，但它的能力有限，因为它是非常低级的，并且受到区块大小的限制。
- en: Ethereum's development
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊的发展
- en: 'The development of Ethereum was planned to be done in four different stages,
    with major changes in each one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的发展计划分为四个不同阶段，每个阶段都有重大变化：
- en: Frontier
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frontier
- en: Homestead
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homestead
- en: Metropolis
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大都会
- en: Serenity
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宁静
- en: It was used to deliver and research innovative solutions as they were required,
    with a hard fork for functionality that is not backward compatible. In 2015, Frontier
    was launched as the first version of Ethereum. A year later, Homestead was launched,
    which included many improvements and made Ethereum a capable system with enough
    power to process smart contracts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它被用来在需要时交付和研究创新解决方案，并通过硬分叉实现了不向后兼容的功能。2015年，Frontier作为以太坊的第一个版本推出。一年后，推出了Homestead，其中包括许多改进，使以太坊成为一个功能强大、能够处理智能合约的系统。
- en: One of the biggest ICOs conducted on top of Ethereum was the decentralized autonomous
    organization ICO, also known as **the DAO,** which raised $150 million dollars
    with contributions from more than 11,000 people. The problem is that it got hacked
    by an unknown group of individuals that moved the funds to a different DAO. Interestingly
    enough, a group of programmers known as **the White Hat Group** saw the hack happening
    and extracted as many funds as possible into a separate decentralized organization
    known as the **White Hat DAO**, where they stored people's money to distribute
    them later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊之上进行的最大的ICO之一是去中心化自治组织ICO，也被称为**DAO**，它筹集了来自11000多人的1.5亿美元。问题在于，它被一个未知的个人组织攻击了，他们将资金转移到了另一个DAO。有趣的是，一个名为**白帽子组织**的程序员团队看到了这次黑客攻击正在发生，并尽可能多地将资金转移到了一个名为**白帽子DAO**的独立去中心化组织中，他们在那里存放着人们的资金以供以后分配。
- en: This event originated a heated debate in the community that caused Ethereum
    to be divided in two groups, where some believed in the fact that Ethereum must
    be immutable and shouldn't be modified, while others believed in a hard fork to
    revert the damage done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事件引发了社区内的激烈争论，导致以太坊分为两个派别，一些人认为以太坊必须是不可变的，不应该被修改，而另一些人则认为应该进行硬分叉以恢复所造成的损失。
- en: 'That was the beginning of Ethereum Classic and Ethereum as we know it. Ethereum
    Classic has a noticeable smaller user base, but it preserves the initial immutability
    ideals that they consider essential for a blockchain. In March 2017, several companies
    joined efforts to create the **Ethereum Enterprise Alliance** (**EEA**), which
    is currently a non-profit organization made of more than 500 members whose goal
    is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是以太坊经典和我们所知的以太坊的开端。以太坊经典的用户群明显较小，但它保留了他们认为区块链必不可少的初始不可变性理念。 2017年3月，几家公司联合努力创建了目前超过500名成员的非营利组织**以太坊企业联盟**（**EEA**），其目标如下：
- en: '"To create open-source, standards-based blockchain specifications."'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建基于开源和标准的区块链规范。"'
- en: -Ethereum Enterprise Alliance
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: -以太坊企业联盟
- en: In other words, they created a group of people collaborating on solutions for
    future blockchains to come, so that they are better, faster, and more capable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，他们创建了一个合作解决未来区块链技术的人群，以使其更好、更快和更有能力。
- en: It suffered from several hacks, where millions of dollars were stolen. They
    had to do a hard fork to save people's funds and have a notorious price volatility,
    but the future looks bright and it continues, improve as demand increases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它遭受了几次黑客攻击，数百万美元被盗。他们不得不进行硬分叉来拯救人们的资金，并且价格的波动性非常大，但未来看起来光明，随着需求的增长而不断改进。
- en: The EEA
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA
- en: The **EEA** ([entethalliance.org](http://entethalliance.org)) is one of the
    most exciting projects being developed by the core Ethereum team, because they
    intend to help companies from all over the world to benefit from decentralized
    technology. By learning about this project, you'll be well positioned when it
    comes to working as an EEA expert.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**EEA** ([entethalliance.org](http://entethalliance.org))是由以太坊核心团队开发的最令人振奋的项目之一，因为他们打算帮助来自世界各地的公司从去中心化技术中受益。通过了解这个项目，当您成为EEA专家时，您将处于良好的位置。'
- en: 'In this section, we will cover the following topics:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下主题：
- en: The EEA's vision
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA的愿景
- en: The EEA membership
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA的会员资格
- en: The EEA architecture
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEA架构
- en: Vitalik funded the organization because he received a huge demand from executives
    to create software that could be used in big companies to handle demanding dApps.
    Those companies now want to build a private version of Ethereum to fulfill their
    research and development needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Vitalik资助了组织，因为他收到了来自高管的巨大需求，希望创建可以在大公司中使用来处理要求严格的dApps的软件。这些公司现在希望建立以太坊的私有版本，以满足其研发需求。
- en: What's interesting about this initiative is that they work with hundreds of
    companies to research and develop solutions that are shared across them. For instance,
    if a company member of the EEA creates a new implementation protocol for better
    and faster dApps, they will share it with the other members so that they can also
    benefit from this cutting-edge research, while together growing the Ethereum ecosystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个倡议的有趣之处在于，他们与数百家公司合作研究和开发解决方案，并将其共享。例如，如果EEA的公司成员为更好、更快的dApps创建了新的实施协议，他们将与其他成员分享，以便他们也能从这一最尖端的研究中受益，同时共同发展以太坊生态系统。
- en: The EEA's vision
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA的愿景
- en: 'The EEA''s four big public goals that they envision they will achieve in the
    longer term are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: EEA在较长期内设想实现的四个重要公共目标如下：
- en: '**Be an open source standard, not a product**:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成为一个开源标准，而不是产品**：'
- en: They only work with open source code that can be shared with anybody publicly
    without restrictions in order to spread development advances that may or may not
    help others improve their blockchain products. You see, they are a non-profit
    organization that wants to move blockchain (as we know it) further by combining
    the efforts of many companies interested in private blockchain solutions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 他们只与可以公开分享给任何人而没有限制的开源代码合作，以便传播可能有助于改进他们的区块链产品的开发进展。你看，他们是一个非营利组织，希望通过结合许多对私有区块链解决方案感兴趣的公司的努力，推动区块链（我们知道的）进一步发展。
- en: '**Address enterprise development requirements**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决企业开发需求**：'
- en: The EEA helps companies incorporate the new innovations that are being discovered
    by others for free, so that they can enjoy the benefits of the latest requirements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: EEA帮助公司免费整合其他人发现的新创新，以便享受最新需求的好处。
- en: '**Share improvements between public and private Ethereum**:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在公共和私有以太坊之间分享改进建议**：'
- en: They want to improve what they are building by taking improvements from the
    public blockchain so that they can evolve faster while keeping a great product
    in mind.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 他们希望通过从公共区块链获取改进来改善他们正在构建的东西，以便在保持一个伟大的产品的同时更快地发展。
- en: '**Leverage existing standards**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用现有标准**：'
- en: When it comes to the blockchain technology, much is left to research and discover.
    Many problems regarding scalability, security, and transparency are being studied,
    since this type of decentralized structure is new to modern computing. So, the
    idea is to learn from existing standards, such as **proof-of-stake** (**PoS**),
    to improve faster than anyone else.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到区块链技术时，还有很多需要研究和发现的地方。许多关于可伸缩性、安全性和透明度的问题正在研究中，因为这种去中心化的结构对现代计算来说是新的。因此，想法是借鉴现有标准，例如**权益证明**（**PoS**），以便比其他人更快地提升。
- en: In essence, they are trying to fulfill the demands that many companies are making
    regarding private enterprise and fast blockchains for their personal applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，他们试图满足许多公司对私有企业和快速区块链为其个人应用提出的要求。
- en: The EEA membership
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA 成员资格
- en: What's interesting about the EEA is that any company is free to join by just
    filling a form on their website to become a member of the group for a yearly cost.
    This openness helps many individuals stay relevant with the new improvements on
    the Ethereum blockchain.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何公司都可以通过在他们的网站上填写一个表格免费加入 EEA 成为该团体的成员，每年需支付一定费用。这种开放性有助于许多个人跟上以太坊区块链的新改进。
- en: 'Here''s the breakdown in yearly costs to become a member:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是成为会员的年度费用的分解：
- en: 'Less than 50 employees: $3,000 per year'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不到 50 名员工：每年 3000 美元
- en: 'Between 51 and 500 employees: $10,000 per year'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 51 到 500 名员工：每年 10000 美元
- en: 'Between 501 and 5,000 employees: $15,000 per year'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 501 到 5000 名员工：每年 15000 美元
- en: 'More than 5,000 employees: $25,000 per year'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5000 名以上的员工：每年 25000 美元
- en: Non-profit organizations only pay $3,000 dollars per year, regardless of company
    size. By becoming a member of the Alliance, you can enjoy a series of general
    benefits, such as being able to participate in discussions, voting, open source
    code, meetups, and the prestige that you get from having the EEA logo in your
    website. As a big blockchain company, it makes sense to become a member just for
    the reputation that you'll get by becoming a member with the EEA logo on your
    website.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非营利组织每年只需支付 3000 美元，无论公司规模如何。通过加入联盟，你可以享受一系列普通好处，比如参与讨论、投票、开源代码、见面会，以及在你的网站上展示
    EEA 徽标所带来的声望。作为一家大型区块链公司，成为成员只为了在你的网站上展示 EEA 徽标所带来的声誉是有道理的。
- en: 'The benefits depend on the type of company you are in, and you can see them
    in the following section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好处取决于你所在公司的类型，你可以在下一节中看到它们：
- en: Class A members are the directors that run the companies associated with the
    Alliance. They have priorities when reaching decisions and have access to all
    the benefits.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class A 成员是联盟关联公司的董事，他们在做决定时有优先权，并且可以享受所有的好处。
- en: Class B members are those that have a normal company, so they get standard benefits
    without exclusiveness.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class B 成员是拥有一家普通公司的人，因此他们会获得标准好处而没有独家权利。
- en: Class C members are lawyers and legal firms that are in charge of the legal
    challenges when it comes to the research done in the EEA.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class C 成员是负责 EEA 研究中的法律挑战的律师和法律公司。
- en: Class D members are non-profit companies and academic institutions. They get
    basic benefits for the lowest price without voting rights.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class D 成员是非营利组织和学术机构。他们以最低价格获得基本好处，但没有投票权。
- en: The EEA has a powerful pool of about 500 companies, including giants such as
    Intel, Microsoft, and J.P. Morgan. If you run a decent-sized company, you may
    be interested in becoming a member of the EEA just to be a part of this revolution
    when it comes to enterprise blockchains.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EEA 拥有大约 500 家公司的强大联盟，其中包括英特尔、微软和摩根大通等巨头。如果你经营一家体量不小的公司，你可能会有兴趣成为 EEA 的成员，因为这意味着你将成为企业区块链革命的一部分。
- en: The EEA architecture
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EEA 架构
- en: The enterprise grade applications built with EEA's tools have a very interesting
    structure that builds on top of the existing Ethereum structure. They developed
    the **Enterprise Ethereum Architecture Stack** (**EEAS**), which is a design that
    specifies how this new type of Ethereum blockchain should work in a private setting,
    with features designed for privacy. The team working on the Ethereum Enterprise
    project details functions of this type of private blockchain without regard to
    the underlying technology below it, such as software code, APIs, and communication
    protocols. What the EEA intends to do is focus on creating what's described in
    their specification so that people can enjoy private blockchains for their companies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EEA 工具构建的企业级应用具有非常有趣的结构，建立在现有以太坊结构之上。他们开发了**企业以太坊架构堆栈**（**EEAS**），这是一个设计，指定了这种新类型的以太坊区块链应如何在私有环境中运作，具有专为隐私设计的功能。致力于以太坊企业项目的团队详细说明了这种私有区块链的功能，而不考虑其下层技术，如软件代码、API
    和通信协议。EEA 的意图是专注于创建他们规范中描述的内容，以便人们可以为其公司享受私有区块链。
- en: 'The tooling will benefit from innovative solutions exclusive to the Enterprise
    Ethereum blockchain, such as the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 包括以下独家于企业以太坊区块链的创新解决方案：
- en: '**Hardware security module** (**HSM**): This is a physical computing device
    that safely stores digital keys, such as your private cryptocurrency keys, with
    maximum security features. For instance, Ledger and Trezor are hardware wallets
    that are also called HSMs, because they provide security in a physical device
    for your blockchain private keys.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件安全模块**（**HSM**）：这是一种安全存储数字密钥的物理计算设备，例如您的私人加密货币密钥，具有最大的安全功能。例如，Ledger 和
    Trezor 是也被称为 HSM 的硬件钱包，因为它们为您的区块链私钥提供了物理设备的安全性。'
- en: '**Permissioning and authentication**: This is useful in order to give users
    specific roles with limited access to certain areas in a more structured fashion.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限和认证**：这对于以更加结构化的方式为用户赋予特定角色并限制对某些区域的访问非常有用。'
- en: '**Enterprise management systems**: This is used to help companies control their
    private blockchain internal workings.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业管理系统**：这用于帮助公司控制其私有区块链的内部工作。'
- en: '**Oracles**: These are helpful for communicating with external services for
    custom smart contracts written on top of the enterprise private blockchain. They
    are essential to exchange key information with the outer world.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预言机**：这对于与构建在企业私有区块链之上的自定义智能合约进行通信的外部服务非常有帮助。它们是与外部世界交换关键信息的必要手段。'
- en: 'Regarding privacy and scaling, we know that many different teams are working
    on creating unique solutions that could benefit the entire community. However,
    we know that, initially, the blockchain will use two main systems to scale the
    capacity of existing dApps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隐私和扩展性，我们知道许多不同的团队正在努力创建独特的解决方案，这些解决方案可能会使整个社区受益。然而，我们知道，最初，区块链将使用两个主要系统来扩展现有
    dApps 的容量：
- en: '**Off-chain transactions with trusted execution**: Protocols such as plasma
    and state channels are being developed to leverage off-chain transactions that
    can be executed locally by users'' computers to reduce the computing load of the
    main blockchain.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与可信执行的离链交易**：诸如 plasma 和状态通道等协议正在开发中，以利用可以由用户的计算机本地执行的离链交易，从而减少主区块链的计算负载。'
- en: '**Private transactions**: Transactions that use zero-knowledge proofs, ring
    signatures, and many other famous protocols to guarantee the privacy of the data
    being exchanged with the public blockchain. This is an important aspect that companies
    demand because they have private data and internal processes that can''t be shared
    publicly. We cannot know which solution they will choose, so it''s up to them
    to decide. They will also implement private code execution that will allow companies
    to execute certain smart contract transactions in a secure environment, where
    the users will see an encoded hash.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私密交易**：使用零知识证明、环签名和许多其他著名协议来保证与公共区块链交换的数据的隐私的交易。这是公司需求的一个重要方面，因为它们拥有不能公开共享的私有数据和内部流程。我们无法知道他们将选择哪种解决方案，所以这取决于他们自己的决定。他们还将实现私有代码执行，使公司能够在安全环境中执行某些智能合约交易，用户将看到一个编码的哈希。'
- en: 'The EEA is building three additional elements on top of the existing core blockchain:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: EEA 正在现有核心区块链之上构建三个额外的元素：
- en: '**On-chain private state**: This is a separate storage compartment where they
    will store private states of smart contracts. It will provide us, the developers,
    truly private variables and store functions that we''ll be able to use for keeping
    information secure and unseen by the public. It''s very powerful for enterprise-grade
    dApps.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链上私有状态**：这是一个单独的存储区，用于存储智能合约的私有状态。它将为我们，开发人员，提供真正的私有变量和存储函数，我们将能够使用这些函数来保持信息安全，不被公众所见。这对企业级
    dApp 非常强大。'
- en: '**Trusted execution**: These are systems that will provide a trusted execution
    environment where the code will be executed without interfering with public processes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可信执行**：这些系统将提供可信执行环境，在此环境中，代码将被执行，而不会干扰公共流程。'
- en: '**Private consensus**: Companies will have the ability to reach agreements
    using their own private blockchain for their own systems, similar to voting systems
    that we can see in the *Decentralized autonomous organizations* section in: [Chapter
    3](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml), *Ethereum Assets*.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有共识**：公司将能够使用自己的私有区块链为其自身系统达成协议，类似于我们可以在[第三章](8f93512c-8a39-4030-aa79-7e5ca832412b.xhtml)的*去中心化自治组织*部分看到的投票系统。*以太坊资产*。'
- en: Lastly, the blockchain network layer will benefit from Enterprise P2P, which
    will be used to exchange transactions in smaller networks of nodes that are set
    up by the company, so that they enjoy the benefits of faster processing speeds
    and confirmation times. Enterprise blockchains will be able to interact with other
    networks, including the public blockchain to exchange information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，区块链网络层将受益于企业 P2P，该层将用于在公司设置的更小的节点网络中交换交易，以便它们享受更快的处理速度和确认时间带来的好处。企业区块链将能够与其他网络进行交互，包括公共区块链，以交换信息。
- en: Understanding the Ethereum blockchain
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解以太坊区块链
- en: The Ethereum blockchain is a complex system made of several important components
    that work together to achieve an impressive platform that everybody can use to
    create unstoppable applications. You'll learn the intricacies of the internal
    workings of the blockchain to gain a greater understanding about how it's made.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链是一个由几个重要组件组成的复杂系统，这些组件共同工作，形成一个令人印象深刻的平台，每个人都可以用来创建不可阻止的应用程序。您将学习区块链内部工作的复杂性，以更深入地了解它的构造方式。
- en: The reasoning behind a decentralized blockchain
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化区块链的原理
- en: At the most basic level, the Ethereum blockchain is a set of connected blocks
    that contain information that many nodes share so that there's an unchangeable
    data structure to keep information permanently. The goal of any blockchain is
    to preserve information without the possibility of changing it or deleting it
    to avoid censorship or manipulation by external entities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，以太坊区块链是一组连接的块，其中包含许多节点共享的信息，以便保持不可改变的数据结构，永久保存信息。任何区块链的目标都是保留信息，而不可能更改或删除它，以避免外部实体的审查或操纵。
- en: As such, the Ethereum blockchain builds upon that concept by implementing several
    well-known tools, thanks to Bitcoin and previous research to create programs that
    run on top of those blocks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以太坊区块链通过实施几种众所周知的工具，借助比特币和先前的研究创建了运行在这些区块之上的程序，从而建立在该概念基础上。
- en: To understand how the Ethereum blockchain works internally, we have to understand
    each component that makes up a blockchain. First, I'll give you a high-level overview
    of the blockchain as a set of nodes, and then we'll go through each component
    from higher to lower levels in the pyramid that makes the blockchain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解以太坊区块链的内部工作原理，我们必须了解构成区块链的每个组件。首先，我将为您概述区块链作为一组节点，然后我们将逐个从金字塔形成的较高到较低级别的每个组件进行介绍。
- en: The blockchain as a set of nodes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链作为一组节点
- en: Ethereum is a decentralized platform, which means that two or more nodes work
    together in a coordinated fashion to achieve a common outcome in a way that the
    end user sees as a single operation. A node performs various types of functions
    depending on the role it decides to take. It can propose and validate transactions
    with mining software to achieve consensus while securing the blockchain using
    the **proof-of-work** (**PoW**) protocol or be a light-weight node that performs
    payment verification and many other tasks that can be done with limited resources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是一个去中心化平台，这意味着两个或多个节点以协调的方式共同实现用户视为单个操作的共同结果。节点根据其决定扮演的角色执行各种类型的功能。它可以使用挖矿软件提出和验证交易以达成共识，同时使用**工作量证明**（**PoW**）协议来保护区块链，或者是一个轻量级节点，执行支付验证和许多其他可以使用有限资源完成的任务。
- en: The Ethereum blockchain is based on Bitcoin, since the system created by Satoshi
    Nakamoto is a very robust decentralized solution. In fact, it uses a system to
    execute decentralized code using opcodes that can process basic instructions on
    top of a network of hundreds of thousands of computers in a safe manner. They
    must be simple to preserve security above all.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链基于比特币，因为由中本聪创建的系统是一个非常强大的去中心化解决方案。实际上，它使用一种系统来执行分散代码，使用能够在数十万台计算机网络上安全处理基本指令的操作码。它们必须简单以确保安全性优先。
- en: 'Although both blockchains are quite similar in their systems, they have noticeable
    differences, such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两个区块链在其系统上相当相似，但它们有明显的区别，例如以下内容：
- en: Bitcoin and Ethereum use PoW to generate blocks, while Ethereum intends to move
    to PoS as the block generation system in the future to avoid wasting computational
    power.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币和以太坊都使用PoW来生成区块，而以太坊打算在未来将PoS作为块生成系统，以避免浪费计算能力。
- en: Ethereum uses the Ethash algorithm, while Bitcoin uses SHA256 for processing
    transactions and generating blocks.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊使用Ethash算法，而比特币使用SHA256来处理交易和生成区块。
- en: Ethereum's block time is about 15 seconds, which is about 100 times faster than
    Bitcoin's. This gives people better confirmation times.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊的区块时间约为15秒，比比特币快大约100倍。这使人们获得更好的确认时间。
- en: 'The Ethereum blockchain is decentralized and distributed, which means that
    the connected nodes have several relationships with each other independently,
    while running the same software at different locations. This is very important
    to guarantee the unstoppable aspect of the blockchain. Here what each term means:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链是去中心化和分布式的，这意味着连接的节点在不同位置独立地彼此有几个关系，同时在不同位置运行相同的软件。这对于保证区块链不可阻止的特性非常重要。这里解释了每个术语的含义：
- en: '**Decentralized network**: This is a network of computers running without a
    single point of control, no entity controls the entire system, and each node is
    connected to other nodes directly in a **peer-to-peer** (**P2P**) relationship.
    If the blockchain wasn''t decentralized, some government or entity could locate
    the main controller node and stop the entire system immediately.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化网络**：这是一个没有单一控制点的计算机网络，没有任何实体控制整个系统，每个节点都以**点对点**（**P2P**）的方式直接连接到其他节点。如果区块链不是去中心化的，某个政府或实体可能会找到主控节点并立即停止整个系统。'
- en: '**Distributed network**: This is a network where many different computers run
    on different locations with the same software. If the blockchain wasn''t distributed,
    some entity could go to where all the nodes are located and stop the entire operation
    because they are all in the same place, so none are safe from such an attack.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式网络**：这是一个网络，许多不同的计算机在不同的位置运行相同的软件。如果区块链不是分布式的，某个实体可能会到所有节点所在的地方，并停止整个操作，因为它们都在同一个地方，因此没有一个是安全的免受这样的攻击。'
- en: 'You can see in the following diagram how the structure of these types of technologies
    connect nodes together so that they can communicate with complete security, in
    their own way, since it''s often a confusing point when trying to understand the
    differences between distributed and decentralized systems:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到以下图表，说明这些类型的技术如何连接节点，以便它们可以以完全安全的方式进行通信，因为在试图理解分布式和去中心化系统之间的区别时，这通常是一个令人困惑的点：
- en: '![](img/fe07ba80-1398-4356-b5b1-34642bd7d179.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe07ba80-1398-4356-b5b1-34642bd7d179.png)'
- en: Those two characteristics give the Ethereum network the capacity to work without
    having to rely on anybody, because thousands of nodes are able to communicate
    between each other in a secured and independent fashion. Notice that Ethereum
    is a completely open blockchain, meaning that anybody is free to join and participate
    in the decisions that take place, such as block creation and transaction processing.
    It allows people to join the network of nodes as a participant without any requirements,
    since the entire structure is secured by cryptographically-safe algorithms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征使得以太坊网络有能力不必依赖任何人即可运行，因为成千上万的节点能够在受保护且独立的方式之间相互通信。请注意，以太坊是完全开放的区块链，这意味着任何人都可以自由加入并参与其中的决策，比如区块创建和交易处理。它允许人们以参与者的身份加入节点网络，而不需要任何要求，因为整个结构都由密码安全算法保护。
- en: Nodes can work together or become malicious by executing unexpected code. Those
    that exhibit arbitrary behavior are known as **Byzantine nodes**. The main goal
    is to create a system where nodes cooperate even in the worst situations, with
    fault-tolerance protections in place to avoid breaking the entire structure. But
    how do they work together if the nodes making the blockchain can behave randomly
    because they are Byzantine nodes?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以共同工作，也可以通过执行意外代码而变得恶意。那些表现出任意行为的被称为**拜占庭节点**。主要目标是创建一个系统，即使在最坏的情况下节点也能合作，在那里它们存在容错保护以避免破坏整个结构。但是如果做出区块链的节点可以因为是拜占庭节点而随机行事，它们怎么能一起工作呢？
- en: At the end of the day, it's a group of computers working voluntarily toward
    the same objective. Nothing stops them from doing unexpected actions. That's where
    one of the most interesting problems that blockchain is facing lies. There are
    several solutions, but research is still being done to obtain a perfect balance
    between performance and security in a decentralized system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一组计算机志愿地朝着同一个目标工作。没有什么能阻止它们执行意外的动作。这正是区块链面临的最有趣的问题之一。有几种解决方案，但仍在进行研究，以在分散式系统中在性能和安全性之间获得完美平衡。
- en: The CAP theorem
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAP理论
- en: 'The CAP theorem, introduced originally by Eric Brewer in 1998, states that
    any distributed system cannot have all three of these properties simultaneously:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CAP理论最初由Eric Brewer在1998年提出，指出任何分布式系统不能同时具有这三个属性之一：
- en: '**Consistency**: This is a capability of the network of nodes to keep a consistent
    copy of the blockchain data in their computers at the same time.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这是节点网络在同一时间保持一致的区块链数据副本的能力。'
- en: '**Availability**: This means that the system of connected nodes is online and
    available at all times while being accessible by all users to respond to requests
    without failure when required to do so.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这意味着连接节点的系统在线并且始终可用，同时可以在需要时响应所有用户的请求，而无故障。'
- en: '**Partition tolerance**: If a group of nodes of the entire network stops working
    or loses connection for any reason, the system should not be affected, and it
    should continue working properly as if nothing happened.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容忍性**：如果整个网络中的一组节点因任何原因停止工作或失去连接，系统不应受影响，应该继续正常工作，就好像什么都没有发生一样。'
- en: It has been proven that a distributed or decentralized system cannot have all
    three of these properties at the same time, which is interesting because Ethereum,
    just like Bitcoin, achieves all of them at what appears to be the same time. The
    truth is that consistency is not achieved at the same time as partition tolerance
    and availability, but at a later time. You see, in order to have order in such
    a diverse variety of computers, we can only hope to achieve the same level of
    data over time whenever the blockchain grows at an established pace. It lags behind
    the others. This is called **eventual consistency**, where the goal is achieved
    as a result of validating multiple nodes over time. For this reason, the concept
    of mining was introduced in Bitcoin and Ethereum to agree on a consensus with
    the PoW protocol.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 已经证明分布式或分散式系统不能同时具有这三个属性，这很有趣，因为以太坊，就像比特币一样，在看似同时实现了所有这些属性。事实上，一致性并不是与分区容忍性和可用性同时实现的，而是在稍后的时间实现的。你看，为了在这样多样化的计算机中有秩序，我们只能希望在区块链以已建立的速度增长时随着时间达到相同的数据水平。这就是称为**最终一致性**的概念，其中的目标是通过随时间验证多个节点来实现。因此，在比特币和以太坊中引入了挖矿的概念，以
    PoW 协议达成共识。
- en: Eventually, Ethereum plans to move to PoS, which consists of the idea that a
    node or user maintains a stake, a certain number of Ether or any type of valuable
    investment in the system, so that the negative consequences of any malicious activity
    would outweigh the benefits of attacking the network.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，以太坊计划转向PoS，其核心思想是，节点或用户维持一定数量的以太或任何类型的有价值的投资，并使得任何恶意活动的负面后果都超过攻击网络的好处。
- en: For instance, if I want to become a miner to earn some Ether in exchange for
    my time and resources, I have to lock 100 Ether in a smart contract that runs
    the PoS protocol. If I decide to validate invalid blocks or transactions, and
    someone notices my malicious behavior via several security mechanisms, I would
    lose all those 100 Ether and wouldn't be able to attack again. The reward for
    processing a block successfully would be a percentage of the resources invested,
    for example, 0.1 ETH. This forces nodes to cooperate and act responsibly to avoid
    losing a big stake, even if they agree to attack the system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想成为矿工以换取一些以太币作为我的时间和资源，我必须在运行PoS协议的智能合约中锁定100个以太币。 如果我决定验证无效的区块或交易，而某人通过多个安全机制注意到我的恶意行为，我将失去所有这100个以太币，并且无法再次发动攻击。
    成功处理一个块的奖励将是投入的资源的一部分，例如0.1 ETH。 这迫使节点合作并负责行事，以避免失去大笔赌注，即使他们同意攻击系统。
- en: Alternatively, **delegated proof-of-stake** (**DPoS**) could be used in later
    versions of Ethereum. It consists of delegating the validation of a transaction
    to other nodes by voting. It is used in the BitShares blockchain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，**委托权益证明**（**DPoS**）可以在以太坊的后续版本中使用。 它涉及通过投票将交易的验证委托给其他节点。 它在BitShares区块链中使用。
- en: Introducing the Ethereum Virtual Machine
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍以太坊虚拟机
- en: The **Ethereum Virtual Machine** (**EVM**) is a virtual machine that allows
    code to be executed with limitations regarding gas costs and price, where each
    individual interacting with it must pay a fee to protect the network from spamming
    attacks, so that many decentralized nodes can interact with each other using the
    same software. It processes bytecode that gets generated with assembly code, which,
    in turn, uses instruction called **operational codes** (**opcodes**). It's a **Turing
    complete** computer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊虚拟机**（**EVM**）是一台虚拟机，允许执行带有有关燃气成本和价格的限制的代码，每个与之交互的个体都必须支付费用以保护网络免受垃圾邮件攻击，以便许多去中心化节点可以使用相同的软件进行交互。
    它处理使用汇编代码生成的字节码，汇编代码又使用称为操作码的指令（**opcodes**）。 这是一台**图灵完备**的计算机。'
- en: 'When I say Turing complete, I mean that the smart contract programming languages
    running on top of Ethereum have the following properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说图灵完备时，我的意思是在以太坊上运行的智能合约编程语言具有以下特性：
- en: They have unlimited access to **random access memory** (**RAM**)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以无限访问**随机存取内存**（**RAM**）
- en: They can make decisions based on the information available in memory
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以根据内存中的可用信息做出决策
- en: They can run forever with the help of `while`, `for`, and `recursive` loops
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在`while`、`for`和`递归`循环的帮助下永久运行
- en: They can use functions
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用函数
- en: What this means, is that smart contracts are capable of executing any operation
    that you give them, given enough time and resources. This is important to understand
    to avoid confusions when someone says that Ethereum is a Turing complete blockchain.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着智能合约能够执行您给予它们的任何操作，只要有足够的时间和资源。 这一点很重要，以避免有人说以太坊是图灵完备的区块链时产生混淆。
- en: Introducing the state machine
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: The state machine is a mechanism that keeps track of the state changes that
    occur on the blockchain. For instance, a normal day has two simple states, either
    day or night. A state machine would record the situation of each day at every
    moment so that when the sun goes down, the state of the day changes to night.
    It is the same thing with the days of the week. Each day can be one out of seven
    different states, such as Monday or Friday. Whenever it changes at 12 am, the
    state that keeps track of the day of the week gets updated in the state machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一种机制，用于跟踪区块链上发生的状态更改。 例如，一个正常的一天有两种简单状态，要么白天要么晚上。 状态机将记录每天的情况，以便当太阳下山时，白天的状态变为晚上。
    这与一周中的日子一样。 每天可以是七种不同的状态之一，例如星期一或星期五。 每当在午夜时分发生变化时，跟踪一周中日期的状态将在状态机中更新。
- en: 'The state machine enforces consensus rules to make sure that users are processing
    valid transactions in a Byzantine resistant system:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机强制执行共识规则，以确保用户在拜占庭抗攻击系统中处理有效的交易：
- en: '**A P2P network**: It connects the participants and propagates the transactions
    and blocks of verified transactions. This is the network used by the nodes of
    the blockchain to propagate information between them to achieve consensus.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P2P 网络**：它连接参与者并传播已验证交易的事务和区块。这是区块链节点用来在它们之间传播信息以达成共识的网络。'
- en: '**An incentivization scheme**: In the case of Ethereum, that scheme is PoW
    for creating an economically secure state machine. Ethereum developers plan to
    move to a PoS system where the users will process transactions using a passive
    system of transaction verification based on the number of ETH that the miner locks
    at that moment.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激励计划**：在以太坊的情况下，该计划是 PoW，用于创建经济安全的状态机。以太坊开发人员计划转向 PoS 系统，其中用户将使用基于矿工在那一刻锁定的
    ETH 数量的被动交易验证系统来处理交易。'
- en: '**An open source client**: This client is the one used by the nodes to interact
    with the blockchain. In Ethereum, we have Geth, Parity, and many others that allow
    you to connect to the blockchain for mining and processing transactions and all
    sorts of tasks after downloading the blockchain.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源客户端**：这个客户端是节点用来与区块链交互的客户端。在以太坊中，我们有 Geth、Parity 和许多其他客户端，允许您连接到区块链进行挖矿和处理交易以及下载区块链后执行各种任务。'
- en: You can download a light version of the blockchain by downloading the client
    Geth and running `geth --fast`, which only keeps track of the reference numbers
    of each block to limit the download size of the blockchain, since it can reach
    several hundreds of gigabytes. The purpose of the light client is to make the
    Ethereum blockchain available for low-spec computers with limited storage and
    computing power.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过下载 Geth 客户端并运行 `geth --fast` 来下载区块链的轻量版，它只会跟踪每个区块的参考编号，以限制区块链的下载大小，因为它可能达到几百吉字节。轻客户端的目的是使以太坊区块链适用于具有有限存储和计算能力的低规格计算机。
- en: The P2P network
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P2P 网络
- en: The blockchain runs on top of a P2P network, where nodes are connected to each
    other to exchange data and state updates. Because of this technology, we are able
    to interact directly with other computers in order to process orders so that we
    all agree on the block generation system. It allows miners to be rewarded for
    completing PoW challenges.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链运行在一个 P2P 网络之上，其中节点相互连接以交换数据和状态更新。由于这项技术，我们能够直接与其他计算机交互，以便处理订单，以便我们都同意区块生成系统。它允许矿工完成
    PoW 挑战并获得奖励。
- en: Consensus rules
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识规则
- en: When we say consensus, we talk about a group of techniques used in systems with
    many participants to agree on decisions that benefit the whole underlying system.
    While voting gives the power to decide to a few selected individuals that fulfill
    a set of requirements, consensus takes in consideration each and every one of
    the participants to agree on the global way of thinking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到共识时，我们指的是在拥有许多参与者的系统中使用的一组技术，以便让所有参与者就有利于整个基础系统的决策达成一致。虽然投票赋予了少数满足一系列要求的特定个体决策权，但共识考虑了每一个参与者，以达成全局思维的一致。
- en: 'Each algorithm that implements any form of consensus when it comes to blockchain
    technology must provide the following features:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现任何形式的区块链技术共识的每个算法必须提供以下功能：
- en: '**To agree on decisions that benefit the whole system**: The idea is to take
    choices that not only benefit the individual, but the entire network, so that
    everybody has a better platform.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**达成有利于整个系统的决策**：这个想法是做出不仅有利于个人，而且有利于整个网络的选择，以便每个人都有一个更好的平台。'
- en: '**To allow open participation**: Every person should be completely free to
    join and make decisions that they believe will be positive.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许开放参与**：每个人都应该完全自由地加入并做出他们认为会是积极的决定。'
- en: '**To be secure enough so that malicious actors can''t prejudice the system**:
    All the consensus agreements have to be toward the betterment of the systems,
    where malicious users can''t have enough power to decide for many others.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**足够安全，以至于恶意行为者无法损害系统**：所有共识协议都必须朝着系统的改进方向，其中恶意用户无法有足够的权力为其他人做出决定。'
- en: The problem with reaching consensus started with what's known as the **Byzantine
    Generals Problem**, a problem that consists on the fact that many computers can't
    easily agree on a predetermined order. Some computers will receive the order late,
    others will ignore it because they don't benefit from fulfilling it, while others
    will follow the order as best as they can.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 达成共识的问题始于所谓的**拜占庭将军问题**，这个问题在于许多计算机不容易达成预定顺序的一致性。一些计算机会迟收到指令，其他一些会因为不能从中受益而忽略它，而其他一些会尽量按照指令执行。
- en: In essence, consensus rules are mandatory to achieve a global state that all
    agree with, while being rewarded for participating in a beneficial manner in the
    decision-making process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，共识规则是必须实现全球认可的全球状态的，同时也是为了以有益的方式参与决策过程而获得奖励。
- en: Proof-of-work
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作量证明
- en: 'This is a method to guarantee that the result of a task was hard to achieve.
    Why do we want to make processing tasks difficult? To reward those that are best
    at completing it. In a blockchain, it costs processing power, which is just hardware,
    energy, and time, to process transactions made by individuals using the network.
    It is used to generate blocks in a simple process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种保证任务的结果很难完成的方法。为什么我们希望使处理任务变难？为了奖励那些最擅长完成它的人。在区块链中，处理来自使用网络的个人的交易需要处理能力，即硬件，能量和时间。它被用来以简单的过程生成区块：
- en: The miner proposes a new block that contains a hash number made of the header
    of the most recent block and the nonce counter.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖矿者提出一个包含最近区块头和nonce计数器的哈希数字的新区块。
- en: Then, the miner compares the hash to the target value which is determined by
    the mining difficulty.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，挖矿者将哈希与由挖矿难度确定的目标值进行比较。
- en: If the hash is of the target difficulty, the user gets rewarded with the solution
    by getting ETH. If not, the nonce gets incremented until a hash is generated with
    the desired solution.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果哈希达到目标难度，用户将通过获得ETH来获得解决方案的奖励。如果没有，nonce将被递增，直到生成具有期望解决方案的哈希。
- en: Since the miner will be competing with many others, there must be a system to
    make sure that the block times are consistent, because we want to keep generating
    blocks with the same periodicity even when new nodes join the mining network.
    To guarantee similar block times, the mining difficulty was created.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于挖矿者将与许多其他人竞争，所以必须有一个系统来确保区块时间的一致性，因为我们希望即使新节点加入挖矿网络，也能保持以相同周期生成区块。为了保证相似的区块时间，挖矿难度被创建了。
- en: Proof-of-stake
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股权证明
- en: 'PoS is a new algorithm to reach consensus between nodes in a decentralized
    blockchain that focuses on removing the high computing performance requirements
    from PoW while still keeping the network safe from attacks and malicious behavior.
    The way it works is based on locking Ether as a stake and validating blocks with
    the risk of losing your stake if you misbehave. Here''s the process:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PoS是一种新的算法，用于在去中心化区块链中节点之间达成共识，重点是在保持网络免受攻击和恶意行为的同时，消除PoW对高计算性能的要求。它的工作方式是基于锁定Ether作为押注，并验证可能失去押注的区块，如果你行为不端。以下是该过程：
- en: People that want to participate in the PoS process are called **validators**.
    They start by locking a specific number of coins as their stake (for instance,
    100 Ether) that they can't touch while they are mining. It should be expensive
    enough to guarantee that groups of people don't agree on attacking the system
    with the risk of losing their stake if they're unsuccessful.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想参与PoS过程的人被称为**验证者**。他们首先将一定数量的代币锁定为他们的押注（例如，100个Ether），在他们挖矿时不能触及。这应该足够昂贵，可以确保一群人不会同意以攻击系统的方式冒险，如果他们不成功会失去他们的押注。
- en: Then, they start receiving transactions from people using the Ethereum blockchain.
    Validators run programs to validate that the transactions they are receiving are
    valid so that they can create new blocks by grouping transactions in order. When
    they have enough transactions to cover the gas limit per block, they place bets
    on those blocks – for instance, 20 Ether from the initial 100 Ether staked.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，他们开始接收使用以太坊区块链的交易。验证者运行程序来验证他们收到的交易是否有效，以便可以按顺序将交易分组创建新的区块。当他们有足够的交易来覆盖每个区块的gas限制时，他们将对这些区块下注
    - 例如，从最初押注的100 Ether中押注20 Ether。
- en: The block with the most bets is selected as the winner.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下注最多的区块被选为赢家。
- en: When the winning block is selected from the pool of generated blocks, the miners
    that bet on that valid block get a percentage of the total gas used in that block
    based on their bets. They are not paid in block rewards but in transaction fees.
    For instance, if the block selected has 100 transactions accumulating a total
    of 0.5 Ether in transaction costs, that 0.5 Ether will have to be distributed
    between all the validators that bet on that block. If that block has a sum bet
    of 1,000 Ether from 10 users and you bet 20 ether, you'd get a 2% of 0.5 Ether,
    since that's how much you bet for that block. In total, you'd earn 0.01 Ether.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从生成的区块池中选择获胜区块时，对该有效区块进行押注的矿工将根据他们的押注比例获得该区块使用的总 gas 的一部分。他们不是以区块奖励的形式获得报酬，而是以交易费的形式。例如，如果所选区块有
    100 笔交易，累积了总共 0.5 以太币的交易费用，那么这 0.5 以太币将必须在所有押注该区块的验证者之间分配。如果该区块从 10 个用户处获得了总共
    1,000 以太币的押注，而你押注了 20 以太币，那么你将获得 0.5 以太币的 2%，因为这是你为该区块押注的金额。总体上，你将获得 0.01 以太币。
- en: You don't lose any money when betting for blocks, it's just an indicator of
    how much you trust the validity of that block. It may seem a small reward considering
    that there aren't block rewards, just fees, but you must consider that these blocks
    are being generated in a matter of seconds. Maybe even one second per block, which
    ends up generating a lot of money over the day.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在为区块进行押注时，你不会损失任何资金，它只是一个指示器，表明你对该区块的有效性有多少信任。考虑到没有区块奖励，只有费用，这可能看起来是一个小奖励，但你必须考虑到这些区块是在几秒钟内生成的。甚至可能每秒一个区块，这最终会在一天内产生大量的利润。
- en: 'It looks great in theory, but there''s a major roadblock that''s stopping PoS
    from being completely viable. It''s called the **Nothing at Stake** problem and
    is shown in the following scenario, where there is a main chain and a new chain
    being created with PoS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上看，这听起来很好，但有一个主要障碍阻止了 PoS 完全可行。它被称为 **无所谓的押注（Nothing at Stake）** 问题，并在以下场景中展示，在该场景中，存在一个主链和一个使用
    PoS 创建的新链：
- en: '![](img/ae3268e2-6d03-422b-b546-606c9804d9bd.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae3268e2-6d03-422b-b546-606c9804d9bd.png)'
- en: When it comes to PoW, you can mine on any fork that you desire without any risk,
    since you can place bets on every block that looks good to you. What's stopping
    you from deciding to put all your eggs in a new chain, thus generating a hard
    fork?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 PoW 时，你可以在任何你想要的分叉上进行挖矿而不会有任何风险，因为你可以对每个看起来不错的区块进行押注。什么阻止你决定把所有的蛋放在一个新链上，从而生成一个硬分叉呢？
- en: If we were using PoW, you couldn't move to a new chain without having to spend
    lots of processing power and time generating new blocks for as long as people
    decide to accept it as a new blockchain. You'd be mining for many months with
    a very slim chance of creating a new chain that could be accepted as a new coin,
    worth much less money because of its reduced use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 PoW，你就不能轻易转移到一个新链上，因为你必须花费大量的处理能力和时间生成新的区块，只要人们决定接受它作为一个新的区块链。你将在很多个月内进行挖矿，但很难创建一个能够被接受为一种新币的新链，因为它的使用减少了，价值更低了。
- en: But with PoS, you can simply diversify your portfolio and bet on all the blocks
    that look appealing without consequences, since you won't be losing your stake
    as long as you're validating good transactions. You'd be generating blocks on
    several different blockchains without risks. This kind of possibility could end
    up creating hundreds of different blockchains, since people could be mining on
    all of them simultaneously. That's why it's called the **Nothing at Stake** problem,
    because you don't lose anything when participating in the mining process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用 PoS，你可以简单地对所有看起来吸引人的区块进行分散投资，并且没有后果，因为只要你验证的是好的交易，你不会损失你的股份。你将在几个不同的区块链上生成区块而没有风险。这种可能性可能会导致创建数百个不同的区块链，因为人们可以同时在所有这些区块链上进行挖矿。这就是为什么被称为
    **无所谓的押注（Nothing at Stake）** 问题，因为当参与挖矿过程时，你不会失去任何东西。
- en: This is one of the main reasons why Ethereum has been unable to switch fully
    to PoS in recent times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以太坊近期无法完全转向 PoS 的主要原因之一。
- en: Researchers at Ethereum have been working on solving this problem for a long
    time. One of the proposals, known as **Casper**, intends to solve it by punishing
    users that mine on new chains mindlessly by taking their stake out of them, so
    that users focus on betting for the longest chain. Casper also punishes nodes
    that don't actively participate on the network so that they don't start consuming
    resources without providing value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的研究人员一直在努力解决这个问题。其中之一被称为**Casper**的提案旨在通过惩罚那些无意义地在新链上挖矿的用户，从而将他们的股份收回，以便用户集中于对最长链进行投注。Casper还惩罚不积极参与网络的节点，以免它们在不提供价值的情况下开始消耗资源。
- en: At the end of the day, PoW has to improve or change completely to become sustainable,
    given that many large mining pools are starting to gain too much power. We are
    at a point where four mining companies can achieve about 60% of the total transaction
    power, giving them the choice to run a 51% attack and force all users to mine
    on their own terms with their own corrupted blockchains. PoS is here to stay and
    bring balance back once again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，PoW必须改进或完全改变才能变得可持续，因为许多大型矿池开始获得过多的权力。我们现在处于这样一个阶段，四家矿业公司可以获得约60%的总交易力量，使它们有权进行51%攻击，并强迫所有用户按照它们自己的条款和自己的腐败区块链挖矿。
    PoS将会长期存在，并再次带来平衡。
- en: Workings of smart contracts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约的工作原理
- en: Smart contracts are blockchain applications that can execute code and do a diverse
    variety of tasks. These are programs that the miners execute when mining blocks.
    They are secure and unstoppable agreements that are automatically executed and
    enforced. You are probably familiar with them, since this book is aimed at Ethereum
    developers; however, if you don't know how to use them or if you want to learn
    more about them, you can rest assured that you'll understand everything because
    of detailed explanations that you'll be given at the appropriate times.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是区块链应用，可以执行代码并执行各种不同的任务。这些是矿工在挖矿时执行的程序。它们是安全且不可阻挡的协议，会自动执行和强制执行。您可能已经对它们很熟悉，因为本书面向以太坊开发人员；然而，如果您不知道如何使用它们，或者想更多了解它们，可以放心，因为您将在适当的时候得到详细的解释，从而全面理解一切。
- en: Unlike traditional paper contracts, smart contracts don't have real-world legal
    consequences on Ethereum, and they can't be enforced by a legal entity when they
    break. Instead, they rely on the principle that code is law, which means that
    the code is the one governing the behaviors of the contract. You can't execute
    functions that are not defined in the smart contract and you must respect each
    function's requirements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的纸质合同不同，以太坊的智能合约在现实世界中没有法律后果，并且在它们违反时无法被法律实体强制执行。相反，它们依赖于代码即法律的原则，这意味着代码是规范合约行为的唯一依据。您不能执行未在智能合约中定义的功能，并且必须遵守每个功能的要求。
- en: What's interesting about smart contracts is that they allow the creation of
    unstoppable applications that will keep the data and functionalities running on
    top of the blockchain regardless of whether the underlying web interface is not
    available or is censured for whatever reasons. Smart contracts open the world
    to a new type of application that you can deploy and forget, knowing that it will
    work under any circumstances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，智能合约允许创建不可阻挡的应用程序，这些应用程序将在区块链的顶部保持数据和功能运行，而不管底层网络界面是否不可用或因某种原因被审查。智能合约为一种新类型的应用程序打开了世界，您可以部署并忘记，知道它将在任何情况下运行。
- en: There's an ongoing debate about whether the code is acceptable as a real contract
    in a court of law. One side thinks that smart contracts have to go further and
    be enforced legally for a more general view of applications, while the other side
    thinks that the code as law is enough to guarantee the security and enforcement
    of the agreements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码是否可以作为法律合同在法庭上受到认可存在着持续的争论。一方认为智能合约必须进一步发展，并在法律上加以执行，以获得更广泛的应用视角，而另一方则认为代码即法律足以保证协议的安全性和执行。
- en: Smart contracts are programs that run on top of the blockchain in the software
    layer. They allow developers to create decentralized trustless programs that have
    certain functions for managing transactions between individuals. Instead of relying
    on a centralized server, they are the database and the server in decentralized
    applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是在软件层的区块链顶部运行的程序。它们允许开发人员创建去中心化的无信任程序，具有管理个体之间交易的特定功能。它们不依赖于集中式服务器，而是在去中心化应用程序中充当数据库和服务器。
- en: Inherently, smart contracts must be limited in their capacity given that we
    are executing code that will stay as a transaction on the blockchain permanently,
    meaning that every function you execute gets registered in the blockchain without
    having the option to undo what's been done. This imposes some natural limitations,
    since you can't just modify the public database that every node of the Ethereum
    will have to download without some restrictions. Every change has to be downloaded
    by all the peers of the network.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，智能合约在其容量上必须受到限制，因为我们正在执行的代码将永久地作为区块链上的一笔交易，这意味着您执行的每个函数都会在区块链上注册，而没有撤消已完成的操作的选项。这就施加了一些自然的限制，因为您不能只是修改每个以太坊节点都必须下载的公共数据库而不受任何限制。每次更改都必须由网络的所有节点下载。
- en: The purpose of them is to solve the trust problem that many companies are facing
    when dealing with voting, banking, and situations where people are expected to
    blindly trust companies without disclosing what they do with your data and money.
    They also provide accessibility, since anybody with an internet connection will
    be able to access them and retrieve the data stored inside.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的目的是解决许多公司在处理投票、银行业务以及人们在不公开他们对你的数据和金钱做了什么的情况下所面临的信任问题。它们还提供了可访问性，因为任何有互联网连接的人都能够访问它们并检索存储在内部的数据。
- en: 'However, smart contracts are limited in what they can do. They are not a great
    solution for many cases, such as the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能合约在其所能做的事情上受到限制。对于许多情况来说，它们并不是一个很好的解决方案，比如以下情况：
- en: Applications that require a performing backend that is able to process information
    at a rapid pace, such as creating users and interacting with an application. They
    are slow by nature, since they depend on the block times of Ethereum and they
    cannot work in real-time situations.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个能够以快速速度处理信息的高效后端的应用程序，比如创建用户和与应用程序交互。它们天生就慢，因为它们依赖于以太坊的区块时间，并且它们无法在实时情况下工作。
- en: Applications that store large amounts of data on a database. Smart contracts
    work like a database, since they allow anybody to store certain information on
    top of the blockchain, but they are limited and it's costly to do so.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储大量数据的应用程序在数据库上。智能合约的工作原理类似于数据库，因为它们允许任何人在区块链上存储特定信息，但它们受限且成本高昂。
- en: Gas is another concept that is important to understand properly. It was created
    because smart contracts are Turing complete, which means that they can execute
    loops such as `while` or `for` endlessly until a task is done. It could happen
    that developers create endless loops that are stuck in the same state forever.
    To avoid a situation where thousands of nodes are stuck processing one transaction
    with no limit, each transaction has a gas cost that depends on the processing
    power required to execute it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 是另一个很重要的概念，适当地理解它至关重要。它的创建是因为智能合约是图灵完备的，这意味着它们可以执行无限循环的`while`或`for`，直到完成任务。开发者可能会创建永远停留在相同状态的无限循环。为了避免成千上万的节点被困在处理一笔交易而没有限制的情况，每笔交易都有一个取决于执行它所需的处理能力的
    gas 成本。
- en: 'So, they created a system where you have to pay for every action you take using
    the blockchain. You can store information on the blockchain, but you''ll have
    to pay an important cost, because every single node using it will have to download
    your changes. The way it calculates the gas cost is simple:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们创建了一个系统，你在使用区块链进行每一项操作时都需要付费。你可以在区块链上存储信息，但你将不得不支付重要的成本，因为使用它的每一个单节点都将不得不下载你的更改。它计算
    gas 成本的方式很简单：
- en: You pay a certain maximum gas that you're willing to spend for your transaction.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你支付了你愿意为你的交易花费的最大 gas。
- en: Your local Ethereum node calculates how much it will cost to execute your transaction
    by checking the opcodes used to generate a precise approximation of the computing
    power needed. You see, every small operation using the blockchain can be measured
    because we use a sort of assembly language that tells us when this super computer
    is being used and how.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的本地以太坊节点通过检查用于生成所需计算能力的操作码来计算执行您的交易将花费多少。您知道，使用区块链的每个小操作都可以被测量，因为我们使用一种告诉我们何时正在使用这台超级计算机以及如何使用的一种汇编语言。
- en: The right amount of gas is used, and the rest is refunded to you.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用了正确数量的 gas，并且剩余的部分会退还给您。
- en: You also have to determine a gas price ranging from 1 to usually 100 or more
    to tell miners which transactions to process first, since they get paid more the
    more expensive each gas is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要确定一个从 1 到通常 100 或更高范围的燃气价格，以告诉矿工首先处理哪些交易，因为每个燃气越昂贵，他们就可以得到更多报酬。
- en: Smart contract deployment process
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约部署过程
- en: Smart contracts run on top of the Ethereum blockchain in a similar way to how
    a server-side web application works. However, the process of deploying a smart
    contract to it is vastly different. In order to be an expert Ethereum developer,
    you must understand how the smart contract code is processed and stored in the
    blockchain blocks for you to be able to use them, because it will give you an
    understanding of why and how things can go wrong when pushing your newly written
    smart contract code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约类似于在以太坊区块链上运行的服务器端 Web 应用程序。然而，部署智能合约的过程却大不相同。要成为一名专业的以太坊开发者，你必须理解智能合约代码是如何在区块链块中处理和存储的，以便你能够使用它们，因为这将让你了解在推送你新编写的智能合约代码时可能出现问题的原因和方法。
- en: It's not uncommon to receive errors when trying to deploy your code to the blockchain,
    so to be able to debug it successfully, you need to understand what happens under
    the hood.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试部署代码到区块链时收到错误并不罕见，所以要成功调试它，你需要理解底层发生了什么。
- en: Ethereum transactions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊交易
- en: To understand how smart contracts are deployed on the network, it's important
    to understand first how transactions work, since when you deploy a smart contract,
    what you're actually doing is generating a transaction with the bytecode of the
    application that you just built.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解智能合约如何部署到网络上，首先要了解交易的工作原理是很重要的，因为当你部署一个智能合约时，你实际上是生成了一个带有你刚刚构建的应用程序的字节码的交易。
- en: 'The message that makes up a transaction on Ethereum is made up of the following
    encoded components:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上组成交易的消息由以下编码组件组成：
- en: '**Recipient**: This is the receiver Ethereum address that will get the transaction.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：这是将接收交易的以太坊地址。'
- en: '**Value**: This represents the amount of ether to transfer to the recipient
    address. This value can be zero, and you can access it in Solidity with the global
    `msg.value` variable. The value is always in **wei**, the smallest unit in Ethereum.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价值**：这表示要转移到收件人地址的以太量。这个值可以是零，并且你可以在 Solidity 中使用全局 `msg.value` 变量来访问它。该值始终以以太为单位，是以太坊中的最小单位。'
- en: '**Data**: This is a hexadecimal bytecode string that is mostly used to call
    a specific function with the required parameters. This is specific information
    that you need your smart contract to execute. When smart contracts communicate
    with each other, they need a way to tell when to execute a specific function with
    a given set of variables. Thanks to this data parameter, we can encode the functions
    that we want to call in the contract when the transaction is processed. On the
    other hand, when the smart contract is deployed to the blockchain for the first
    time, the data parameter contains the smart contract converted to bytecode so
    that machines can understand it. In general, it contains the smart contract functions
    to be executed in the next block by the miners.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是一个十六进制的字节码字符串，主要用于调用具有所需参数的特定函数。这是你需要智能合约执行的具体信息。当智能合约彼此通信时，它们需要一种方式来告诉何时以给定的一组变量执行特定函数。由于这个数据参数，我们可以在交易处理时编码我们想要在合约中调用的函数。另一方面，当智能合约首次部署到区块链时，数据参数包含了智能合约转换为字节码的内容，以便机器能够理解它。总的来说，它包含了智能合约函数将由矿工在下一个区块中执行的信息。'
- en: '**Gas limit**: This represents the gas limit, which is how much gas you''re
    willing to spend to process your function transactions. The gas limit is represented
    in wei, and it''s mandatory to give miners as much gas as possible to process
    your code.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃气限额**：这代表了燃气限额，即你愿意为处理你的函数交易支付多少燃气。燃气限额以 wei 表示，给矿工尽可能多的燃气来处理你的代码是强制性的。'
- en: '**Gas price**: The gas price determines how much each gas you provide will
    cost. If your gas cost is one, you''ll pay one wei per gas. If it''s 20, you''ll
    pay 20 wei per 1 gas. It''s used to help miners process the transactions, since
    they will be rewarded partially with the transaction fees.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃气价格**：燃气价格决定了你提供的每个燃气的成本。如果你的燃气成本为 1，你将支付每个燃气 1 wei。如果是 20，你将支付每 1 个燃气 20
    wei。它用于帮助矿工处理交易，因为他们将部分通过交易费用获得奖励。'
- en: '**Nonce**: The nonce is a unique counter number that is used to identify transactions.
    This unique counter is used to identify each block, and it helps miners to identify
    invalid blocks, since the nonce must always be one number bigger than the previous
    block.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nonce**：Nonce是一个用于标识交易的唯一计数器号码。这个唯一计数器用于标识每个区块，并帮助矿工识别无效区块，因为Nonce必须始终比上一个区块的数字大一个数。'
- en: '**Signature**: This is a parameter made of three independent variables known
    as *v*, *r*, and *s*. These variables are used to sign transactions with your
    unique Ethereum address data so that people can confirm that you''re the one that
    created it.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：这是由三个独立变量组成的参数，称为*v*、*r*和*s*。这些变量用于使用你的唯一以太坊地址数据签署交易，以便人们可以确认你是创建者。'
- en: When a user makes a transaction to a smart contract, it's called a **message**
    instead of a transaction. This difference between transaction and message exists,
    because messages don't have signature data since they don't have to be signed
    by the other party. The nonce is required to prevent replay attacks where an external
    user could take the same transaction data and execute it again for his own benefit.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向智能合约发出交易时，称为**消息**而不是交易。交易和消息之间的区别存在，因为消息没有签名数据，因为它们不需要被对方签名。Nonce是必需的，以防止重放攻击，其中外部用户可以获取相同的交易数据并为自己的利益再次执行它。
- en: When you deploy a smart contract, you're actually sending a transaction to the
    address `0x0` with a special bytecode identifier, so that miners understand that
    you're creating a new smart contract. The data parameter in this case contains
    all the smart contract logic, including function names and parameters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署一个智能合约时，实际上你是向地址`0x0`发送一个交易，带有一个特殊的字节码标识符，以便矿工理解你正在创建一个新的智能合约。在这种情况下，数据参数包含所有智能合约逻辑，包括函数名称和参数。
- en: In summary, creating and working with smart contracts is a transparent process,
    where you tell miners to process your data. They will then understand the bytecode
    behind it and make the required changes to the blockchain with the needed parameters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，创建和使用智能合约是一个透明的过程，你告诉矿工处理你的数据。然后他们将理解其背后的字节码，并使用所需的参数对区块链进行必要的更改。
- en: Essential smart contract programming
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的智能合约编程
- en: After understanding how smart contracts are created and where they integrate
    in the blockchain system, you will now get a more practical insight about how
    to create smart contracts using the two most popular languages for it—**Solidity**
    and **Vyper**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了智能合约是如何创建的以及它们如何融入区块链系统后，你现在将更加实际地了解如何使用两种最流行的语言——**Solidity**和**Vyper**来创建智能合约。
- en: Solidity
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solidity
- en: Solidity is the most advanced programming language created for developing smart
    contracts on the Ethereum network. Its syntax is similar to JavaScript, but with
    statically typed variables and functions. It provides simple features, such as
    functions, loops, and several types of variables, as well as complex functions,
    such as assembly, encryption functions, and signature verification systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是为在以太坊网络上开发智能合约而创建的最先进的编程语言。它的语法类似于JavaScript，但具有静态类型的变量和函数。它提供了简单的功能，如函数、循环和几种类型的变量，以及复杂的功能，如汇编、加密函数和签名验证系统。
- en: It's been used in many projects, especially ICOs, with great success, so it's
    mature enough to be used by any kind of developer interested in developing decentralized
    applications and secure smart contracts.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经在许多项目中被使用，特别是ICO，在取得了巨大成功，因此足够成熟，可以被任何对开发去中心化应用程序和安全智能合约感兴趣的开发者使用。
- en: The main drawback of it is that it's harder to secure, given that it provides
    a more complete set of features that could lead to security issues if not audited.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其主要缺点是它更难以保护，因为它提供了更完整的功能集，这可能导致安全问题，如果不经过审核。
- en: File structure
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件结构
- en: We'll use the 0.5.0 version of Solidity for all the examples in this book. A
    smart contract in Solidity always starts with the version that is used in the
    file to ensure that the contract is not compatible with newer versions that could
    break the contract because of newly added functionalities.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的所有示例中使用Solidity的0.5.0版本。Solidity中的智能合约始终从文件中使用的版本开始，以确保合约与可能因新增功能而破坏合约的新版本不兼容。
- en: 'Let''s look at the structure of a contract in Solidity using the following
    steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来看一下Solidity合约的结构：
- en: 'You define the version at the beginning of the file with the `pragma` statement:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在文件开始使用`pragma`语句来定义版本：
- en: '[PRE0]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you can start writing your contracts. All statements in Solidity must
    end with a semicolon (`;`) to be valid. After defining the version used in the
    file, you have to create the contracts, as shown here:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你可以开始编写你的合同。Solidity中的所有语句必须以分号(`;`)结尾才能有效。在文件中定义了使用的版本后，你必须创建合同，就像这样：
- en: '[PRE1]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can define multiple contracts in one single file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在一个文件中定义多个合同：
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the contract, you''ll have state variables, functions, modifiers, and
    a single constructor. I''ll explain later how they are used in detail:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合同内，你将拥有状态变量，函数，修改器和一个构造函数。稍后我会详细解释它们的用法：
- en: '[PRE3]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The variables that are defined directly in the contract, meaning that they
    are outside functions, are called **state variables**. These are special variables
    that store their value even after executing the contract. Think of them as special
    permanent variables that you can always read and modify:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在合同中定义的变量，即在函数之外定义的变量，被称为**状态变量**。这些都是特殊的变量，即使在执行合同之后也会保留它们的值。把它们想象成特殊的永久性变量，你可以随时读取和修改它们：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, they are outside functions but inside the contract, and they
    are defined at the top of the file, right when the contract begins. As I said,
    they keep their value forever, even after making changes to your contract. So,
    if your `myStateVariable` has a value of `5`, you'll be able to read the value
    of that variable days or months after it has been modified, as long as you don't
    modify it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它们位于函数之外但是在合同之内，并且它们是在文件顶部定义的，就在合同开始的地方。正如我所说，它们永远保持它们的值，即使在修改合同之后也是如此。所以，如果你的`myStateVariable`的值为`5`，你可以在修改它之后的几天或几个月后读取该变量的值，只要你不修改它。
- en: They store their value directly on the blockchain storage, not in memory. In-memory
    variables, as you'll learn later, lose their value and are reset after the contract
    execution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它们直接存储在区块链存储中，而不是在内存中。如你稍后所学，内存变量会在合同执行后失去值并被重置。
- en: Finally, Solidity files use the `.sol` extension, for instance, `example.sol`.
    You will learn how to deploy them with the **Remix IDE** and `Truffle` in *`Chapter
    3`*, *Mastering Smart Contracts,* and *`Chapter 9`*, *Decentralized Exchanged
    Workflow*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Solidity文件使用`.sol`扩展名，例如，`example.sol`。你将学习如何使用**Remix IDE**和`Truffle`部署它们，在*`第3章`*，*`掌握智能合同`*和*`第9章`*，*`去中心化交易工作流`*中。
- en: Variables
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Solidity is a statically typed language, which means that you have to define
    the type of every variable that you create.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种静态类型的语言，这意味着你必须为你创建的每个变量定义类型。
- en: Let's define the types of variables available in this programming language to
    later understand how to use them, but before that, you need to understand the
    visibility of variables.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义这种编程语言中可用的变量类型，以便后来理解如何使用它们，但在此之前，你需要了解变量的可见性。
- en: Visibility of variables
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的可见性
- en: 'Every variable and function in Solidity has a specific visibility. The visibility
    is a keyword you use after the variable type to define who should have access
    to it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的每个变量和函数都有特定的可见性。可见性是你在变量类型后使用的关键字，用来定义谁可以访问它：
- en: '**Public**: This means that the variable can be read or written by any contract,
    including external ones, as long as there''s a function to update them.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：这意味着该变量可以被任何合同读取或写入，包括外部合同，只要有一个函数来更新它们。'
- en: '**Private**: Private variables can''t be accessed by a derived smart contract,
    those that implement your contract with the `is` keyword; for example, `contract
    Example is Another {}`, where `Another` is a smart contract with private variables
    that can''t be accessed by `Example`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：私有变量无法被派生的智能合同访问，那些用`is`关键字实现你的合同的智能合同；例如，`contract Example is Another
    {}`，其中`Another`是一个带有私有变量的智能合同，无法被`Example`访问。'
- en: '**External**: These variables and functions are not accessible by the contract
    containing them. Only external contracts and users can use them.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：这些变量和函数不能被包含它们的合同访问。只有外部合同和用户可以使用它们。'
- en: '**Internal**: These are variables and functions that can''t be read or written
    by external entities, only by the contract itself or by inherited contracts, as
    you saw in the example for the private variable.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：这些是无法被外部实体读取或写入的变量和函数，只能被合同本身或继承的合同访问，就像你在私有变量的例子中看到的那样。'
- en: To keep things simple, I recommend you to always write `public` for your variables
    unless it's a special variable, which doesn't happen that often. If you don't
    define any visibility, the variable will be `public` by default, although it's
    better to just write the `public` keyword in every variable to make sure that
    you understand the visibility of the variable and it's not a mistake.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我建议你对变量始终写上`public`，除非它是一个特殊的变量，这种情况并不经常发生。如果你不定义任何可见性，变量默认是`public`，虽然最好每个变量都写上`public`关键字，以确保你理解变量的可见性，并且这不是一个错误。
- en: Uints
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uints
- en: Uints are unsigned integers, which means that they are numbers starting from
    zero that can't be negative.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Uints是无符号整数，意味着它们是从零开始的数字，不能为负数。
- en: 'You define them as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义它们如下：
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, you first define the type of the variable, then the visibility,
    and then the name of the variable. Remember that if you don't define the visibility
    of the variable, the variable will be `public`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你首先定义变量的类型，然后是可见性，然后是变量的名称。请记住，如果你不定义变量的可见性，变量将是`public`。
- en: 'Uints can be of the following types:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Uints可以是以下类型之一：
- en: '`uint8`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint8`'
- en: '`uint16`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16`'
- en: '`uint24`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint24`'
- en: '`uint32`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32`'
- en: '`uint64`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint64`'
- en: '`uint128`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint128`'
- en: '`uint256`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint256`'
- en: 'The number for each variable means the size of the `uint`. A `uint8` type of
    variable will be able to store up to 256\. So, the maximum variable of a `uint8`
    variable is `256`. If you want to store the number 255, the variable will work
    properly, but, if you want to store the number `256` as follows, then the variable
    will overflow, and it will reset to zero instead of `256`, because it exceeds
    the capacity of that type of variable:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量的数字表示`uint`的大小。一个`uint8`类型的变量能够存储最多256。因此，`uint8`变量的最大值是`256`。如果你想存储数字255，变量将正常工作，但是，如果你想存储数字`256`如下，那么变量将溢出，并且会重置为零而不是`256`，因为它超出了该类型变量的容量：
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you try to store a value `256`, the variable resets because it starts at
    zero, so the capacity is the calculated number minus one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试存储一个值`256`时，变量会重置，因为它从零开始，所以容量是计算出来的数字减去一。
- en: 'What happens when you try to store another number that exceeds the capacity
    of the variable, such as `300`? Then, the value of the variable will be `44`.
    So, input the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试存储另一个超过变量容量的数字时，比如`300`，变量的值将会是`44`。所以，输入以下内容：
- en: '[PRE7]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It will become the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它将变成以下内容：
- en: '[PRE8]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that you can't assign a value that is bigger than the variable's capacity,
    because you'll get a compilation error in some cases when trying to deploy your
    contract. The overflow problem can happen when you have a function that receives
    a `uint8`, but the user inputs a value bigger than 255.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能给变量赋一个超过其容量的值，因为在某些情况下，尝试部署你的合约时会得到编译错误。当函数接收到一个`uint8`，但用户输入的值大于255时，就会出现溢出问题。
- en: This is the same thing with `uint16`, which has a maximum value of *65536*-*1*.
    Likewise, `uint24` has a maximum value of *16777216*-*1*. The `uint32` variable
    has a maximum value of *4294967296*-*1*. The `uint64` variable has a maximum value
    of *1844674407370955e19*-*1*. The `uint128` variable has a maximum value of *3402823669209385e38*-*1*.
    The `uint256` variable has a maximum value of *1157920892373163e77*-*1*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`uint16`是一样的，它的最大值是*65536*-*1*。同样，`uint24`的最大值是*16777216*-*1*。`uint32`变量的最大值是*4294967296*-*1*。`uint64`变量的最大值是*1844674407370955e19*-*1*。`uint128`变量的最大值是*3402823669209385e38*-*1*。`uint256`变量的最大值是*1157920892373163e77*-*1*。
- en: As you can see, the maximum number grows pretty quickly. This is great to avoid
    overflows when you are dealing with big numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，最大数字增长得相当快。这对于处理大数字时避免溢出非常有用。
- en: 'On the other hand, you have the problem of underflows. These happen when you
    try to store a negative number into a `uint`. For instance, try to do this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你还会遇到欠流的问题。当你尝试将一个负数存储到`uint`中时，就会发生这种情况。例如，尝试执行以下操作：
- en: '[PRE9]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''ll get the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下结果：
- en: '[PRE10]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This happens for the same reason as overflows; you are going from zero to the
    biggest number possible that that variable can hold.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为溢出的原因发生的。你从零开始，一直加到变量能够容纳的最大值。
- en: Those problems can result in heavy vulnerabilities. That's why it's important
    that you check that the values that the user inputs in your functions are within
    the range of acceptable numbers. You'll later see how to verify inputs from functions
    with a global function called `require()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能导致严重的漏洞。这就是为什么重要的是检查用户在函数中输入的值是否在可接受数字范围内。稍后你将看到如何使用一个名为`require()`的全局函数来验证函数的输入。
- en: Addresses
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址
- en: In Solidity 0.4.0, there was only one type of address. Now, we have two types
    to define whether an Ethereum address should be payable or not.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity `0.4.0`中，只有一种地址类型。现在，我们有两种类型来定义以太坊地址是否应该是`payable`的。
- en: 'An **address** contains the account number of each user in Ethereum. It''s
    a 42-character piece of hexadecimal text, such as this one:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**地址**包含每个以太坊用户的账号编号。它是一个由`42`个十六进制文本字符组成的文本，例如这样一个：
- en: '[PRE11]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create an `address` variable in your contract, you have to define it as
    follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的合同中创建一个`地址`变量，您必须定义如下：
- en: '[PRE12]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Addresses don''t have quotes because they are not strings of text. In this
    version of Solidity, you must define the type of address, which could be one of
    the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 地址没有引号，因为它们不是文本字符串。在这个版本的Solidity中，你必须定义地址的类型，它可以是以下之一：
- en: '**Address** `payable`**:** A payable address is a new type of variable introduced
    in Solidity `0.5` that allows the address to receive and store Ether inside. Previously,
    all addresses were `payable`, now only those explicitly marked as `payable` will
    be able to receive or send Ether and use functions that deal with Ether, such
    as `.transfer()` or `.send()`.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址** `payable`**：** 可支付地址是在Solidity `0.5`中引入的一种新的变量类型，允许该地址接收和存储以太币。以前，所有地址都是`payable`，现在只有那些明确标记为`payable`的地址才能接收或发送以太币，并且使用处理以太币的函数，如`.transfer()`或`.send()`。'
- en: '**Address:** A normal address that can''t receive or send Ether to prevent
    users from doing so.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址：** 一个普通地址，无法接收或发送以太币，以防止用户这样做。'
- en: 'You define the `payable` addresses as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`payable`地址定义如下：
- en: '[PRE13]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s useful to have payable addresses when you want to send Ether to that
    address. For instance, let''s say that user A wants to receive 10 ether from the
    balance stored in the smart contract. They would do something like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要向该地址发送以太币时，拥有`payable`地址将非常有用。例如，假设用户A想从智能合约存储的余额中收到`10`个以太币。他们将执行以下操作：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, user A would receive 10 ether from the funds stored in this smart contract.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户A将从存储在此智能合约中的资金中收到`10`个以太币。
- en: Another important aspect of the addresses is that you sometimes need to access
    the address of the current smart contract, because, as you know, smart contracts
    can hold Ether inside.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的另一个重要方面是，有时您需要访问当前智能合约的地址，因为，正如您所知，智能合约可以在内部持有以太币。
- en: 'To get the address of your smart contract, use the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您的智能合约地址，请使用以下代码：
- en: '[PRE15]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `this` is the special keyword used to reference the active smart contract
    being used at that moment. But because it is an instance of a smart contract,
    you need to convert that instance to an address with the type conversion function,
    which essentially gets the address of this smart contract.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this`是一个特殊关键词，用于引用当前正在使用的活动智能合约。但因为它是智能合约的一个实例，您需要使用类型转换函数将该实例转换为地址，该函数本质上是获取本智能合约的地址。
- en: 'You can also access the balance of this smart contract with the `.balance`
    function as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`.balance`函数访问此智能合约的余额，如下所示：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That will return the number of wei in the smart contract, useful for making
    transfers with the `transfer()` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回智能合约中的 wei 数量，可用于使用`transfer()`函数进行转账：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That will send `myUserAddress` all the Ether stored inside this contract.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向`myUserAddress`发送存储在此合约中的所有以太币。
- en: You can convert payable addresses to normal addresses, but not the other way
    around, based on the fact that payable addresses are an augmented version with
    additional functions that can't be passed easily.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`payable`地址转换为普通地址，但反之则不行，基于`payable`地址是具有额外函数的增强版本，无法轻松传递。
- en: Strings and bytes
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: 'Strings and bytes hold pieces of text in single or double quotes, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和字节以单引号或双引号形式存储文本片段，如下所示：
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: They allow you to store about 1,000 words and they are essentially the same.
    You can have smaller variations of bytes, such as `bytes1`, `bytes2`, and `bytes3`,
    up to `bytes32`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它们允许您存储大约`1,000`个字，并且它们本质上是相同的。您可以有更小的字节变体，比如`bytes1`，`bytes2`和`bytes3`，一直到`bytes32`。
- en: 'Now, `bytes32` is an interesting type of variable, because it allows you to
    store about 32 characters of text in a very compact and efficient way. They are
    used in many cases where short text is required:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`bytes32`是一种有趣的变量类型，因为它允许你以非常紧凑和高效的方式存储约32个字符的文本。它们在需要短文本的许多情况下使用：
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They are used in many other advanced uses cases, such as checking if a string
    or byte''s text is empty. For instance, if you have a function that receives text,
    you may want to make sure that the text is not empty. Here''s how you''d do it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在许多其他高级用例中使用，例如检查字符串或字节的文本是否为空。例如，如果你有一个接收文本的函数，你可能希望确保文本不为空。你可以这样做：
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Don''t worry about the technicalities of the function. If you don''t know or
    remember them yet, to check if a string is empty, you must do the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心函数的技术细节。如果你还不知道或记不住它们，要检查字符串是否为空，你必须执行以下操作：
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This tells the contract to make sure that the first letter of the string is
    not empty. That's the right way to check for empty strings. We do the same thing
    with bytes, but without the conversion to bytes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉合约确保字符串的第一个字母不为空。这是检查空字符串的正确方法。我们对字节执行相同的操作，但不进行字节转换。
- en: Use them whenever you need to add special characters to your strings in Ethereum.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊字符串中添加特殊字符时使用它们。
- en: Structs
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'If you are familiar with JavaScript, you can think of structs as objects with
    properties and values. A `struct` looks similar to the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 JavaScript，你可以将结构想象成具有属性和值的对象。`struct`看起来类似于以下内容：
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Enums
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are fixed size lists with unique names that you define. You can use them
    as custom modifiers for specific objects, or to hold a specific state in your
    smart contract. This is ideal for controlling the state of ICOs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是具有唯一名称的固定大小列表，由你定义。你可以将它们用作特定对象的自定义修饰符，或者在智能合约中保持特定状态。这对于控制 ICO 的状态非常理想。
- en: 'You declare them as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明它们如下：
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you create the `enum` variable:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建`enum`变量：
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you don't have to add a semicolon at the end of the `enum` declaration,
    but you do have to add it for the variable with the `enum` type that you just
    created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`enum`声明的末尾不必添加分号，但是对于刚创建的具有`enum`类型的变量，你必须添加分号。
- en: Booleans
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'A Boolean variable can either be `true` or `false`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量可以是`true`或`false`：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Arrays
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays allow you to store large amounts of the same type of variable in one
    place. They are used as lists that contain a specific type of information for
    your smart contracts so that you can store your data in an orderly manner. They
    can be accessed with a simple `for` loop by getting the length of them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许你将大量相同类型的变量存储在一个地方。它们被用作包含特定类型信息的列表，以便在智能合约中有序存储数据。你可以通过简单的`for`循环获取它们的长度来访问它们。
- en: 'You can create arrays of uints, strings, structs, addresses, and pretty much
    any other type:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建uints、strings、structs、addresses等几乎任何其他类型的数组：
- en: '[PRE26]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also delete elements from an array with the following keyword:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下关键字从数组中删除元素：
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also use `.push()` and `.pop()` to add or remove elements from the array
    in dynamically-sized arrays.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`.push()`和`.pop()`向动态大小数组中添加或删除元素。
- en: Mappings
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Mappings are a special type of variable in the sense that they can hold an
    endless amount of data. It''s like a combination of an array and a struct. You
    can add elements to it for a set of types:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种特殊类型的变量，它们可以容纳无限量的数据。它就像数组和结构的组合。你可以为一组类型添加元素：
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mappings store information as an unlimited array. They work similar to objects
    in JavaScript, where each key has a value associated and they can be accessed
    randomly. They don't have a fixed length, nor can you get the length of them,
    as with arrays, for looping their values. What you must do instead is save the
    latest updated key of your mapping and go from there.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 映射将信息存储为无限数组。它们的工作方式类似于 JavaScript 中的对象，其中每个键都有一个关联的值，并且它们可以被随机访问。它们没有固定长度，也不能像数组那样获取它们的长度来循环它们的值。你必须做的是保存映射的最新更新键，然后从那里开始。
- en: 'You can set values for mappings as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下设置映射的值：
- en: '[PRE29]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our example, all values of `validStrings` will be `false` until you set them
    to `true`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`validStrings`的所有值都将是`false`，直到你将它们设置为`true`。
- en: Data location
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据位置
- en: 'In Solidity, you have the option to define where your variables will be stored.
    You can decide to store them in the following places:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，您可以选择定义变量存储的位置。您可以决定将它们存储在以下位置：
- en: '**Storage**: This is a permanent place that gets written on the blockchain,
    therefore it''s expensive to use'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：这是在区块链上写入的永久位置，因此使用起来很昂贵'
- en: '**Memory**: This is a non-permanent place where variables are held for only
    as long as the smart contract is running'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：这是一个非永久的地方，变量只在智能合约运行的时间内保存。'
- en: '**Calldata**: This is where the `msg` object data information is stored, a
    place dedicated to global variables'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用数据**：这是`msg`对象数据信息存储的地方，一个专门的全局变量'
- en: 'An example of this is in the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种例子在以下代码中可以看到：
- en: '[PRE30]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Events
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Events are a special type of function. Their purpose is to log data on the blockchain
    and actions that you want to retrieve at a later date. They can be **subscribed
    to** to receive an update whenever a new event is generated, almost in real time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种特殊类型的函数。它们的目的是在区块链上记录数据和您希望在以后检索的操作。它们可以**订阅**以在产生新事件时接收更新，几乎是实时的。
- en: Essentially, you want them to keep a registry of the things that are happening
    inside your smart contract to later analyze them in order to fix bugs and to understand
    what happened if you need to read the past in an easy way.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，您希望它们保留智能合约内部发生的事情的注册表，以便以后分析它们以修复错误，并了解如果需要以轻松的方式阅读过去发生了什么。
- en: 'Here''s how you declare events inside your smart contract in Solidity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Solidity智能合约中声明事件的方式：
- en: '[PRE31]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, you can see how an event is declared and emitted. When you
    declare your event, you have to decide the parameters that it will be able to
    receive; all of them are always optional, so you can omit them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到如何声明和发出一个事件。当您声明事件时，您必须决定它能够接收的参数；它们始终是可选的，因此您可以省略它们。
- en: 'When you emit the event inside a function, you must make sure that they are
    of the right type. In the declaration, you can add a name for each parameter,
    or you can leave it with just the type, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在函数内部发出事件时，必须确保它们是正确的类型。在声明中，您可以为每个参数添加名称，或者只留下类型，如下所示：
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's good practice to name the parameters inside the event, to help others understand
    the purpose of each of those parameters.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 好的做法是在事件内部命名参数，以帮助他人理解每个参数的目的。
- en: 'You can also add an optional keyword called `indexed`. It''s a modifier to
    the parameter of the event that allows you to search past events for that specific
    event. Think of `indexed` parameters as searchable entries in a database:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加一个名为`indexed`的可选关键字。它是事件参数的修饰符，允许您搜索过去的事件以获得特定事件。将`indexed`参数视为数据库中可搜索的条目：
- en: '[PRE33]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that you must name the parameters that are `indexed`. Later you'll see
    how to retrieve those events and search for specific ones with web3.js.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须为`indexed`的参数命名。稍后您将看到如何使用web3.js检索这些事件并搜索特定事件。
- en: Modifiers
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'Modifiers are a special type of function that are used to verify data or execute
    something before the current function execution as a middleware. They are mostly
    used to verify that the user executing the function has the required permissions
    and to verify the parameters:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符是一种特殊类型的函数，用于在当前函数执行之前验证数据或执行某些操作作为中间件。它们主要用于验证执行函数的用户是否具有所需权限，并验证参数：
- en: '[PRE34]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the `onlyOwner` modifier is used to check if the `doSomething`
    function is being executed by the owner of the contract or by another user. If
    the caller is the owner, the functions gets executed, and if it's an external
    address, the contract will revert, and an exception will be thrown.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`onlyOwner`修饰符用于检查`doSomething`函数是由合同所有者执行还是由其他用户执行。如果调用者是所有者，则函数被执行，如果是外部地址，则合同将恢复，抛出异常。
- en: Note that the `require()` function is a global assert function to verify that
    the condition inside it it's true or not. If not, it will throw, and it will stop
    executing the smart contract.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`require()`函数是一个全局断言函数，用于验证其中的条件是否为真。如果条件不为真，它将抛出异常，停止执行智能合约。
- en: 'The underscore statement inside the `_` modifier is used to indicate where
    the code of the function will be executed. Sometimes, you want to execute the
    function before the modifier''s checks. The underscore statement is mandatory
    in modifiers. Also note that the modifier can have parameters optionally. If none
    are required, you can remove the brackets as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`修饰符内部的下划线语句用于指示函数的代码将在哪里执行。有时，你希望在修饰符的检查之前执行函数。在修饰符中，下划线语句是强制性的。此外，请注意，修饰符可以选择性地具有参数。如果不需要参数，你可以将括号删除如下所示：'
- en: '[PRE35]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modifiers are very powerful tools that you'll often use whenever you see repetitive
    code doing the same verifications for several functions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符是非常强大的工具，当你看到重复的代码为多个函数执行相同的验证时，你经常会使用它们。
- en: In the next section, you'll see the types of special modifiers that functions
    can take for visibility and payments.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到函数可以采用的用于可见性和支付的特殊修饰符的类型。
- en: Functions
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions in Solidity are pretty similar in syntax to those in JavaScript,
    but they have some key differences that you must understand, such as the fact
    that you must specify return types, the visibility of the function, and the modifiers
    that apply to each particular function, if any. The syntax is the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity中的函数在语法上与JavaScript中的函数非常相似，但它们具有一些您必须了解的关键区别，例如您必须指定返回类型、函数的可见性以及适用于每个特定函数的修饰符（如果有的话）。语法如下：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Functions have visibility just as variables do, where public functions can be
    executed by external users, contracts, and in the contract itself. External functions
    can only be by external entities, not by the contract itself. Internal functions
    can only be executed by the containing contract. Private functions can be executed
    only inside the current contract, or by inherited contracts.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与变量一样具有可见性，其中公共函数可以被外部用户、合约以及合约本身执行。外部函数只能由外部实体执行，而不是由合约本身执行。内部函数只能由包含合约执行。私有函数只能在当前合约内部执行，或由继承合约执行。
- en: 'Now, a function can have special modifiers that determine the type of function
    it is. This includes modifiers such as the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个函数可以具有确定其类型的特殊修饰符。这包括以下修饰符：
- en: '**View**: A view function is one that doesn''t modify state variables but can
    read them. Remember that state variables are declared at the beginning of the
    contract, and they are used to store information directly on the blockchain. So,
    if your function doesn''t modify any state variable, you have to mark it as `view`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图函数是一种不修改状态变量但可以读取它们的函数。请记住，状态变量在合约开始处声明，并且它们用于直接在区块链上存储信息。因此，如果你的函数不修改任何状态变量，你必须将其标记为`view`。'
- en: '**Pure**: A pure function is even more restrictive. It applies to those functions
    that don''t even read state variables. Pure functions are normally functions that
    make some type of calculation inside them without relying on external data. This
    usually includes mathematical functions or formatting functions.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：纯函数更为严格。它适用于那些甚至不读取状态变量的函数。纯函数通常是在函数内部进行某种类型的计算而无需依赖外部数据的函数。这通常包括数学函数或格式化函数。'
- en: '**Payable**: A `payable` function is able to receive Ether when it is executed.
    It will store that Ether inside the contract, so it''s very important that you
    create systems to extract the Ether that gets sent to the smart contract, otherwise
    the money will be stuck inside there forever. If your function is not marked as
    `payable`, when you send Ether alongside the function execution, you''ll receive
    an error and the transaction will revert.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可支付函数**：`可支付（payable）`函数在执行时能够接收以太币。它会将以太币存储在合约内部，因此非常重要的是你要创建系统来提取发送到智能合约的以太币，否则这笔钱将永远被困在里面。如果你的函数没有标记为`可支付（payable）`，当你在函数执行过程中发送以太币时，你会收到一个错误并且交易会回滚。'
- en: 'Here''s how it looks:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如下是其外观：
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In that function, we are simply reading and returning the `myStateString` state
    variable, so we can mark it as `view`. Note that we must use the `memory` keyword
    for string types, since they are a type of array internally like an array of each
    individual character.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数中，我们只是读取并返回`myStateString`状态变量，因此我们可以将其标记为`view`。请注意，对于字符串类型，我们必须使用`memory`关键字，因为它们在内部是一种数组类型，就像一个个单独的字符数组一样。
- en: 'Another example is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例如下：
- en: '[PRE38]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This `pure` function is simply adding two numbers and returning the result to
    the caller. It doesn't modify the state and it doesn't read the state variables.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pure`函数只是将两个数字相加并将结果返回给调用者。它不修改状态，也不读取状态变量。
- en: 'Here''s a `payable` function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`payable`函数：
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `receiveDonation` function is empty because we only need to receive the
    Ether. We don't have to do anything with it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveDonation`函数是空的，因为我们只需要接收以太币。我们不必对其做任何处理。'
- en: The fallback function
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回退函数
- en: This is a special type of function that doesn't have a name. It is executed
    whenever someone uses the `.send()` or `.transfer()` function to this contract
    address, similar to a default function. It is often used in ICOs to receive Ether
    and return the specified number of tokens for the Ether received. This allows
    anybody to buy tokens without having to understand and deploy the contract instance,
    with just the address of the contract.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种没有名称的特殊类型的函数。每当有人使用`.send()`或`.transfer()`函数发送以太币到此合约地址时，它都会被执行，类似于默认函数。它经常在ICO中用于接收以太币并返回收到的以太币的指定数量的代币。这允许任何人购买代币，而无需理解和部署合约实例，只需合约的地址。
- en: 'Here''s how it looks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE40]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Fallback functions must be marked `external` to help people understand that
    it shouldn't be executed inside this contract by mistake. If you don't add the
    `payable` modifier, it will reject all the transactions sending it Ether.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 回退函数必须标记为`external`，以帮助人们理解不应该错误地在此合约内执行它。如果你不添加`payable`修饰符，它将拒绝所有发送以太币的交易。
- en: I recommend that you should write and try different functions using the `remix.ethereum.org`
    IDE, which will show you errors and notifications about things that must be verified.
    That way, you'll be able to write your own contract securely.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你应该使用`remix.ethereum.org` IDE编写并尝试不同的函数，它将向你显示必须验证的错误和通知。这样，你就能安全地编写自己的合约。
- en: Vyper
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vyper
- en: Vyper is a new programming language for smart contracts that has a syntax similar
    to Python. It was created by Vitalik himself and it's one of the most interesting
    choices for new decentralized applications, given that it provides a different
    approach to traditional Solidity smart contracts.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper是一种新的智能合约编程语言，其语法类似于Python。它是由维塔利克亲自创建的，对于新的去中心化应用来说，它是最有趣的选择之一，因为它提供了一种与传统Solidity智能合约不同的方法。
- en: Its goal is to be a simple programming language that has increased security
    based on simplicity, where the code should be easily understandable, even by non-developers.
    That's why the syntax is so minimalistic. They also wanted it to be a programming
    language where it's increasingly hard to write buggy or vulnerable code, so that
    developers don't spend countless hours analyzing the security of every single
    application while avoiding unexpected vulnerabilities by default.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目标是成为一种简单的编程语言，具有基于简单性的增强安全性，代码应该易于理解，即使对于非开发人员也是如此。这就是为什么语法如此简约的原因。他们还希望它成为一种编程语言，越来越难编写出有缺陷或易受攻击的代码，以便开发人员不必花费无数小时分析每个应用程序的安全性，同时默认避免意外的漏洞。
- en: 'That''s the main reason Vyper added several interesting features, such as the
    following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Vyper添加了几个有趣功能的主要原因，例如以下内容：
- en: '**Knowing how much gas each function call will cost every time**: Having a
    precise indication of gas costs is important, because you want users to be able
    to calculate precisely how much Ether they will invest per transaction. It saves
    people''s money while making the program predictable.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每次函数调用将花费多少gas的了解**：精确指示气体成本是重要的，因为您希望用户能够准确计算每笔交易将投入多少以太币。它既节省了人们的钱，又使程序可预测。'
- en: '**Automatic vulnerability checking**: Overflows, underflows, reentrancy attacks,
    and many other well-known vulnerabilities are automatically fixed in Vyper, without
    having to manually pay attention to every single function of your smart contracts.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动漏洞检查**：溢出、下溢、重入攻击和许多其他众所周知的漏洞在Vyper中自动修复，无需手动注意每个智能合约函数。'
- en: 'On the other hand, they removed important characteristics found in other smart
    contract programming languages, such as Solidity:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，他们移除了其他智能合约编程语言（如Solidity）中的重要特征：
- en: '**No more modifiers:** Modifiers are not allowed in Vyper, because they make
    code confusing to read, given that you have to jump back and forth between the
    modifier definition and its use. Also, they can be used maliciously by executing
    code unexpectedly; for instance, creating a modifier called `onlyOwner` but then
    executing a `transfer()` function totally unrelated to what''s expected from its
    name.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不再使用修饰符：** 在 Vyper 中不允许使用修饰符，因为它们使代码难以阅读，你必须来回跳转到修饰符定义和使用之间。此外，它们可能被恶意使用，通过意外执行代码；例如，创建一个名为
    `onlyOwner` 的修饰符，但随后执行与其名称预期完全不相关的 `transfer()` 函数。'
- en: '**No more assembly:** Assembly code is hard to understand, even to experienced
    developers, because you''re dealing with very low-level functions that can be
    misleading. This means that you won''t be able to create smart contracts that
    use signatures, state channels, and similar applications relying on assembly.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不再使用汇编：** 汇编代码很难理解，即使对经验丰富的开发人员来说也是如此，因为你正在处理非常低级的函数，可能会产生误导。这意味着你将无法创建使用签名、状态通道等依赖于汇编的智能合约。'
- en: '**No more recursive functions:** To avoid reentrancy attacks while guaranteeing
    a precise calculation of gas costs, they removed recursive functionality where
    functions can call themselves an uncertain amount of times.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不再使用递归函数：** 为了避免重入攻击并确保精确计算气体成本，他们移除了函数可以调用自身不确定次数的递归功能。'
- en: In general, Vyper is a powerful language that's great for smaller projects and
    won't require advanced functionality, such as assembly. You can quickly create
    an easy-to-maintain smart contract that your users will be able to understand
    within a few minutes for its light syntax and minimalistic code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Vyper 是一种功能强大的语言，非常适合较小的项目，并且不需要高级功能，例如汇编。你可以快速创建易于维护的智能合约，用户将在几分钟内就能理解其轻量级语法和简约的代码。
- en: Vyper by example
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以示例来说明 Vyper
- en: To get up to speed with this new exciting language, we'll go through a simple
    smart contract so that you can see the full complexity of Vyper. We'll see all
    the types of variables and functions in one single smart contract.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速掌握这种新的令人兴奋的语言，我们将通过一个简单的智能合约来进行，这样你就可以看到 Vyper 的完整复杂性。我们将在一个单一的智能合约中看到所有类型的变量和函数。
- en: 'Go ahead and create a new `example.vy` file. As you can see, Vyper smart contracts
    have the `.vy` termination. Inside it, type down the following code; we''ll later
    explain what every variable means and how they are used. This is just a quick
    exercise to get your programming hands familiar with how Vyper is written. This
    code will be your go-to guide to familiarize yourself with Vyper''s syntax:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接着创建一个新的 `example.vy` 文件。正如你所见，Vyper 智能合约的后缀是 `.vy`。在其中，输入以下代码；我们稍后会解释每个变量的含义以及它们如何使用。这只是一个快速的练习，让你的编程手熟悉
    Vyper 的编写方式。这段代码将成为你熟悉 Vyper 语法的指南：
- en: '[PRE41]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These are some clarifications to help you understand what is going on:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些澄清，帮助你理解正在发生的事情：
- en: 'Events must be declared at the top of the Vyper file, and they have to come
    inside curly brackets, like these: `({})`.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件必须在 Vyper 文件的顶部声明，并且它们必须放在大括号内，就像这样：`({})`。
- en: Unsigned integers can only be positive, and their maximum value is 2**256\.
    You can't have `uint8` or equivalent; all uints must be `uint256`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号整数只能是正数，它们的最大值是 2**256。你不能有 `uint8` 或等效的；所有的 uint 必须是 `uint256`。
- en: Signed integers, normal integers, can be positive or negative with a maximum
    value of 2**128 from both sides. They can only be `int128`, so you can't have
    smaller sizes.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号整数、普通整数，可以是正数或负数，最大值是从两边各 2**128。它们只能是 `int128`，所以你不能有更小的大小。
- en: Decimals have a precision of 10 decimal places, meaning that you can have up
    to 10 characters after the dot, for instance, `1.2394837662`.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数点的精度为 10 位小数，这意味着你可以在小数点后有最多 10 个字符，例如，`1.2394837662`。
- en: Strings can either be `bytes32` or `byte` arrays with a custom size, such as
    `bytes[2000]`. Note that you don't have the `string` type of variable, so your
    strings will be stored as hexadecimal texts after you upload them. Also, you can't
    have variable-size bytes, such as `bytes[]`, because they create uncertainty when
    calculating gas costs.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以是 `bytes32` 或带有自定义大小的 `byte` 数组，例如 `bytes[2000]`。注意，你没有 `string` 类型的变量，因此上传后你的字符串将被存储为十六进制文本。此外，你不能有可变大小的字节，例如
    `bytes[]`，因为它们在计算气体成本时会产生不确定性。
- en: Mappings must be declared with the `map()` function and they can be accessed
    with brackets, for instance, `todoList[3] = "Start something"`.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射必须使用 `map()` 函数声明，并且它们可以用方括号访问，例如，`todoList[3] = "Start something"`。
- en: '`Timestamp` is a fixed date for events such as your birthday, or a specific
    time in the future. This is mostly used as date containers. `timedelta` is more
    like a counter without a precise date in the calendar. For instance, `timedelta`
    could store `2 months`, while timestamp could store `January 1 2019`, all in numerical
    format.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timestamp`是用于事件的固定日期，例如您的生日，或者将来的特定时间。这主要用作日期容器。`timedelta`更像是一个没有在日历中具体日期的计数器。例如，`timedelta`可以存储`2
    months`，而时间戳可以存储`2019年1月1日`，都以数字格式表示。'
- en: The wei value is the type used for storing Ether in wei.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wei 值是用于以太币在 wei 中存储的类型。
- en: Custom unit types are personalized types that you define at the top of the file
    and you can then use for your variables. They must be casted as uints, ints, or
    decimals.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义单位类型是您在文件顶部定义的个性化类型，然后可以用于您的变量。它们必须转换为 uints、ints 或 decimals。
- en: Functions can be public or private. Public functions must have the `@public`
    decorator on top of them. The return value of functions is specified with the
    arrow sign, `->`.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以是公共的或私有的。公共函数必须在顶部加上`@public`装饰器。函数的返回值用箭头符号`->`指定。
- en: Payable functions must use the `@payable` decorator and they can access the
    Ether sent (if any) with `msg.value`.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付函数必须使用`@payable`装饰器，并且可以访问与`msg.value`一起发送的以太币（如果有）。
- en: To update state variables inside functions, you must use the `self.` keyword
    in front of them to update them as state variables. In Vyper, you don't need to
    add the underscore `_` in front of parameter names, because you can easily reference
    the variable with the same name in state, while in Solidity you can't, so you
    had to use underscores to differentiate them.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在函数内更新状态变量，您必须在它们前面使用`self.`关键字将它们更新为状态变量。在 Vyper 中，您不需要在参数名称前面添加下划线`_`，因为您可以轻松地引用与状态中相同名称的变量，而在
    Solidity 中您不能这样做，因此您必须使用下划线来区分它们。
- en: The constructor is called `__init__()`, while the fallback function is called
    `__default__()`.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数称为`__init__()`，而回退函数称为`__default__()`。
- en: That's it! The fastest way you can master Vyper in a few pages. Make sure that
    you keep this guide in a special place for whenever you write Vyper contracts
    to save you hours of headaches and uncomfortable moments.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您可以在几页中掌握 Vyper 的最快方式。确保您将这个指南放在一个特殊的地方，以便在编写 Vyper 合约时节省数小时的头痛和不舒服的时刻。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we started by getting a high-level overview of Ethereum's history
    to understand where it came from and where it's headed. Then, we moved to specific
    topics, such as the EEA, since it's great to know how the Ethereum technology
    is being applied in different real-world scenarios. After that, we covered many
    different topics regarding the specifics of the Ethereum blockchain to understand
    it more on a technical level that makes sense as a developer, since we'll be dealing
    with all aspects related to its blockchain. Next, we moved to more technical topics
    regarding smart contracts, since they are at the core of what an Ethereum developer
    does, so that you get a clear vision of how they are implemented in the grand
    scheme of things. Finally, we moved to essential smart contract programming with
    Solidity and Vyper to kick-start your understanding of how the most popular languages
    are used in the real world, setting up a solid foundation for future projects
    to start your journey to become a master Ethereum developer.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先对以太坊的历史进行了高层次的概述，以了解它的起源和发展方向。然后，我们转向特定主题，如 EEA，因为了解以太坊技术如何应用于不同的实际场景非常重要。之后，我们涵盖了许多关于以太坊区块链的具体主题，以更深入地理解作为开发人员有意义的技术层面，因为我们将处理与其区块链相关的所有方面。接下来，我们转向关于智能合约的更多技术主题，因为它们是以太坊开发人员所做的核心内容，以便您清楚地了解它们在整个计划中是如何实现的。最后，我们转向使用
    Solidity 和 Vyper 进行基本智能合约编程，以启动您对这些最受欢迎的语言在现实世界中的使用方式的理解，为开始您的成为一名优秀以太坊开发人员的旅程奠定坚实的基础。
- en: 'If you weren''t familiar with Vyper, you should now be able to program simple
    contracts using the online compiler, which can be found at: [https://vyper.online/](https://vyper.online/).
    Make sure that you practice the functions described in this chapter by yourself
    and continue reading once you have an intuitive understanding on the concepts
    explained.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Vyper，现在应该能够使用在线编译器编写简单的合约了，该编译器位于：[https://vyper.online/](https://vyper.online/)。确保您自己练习本章中描述的函数，并在您对所解释的概念有直观的理解后继续阅读。
- en: In the next chapter, we're going to explore the Ethereum architecture in depth
    to understand how each component works at a fundamental level and the main driving
    forces behind blockchain technology.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨以太坊架构，以深刻理解每个组件在基本层面上的工作方式，以及区块链技术背后的主要推动力。
