- en: What are Decentralized Applications?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是去中心化应用程序？
- en: Since the beginning of internet, all internet-based applications that have been
    developed have been based on client-server architecture, where there is a centralized
    server that forms the backend of the application and controls the complete application.
    These applications often end up with issues such as having a single point of failure,
    failure to prevent net censorship, lack of transparency, users not trusting their
    data, activity and identity privacy, and so on. This centralized architecture
    even made it impossible to build certain kinds of applications. For example, you
    cannot build a digital currency using this architecture. Due to these issues,
    a new kind of architecture emerged called **Decentralized Applications** (**DApps**).
    In this chapter, we will learn about DApps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网诞生以来，所有开发的基于互联网的应用程序都基于客户端-服务器架构，其中有一个中心化的服务器构成应用程序的后端并控制整个应用程序。这些应用程序经常出现一系列问题，比如存在单一故障点，无法阻止网络审查，缺乏透明度，用户不相信他们的数据、活动和身份隐私等。这种中心化的架构甚至使构建某种应用程序成为不可能。例如，你不能使用这种架构构建数字货币。由于这些问题，出现了一种新的架构类型，称为**去中心化应用程序**（**DApps**）。在本章中，我们将学习关于DApps的知识。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are DApps?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DApps？
- en: What is the difference between decentralized, centralized, and distributed applications?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化、中心化和分布式应用程序之间有什么不同？
- en: What is a blockchain?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是区块链？
- en: What is the difference between public and permissioned DApps?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共DApps和权限DApps之间的区别是什么？
- en: Examples of some of the popular consortium DApps, and how they work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些流行的联合DApps的示例及其工作原理
- en: What are the various popular platforms on which to build enterprise DApps?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建企业DApps的各种流行平台是什么？
- en: What is a DApp?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是DApp？
- en: A DApp is a kind of application whose backend runs on a decentralized peer-to-peer
    network, and its source code is open source. No single node in the network has
    complete control of the DApp. Remember that, when we say that an application is
    decentralized we mean technically it's decentralized but the governance can be
    distributed, decentralized, or centralized.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DApp是一种其后端运行在去中心化对等网络上，并且其源代码是开源的应用程序。网络中没有一个单一的节点完全控制DApp。记住，当我们说一个应用程序是去中心化的，我们指的是技术上是去中心化的，但治理可以是分布式的、去中心化的或中心化的。
- en: 'The major advantages of DApps are that they don''t have a single point of failure,
    and prevent censorship. DApps do have some disadvantages: it''s difficult to fix
    bugs or add features once deployed as everyone in the network has to update their
    node software, and it''s very complicated to couple different DApps together as
    they are very difficult to build compared to centralized applications and involve
    very complex protocols.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用程序（DApps）的主要优势在于它们没有单一的故障点，并且可以防止审查。 DApps确实有一些缺点：一旦部署，很难修复错误或添加功能，因为网络中的每个人都必须更新他们的节点软件，而且将不同的DApps耦合在一起非常复杂，因为与集中式应用程序相比，它们很难构建，并涉及非常复杂的协议。
- en: To be able to use a DApp, you first need the DApp's node server running so that
    you can connect to the peer-to-peer network. Then, you need a client respective
    to the DApp that connects to the node server and exposes a UI or command line
    interface to use the DApp.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用DApp，您首先需要运行DApp的节点服务器，以便您可以连接到对等网络。然后，您需要一个与DApp对应的客户端，该客户端连接到节点服务器并公开用于使用DApp的UI或命令行界面。
- en: Currently, DApps are not yet as mature as centralized applications in terms
    of performance and scalability. There is still a lot of research and development
    on these topics such as performance, scalability, users identity, privacy, communication
    between DApps, data redundancy, and so on. A use case may fit into a DApp, but
    whether the use case can be made production-ready with the currently available
    technology can be a challenge. Popular examples of decentralized applications
    are Torrent, Bitcoin, Ethereum, Quorum, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，DApps在性能和可扩展性方面还没有像集中式应用程序那样成熟。在这些主题上仍然存在大量研究和开发，如性能、可扩展性、用户身份、隐私、DApp之间的通信、数据冗余等。一个用例可能适用于DApp，但基于当前可用技术使用例可以投入生产可能是一个挑战。去中心化应用程序的流行示例包括Torrent，Bitcoin，Ethereum，Quorum等。
- en: A DApp can be public or permissioned. Public DApps are those which anyone can
    be part of, in other words, they are permissionless, whereas permissioned DApps
    are those which are not open for everyone to join, so you will need permission
    to join. A permissioned DApp is called a **consortium DApp** when the participants
    of the DApp are enterprises and/or government entities. Similarly, when the participants
    of a permissioned DApp are only enterprises, then we can call it an enterprise
    DApp. In this book we will learn everything about permissioned DApps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 DApp 可以是公开的或许可的。公开的 DApp 是任何人都可以参与的，换句话说，它们是无需许可的，而许可的 DApp 是不是每个人都能加入的，所以你需要许可才能加入。当
    DApp 的参与者是企业和/或政府实体时，许可的 DApp 被称为**联盟 DApp**。同样地，当许可的 DApp 的参与者只是企业时，我们可以称之为企业
    DApp。在这本书中，我们将学习关于许可的 DApp 的一切。
- en: As you just got a basic introduction to what decentralized applications are,
    you must be wondering what the difference between decentralized and distributed
    applications is. Well, an application is said to be distributed when it's spread
    across multiple servers. Decentralized applications are by default distributed,
    whereas centralized applications may or may not be distributed. Centralized applications
    are usually distributed across multiple servers to prevent downtime, and also
    to handle huge data and traffic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚对分布式应用有了基本介绍，你一定想知道分布式应用和去中心化应用的区别是什么。好吧，当一个应用分布在多个服务器上时，就说这个应用是分布式的。去中心化应用默认情况下是分布式的，而中心化应用可能是分布式的也可能不是。中心化应用通常分布在多个服务器上，以防止停机，并处理大量数据和流量。
- en: What is a blockchain?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是区块链？
- en: Before we get into what a is, we need to understand what a ledger is. A ledger
    in computer science is software that stores transactions. A database is different
    from a ledger such that in a database we can add, remove, and modify records,
    whereas in a ledger we can only append but not delete or modify.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论什么之前，我们需要理解什么是账本。在计算机科学中，账本是存储交易的软件。数据库与账本不同，因为在数据库中我们可以添加、删除和修改记录，而在账本中我们只能追加而不能删除或修改。
- en: A blockchain is basically a data structure to implement a decentralized ledger.
    A blockchain is a chain of blocks connected to each other. Every block contains
    a list of transactions and certain other metadata, such as when it was created,
    which is it's previous block, the block number, who is the creator of the block,
    and so on. Every block maintains a hash of the previous block, therefore creating
    a chain of blocks linked with each other. Every node in the network should hold
    the complete copy of the blockchain and, when a new node comes in, it will request
    and download the blockchain from other nodes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链基本上是一个实现去中心化账本的数据结构。区块链是相互连接的块链。每个块包含一系列交易和某些其他元数据，比如它是何时创建的，它的前一个块是什么，块号是多少，谁是块的创建者等等。每个块都维护前一个块的哈希值，因此创建了相互链接的块链。网络中的每个节点都应该保存完整的区块链副本，当一个新节点加入时，它将从其他节点请求并下载区块链。
- en: Technologies such as blockchains are called **Distributed Ledger Technology**
    (**DLT**). A DLT is the process of replicating, sharing, and synchronizing digital
    transactions geographically stretched across numerous sites, countries, and/or
    institutions. You can think of a blockchain as a type of DLT. Also, not every
    DLT system has to be decentralized. In this book, we only learn to build decentralized
    blockchain-based applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像区块链这样的技术被称为**分布式账本技术**（**DLT**）。DLT 是在许多地点、国家和/或机构之间复制、共享和同步数字交易的过程。你可以将区块链看作是一种
    DLT。此外，并不是每个 DLT 系统都必须是去中心化的。在这本书中，我们只学习构建基于区块链的去中心化应用。
- en: The major advantages of using a blockchain is that it enables the facilitation
    of transactions without a central trusted party; data is secured using cryptography,
    and data is immutable, as blockchain removes friction and reduces risk so settlements
    happen in real time, and so on. Basically, it automates auditing, makes the application
    transparent, and provides a single source of truth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区块链的主要优势是它使交易无需中央信任方进行 facilitation；数据使用密码学进行安全保护，并且数据是不可变的，因为区块链消除了摩擦并降低了风险，因此结算实时发生，等等。基本上，它自动化了审计，使应用程序透明化，并提供了唯一的真相来源。
- en: In the real world, private blockchains are used in trade finance, cross-border
    payments, digital identity, the clearing and settlement of tokenized and digital
    assets, provenance of ownership of a product, record keeping for critical data,
    signing contracts, multi-party aggregation (namely, they can be used as a shared
    master repository for common industry information, allowing members to query for
    data), payment-versus-payment or payment-versus-delivery, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Every blockchain node maintains a database that contains the blockchain's state.
    The state contains the final result of running all the transactions in the blockchain.
    For example, in a blockchain, the state represents the final balances of all addresses.
    So when you query the blockchain node for an addresses balance, it doesn't have
    to go through all transactions and calculate the final balance of the address;
    instead, it directly fetches the balance from the state of the blockchain. Bitcoin
    uses LevelDB to maintain the state of the blockchain. Even if the database gets
    corrupted, the database can be restored by simply running all the transactions
    in the blockchain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Byzantine Fault Tolerance
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Byzantine Fault Tolerance** (**BFT**) is a characteristic of a decentralized
    system that indicates that it can tolerate Byzantine failures. A crash failure
    is when nodes just stopping to do anything (no messages at all) and Byzantine
    failure is when nodes just don''t do anything or exhibit arbitrary behavior. Basically,
    Byzantine failures include crash failures.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In any decentralized computing environment where a blockchain data structure
    is used, there is a risk that one or more rogue or unreliable actors could be
    a reason for the environment to disband. A server cluster will not work well if
    a few servers within it lose out on passing data to other servers in a consistent
    manner. In order to be reliable, the decentralized computing environment has to
    be designed in a way that it has solutions to these kinds of Byzantine failures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: On blockchain-based decentralised applications, there is, by definition, no
    central authority, so a special kind of protocol called the **consensus protocol** is
    used to achieve BFT.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, you must be wondering how to ensure that everyone has the same
    copy of the blockchain, and how to know which blockchain is correct when two nodes
    publish different blockchains? Also, how do you decide who creates the blocks,
    as there is nothing such as a master node in decentralized architecture? Well,  consensus
    protocols provide an answer to these questions. A few examples of consensus protocols
    are **Proof-of-Work** (**PoW**), **Proof-of-Stake** (**PoS**), **Proof-of-Authority**
    (**PoA**), PBFT, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: A consensus protocol is designed specially for permissioned or public blockchains.
    A consensus protocol made for a public blockchain is likely to create security
    and performance issues when implemented in a permissioned blockchain. Every consensus
    protocol has different performance and scalability vectors. You have to be alert
    while selecting a consensus protocol for your blockchain-based DApp.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Consensus protocols such as Raft and Paxos are not BFT; rather, they make the
    system only crash-tolerant. So, you should also consider this when choosing a
    consensus protocol.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: You might have come across the term PoA. PoA is a categorisation of consensus
    protocols in which there is a set of authorities—nodes that are explicitly allowed
    to create new blocks and secure the blockchain. Ripple's iterative process, PBFT,
    Clique, Aura, and so on, are examples of PoA-based consensus protocols.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Representation of user accounts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In blockchain-based applications, user accounts are identified and authenticated using
    asymmetric key pairs. The private key is used to sign transactions on behalf of
    the user. Username and password-based accounts systems will not work in blockchain
    as it cannot be used to prove which user has sent a transaction. The demerits
    in using private-public key pair include that they are not user-friendly and if
    you lose the private key then there is no way to recover it. So, it adds a new
    responsibility for the users to secure their private key. The address of a user
    account acts as the account identifier on blockchain. The address of a user account
    is derived from the public key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: What are UTXOs?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some blockchain applications use the UTXO model for transactions. Blockchain
    applications such as Bitcoin and MultiChain use this model. Even DLTs such as
    R3 Corda also use this model. Let's understand this model by understanding how
    Bitcoin transactions work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bitcoin, a transactions is a collection of zero or more and outputs. These
    input and output objects are called **Unspent Transaction Outputs** (**UTXO**).
    Outputs of transactions are used as inputs of future transactions. A UTXO can
    be used as input only once. Each UTXO in Bitcoin contains a denomination and an
    owner (a Bitcoin address). In this model, the balances of addresses in the unconsumed
    UTXOs are stored. For a transaction to be valid, these requirements should be
    met:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The transaction must contain a valid signature for the owner of each UTXO that
    it consumes
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total denomination of the UTXOs consumed must be equal to or greater than
    the total denomination of the UTXOs that it produces
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user's balance is computed as the total sum of the denominations of UTXOs
    that they own. A transaction can consume zero or more UTXOs and produce zero or
    more UTXOs. For a miner to pay reward to itself, it includes a transaction in
    the block that consumes zero UTXOs but produces one UTXO with the denomination
    assigned the amount of Bitcoin it is supposed to award itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: A UTXO transaction model is suitable when blockchain transactions involve the transfer
    of asset, but for non-assets transfer transactions such as recording facts, invoking
    smart contracts, and so on, this model it not suitable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当区块链交易涉及资产转移时，UTXO事务模型是合适的，但对于无资产转移交易（如记录事实、调用智能合约等），这种模型就不合适了。
- en: Popular permissioned blockchain platforms
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的许可制区块链平台
- en: Now we have a basic idea about what a DApp, blockchain, and DLT is, let's have
    an overview of what platforms are available to build a permissioned blockchain
    applications and DApps. We will only go through the ones that are popular on the
    market, and for which there is a demand.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经基本了解了什么是DApp、区块链和DLT，让我们来概述一下可用于构建许可制区块链应用程序和DApp的平台。我们只会介绍市场上流行的、有需求的平台。
- en: Ethereum
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以太坊
- en: Ethereum is the most popular DApp after Bitcoin. Ethereum is a decentralized
    platform that allows us to build other blockchain-based DApps on top of it. In
    Ethereum, we build DApps using Ethereum smart contracts. Smart contracts are applications
    that run exactly as programmed without any possibility of downtime, censorship,
    fraud, or third-party interference. Ethereum can be thought of as a platform to
    deploy and run smart contracts. Ethereum supports two consensus protocols, PoW
    and PoA (Clique).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是继比特币之后最受欢迎的DApp。以太坊是一个分散的平台，允许我们在其上构建其他基于区块链的DApp。在以太坊中，我们使用以太坊智能合约来构建DApp。智能合约是一种完全按程序运行的应用程序，没有任何停机时间、审查、欺诈或第三方干预的可能性。以太坊可以看作是一个部署和运行智能合约的平台。以太坊支持两种共识协议，即PoW和PoA（Clique）。
- en: The main public Ethereum network uses PoW for consensus. If you want to deploy
    your own private Ethereum network, then you have to use PoA. PoW requires a lot
    of computation power to keep the blockchain secure, therefore it's good for public
    blockchain use, whereas PoA doesn't have any such computation power requirement;
    instead it requires a few authority nodes in the network to achieve consensus.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的以太坊公共网络使用PoW进行共识。如果您想部署自己的私有以太坊网络，那么您必须使用PoA。PoW需要大量的计算能力来保护区块链的安全，因此适用于公共区块链使用，而PoA则没有任何这样的计算能力要求；相反，它需要网络中的少数权威节点来达成共识。
- en: You must be wondering why we need smart contracts to build DApps. Why cannot
    we simply put formatted messages on blockchain in the form of transactions and
    interpret them on client? Well, using smart contracts gives you both technical
    and business benefits.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定在想为什么我们需要智能合约来构建DApp。为什么不能简单地在区块链上放置格式化消息，以交易的形式在客户端上解释它们呢？好吧，使用智能合约可以为你带来技术和商业上的双重利益。
- en: Quorum
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quorum
- en: Quorum is a decentralized platform that allows us to build permissioned blockchain-based
    DApps on top of it. Actually, Quorum is a fork of Ethereum (actually Quorum is
    a fork of Go Ethereum, which is an implementation of Ethereum using Golang), therefore
    if you have ever worked on Ethereum then you will find it easy to learn and build
    permissioned blockchains using Quorum. Many enterprises select Quorum for building
    blockchains because of Ethereum's large community, which makes it easy to find
    Ethereum developers. What makes Quorum different from Ethereum is that it supports
    privacy (it lets parties do transactions privately); peer whitelisting, so you
    can mention a list of other nodes that are allowed to connect to your node (in
    Ethereum this needs to be done at network level); many different flavors of consensus
    protocols suitable for permissioned blockchain, and provides very high performance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Quorum是一个分散的平台，允许我们在其上构建基于许可制区块链的DApp。实际上，Quorum是以太坊的一个分叉（实际上Quorum是以太坊的一个分叉，使用Golang实现的以太坊的一个实现），因此如果你曾经在以太坊上工作过，那么你将会发现学习并使用Quorum来构建许可制区块链是很容易的。许多企业选择Quorum来构建区块链，因为以太坊拥有庞大的社区，这使得找到以太坊开发人员变得容易。Quorum与以太坊的不同之处在于，它支持隐私（让各方可以私下进行交易）、对等节点白名单，因此可以指定允许连接到您的节点的其他节点列表（在以太坊中，这需要在网络级别完成），适用于许可制区块链的许多不同类型的共识协议，并提供非常高的性能。
- en: Quorum currently supports three consensus protocols, QuorumChain, IBFT, and
    Raft. We will skip QuorumChain in this book, as Raft and IBFT fulfil all our requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Quorum目前支持三种共识协议，QuorumChain、IBFT和Raft。在本书中，我们将跳过QuorumChain，因为Raft和IBFT满足了我们的所有需求。
- en: Microsoft Azure provides BaaS to easily build your own Quorum network on the
    Cloud. But, in this book, we will learn how to install it manually, and we won't
    be using BaaS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure提供了BaaS，可以在云上轻松构建自己的Quorum网络。但是，在本书中，我们将学习如何手动安装，并不会使用BaaS。
- en: Parity
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇偶校验
- en: Popular node software for Ethereum include Go Ethereum, Ethereum C++, and Parity.
    Parity also supports two other consensus protocols, other than Ethereum's PoW,
    which are specifically designed for permissioned blockchains. These consensus
    protocols are Aura and Tendermint. Many Ethereum developers use parity compared
    to Quorum when they don't need the extra features provided by Quorum.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的流行节点软件包括 Go Ethereum、以太坊 C++ 和 Parity。Parity 还支持两种与以太坊的 PoW 不同的共识协议，专为权限区块链设计。这些共识协议是
    Aura 和 Tendermint。许多以太坊开发者在不需要 Quorum 提供的额外功能时，会使用 Parity 而不是 Quorum。
- en: As parity doesn't provide any unique features compared to Quorum, we will be
    skipping parity in this book. But, once you finish this book, you will find it
    really easy to grasp parity's concepts and will be able to build something using
    it too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Parity 与 Quorum 没有提供任何独特的功能，所以我们将在本书中跳过 Parity。但是，一旦你完成了这本书，你会发现很容易掌握 Parity
    的概念，并且也能够利用它构建一些东西。
- en: MultiChain
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultiChain
- en: MultiChain is a platform to build permissioned blockchain-based DApps. Unique
    features of MultiChain include permissions management, data streams, and assets.
    It doesn't support smart contracts. This is an example of a non-smart contract-based
    platform for building blockchain-based DApps. MultiChain uses round robin validation
    consensus.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MultiChain 是一个构建基于权限的区块链 DApps 的平台。MultiChain 的独特功能包括权限管理、数据流和资产。它不支持智能合约。这是一个构建基于区块链的
    DApps 的非智能合约平台的例子。MultiChain 使用循环验证共识。
- en: Initially MultiChain was based on the idea of managing ownership and transfer
    of assets on blockchain. Operations on assets includes issuance, reissuance, transfer,
    atomic exchange, escrow, and destruction of assets. Later on, data streams were
    introduced to provide a different flavor of representing data in MultiChain. Any
    number of streams can be created in a MultiChain, and each stream acts as an independent
    append-only collection of items. Operations on streams include creating streams,
    writing, subscribing, indexing, and retrieving. So, basically, a blockchain use
    case on MultiChain can be built on a foundation of assets or streams. Finally,
    permission management is used to control who can connect, transact, create assets/streams,
    mine/validate, and administrate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，MultiChain 的理念是在区块链上管理资产的所有权和转移。对资产的操作包括发行、再发行、转移、原子交换、托管和销毁。后来，数据流被引入以提供在
    MultiChain 中表示数据的不同方式。在 MultiChain 中可以创建任意数量的流，每个流都是独立的追加集合。关于流的操作包括创建流、写入、订阅、索引和检索。因此，基本上，MultiChain
    上的区块链用例可以建立在资产或流的基础上。最后，权限管理用于控制谁能连接、交易、创建资产/流、挖掘/验证和管理。
- en: MultiChain provides maximal compatibility with the Bitcoin ecosystem, including
    the peer-to-peer protocol, transaction/block formats, the UTXO model, and Bitcoin
    Core APIs/runtime parameters. So, before you start learning MultiChain, it's better
    to learn how Bitcoin works at a high level at least.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MultiChain 提供与比特币生态系统最大的兼容性，包括点对点协议、交易/区块格式、UTXO 模型和比特币核心 API/运行时参数。因此，在开始学习
    MultiChain 之前，最好至少了解比特币的工作原理。
- en: Hyperledger Fabric 1.0
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 1.0
- en: Before we get into what Hyperledger Fabric 1.0 is, we need to understand what
    Hyperledger is specifically. Hyperledger is an umbrella project of open source
    blockchains and related tools, started in December 2015 by the Linux Foundation. At
    the time of writing this book, there are four projects under Hyperledger:Fabric,
    Sawtooth, Iroha, and Burrow.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 Hyperledger Fabric 1.0 之前，我们需要明确了解 Hyperledger 的概念。Hyperledger 是由 Linux
    基金会于 2015 年 12 月发起的一个开源区块链和相关工具的整体项目。在撰写本书时，Hyperledger 有四个项目：Fabric、Sawtooth、Iroha
    和 Burrow。
- en: Hyperledger Fabric is the most popular project under Hyperledger. IBM is the
    main contributer to the project. IBM's Bluemix also provides BaaS to build your
    own Fabric network on the Cloud easily.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 是 Hyperledger 下最受欢迎的项目。IBM 是该项目的主要贡献者。IBM 的 Bluemix 还提供了在云上构建自己的
    Fabric 网络的 BaaS 服务。
- en: Hyperledger Fabric 1.0 is a platform to build your own permissioned blockchain-based
    applications. Currently, at the time of writing this book, Hyperledger Fabric
    1.0 supports only distributed architecture, and for the creation of blocks it
    depends on a central trusted node called the **orderer**. It supports smart contracts,
    network permissioning, privacy, and other features. In HLF 1.0, there is a special
    kind of node called as **OSN**, which is hosted by a trusted party. This OSN creates
    blocks and distributes to peers in networks. As you trust this node, there is
    no need for consensus. HLD 1.0 currently supports CouchDB and LevelDB to store
    the state of the blockchain. Peers in the network store the state of the blockchain
    in the LevelDB database, by default.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 1.0 是一个构建自己的基于区块链的权限管理应用的平台。当前，在撰写本书时，Hyperledger Fabric
    1.0 仅支持分布式架构，并且对于区块的创建，它依赖于一个名为**orderer**的中心可信节点。它支持智能合约、网络许可、隐私和其他功能。在 HLF 1.0
    中，有一种特殊的节点称为**OSN**，由可信方托管。这个 OSN 创建区块并分发给网络中的对等方。由于信任这个节点，没有必要进行共识。HLF 1.0 目前支持CouchDB和LevelDB来存储区块链的状态。网络中的对等方默认在LevelDB数据库中存储区块链的状态。
- en: HLF 1.0 has a concept of channels to achieve privacy. A channel is a sub-blockchain
    in the network and allows certain parties to be part of a channel depending on
    configuration. Actually, every transaction has to belong to a channel and when
    the HLF 1.0 network is deployed, a default channel is created. OSN can see all
    the data in all the channels, therefore it should a trusted party. Technically,
    it's possible to configure the network to have multiple OSNs hosting different
    channels if you cannot trust a single party for all channels. Even if the traffic
    is going to be huge or OSN availability is critical, then you can plug Kafka into
    OSN for better performance and increased stability. We can even have multiple
    OSNs per channel connected via Kafka if high availability is required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HLF 1.0 通过频道的概念实现隐私。频道是网络中的子区块链，并且允许根据配置让某些参与方成为某个频道的一部分。实际上，每个交易都必须属于一个频道，当部署
    HLF 1.0 网络时，默认会创建一个默认频道。OSN 可以看到所有频道中的所有数据，因此它应该是一个可信的方。从技术上讲，如果你不能信任单个方处理所有频道，可以配置网络来拥有托管不同频道的多个OSN。即使流量庞大或者OSN的可用性至关重要，也可以将Kafka连接到OSN以获得更好的性能和更高的稳定性。如果需要高可用性，我们甚至可以每个频道连接多个经过Kafka连接的OSN。
- en: Fabric 1.0 has a feature called **transaction endorsement**, which provides
    a mechanism of taking approvals from certain parties before sending a transaction.
    When we say that a transaction has been endorsed by a member in the network, we
    mean that the member has verified the transaction. Every chaincode (smart contracts
    in HLF) has an endorsement policy defined to it at the time of deployment. The
    policy states which members has to endorse the transactions associated with this
    chaincode. The default policy states that any one member of the channel has to
    sign the transaction. But, we can define custom policies containing **AND** and
    **OR** operators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 1.0 有一个名为**交易背书**的特性，提供了在发送交易之前从特定方批准的机制。当我们说一个成员在网络中背书了一笔交易时，我们的意思是该成员已经验证了交易。HLF
    中的每个链码（智能合约）在部署时都有一个背书策略。该策略规定了哪些成员必须背书与该链码相关的交易。默认策略规定频道中的任一成员必须签署交易。但是，我们可以定义包含**AND**和**OR**运算符的自定义策略。
- en: Also, peers of the same channel broadcast blocks to each other regardless of
    the presence or absence of OSN, but in the absence of OSN new blocks cannot be
    created for the channel. Peers broadcast blocks using a special protocol called
    as **gossip data dissemination protocol**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，同一频道的对等方无论是否存在OSN，都会向彼此广播区块，但在缺乏OSN的情况下，无法为频道创建新的区块。对等方使用称为**gossip数据传播协议**的特殊协议广播区块。
- en: HLF 1.0 has very advanced membership features to control network membership,
    and that are also internal to a specific organization. In HLF 1.0, you can write
    chaincodes in Java or Go programming languages. In the future, Fabric 1.0 will
    come with the **Simple ****Byzantine Fault Tolerance** (**SBFT**) consensus protocol
    and some other features that will enable us to build DApps. Similarly, there are
    various new features that are under development and will be released in future
    as a sub-version of the product.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get started with building your first HLF 1.0 application is
    the check out examples at [https://github.com/hyperledger/fabric-samples](https://github.com/hyperledger/fabric-samples)
    and modify them according to your application needs. You can find HLF 1.0 detailed
    docs at [http://hyperledger-fabric.readthedocs.io/en/latest/.](http://hyperledger-fabric.readthedocs.io/en/latest/)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: BigchainDB
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BigchainDB is a decentralized database that uses blockchain. BigchainDB is highly
    scalable and customizable. It uses the Blockchain data structure. It supports
    features such as rich permissioning, petabytes capacity, advanced querying, linear
    scaling, and so on. At the time of writing this book, BigchainDB is not production-ready
    but can be used for building **Proof of Concepts** (**PoCs**). We will learn how
    it works, and will create a basic PoC using it, in later chapters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: InterPlanetary File System
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**InterPlanetary File System** (**IPFS**) is a decentralized filesystem. IPFS
    uses **Distributed Hash Table** (**DHT**) and Merkle **Direct Acyclic Graph** (**DAG**)
    data structures. It uses a protocol similar to Torrent to decide how to move the
    data around the network. One of the advanced features of IPFS is that it supports
    file versioning. To achieve file versioning, it uses data structures similar to
    Git.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Although it's called as a decentralized filesystem, it doesn't adhere to a major
    property of a filesystem, namely, when we store something in filesystem, it should
    be there until deleted. But, IPFS doesn't work this way. Each node doesn't store
    all files, instead it stores only those files it needs. Therefore, if a file is
    not popular, then many nodes will not have the file therefore there is a huge
    chance of the file disappearing in the network. Due to this, we can call IPFS
    a decentralised peer-to-peer file-sharing application. We will learn about about
    how it works in later chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Corda
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Corda is a platform on which to build your own permissioned DLT-based applications.
    Corda is a product of R3. R3 is an enterprise software firm working with over
    100 banks, financial institutions, regulators, trade associations, professional
    services firms, and technology companies to develop Corda. The latest version
    of Corda is 1.0, which aims to replace legacy softwares used for financial transactions,
    and enables organisations to digitalize various business process that were cumbersome
    using legacy software systems:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a207ce91-298e-4762-b1a5-86c1ddff84c0.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the high level architecture of a Corda network.
    Let's understand Corda's architecture at a high level. The idea of R3's Corda
    is to provide a shared trusted ledger for financial transactions. R3's Corda is
    not a blockchain platform, therefore there is no concept of blocks, global broadcasts,
    and so on. All the transactions are point to point. Corda applications are not
    decentralized. In Corda, smart contracts are called as **CorDapps** and they are
    written in either Java or Kotlin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure services form the nodes in the network that should be hosted
    by the trusted parties. Network Map publishes IP addresses of all the other nodes,
    so that nodes can reach out to other nodes. Permissioning service gives permission
    to nodes to join the network ; the node will receive a root-authority-signed TLS
    certificate from the network's permissioning service if permitted to join the
    network. Notaries provide transaction ordering and time stamping services (optionally,
    a notary also acts as the timestamping authority, verifying that a transaction
    occurred during a specific time-window before notarizing it). A notary service
    may be a single network node, a cluster of mutually-trusting nodes, or a cluster
    of mutually-distrusting nodes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Notaries are expected to be hosted by enterprises that the network doesn't trust,
    therefore consensus is required between the notaries, due to which Corda provides
    various pluggable consensus protocols, such as Raft, BFT, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, Corda applications need to depend on external application APIs. For
    example, a multi-currency bank-to-bank payment application built using Corda will
    need to fetch the exchange rate. In this scenario, the node initiating the transaction
    can fetch the exchange rate and put on the transaction, but how can you trust
    that node? Also, every node cannot simply re-fetch the exchange rate to verify
    if it's correct because by the time other nodes fetch it the rate might have changed,
    and also this is not a scalable solution. Therefore, Corda provides oracles to
    solve this issue. There can be one or more oracles in the network. An Oracle is
    a service that acts as a bridge for communication between two applications. In
    Corda, the transaction initiator can fetch the information from outside the Corda
    network and get the information signed from **Oraclize** to prove its validity.
    Optionally, Oraclize can also provide the information to the transaction initiator
    on request. Obviously, the Oraclize should be hosted by trusted parties with respect
    to what information they provide and sign.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Corda supports any pluggable RDBMS (currently, it is using the H2 database)
    to store smart contracts data. Data privacy is maintained as to which nodes can
    see the transactions. Multisignature support is also given by the framework, which
    enables multiple nodes to sign a transaction. One of the major downsides of Corda
    is that as there is no global broadcasting, each node has to maintain its own
    backup and failover redundancy in a traditional way as there is no redundancy
    built into the network. A node will store transactions and retry sending the messages
    to the recipient until the recipient has successfully received it. Once the messages
    are received, the sender has no more responsibility.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Corda支持任何可插拔的RDBMS（当前正在使用H2数据库）来存储智能合约数据。数据隐私由哪些节点可以看到交易来维护。框架还提供了多重签名支持，这使得多个节点可以签署交易。Corda的一个主要缺点是，由于没有全局广播，每个节点必须以传统方式维护自己的备份和故障转移冗余，因为网络中没有内置冗余。节点将存储交易并重试向接收者发送消息，直到接收者成功接收为止。一旦消息被接收，发送方就没有更多的责任。
- en: Transaction validity
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易的有效性
- en: As all transactions are not broadcasted to all parties in the network, to prevent
    a double spend (a double spend is an attack on DLTs to spend the same money twice,
    transfer the same asset twice and so on), we use notaries. Notaries contain all
    the unconsumed UTXOs, and after notarization they mark them as consumed and add
    the new unconsumed ones to their state. The transaction purposer gets the transaction
    notarized by a notary before sending to the other parties for commit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有交易都广播给网络中的所有参与方，为了防止双重支付（双重支付是一种攻击DLT，将相同的资金花费两次，转移相同的资产两次等），我们使用公证员。公证员包含所有未使用的UTXOs，在公证之后，他们将其标记为已使用，并将新的未使用的UTXOs加入其状态。在发送给其他参与方之前，交易发起者会请公证员对交易进行公证。
- en: 'A notary will only be able to sign a transaction if it has earlier signed input
    states of the transaction. But, this may not always be the case, therefore Corda
    also lets us change the state''s appointed notary. This situation can occur mostly
    due to the following reasons:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在公证员先前签署了交易的输入状态时，公证员才能签署交易。但是，这并不总是情况，因此Corda还让我们改变状态的指定公证员。这种情况通常是由于以下原因导致的：
- en: A transaction consuming states that have different appointed notaries
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗具有不同指定公证员的状态的交易
- en: A node wishes to use a different notary for achieving privacy or efficiency
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点希望使用不同的公证员以实现隐私或效率
- en: Before these transactions can be created, the states must first be repointed
    to all have the same notary. This is achieved using a special notary-change transaction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些交易可以创建之前，状态必须首先被重新指向以使所有状态具有相同的公证员。这是通过特殊的改变公证的交易来实现的。
- en: CorDapps are not like smart contracts of other platforms. They don't have a
    state. Their purpose is to just validate if the outputs produced from the inputs
    are correct. Every UTXO points to a CorDapp. CorDapps define the format of UTXOs.
    In a transaction, we can have UTXOs of multiple CorDapps, and in these cases each
    CorDapp will run only once and validate all the inputs and outputs belonging to
    it. For a transaction to be valid, it must be contractually valid; the CorDapp
    should approve it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CorDapps不像其他平台的智能合约那样有状态。它们的目的只是验证所产生的输出是否正确。每个UTXO指向一个CorDapp。CorDapps定义了UTXOs的格式。在一个交易中，我们可以有来自多个CorDapps的UTXOs，在这种情况下，每个CorDapp只运行一次，并验证属于它的所有输入和输出。要使交易有效，它必须在合约上有效；CorDapp应该批准它。
- en: Apart from inputs and outputs, transactions might consist of commands too, small
    data packets that the platform doesn't decipher itself but which help CorDapps
    to process the inputs and outputs. A command is a piece of data associated with
    some public keys. Commands are used to provide additional information to the CorDapps
    that it cannot get via the UTXOs. The platform assures that the transaction is
    signed by every key listed in the commands before the contracts start to execute.
    Thus, the CorDapp can trust that all listed keys have signed the transaction,
    but is responsible for verifying that the intended parties have signed it. Public
    keys may be random or identityless for privacy, or linked to a well-known legal
    identity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Oracles provide signed information to the transaction purposer in the form of
    commands that encapsulate a specific fact, and list the oracle as a required signer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Also, transactions can contain a hash of attachments. Attachments are ZIP/JAR
    files. Attachments are useful when there's a large fragment of data that can be
    reused across several different transactions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that while verifying a proposed transaction, the node may not
    have all the transactions of the transaction chain that it needs to verify. Therefore,
    Corda lets the node request the missing transactions from the proposer(s). It's
    always true that the transaction proposer will have all the transactions of the
    required transaction chain, as they would have requested it when verifying the
    transaction and created the purposed transaction's input states.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once the transaction is committed, you can query the Vault (which keeps
    track of both unconsumed and consumed states).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Corda and build your first Corda app, visit [https://docs.corda.net/](https://docs.corda.net/),
    which contains detailed documentation. There are several example apps that you
    can download and experiment with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Sawtooth
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sawtooth is a decentralized platform to build your own permissioned DApps. The
    main contributer to Sawtooth is Intel. What makes Sawtooth special is that it
    uses a **Trusted Execution Environment** (**TEE**) (it currently supports Intel's
    SGX only) for consensus, which makes the network very safe and trustworthy and
    increases trust in the final result of the consensus.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The TEE is a secure area of the main processor. It guarantees that the code
    and data loaded inside is protected with respect to confidentiality and integrity.
    The TEE as an isolated execution environment that provides security features such
    as isolated execution, integrity of Trusted Applications, along with confidentiality
    of their assets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of Elapsed Time** (**PoET**) is the name of the consensus protocol
    that Sawtooth uses. In PoET, there are special types of nodes called as validators.
    Validators must run their node on an SGX-supported CPU. This is how PoET works.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Every validator requests a wait time from an enclave (a trusted function). The
    validator with the shortest wait time for a particular transaction block is elected
    the leader. One function, say `CreateTimer`, creates a timer for a transaction
    block that is guaranteed to have been created by the enclave. Another function,
    say `CheckTimer`, verifies that the timer was created by the enclave and, if it
    has expired, creates an attestation that can be used to verify that the validator
    did, in fact, wait the allotted time before claiming the leadership role. PoET
    randomly distributes leadership election across the entire population of validators.
    The probability of election is proportional to the resources contributed (in this
    case, resources are general-purpose processors with a TEE). An attestation of
    execution provides information for verifying that the certificate was created
    within the enclave (and that the validator waited the allotted time). Further,
    the low cost of participation increases the likelihood that the population of
    validators will be large, increasing the robustness of the consensus algorithm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Sawtooth also supports smart contracts (specifically, Ethereum smart contracts
    can be executed on Sawtooth). Performance-wise, Sawtooth scales well in terms
    of large numbers of transactions and nodes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Popular blockchain use cases
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see some of the popular use cases for permissioned blockchains. It will
    help us to understand what enterprises can use permissioned blockchains for and
    what use cases are valid for permissioned blockchains.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Everledger
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everledger is a digital registry for diamonds powered by blockchain. It's an
    example of supply chain management on blockchain. Blockchain was used because,
    in blockchain, records are immutable. Everledger uses more than 40 features, including
    color and clarity, to create a diamond's ID. When this information is placed on
    blockchain, this information becomes a certificate chronicling the jewel's ownership,
    from mine to ring. Everledger has digitized more than a million diamonds and partnered
    with firms including Barclays. Participants in the blockchain network, such as
    merchants, banks, and insurers, can verify if a diamond is legitimate. Everledger
    is built on the Hyperledger Fabric platform. In the future, they are also planning
    to add other precious goods to their blockchain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example scenerio and see how blockchain helps in this use case. Alice
    purchases a diamond, insures it, and registers it on the Everledger blockchain. Next,
    she loses the diamond and reports it as stolen. The insurance company then compensates
    her for the loss. Finally, Bob the thief attempts to sell the stolen diamond to
    Eve the jeweller. She requests verification from Everledger and finds out that
    it's a stolen diamond. The insurance company is notified about the stolen diamond
    and they take possession of it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Walmart's food tracking
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walmart's food tracking use case is a combination of blockchain and IoT to make
    a food product's history transparent and traceable to it's origin. It's an example
    of supply chain management on blockchain. Walmart's food tracking supply chain
    management is built on top of the Hyperledger Fabric platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 沃尔玛的食品追踪用例是区块链和物联网的结合，使食品产品的历史透明化和可追溯到其来源。这是区块链上的供应链管理示例。沃尔玛的食品追踪供应链管理建立在Hyperledger
    Fabric平台之上。
- en: A lot of people die every year due to food poisoning. As soon as someone falls
    sick or dies due to food poisoning the authorities try to track the source of
    the food and make sure that all the food items from the source that are distributed
    is suspended from selling and is called back. This saves lives of a lot of people.
    But the issue is that as every participation in the supply chain have their own
    ways and processes storing and retrieving information therefore it takes weeks
    for the authorities to track the source prevent everyone in the chain from selling
    the food items. Blockchain in combination with the IoT might just be able to solve
    this problem.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每年有很多人死于食物中毒。一旦有人因食物中毒而生病或死亡，当局会试图追踪食物的来源，并确保源自该地的所有食品暂停销售并召回。这拯救了很多人的生命。但问题在于，由于供应链中的每个参与方都有自己的存储和检索信息的方式和过程，因此当局需要数周的时间来追踪来源，并阻止链中的每个人销售食品。区块链结合物联网也许能够解决这个问题。
- en: 'With every party in the supply chain storing and retrieving information, blockchain
    can fasten the process of finding the source of a food item. The following list
    shows additional benefits blockchain can add:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着供应链中的每个参与方都存储和检索信息，区块链可以加快查找食品来源的过程。以下是区块链可以添加的额外好处列表：
- en: Consumers can see exactly where a food product was harvested.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者可以准确地了解食品产品的收获地点。
- en: Due to panic over food poisoning, people tend to throw away clean food, which
    increases the amount of food wasted. Blockchain can pinpoint the tainted food,
    therefore preventing food waste.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于对食物中毒的恐慌，人们倾向于扔掉干净的食物，这增加了食物浪费的数量。区块链可以准确定位有问题的食物，从而防止食物浪费。
- en: Each step in the supply chain is visible to everybody. Fraudulent food entering
    the market can be avoided.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应链中的每个步骤对所有人都是可见的。可以避免欺诈性食品进入市场。
- en: Blockchain can act as evidence that a tainted food items was shipped from a
    particular producer. Due to this, producers will take care and adhere to safe
    practices because, if they don't, they will be caught with the evidence.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链可以作为证据证明某个有问题的食品是从特定生产者那里运出的。由于这个原因，生产者会小心并遵守安全操作规程，因为如果他们不这样做，就会被证据抓住。
- en: Finally every food item gets a story associated with it. This enables users
    to learn about the food item's history.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，每个食品都有一个与之相关的故事。这使用户能够了解食品的历史。
- en: IoT technology, such as sensors and RFID tags, enables real-time data to be
    written on the blockchain as food products pass along the supply chain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网技术，如传感器和射频识别标签，使食品产品沿着供应链传递时可以实时写入区块链的数据。
- en: Let's see an example of what the blockchain records in this case, and who the
    participants are. The participants are farms from where the food originates, factories
    where they are packed and processed, cargo companies who ship the food, Walmart
    stores, and so on. The data recorded on the blockchain is farm origin data, the
    batch number, factory and processing data, expiration dates, storage temperatures,
    and shipping details.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解在这种情况下区块链记录了什么，以及参与者是谁。参与者包括食物的原产地农场、打包加工厂、运输食物的货运公司、沃尔玛商店等等。记录在区块链上的数据包括农场原产地数据、批号、工厂和加工数据、过期日期、储存温度和运输细节。
- en: Ghana's land registry
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加纳的土地登记
- en: BenBen is a team of research and development engineers dedicated to building
    innovative products to improve government technology in Ghana. They developed
    a digital land registry solution using blockchain for Ghana citizens.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: BenBen 是一支致力于为加纳建设创新产品以改善政府技术的研发工程师团队。他们利用区块链为加纳公民开发了数字土地登记解决方案。
- en: In Ghana, banks don't accept land as a collateral when giving loans. That's
    because in Ghana, a paper registry system is unenforceable in court. This is preventing
    millions of people from getting loans.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在加纳，银行在发放贷款时不接受土地作为抵押品。这是因为在加纳，纸质登记系统在法庭上不可执行。这导致数百万人无法获得贷款。
- en: BenBen provides a top-of-stack land registry and verification platform for financial
    institutions. This platform captures transactions and verifies the data. BenBen
    works with financial institutions to update current registries, enable smart transactions,
    and distribute private keys for clients, to allow automated and trusted property
    transactions between all parties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Dubai's housing rental
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dubai's housing rental use case is a blockchain application that let's individual
    expats lease an apartment or renew their housing tenancy contract online within
    minutes. In Dubai, if an individual wants to take an apartment for rent, then
    they have to provide KYC documents, cheques as a contract-term guarantee, and
    create an Ejari (a government contract to legalize the otherwise unpleasant relationship
    between landlords and tenants in Dubai). In Dubai, most real estate companies
    rent apartments only if you want to stay for a longer period of time (for instance,
    at least a year) and to make sure you obey the contract, they ask you to provide
    postdated cheques as a guarantee, as in Dubai, a cheque bounce is considered a
    criminal offence. As the process of renting an apartment and renewing the tenancy
    contract is a cumbersome process for both tenants and real estate companies, **Dubai
    Smart Government** (**DSG**) (a technology arm of Smart Dubai, a city-wide initiative
    to transform Dubai technologically) launched a mission to make this whole process
    easier and quicker using blockchain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This housing rental application was built using Hyperledger Fabric 1.0, and
    initially seven entities participated in the network. DSG, **General Directorate
    of Residency and Foreigners Affairs Dubai** (**DNRD**), wasl, **Dubai Land Department**, The
    **Dubai Electricity and Water Authority** (**DEWA**), Emirates **National Bank
    of Dubai** (**NBD**), and **Emirates Islamic** (**EI**) bank were the entities
    who shared their data on blockchain to make the tenancy contract creation and
    renewing easier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, DSG and the **Emirates Identity Authority** (**EIDA**) launched DubaiID,
    which allowed Dubai residents a unified access to all eServices provided by government
    agencies through one login, and interaction with them via the internet. In this
    blockchain use case, the tenant had to log in to the real estate's portal using
    DubaiID; in this case, wasl's tenant must have a DubaiID to login. Once logged
    in, SDG will write the Emirates ID number into blockchain, and DNRD shares visa
    and passport information on the blockchain for that tenant. Then, wasl's portal
    redirects users to submit digital cheques using an Emirates NBD or EI bank account.
    Once digital cheques are submitted, a request is made to DLD via blockchain to
    renew or create an Ejari. Finally, once Ejari processing is done, DEWA is notified
    to activate the water and electricity supply. So basically, the first pilot was
    for individuals who wanted to lease or renew a wasl apartment and had a bank account
    with Emirates NBD or EI. Soon, more banks and real estate companies will be added
    to the network to provide this service for more people in Dubai. In this process,
    it was ensured that a piece of information can only be seen by the concerned parties.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This use case fits in well as a blockchain use case because a signed immutable
    ledger was required to store KYC, cheques, and Ejaris and the latter can be proved
    if the customer or any entity tries to commit fraud. For example, when Emirates
    NBD issues cheques, if they do it without blockchain and simply make point-to-point
    API calls, then there is a very good possibility of intentional and unintentional
    disagreement between ENBD, the tenant, and wasl regarding the existence of a digital
    cheque or its current status. Therefore, blockchain can be the final tool for
    reference if any dispute occurs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Project Ubin
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Project Ubin** is a digital cash-on-ledger project run in partnership between
    **Monetary Authority of Singapore** (**MAS**) and R3, with the participation of
    **Bank of America** (**BOA**) **Merrill Lynch**, **Credit Suisse**, DBS bank,
    **The Hongkong and Shanghai Banking Corporation Limited**, J.P. Morgan, **Mitsubishi
    UFJ Financial Groupb** (**MUFG**), OCBC bank, **Singapore Exchange** (**SGX**),
    and **United Overseas Bank** (**UOB**), as well as **BCS Information Systems**
    as a technology provider.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The aim of Project Ubin is building a digitalized form of the SGD (Singapore's
    national currency) on a distributed ledger to bring many benefits to Singapore's
    financial ecosystem. The benefits would be the same as that of any other cryptocurrencies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Currently, this application is built using Quorum, but in future it may move
    to Corda as R3 is one of the partners.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: MAS is Singapore's central bank and financial regulatory authority. MAS acts
    as a settlement agent, operator, and overseer of payment, clearing, and settlement
    systems in Singapore that focus on safety and efficiency.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what DApps are and got an overview of blockchain-based
    DApps. We saw what a blockchain is, what its benefits are, and saw various platforms
    that we can use to build our own blockchain-based DApps. Finally, we saw some
    use cases and how blockchain can bring change to the financial and non-financial
    industry. In the next chapter, we will get into Ethereum and Quorum, and build
    a basic example DApp.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是 DApps，并对基于区块链的 DApps 进行了概述。我们了解了区块链是什么，它的好处是什么，并看到了我们可以使用的各种平台来构建基于区块链的
    DApps。最后，我们看到了一些用例以及区块链如何为金融和非金融行业带来改变。在下一章中，我们将深入了解以太坊和 Quorum，并构建一个基本的示例 DApp。
