- en: Getting Started with web3.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 web3.js
- en: In this chapter, we will learn web3.js and how to import, connect to geth, and
    use it in Node.js or client-side JavaScript. We will also learn how to build a
    web client using web3.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 web3.js 以及如何在 Node.js 或客户端 JavaScript 中导入、连接到 geth 并使用它。我们还将学习如何使用
    web3.js 构建 web 客户端。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importing web3.js in Node.js and client-side JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 和客户端 JavaScript 中导入 web3.js
- en: Connecting to geth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 geth
- en: Exploring the various things that can be done using web3.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用 web3.js 可以完成的各种事务
- en: Discovering various most used APIs of web3.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 web3.js 的各种最常用的 API
- en: Building a Node.js application for an ownership contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有权合同构建一个 Node.js 应用程序
- en: Introduction to web3.js
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: web3.js 介绍
- en: web3.js provides us with JavaScript APIs to communicate with geth. It uses JSON-RPC
    internally to communicate with geth. web3.js can also communicate with any other
    kind of Ethereum node that supports JSON-RPC. It exposes all JSON-RPC APIs as
    JavaScript APIs; that is, it doesn't just support all the Ethereum-related APIs;
    it also supports APIs related to Whisper and Swarm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 为我们提供了 JavaScript API，用于与 geth 通信。它在内部使用 JSON-RPC 与 geth 通信。web3.js
    还可以与支持 JSON-RPC 的任何其他类型的以太坊节点通信。它将所有 JSON-RPC API 公开为 JavaScript API；也就是说，它不仅支持所有与以太坊相关的
    API；还支持与 Whisper 和 Swarm 相关的 API。
- en: You will learn more and more about web3.js as we build various projects, but
    for now, let's go through some of the most used APIs of web3.js and then we will
    build a frontend for our ownership smart contract using web3.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建各种项目，您将越来越了解 web3.js，但现在让我们先了解一下 web3.js 的一些最常用的 API，然后我们将使用 web3.js 为我们的所有权智能合同构建前端。
- en: At the time of writing this, the latest version of web3.js is 0.16.0\. We will
    learn everything with respect to this version.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，web3.js 的最新版本是 0.16.0。我们将针对该版本学习所有内容。
- en: web3.js is hosted at [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js) 
    and the complete documentation is hosted at [https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 托管在 [https://github.com/ethereum/web3.js](https://github.com/ethereum/web3.js)，完整的文档托管在
    [https://github.com/ethereum/wiki/wiki/JavaScript-API](https://github.com/ethereum/wiki/wiki/JavaScript-API)。
- en: Importing web3.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入 web3.js
- en: To use web3.js in Node.js, you can simply run `npm install web3` inside your
    project directory, and in the source code, you can import it using `require("web3");`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 中使用 web3.js，只需在项目目录中运行 `npm install web3`，然后在源代码中，可以使用 `require("web3");`
    进行导入。
- en: To use web3.js in client-side JavaScript, you can enqueue the `web3.js` file,
    which can be found inside the `dist` directory of the project source code. Now
    you will have the `Web3` object available globally.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端 JavaScript 中使用 web3.js，可以将 `web3.js` 文件加入队列，该文件可以在项目源代码的 `dist` 目录中找到。现在你将全局可用的
    `Web3` 对象。
- en: Connecting to nodes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接节点
- en: web3.js can communicate with nodes using HTTP or IPC. We will use HTTP to set
    up communication with nodes. web3.js allows us to establish connections with multiple
    nodes. An instance of `web3` represents a connection with a node. The instance
    exposes the APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 可以使用 HTTP 或 IPC 与节点通信。我们将使用 HTTP 建立与节点的通信。web3.js 允许我们与多个节点建立连接。`web3`
    的一个实例表示与一个节点的连接。该实例公开了 API。
- en: When an app is running inside Mist, it automatically makes an instance of `web3`
    available that's connected to the mist node. The variable name of the instance
    is `web3`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在 Mist 中运行时，它会自动使一个名为 `web3` 的实例可用，该实例连接到 mist 节点。实例的变量名是 `web3`。
- en: 'Here is the basic code to connect to a node:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接到节点的基本代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At first, we check here whether the code is running inside mist by checking
    whether `web3` is `undefined` or not. If `web3` is defined, then we use the already
    available instance; otherwise, we create an instance by connecting to our custom
    node. If you want to connect to the custom node regardless of whether the app
    is running inside mist or not, then remove the `if` condition form the preceding
    code. Here, we are assuming that our custom node is running locally on port number
    `8545`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在此处我们通过检查 `web3` 是否 `undefined` 来检查代码是否在 mist 中运行。如果 `web3` 已定义，则使用已有的实例；否则，通过连接到我们的自定义节点创建一个实例。如果要连接到自定义节点，而不管应用程序是否在
    mist 中运行，请从上述代码中删除 `if` 条件。在这里，我们假设我们的自定义节点在本地运行，端口号为 `8545`。
- en: The `Web3.providers` object exposes constructors (called providers in this context)
    to establish connection and transfer messages using various protocols. `Web3.providers.HttpProvider`
    lets us establish an HTTP connection, whereas `Web3.providers.IpcProvider` lets
    us establish an IPC connection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Web3.providers` 对象暴露了构造函数（在这个上下文中称为提供程序），用于使用各种协议建立连接和传输消息。`Web3.providers.HttpProvider`
    让我们建立 HTTP 连接，而 `Web3.providers.IpcProvider` 让我们建立 IPC 连接。'
- en: The `web3.currentProvider` property is automatically assigned to the current
    provider instance. After creating a web3 instance, you can change its provider
    using the `web3.setProvider()` method. It takes one argument, that is, the instance
    of the new provider.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.currentProvider` 属性会自动分配给当前提供程序实例。创建 web3 实例后，你可以使用 `web3.setProvider()`
    方法更改其提供程序。它接受一个参数，即新提供程序的实例。'
- en: Remember that geth has HTTP-RPC disabled by default. So enable it by passing
    the `--rpc` option while running geth. By default, HTTP-RPC runs on port 8545.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，geth 默认禁用 HTTP-RPC。因此，在运行 geth 时通过传递 `--rpc` 选项来启用它。默认情况下，HTTP-RPC 在端口 8545
    上运行。
- en: '`web3` exposes a `isConnected()` method, which can be used to check whether
    it''s connected to the node or not. It returns `true` or `false` depending on
    the connection status.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 暴露了一个 `isConnected()` 方法，用于检查是否连接到节点。根据连接状态，它返回 `true` 或 `false`。'
- en: The API structure
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 结构
- en: '`web3` contains an `eth` object (`web3.eth`) specifically for Ethereum blockchain
    interactions and an `shh` object (`web3.shh`) for whisper interaction. Most APIs
    of web3.js are inside these two objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3` 包含一个专门用于以太坊区块链交互的 `eth` 对象 (`web3.eth`) 和一个用于 whisper 交互的 `shh` 对象 (`web3.shh`)。web3.js
    的大多数 API 都在这两个对象内部。'
- en: All the APIs are synchronous by default. If you want to make an asynchronous
    request, you can pass an optional callback as the last parameter to most functions.
    All callbacks use an error-first callback style.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 API 默认都是同步的。如果你想发出异步请求，你可以将可选的回调作为大多数函数的最后一个参数传递。所有回调都使用错误优先的回调风格。
- en: Some APIs have an alias for asynchronous requests. For example, `web3.eth.coinbase()`
    is synchronous, whereas `web3.eth.getCoinbase()` is asynchronous.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 对异步请求有别名。例如，`web3.eth.coinbase()` 是同步的，而 `web3.eth.getCoinbase()` 是异步的。
- en: 'Here is an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`getBlock` is used to get information on a block using its number or hash.
    Or, it can take a string such as `"earliest"` (the genesis block), `"latest"`
    (the top block of the blockchain), or `"pending"` (the block that''s being mined).
    If you don''t pass an argument, then the default is `web3.eth.defaultBlock`, which
    is assigned to `"latest"` by default.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBlock` 用于通过其编号或哈希获取区块的信息。或者，它可以接受字符串，如 `"earliest"`（创世区块），`"latest"`（区块链的顶部区块）或
    `"pending"`（正在挖掘的区块）。如果不传递参数，则默认为 `web3.eth.defaultBlock`，默认为 `"latest"`。'
- en: All the APIs that need a block identification as input can take a number, hash,
    or one of the readable strings. These APIs use `web3.eth.defaultBlock` by default
    if the value is not passed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要区块标识作为输入的 API 如果没有传递值，则默认使用 `web3.eth.defaultBlock`。
- en: BigNumber.js
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigNumber.js
- en: JavaScript is natively poor at handling big numbers correctly. Therefore, applications
    that require you to deal with big numbers and need perfect calculations use the
    `BigNumber.js` library to work with big numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在正确处理大数字方面天生能力较弱。因此，需要处理大数字并进行精确计算的应用程序使用 `BigNumber.js` 库来处理大数字。
- en: web3.js also depends on BigNumber.js. It adds it automatically. web3.js always
    returns the `BigNumber` object for number values. It can take JavaScript numbers,
    number strings, and `BigNumber` instances as input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 也依赖于 BigNumber.js。它会自动添加它。web3.js 总是返回 `BigNumber` 对象作为数字值。它可以接受 JavaScript
    数字、数字字符串和 `BigNumber` 实例作为输入。
- en: 'Here is an example to demonstrate this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例来说明这一点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use the `web3.eth.getBalance()` method to get the balance of an address.
    This method returns a `BigNumber` object. We need to call `toString()` on a `BigNumber`
    object to convert it into a number string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `web3.eth.getBalance()` 方法来获取地址的余额。该方法返回一个 `BigNumber` 对象。我们需要在 `BigNumber`
    对象上调用 `toString()` 来将其转换为数字字符串。
- en: '`BigNumber.js` fails to correctly handle numbers with more than 20 floating
    point digits; therefore, it is recommended that you store the balance in a wei
    unit and while displaying, convert it to other units. web3.js itself always returns
    and takes the balance in wei. For example, the `getBalance()` method returns the
    balance of the address in the wei unit.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigNumber.js` 无法正确处理具有超过 20 个浮点数字的数字；因此，建议您将余额存储在 wei 单位中，而在显示时将其转换为其他单位。web3.js
    本身始终以 wei 单位返回和接受余额。例如，`getBalance()` 方法以 wei 单位返回地址的余额。'
- en: Unit conversion
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位转换
- en: web3.js provides APIs to convert the wei balance into any other unit and any
    other unit balance into wei.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 提供了将 wei 余额转换为任何其他单位以及将任何其他单位余额转换为 wei 的 API。
- en: 'The `web3.fromWei()` method is used to convert a wei number into any other
    unit, whereas the `web3.toWei()` method is used to convert a number in any other
    unit into wei. Here is example to demonstrate this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.fromWei()` 方法用于将 wei 数字转换为任何其他单位，而 `web3.toWei()` 方法用于将任何其他单位中的数字转换为
    wei。以下是演示此功能的示例：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first line, we convert wei into ether, and in the second line, we convert
    ether into wei. The second argument in both methods can be one of these strings:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们将 wei 转换为 ether，在第二行中，我们将 ether 转换为 wei。两种方法中的第二个参数可以是以下字符串之一：
- en: '`kwei/ada`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwei/ada`'
- en: '`mwei/babbage`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mwei/babbage`'
- en: '`gwei/shannon`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gwei/shannon`'
- en: '`szabo`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`szabo`'
- en: '`finney`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finney`'
- en: '`ether`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ether`'
- en: '`kether/grand/einstein`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kether/grand/einstein`'
- en: '`mether`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mether`'
- en: '`gether`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gether`'
- en: '`tether`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tether`'
- en: Retrieving gas price, balance, and transaction details
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索 gas 价格、余额和交易详情
- en: 'Let''s take a look at the APIs to retrieve the gas price, the balance of an
    address, and information on a mined transaction:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下获取 gas 价格、地址余额和已挖掘交易信息的 API：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be of this form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将采用以下形式：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how the preceding method works:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述方法的工作原理：
- en: '`web3.eth.gasPrice()`: Determines the gas price by the x latest blocks'' median
    gas price.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.gasPrice()`: 通过最近 x 个区块的中位 gas 价格确定 gas 价格。'
- en: '`web3.ethgetBalance()`: Returns the balance of any given address. All the hashes
    should be provided as hexadecimal strings to the web3.js APIs, not as hexadecimal
    literals. The input for the solidity `address` type should also be hexadecimal
    strings.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.getBalance()`: 返回给定地址的余额。所有哈希应该以十六进制字符串的形式提供给 web3.js API，而不是十六进制文字。对于
    solidity `address` 类型的输入，也应该是十六进制字符串。'
- en: '`web3.eth.getTransactionReceipt()`: This is used to get details about a transaction
    using its hash. It returns a transaction receipt object if the transaction was
    found in the blockchain; otherwise, it returns null. The transaction receipt object
    contains the following properties:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3.eth.getTransactionReceipt()`: 这用于使用其哈希获取有关交易的详细信息。如果在区块链中找到了交易，则返回交易收据对象；否则返回
    `null`。交易收据对象包含以下属性：'
- en: '`blockHash`: The hash of the block where this transaction was'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockHash`: 此交易所在的区块的哈希'
- en: '`blockNumber`: The block number where this transaction was'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockNumber`: 此交易所在的区块号'
- en: '`transactionHash`: The hash of the transaction'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionHash`: 交易的哈希'
- en: '`transactionIndex`: The integer of the transactions'' index position in the
    block'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionIndex`: 该交易在区块中的事务索引位置的整数'
- en: '`from`: The address of the sender'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 发件人的地址'
- en: '`to`: The address of the receiver; `null` when it''s a contract creation transaction'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 收件人的地址；当它是合约创建交易时为 `null`'
- en: '`cumulativeGasUsed`: The total amount of gas used when this transaction was
    executed in the block'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumulativeGasUsed`: 该交易在区块中执行时使用的总 gas 量'
- en: '`gasUsed`: The amount of gas used by this specific transaction alone'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasUsed`: 仅此特定交易使用的 gas 量'
- en: '`contractAddress`: The contract address created if the transaction was a contract
    creation; otherwise, null'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contractAddress`: 如果交易是合约创建，则为创建的合约地址；否则为 null'
- en: '`logs`: The array of log objects that this transaction generated'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`: 此交易生成的日志对象数组'
- en: Sending ether
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送以太币
- en: 'Let''s look at how to send ether to any address. To send ether, you need to
    use the `web3.eth.sendTransaction()` method. This method can be used to send any
    kind of transaction but is mostly used to send ether because deploying a contract
    or calling a method of contract using this method is cumbersome as it requires
    you to generate the data of the transaction rather than automatically generating
    it. It takes a transaction object that has the following properties:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向任何地址发送以太币。要发送以太币，你需要使用 `web3.eth.sendTransaction()` 方法。这个方法可以用来发送任何类型的交易，但大多数情况下用于发送以太币，因为使用该方法部署合约或调用合约方法很麻烦，因为它需要你生成交易数据而不是自动生成。它接受一个具有以下属性的交易对象：
- en: '`from`: The address for the sending account. Uses the `web3.eth.defaultAccount`
    property if not specified.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`：发送账户的地址。如果未指定，则使用 `web3.eth.defaultAccount` 属性。'
- en: '`to`: This is optional. It''s the destination address of the message and is
    left undefined for a contract-creation transaction.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：这是可选的。这是消息的目标地址，在创建合约交易时保持未定义。'
- en: '`value`: This is optional. The value is transferred for the transaction in
    wei as well as the endowment if it''s a contract-creation transaction.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是可选的。这是以 wei 为单位的交易中转的价值，以及如果是合约创建交易的话就是捐赠。'
- en: '`gas`: This is optional. It''s the amount of gas to use for the transaction
    (unused gas is refunded). If not provided, then it''s automatically determined.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gas`：这是可选的。这是用于交易的气体数量（未使用的气体将被退还）。如果未提供，则会自动确定。'
- en: '`gasPrice`: This is optional. It''s the price of gas for this transaction in
    wei, and it defaults to the mean network gas price.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasPrice`：这是可选的。这是以 wei 为单位的交易的燃气价格，默认为网络平均燃气价格。'
- en: '`data`: This is optional. It''s either a byte string containing the associated
    data of the message, or in the case of a contract-creation transaction, the initialization
    code.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是可选的。它是一个包含消息关联数据的字节字符串，或者在创建合约交易的情况下是初始化代码。'
- en: '`nonce`: This is optional. It''s an integer. Every transaction has a nonce
    associated with it. A nonce is a counter that indicates the number of transactions
    sent by the sender of the transaction. If not provided, then it is automatically
    determined. It helps prevent replay attacks. This nonce is not the nonce associated
    with a block. If we are using a nonce greater than the nonce the transaction should
    have, then the transaction is put in a queue until the other transactions arrive.
    For example, if the next transaction nonce should be 4 and if we set the nonce
    to 10, then geth will wait for the middle six transactions before broadcasting
    this transaction. The transaction with nonce 10 is called a queued transaction,
    and it''s not a pending transaction.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nonce`：这是可选的。这是一个整数。每个交易都与一个 nonce 相关联。一个 nonce 是一个计数器，表示发送交易的发送者发送的交易数量。如果未提供，则会自动确定。它有助于防止重放攻击。这个
    nonce 不是与一个区块相关联的 nonce。如果我们使用的 nonce 大于交易应该具有的 nonce，那么交易将被放入队列，直到其他交易到达。例如，如果下一个交易的
    nonce 应该是 4，而我们设置了 nonce 为 10，那么 geth 将等待中间的六个交易到达，然后再广播此交易。具有 nonce 10 的交易称为排队交易，它不是挂起交易。'
- en: 'Let''s look at an example of how to send ether to an address:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个向地址发送以太币的示例：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we send one ether from account number 0 to account number 1\. Make sure
    that both the accounts are unlocked using the `unlock` option while running geth.
    In the geth interactive console, it prompts for passwords, but the web3.js API
    outside of the interactive console will throw an error if the account is locked.
    This method returns the transaction hash of the transaction. You can then check
    whether the transaction is mined or not using the `getTransactionReceipt()` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从账户编号为 0 的账户向账户编号为 1 的账户发送一个以太币。确保在运行 geth 时两个账户都已解锁，使用 `unlock` 选项。在
    geth 交互式控制台中，它会提示输入密码，但在交互式控制台之外使用 web3.js API 时，如果账户被锁定，会抛出错误。该方法返回交易的交易哈希。然后你可以使用
    `getTransactionReceipt()` 方法来检查交易是否被挖掘。
- en: You can also use the `web3.personal.listAccounts()`, `web3.personal.unlockAccount(addr,
    pwd)`, and `web3.personal.newAccount(pwd)` APIs to manage accounts at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在运行时使用 `web3.personal.listAccounts()`、`web3.personal.unlockAccount(addr,
    pwd)` 和 `web3.personal.newAccount(pwd)` API 来管理账户。
- en: Working with contracts
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与合约交互
- en: Let's learn how to deploy a new contract, get a reference to a deployed contract
    using it's address, send ether to a contract, send a transaction to invoke a contract
    method, and estimate the gas of a method call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何部署一个新的合约，使用它的地址获取已部署合约的引用，向合约发送以太币，发送交易来调用合约方法，并估算方法调用的 gas。
- en: To deploy a new contract or to get a reference to an already deployed contract,
    you need to first create a contract object using the `web3.eth.contract()` method.
    It takes the contract ABI as an argument and returns the contract object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署一个新合约或获取对已部署合约的引用，你首先需要使用`web3.eth.contract()`方法创建一个合约对象。它将合约ABI作为参数，并返回合约对象。
- en: 'Here is the code to create a contract object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建合约对象的代码：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have the contract, you can deploy it using the `new` method of the
    contract object or get a reference to an already deployed contract that matches
    the ABI using the `at` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了合约，你可以使用合约对象的`new`方法部署它，或者使用`at`方法获取与ABI匹配的已部署合约的引用。
- en: 'Let''s take a look at an example of how to deploy a new contract:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个部署新合约的例子：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `new` method is called asynchronously, so the callback is fired twice
    if the transaction was created and broadcasted successfully. The first time, it's
    called after the transaction is broadcasted, and the second time, it's called
    after the transaction is mined. If you don't provide a callback, then the `proof`
    variable will have the `address` property set to `undefined`. Once the contract
    is mined, the `address` property will be set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`new`方法是异步调用的，所以如果交易被成功创建和广播，回调函数会被触发两次。第一次，在交易被广播后调用，第二次，在交易被挖掘后调用。如果你不提供回调函数，那么`proof`变量的`address`属性将被设置为`undefined`。一旦合约被挖掘，`address`属性将被设置。
- en: In the `proof` contract, there is no constructor, but if there is a constructor,
    then the arguments for the constructor should be placed at the beginning of the
    `new` method. The object we passed contains the from address, the byte code of
    the contract, and the maximum gas to use. These three properties must be present;
    otherwise, the transaction won't be created. This object can have the properties
    that are present in the object passed to the `sendTransaction()` method, but here,
    `data` is the contract byte code and the `to` property is ignored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`proof`合约中，没有构造函数，但如果有构造函数，则构造函数的参数应放在`new`方法的开头。我们传递的对象包含来自地址、合约的字节码和要使用的最大
    gas。这三个属性必须存在；否则，交易将不会被创建。这个对象可以具有传递给`sendTransaction()`方法的对象中存在的属性，但这里，`data`是合约的字节码，`to`属性被忽略。
- en: 'You can use the `at` method to get a reference to an already deployed contract.
    Here is the code to demonstrate this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`at`方法来获取一个已经部署的合约的引用。这里是演示这一点的代码：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s look at how to send a transaction to invoke a method of a contract.
    Here is an example to demonstrate this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何发送交易来调用合约的方法。这里有一个示例来演示这一点：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we call the `sendTransaction` method of the object of the method namesake.
    The object passed to this `sendTransaction` method has the same properties as
    `web3.eth.sendTransaction()`, except that the `data` and `to` properties are ignored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们调用方法同名的对象的`sendTransaction`方法。传递给此`sendTransaction`方法的对象具有与`web3.eth.sendTransaction()`相同的属性，除了`data`和`to`属性被忽略。
- en: 'If you want to invoke a method on the node itself instead of creating a transaction
    and broadcasting it, then you can use `call` instead of `sendTransaction`. Here
    is an example to demonstrate this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在节点本身上调用一个方法而不是创建一个交易并广播它，那么你可以使用`call`而不是`sendTransaction`。这里有一个示例来演示这一点：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sometimes, it is necessary to find out the gas that would be required to invoke
    a method so that you can decide whether to invoke it or not. `web3.eth.estimateGas`
    can be used for this purpose. However, using `web3.eth.estimateGas()` directly
    requires you to generate the data of the transaction; therefore, we can use the
    `estimateGas()` method of the object of the method namesake. Here is an example
    to demonstrate this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要找出调用方法所需的 gas，以便决定是否调用它。`web3.eth.estimateGas`可以用于此目的。然而，直接使用`web3.eth.estimateGas()`需要你生成交易的数据；因此，我们可以使用同名方法对象的`estimateGas()`方法。这里有一个示例来演示这一点：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to just send some ether to a contract without invoking any method,
    then you can simply use the `web3.eth.sendTransaction` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想向合约发送一些以太币而不调用任何方法，那么你可以简单地使用`web3.eth.sendTransaction`方法。
- en: Retrieving and listening to contract events
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at how to watch for events from a contract. Watching for events
    is very important because the result of method invocations by transactions are
    usually returned by triggering events.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into how to retrieve and watch for events, we need to learn indexed
    parameters of events. A maximum of three parameters of an event can have the `indexed`
    attribute. This attribute is used to signal the node to index it so that the app
    client can search for events with matching return values. If you don''t use the
    indexed attribute, then it will have to retrieve all the events from the node
    and filter the ones needed. For example, you can write the `logFileAddedStatus`
    event this way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an example to demonstrate how to listen to contract events:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how the preceding code works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we get the event object by calling the method of the event namesake
    on a contract instance. This method takes two objects as arguments, which are
    used to filter events:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first object is used to filter events by indexed return values: for example,
    `{''valueA'': 1, ''valueB'': [myFirstAddress, mySecondAddress]}`. By default,
    all filter values are set to `null`. This means that they will match any event
    of a given type sent from this contract.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next object can contain three properties: `fromBlock` (the earliest block;
    by default, it is `"latest"`), `toBlock` (the latest block; by default, it is
    `"latest"`), and `address` (a list of addresses to only get logs from; by default,
    the contract address).'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `event` object exposes three methods: `get`, `watch`, and `stopWatching`.
    `get` is used to get all the events in the block range. `watch` is like `get`
    but it watches for changes after getting the events. And `stopWatching` can be
    used to stop watching for changes.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the `allEvents` method of the contract instance. It is used to
    retrieve all the events of a contract.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Every event is represented by an object that contains the following properties:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`args`: An object with the arguments from the event'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: A string representing the event name'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logIndex`: An integer representing the log index position in the block'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transactionIndex`: An integer representing the transactions the index position
    log was created from'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transactionHash`: A string representing the hash of the transactions this
    log was created from'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: A string representing the address from which this log originated'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockHash`: A string representing the hash of the block where this log was
    in; `null` when its pending'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockNumber`: The block number where this log was in; `null` when its pending'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: web3.js provides a `web3.eth.filter` API to retrieve and watch for events. You
    can use this API, but the earlier method's way of handling events is much easier.
    You can learn more about it at [https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Building a client for an ownership contract
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建所有权合约的客户端
- en: Now, it's time to build a client for our smart contract so that users can use
    it easily.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为我们的智能合约构建一个客户端，以便用户可以轻松使用它了。
- en: We will build a client where a user selects a file and enters owner details
    and then clicks on Submit to broadcast a transaction to invoke the contract's
    `set` method with the file hash and the owner's details. Once the transaction
    is successfully broadcasted, we will display the transaction hash. The user will
    also be able to select a file and get the owner's details from the smart contract.
    The client will also display the recent `set` transactions mined in real time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个客户端，用户选择一个文件并输入所有者详细信息，然后点击提交来广播一个交易以调用合约的`set`方法，其中包含文件哈希和所有者的详细信息。一旦交易成功广播，我们将显示交易哈希。用户还将能够选择一个文件，并从智能合约获取所有者的详细信息。客户端还将实时显示最近的`set`交易。
- en: We will use sha1.js to get the hash of the file on the frontend, jQuery for
    DOM manipulation, and Bootstrap 4 to create a responsive layout. We will use express.js
    and web3.js on the backend. We will use socket.io so that the backend pushes recently
    mined transactions to the frontend without the frontend requesting for data after
    every equal interval of time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前端使用 sha1.js 获取文件的哈希值，jQuery 用于 DOM 操作，Bootstrap 4 创建响应式布局。我们将在后端使用 express.js
    和 web3.js。我们将使用 socket.io，以便后端在前端每隔一段时间后自动推送最近挖掘的交易，而无需前端请求数据。
- en: web3.js can be used in the frontend. But for this application, it will be a
    security risk; that is, we are using accounts stored in geth and exposing the
    geth node URL to the frontend, which will put the ether stored in those accounts
    at risk.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js 可以在前端使用。但对于这个应用程序来说，这将是一个安全风险；也就是说，我们正在使用存储在 geth 中的账户，并将 geth 节点 URL
    暴露给前端，这将使这些账户中存储的以太币面临风险。
- en: The project structure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'In the exercise files of this chapter, you will find two directories: `Final`
    and `Initial. Final` contains the final source code of the project, whereas `Initial`
    contains the empty source code files and libraries to get started with building
    the application quickly.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，你会找到两个目录：`Final`和`Initial`。`Final`包含项目的最终源代码，而`Initial`包含了空的源代码文件和库，可以快速开始构建应用程序。
- en: To test the `Final` directory, you will need to run `npm install` inside it
    and replace the hardcoded contract address in `app.js` with the contract address
    you got after deploying the contract. Then, run the app using the `node app.js`
    command inside the `Final` directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Final`目录，你需要在其中运行`npm install`并将`app.js`中的硬编码的合约地址替换为部署合约后得到的合约地址。然后，在`Final`目录中使用`node
    app.js`命令运行应用程序。
- en: In the `Initial` directory, you will find a `public` directory and two files
    named `app.js` and `package.json`. `package.json` contains the backend dependencies
    of our app, and `app.js` is where you will place the backend source code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Initial`目录中，你会找到一个`public`目录和两个名为`app.js`和`package.json`的文件。`package.json`包含了我们应用程序的后端依赖项，`app.js`是你将放置后端源代码的地方。
- en: The `public` directory contains files related to the frontend. Inside `public/css`,
    you will find `bootstrap.min.css`, which is the Bootstrap library; inside `public/html`,
    you will find `index.html`, where you will place the HTML code of our app; and
    in the `public/js` directory, you will find JS files for jQuery, sha1, and socket.io.
    Inside `public/js`, you will also find a `main.js` file, where you will place
    the frontend JS code of our app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`目录包含与前端相关的文件。在`public/css`中，你会找到`bootstrap.min.css`，这是 Bootstrap 库；在`public/html`中，你会找到`index.html`，其中包含我们应用程序的
    HTML 代码；在`public/js`目录中，你会找到 jQuery、sha1 和 socket.io 的 JS 文件。在`public/js`中，你还会找到一个`main.js`文件，其中包含我们应用程序的前端
    JS 代码。'
- en: Building the backend
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: 'Let''s first build the backend of the app. First of all, run `npm install`
    inside the `Initial` directory to install the required dependencies for our backend.
    Before we get into coding the backend, make sure geth is running with rpc enabled.
    If you are running geth on a private network, then make sure mining is also enabled.
    Finally, make sure that account 0 exists and is unlocked. You can run geth on
    a private network with rpc and mining enabled and also unlocking account 0:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建应用程序的后端。首先，在`Initial`目录中运行`npm install`以安装我们后端所需的依赖项。在我们开始编写后端代码之前，请确保
    geth 正在运行并启用了 rpc。如果你正在私有网络上运行 geth，则确保也启用了挖矿。最后，请确保账户 0 存在并已解锁。你可以在启用了 rpc 和挖矿并解锁账户
    0 的私有网络上运行 geth：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One final thing you need to do before getting started with coding is deploy
    the ownership contract using the code we saw in the [Chapter 4](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml),
    Smart Contracts and copy the contract address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您需要做的最后一件事是使用我们在[第 4 章](12eebfe5-f775-4550-a8df-d9578dd08980.xhtml)中看到的代码部署所有权合同，并复制合同地址。
- en: 'Now let''s create a single server, which will serve the HTML to the browser
    and also accept `socket.io` connections:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个单一服务器，该服务器将向浏览器提供 HTML，并接受 `socket.io` 连接：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are integrating both the `express` and `socket.io` servers into one
    server running on port `8080`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `express` 和 `socket.io` 服务器集成到一个运行在 `8080` 端口的服务器中。
- en: 'Now let''s create the routes to serve the static files and also the home page
    of the app. Here is the code to do this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来提供静态文件以及应用程序的主页。以下是执行此操作的代码：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are using the `express.static` middleware to serve static files. We
    are asking it to find static files in the `public` directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `express.static` 中间件来提供静态文件。我们要求它在 `public` 目录中查找静态文件。
- en: 'Now let''s connect to the `geth` node and also get a reference to the deployed
    contract so that we can send transactions and watch for events. Here is the code
    to do this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接到 `geth` 节点，并获取已部署合同的引用，以便我们可以发送交易并监视事件。以下是执行此操作的代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code is self-explanatory. Just replace the contract address with the one
    you got.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单明了。只需用您获取的合同地址替换原合同地址即可。
- en: 'Now let''s create routes to broadcast transactions and get information about
    a file. Here is the code to do this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建路由来广播交易并获取有关文件的信息。以下是执行此操作的代码：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `/submit` route is used to create and broadcast transactions. Once
    we get the transaction hash, we send it to the client. We are not doing anything
    to wait for the transaction to mine. The `/getInfo` route calls the get method
    of the contract on the node itself instead of creating a transaction. It simply
    sends back whatever response it got.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/submit` 路由用于创建和广播交易。一旦我们得到交易哈希，我们就将其发送到客户端。我们没有做任何等待交易挖掘的操作。`/getInfo`
    路由调用节点上合同的 get 方法，而不是创建交易。它只是发送回收到的任何响应。
- en: 'Now let''s watch for the events from the contract and broadcast it to all the
    clients. Here is the code to do this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们监听来自合同的事件并将其广播给所有客户端。以下是执行此操作的代码：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we check whether the status is true, and if it's true, only then do we
    broadcast the event to all the connected `socket.io` clients.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查状态是否为 true，如果为 true，则只广播事件给所有连接的 `socket.io` 客户端。
- en: Building the frontend
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: 'Let''s begin with the HTML of the app. Put this code in the `index.html` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的 HTML 开始。将此代码放入 `index.html` 文件中：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is how the code works:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: At first, we display Bootstrap's file input field so that the user can select
    a file.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们显示 Bootstrap 的文件输入字段，以便用户可以选择文件。
- en: Then, we display a text field where the user can enter the owner's details.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们显示一个文本字段，用户可以在其中输入所有者的详细信息。
- en: Then, we have two buttons. The first one is to store the file hash and the owner's
    details in the contract, and the second button is to get information on the file
    from the contract. Clicking on the Submit button triggers the `submit()` method,
    whereas clicking on the Get Info button triggers the `getInfo()` method.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有两个按钮。第一个按钮用于将文件哈希和所有者的详细信息存储在合同中，第二个按钮用于从合同获取文件信息。单击提交按钮会触发 `submit()`
    方法，而单击获取信息按钮会触发 `getInfo()` 方法。
- en: Then, we have an alert box to display messages.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有一个警报框用于显示消息。
- en: Finally, we display an ordered list to display the transactions of the contract
    that gets mined while the user is on the page.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示一个有序列表，以显示用户在页面上的时间内获得的合同交易。
- en: 'Now let''s write the implementation for the `getInfo()` and `submit()` methods,
    establish a `socket.io` connect with the server, and listen for `socket.io` messages
    from the server. Here is the code to this. Place this code in the `main.js` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为 `getInfo()` 和 `submit()` 方法编写实现，与服务器建立 `socket.io` 连接，并监听来自服务器的 `socket.io`
    消息。以下是执行此操作的代码。将此代码放在 `main.js` 文件中：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how the preceding code works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是上述代码的工作原理：
- en: At first, we defined the `submit()` method. In the `submit` method, we make
    sure that a file is selected and the text field is not empty. Then, we read the
    content of the file as an array buffer and pass the array buffer to the `sha1()`
    method exposed by sha1.js to get the hash of content inside the array buffer.
    Once we have the hash, we use jQuery to make an AJAX request to the `/submit` route
    and then we display the transaction hash in the alert box.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了`submit()`方法。在`submit`方法中，我们确保选择了一个文件并且文本字段不为空。然后，我们将文件内容读取为数组缓冲区，并将数组缓冲区传递给由
    sha1.js 暴露的`sha1()`方法，以获取数组缓冲区内的内容的哈希。一旦我们有了哈希，我们就使用 jQuery 发送 AJAX 请求到`/submit`路由，然后在警告框中显示交易哈希。
- en: We define the `getInfo()` method next. It first makes sure that a file is selected.
    Then, it generates the hash like the one it generated earlier and makes a request
    to the `/getInfo` endpoint to get information about that file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来定义`getInfo()`方法。首先确保选择了文件。然后，生成像之前生成的那样的哈希，并向`/getInfo`端点发出请求以获取有关该文件的信息。
- en: Finally, we establish a `socket.io` connection using the `io()` method exposed
    by the `socket.io` library. Then, we wait for the connect event to the trigger,
    which indicates that a connection has been established. After the connection is
    established, we listen for messages from the server and display the details about
    the transactions to the user.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用由`socket.io`库暴露的`io()`方法建立了`socket.io`连接。然后，我们等待触发连接事件，该事件指示已建立连接。连接建立后，我们监听来自服务器的消息，并向用户显示有关交易的详细信息。
- en: We aren't storing the file in the Ethereum blockchain because storing files
    is very expensive as it requires a lot of gas. For our case, we actually don't
    need to store files because nodes in the network will be able to see the file;
    therefore, if the users want to keep the file content secret, then they won't
    be able to. Our application's purpose is just to prove ownership of a file, not
    to store and serve the file like a cloud service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不将文件存储在以太坊区块链中，因为存储文件非常昂贵，需要大量的 gas。对于我们的情况，实际上不需要存储文件，因为网络中的节点将能够看到文件；因此，如果用户希望保持文件内容的机密性，那么他们将无法做到。我们应用的目的只是证明对文件的所有权，而不是像云服务一样存储和提供文件。
- en: Testing the client
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端
- en: 'Now run the `app.js` node to run the application server. Open you favorite
    browser and visit `http://localhost:8080/`. You will see this output in the browser:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`app.js`节点以运行应用程序服务器。打开您喜欢的浏览器并访问`http://localhost:8080/`。您将在浏览器中看到此输出：
- en: '![](img/7f4f6594-ff70-49b6-87aa-59528ec819de.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f4f6594-ff70-49b6-87aa-59528ec819de.png)'
- en: 'Now select a file and enter the owner''s name and click on Submit. The screen
    will change to this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择一个文件并输入所有者的名称，然后点击提交。屏幕将变成这样：
- en: '![](img/304a19f0-5b65-451d-8139-fdd539653429.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/304a19f0-5b65-451d-8139-fdd539653429.png)'
- en: 'Here, you can see that the transaction hash is displayed. Now wait until the
    transaction is mined. Once the transaction is mined, you will be able to see the
    transaction in the live transactions list. Here is how the screen would look:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到交易哈希被显示出来。现在等待交易被挖掘。一旦交易被挖掘，您将能够在实时交易列表中看到交易。屏幕会是这样的：
- en: '![](img/5f54275e-8558-4833-9688-062dcb5b1c3e.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f54275e-8558-4833-9688-062dcb5b1c3e.png)'
- en: 'Now select the same file again and click on the Get Info button. You will see
    this output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次选择相同的文件，然后单击获取信息按钮。您将看到此输出：
- en: '![](img/8f889e32-dfa5-446a-9bb6-a7c8ca414d7d.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f889e32-dfa5-446a-9bb6-a7c8ca414d7d.png)'
- en: Here, you can see the timestamp and the owner's details. Now we have finished
    building the client for our first DApp.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到时间戳和所有者的详细信息。现在我们已经完成了第一个 DApp 的客户端构建。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we first learned about the fundamentals of web3.js with examples.
    We learned how to connect to a node, basic APIs, sending various kinds of transactions,
    and watching for events. Finally, we built a proper production use client for
    our ownership contract. Now you will be comfortable with writing smart contracts
    and building UI clients for them in order to ease their use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先通过示例了解了 web3.js 的基础知识。我们学习了如何连接到节点，基本的 API，发送各种类型的交易和监视事件。最后，我们为我们的所有权合同构建了一个适当的生产使用客户端。现在您将可以轻松编写智能合约并为其构建
    UI 客户端，以便简化其使用。
- en: In the [Chapter 9](5eb488e0-cefa-4c47-b876-b506c95adfd7.xhtml), we will build
    a wallet service, where users can create and manage Ethereum Wallets easily, and
    that too is offline. We will specifically use the LightWallet library to achieve
    this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](5eb488e0-cefa-4c47-b876-b506c95adfd7.xhtml)中，我们将构建一个钱包服务，用户可以轻松地创建和管理以太坊钱包，而且还是离线的。我们将专门使用LightWallet库来实现这一点。
