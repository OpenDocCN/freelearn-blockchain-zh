- en: Chapter 10. Alternative Blockchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is intended to provide an introduction to alternative blockchain
    solutions. With the success of bitcoin and subsequent realization of the potential
    of blockchain technology, a Cambrian explosion started that resulted in the development
    of various blockchain protocols, applications, and platforms. Some projects did
    not gain much traction, but many have succeeded in creating a solid place in this
    space.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, readers will be introduced to alternative blockchains and platforms
    that either are new blockchains on their own or complement other existing blockchains.
    These new platforms are based on the idea of providing SDKs and tools to make
    development and deployment of blockchain solutions easier. The success of Ethereum
    and bitcoin has resulted in various projects that spawned into existence by leveraging
    the underlying technologies and concepts introduced by them. These new projects
    add value by addressing the limitations in the current blockchains or enhancing
    the existing solutions by providing an additional layer of user-friendly tools
    on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section of this chapter, an introduction to new blockchain solutions
    will be given, and later sections will cover various platforms and development
    kits that complement existing blockchains. For example, BlockApps STRATO is an
    Ethereum-compliant platform for the development of blockchain applications, and
    Kadena is a new private blockchain with novel ideas such as Scalable BFT. Various
    concepts such as sidechains, drivechains, and pegging have also been introduced
    for the first time with this growth of blockchain technologies. This chapter will
    cover all these technologies and related concepts in detail. Of course, it's not
    possible to cover all alternative chains (altchains) and platforms, but all those
    platforms have been included in this chapter that are related to blockchains,
    covered in the previous chapters, or are expected to gain traction in the near
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will give an introduction to new blockchain solutions. First, a
    new blockchain named Kadena is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Kadena
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kadena is a recently-introduced private blockchain that has successfully addressed
    scalability and privacy issues in blockchain systems. A new Turing incomplete
    language called Pact has also been introduced with Kadena that allows the development
    of smart contracts. A key innovation in Kadena is its Scalable BFT consensus algorithm,
    which has the potential to scale to thousands of nodes without performance degradation.
    Scalable BFT is based on the original Raft algorithm and is a successor of Tangaroa
    and Juno. Tangaroa, which is a name given to an implementation of Raft with fault
    tolerance (a BFT Raft), was developed to address the availability and safety issues
    that arose from the behavior of byzantine nodes in the Raft algorithm, and Juno
    was a fork of Tangaroa that was developed by *JPMorgan*. Consensus algorithms
    are discussed in [Chapter 1](ch01.html "Chapter 1. Blockchain 101"), *Blockchain
    101* in more detail. Both of these proposals have a fundamental limitation - they
    cannot scale while maintaining a high level of high performance. As such, Juno
    could not gain much traction. Private blockchains have the more desirable property
    of maintaining high performance as the number of nodes increase, but the aforementioned
    proposals lack this feature. Kadena solves this issue with its proprietary Scalable
    BFT algorithm, which is expected to scale up to thousands of nodes without any
    performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, confidentiality is another important aspect of Kadena that enables
    privacy of transactions on the blockchain. This is achieved by using a combination
    of key rotation, symmetric on-chain encryption, incremental hashing, and Double
    Ratchet protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Key rotation is used as a standard mechanism to ensure security of the private
    blockchain. It is used as a best practice to thwart any attacks if the keys have
    been compromised, by periodically changing the encryption keys. There is a native
    support for key rotation in Pact smart contract language.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric on chain encryption allows encryption of transaction data on the blockchain.
    These transactions can be automatically decrypted by the participants of a particular
    private transaction. Double Ratchet protocol is used to provide key management
    and encryption functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalable BFT consensus protocol ensures that adequate replication and consensus
    has been achieved before smart contract execution. Consensus is achieved by following
    the process described below:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a new transaction is signed by the user and broadcasted over the blockchain
    network, which is picked up by a leader node that adds it to its immutable log.
    At this point, an incremental hash is also calculated for the log. Incremental
    hash is a type of hash function that basically allows computation of hash messages
    in the scenario where, if a previous original message which is already hashed
    is slightly changed, then the new hash message is computed from the already existing
    hash. This scheme is quicker and less resource intensive compared to a conventional
    hash function where an altogether new hash message is required to be generated
    even if the original message has only changed very slightly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the transaction is written to the log by the leader node, it signs the
    replication and incremental hash and broadcasts it to other nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other nodes, after receiving the transaction, verify the signature of the leader
    node, add the transaction into their own logs, and broadcast their own calculated
    incremental hashes (quorum proofs) to other nodes. Finally, the transaction is
    committed into the ledger permanently after an adequate number of proofs are received
    from other nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simplified version of this process is shown in the following diagram, where
    the **leader** node is recording the new transactions and then replicating them
    to the **follower** nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kadena](img/B05795_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consensus mechanism in Kadena
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the consensus is achieved, smart contract execution can start and takes
    a number of steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the signature of the message is verified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pact smart contract layer takes over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pact code is compiled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction is initiated and executes any business logic embedded within
    smart contract. In case of any failures, an immediate rollback is initiated that
    reverts that state back to what it was before the execution started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the transaction completes and relevant logs are updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pact has been open sourced by Kadena and is available for download at [http://kadena.io/pact/downloads.html](http://kadena.io/pact/downloads.html).
    This can be downloaded as a standalone binary that provides a REPL for Pact language.
    An example is shown below where Pact is run by issuing the command `./pact` in
    Linux console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kadena](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pact REPL, showing sample commands and error output
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contract in Pact is generally composed of three sections: keysets, modules,
    and tables. First, **keyset** defines relevant authorization schemes for tables
    and modules. Second, **module** defines which is the smart contract code encompassing
    the business logic in the form of **functions** and **Pacts**. Pacts within modules
    are composed of multiple steps and are executed sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: Pact can be used in several execution modes. These modes include **contract
    definition**, **transaction execution,** and **querying**. Contract definition
    mode allows a contract to be created on the blockchain via a single transaction
    message. Transaction execution mode entails the execution of modules of smart
    contract code that represent business logic. Querying is concerned with simply
    probing the contract for data and is executed locally on the nodes for performance
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Pact uses LISP-like syntax and represents in the code exactly what will be executed
    on the blockchain as it is stored on the blockchain in human-readable format.
    This is in contrast to Ethereum's EVM, which compiles into byte code for execution,
    which makes it difficult to verify what code is in execution on the blockchain.
    Moreover, it is Turing incomplete, supports immutable variables, and does not
    allow null values, which improves overall safety of the transaction code execution.
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to cover the complete syntax and functions of Pact in this
    chapter, however, a small example is shown below that shows the general structure
    of a smart contract written in Pact. This example shows a simple addition module
    that defines a function named `addition` that takes three parameters. When the
    code is executed it adds all three values and displays the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example has been developed using the online Pact compiler available
    at [http://kadena.io/try-pact/](http://kadena.io/try-pact/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kadena](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample Pact code
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is run, it produces the output shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kadena](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the code
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding example, the execution output matches exactly with
    the code layout and structure, which allows for greater transparency and limits
    the possibility of malicious code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Kadena is a new class of private blockchains introducing the novel concept of
    **pervasive determinism** where, in addition to standard public/private key-based
    data origin security, an additional layer of fully deterministic consensus is
    also provided. It provides cryptographic security at all layers of the blockchain
    including transactions and consensus layer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relevant documentation and source code for Pact can be found here: [https://github.com/kadena-io/pact](https://github.com/kadena-io/pact).'
  prefs: []
  type: TYPE_NORMAL
- en: Ripple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced in 2012, Ripple is a currency exchange and real-time gross settlement
    system. In Ripple, the payments are settled without any waiting as opposed to
    traditional settlement networks, where it can take days for settlement. It has
    a native currency called **Ripples** (**XRP**). It also supports non-XRP payments.
    This system is considered similar to an old traditional money transfer mechanism
    known as *Hawala*. This system works by making use of agents who take the money
    and a password from the sender, then contact the payee's agent and instruct them
    to release funds to the person who can provide the password. The payee then contacts
    the local agent, tells them the password and collects the funds. An analogy to
    the agent is Gateway in Ripple. This is just a very simple analogy, the actual
    protocol is rather complex but principally it is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ripple network is composed of various nodes that can perform different
    functions based on their type. First, **user nodes**: these use in payment transactions
    and can pay or receive payments. Second, **validator nodes**: these participate
    in the consensus mechanism. Each server maintains a set of unique nodes, which
    it needs to query while achieving consensus. Nodes in the **unique node List**
    (**UNL**) are trusted by the server involved in the consensus mechanism and will
    accept votes only from this list of unique nodes. Ripple is sometimes not considered
    truly decentralized as there are network operators and regulators involved. However
    it can be considered decentralized due to the fact that anyone can become part
    of the network by running a validator node. Moreover, the consensus process is
    also decentralized because any changes proposed to made on the ledger have to
    be decided by following a scheme of super majority voting. However this is a hot
    topic amongst researchers and enthusiasts and there are arguments against and
    in favor of each school of thought.'
  prefs: []
  type: TYPE_NORMAL
- en: Ripple maintains a global distributed ledger of all transactions that is governed
    by a novel low-latency consensus algorithm called **Ripple Protocol Consensus
    Algorithm** (**RPCA**). The consensus process works by achieving an agreement
    on the state of an open ledger containing transactions by seeking verification
    and acceptance from validating servers in an iterative manner until an adequate
    number of votes are achieved. Once enough votes are received (super majority,
    initially 50% and gradually increasing with each iteration up to at least 80%)
    the changes are validated and the ledger is closed. At this point, an alert is
    sent to the whole network indicating that the ledger is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the consensus protocol is a three-phase process. First, the **collection
    phase**, where validating nodes gather all transactions broadcasted on the network
    by account owners and validate them. Transactions, once accepted, are called candidate
    transactions and can be accepted or rejected based on the validation criteria.
    Then the **consensus** process starts, and after achieving it the ledger is **closed**.
    This process runs asynchronously every few seconds in rounds and, as result, the
    ledger is opened and closed (updated) accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ripple](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ripple consensus protocol phases
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Ripple network there are a number of components that work together in
    order to achieve consensus and form a payment network. These components are discussed
    individually below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: This component serves as a participant in the consensus protocol.
    Ripple server software is required in order to be able to participate in consensus
    protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ledger**: This is a main record of balances of all accounts on the network.
    A ledger contains various elements such as ledger number, account settings, transactions,
    timestamp, and a flag that indicates validity of the ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last closed ledger**: A ledger is closed once consensus is achieved by validating
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open ledger**: This is a ledger that has not been validated yet and no consensus
    has been reached about its state. Each node has its own open ledger, which contains
    proposed transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique node list:** This is a list of unique trusted nodes that a validating
    server uses in order to seek votes and subsequent consensus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proposer**: As the name suggests, this component proposes new transactions
    to be included in the consensus process. It is usually a subset of nodes (UNL
    defined above) that can propose transactions to the validating server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transactions are created by network users in order to update the ledger. A transaction
    is expected to be digitally signed and valid in order for it to be considered
    as a candidate in the consensus process. Each transaction costs a small amount
    of XRP, which serves as a protection mechanism against denial of service attacks
    caused by spamming. There are different types of transaction in the Ripple network.
    A single field within the Ripple transaction data structure called `TransactionType`
    is used to represent the type of the transaction. Transactions are executed by
    using a four step process. First, transactions are prepared whereby an unsigned
    transaction is created by following the standards. Second step is signing, where
    the transaction is digitally signed to authorize it. After this, the actual submission
    to the network occurs via the connected server. Finally, the verification is performed
    to ensure that the transaction is validated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Roughly, the transactions can be categorized into three types, namely Payments
    related, Order related, and Account and security related. All these types are
    described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Payments related
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several fields in this category that result in certain actions. All
    these fields are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Payment`: This transaction is most commonly used and allows one user to send
    funds to another.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PaymentChannelClaim`: This is used to claim **Ripples** (**XRP**) from a payment
    channel. A payment channel is a mechanism that allows recurring and unidirectional
    payments between parties. This can also be used to set the expiration time of
    the payment channel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PaymentChannelCreate`: This transaction creates a new payment channel and
    adds XRP to it in *drops*. A single drop is equivalent to 0.000001 of an XRP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PaymentChannelFund`: This transaction is used to add more funds to an existing
    channel. Similar to `PaymentChannelClaim`  transaction, this can also be used
    to modify the expiration time of the payment channel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Order related
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This type of transaction includes following two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OfferCreate`: This transaction represents a limit order, which represents
    an intent for exchange of currency. It results in creating an Offer node in the
    consensus ledger if it cannot be completely fulfilled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OfferCancel`: This is used to remove a previously created offer node from
    the consensus ledger, indicating withdrawal of the order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Account and security related
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This type of transaction include the fields listed as follows. Each field is
    responsible for performing a certain function.
  prefs: []
  type: TYPE_NORMAL
- en: '`AccountSet`: This transaction is used to modify the attributes of an account
    in the Ripple consensus ledger.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetRegularKey`: This is used to change or set the transaction signing key
    for an account. An account is identified using a base-58 Ripple address derived
    from the account''s master public key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SignerListSet`: This can be used to create a set of signers for use in multi-signature
    transactions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TrustSet`: This is used to create or modify a trust line between accounts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A transaction in Ripple is composed of various fields that are common to all
    transaction types. These fields are listed as follows with description:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Account` , address of the initiator of the transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AccountTxnID` , this is an optional field which contains the hash of another
    transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Fee`, Amount of XRP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flags`, optional flags for the transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LastLedgerSequence`, highest sequence number of the ledger in which the transaction
    can appear.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Memos`, optional arbitrary information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Sequence`, a number incremented by 1 with each transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SigningPubKey`, public key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Signers`, represent signers in a multisig transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SourceTag`, represents either sender or reason of the transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TransactionType`, type of the transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TxnSignature`, verification signature for the transaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Various developer's APIs are available with Ripple in order to enable external
    entities to connect to the Ripple network. Two key components, **Interledger**
    protocol and **Ripple connect**, work in harmony in order to enable distributed,
    secure, scalable, and interoperable payments network.
  prefs: []
  type: TYPE_NORMAL
- en: Interledger protocol has been specifically developed to enable interoperability
    between two different ledgers. It can be used to connect ledgers and blockchains
    from various different organizations including, but not limited to, payment networks,
    financial institutions, clearing houses, and exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interledger is a simple protocol that is composed of four layers: Application,
    Transport, Interledger, and Ledger. Each layer is responsible for performing various
    functions under certain protocols. These functions and protocols are described
    in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Protocols running on this layer govern the key attributes of a payment transaction.
    Examples of application layer protocols include **Simple Payment Setup protocol**
    (**SPSP**) and **Open Web payment scheme** (**OWPS**). SPSP is an Interledger
    protocol that allows secure payment across different ledgers by creating *Connectors*
    between them. OWPS is another scheme that allows consumer payments across different
    networks. Once the protocols on this layer have run successfully, protocols from
    the transport layer will be invoked in order to start the payment process.
  prefs: []
  type: TYPE_NORMAL
- en: Transport layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layer is responsible for managing payment transactions. Protocols such
    as **Optimistic Transport protocol** (**OTP**), **Universal Transport protocol**
    (**UTP**) and **Atomic Transport protocol** (**ATP**) are available currently
    for this layer. OTP is the simplest protocol, which manages payment transfers
    without any escrow protection, whereas UTP provides escrow protection. ATP is
    the most advanced protocol, which not only provides an escrowed transfer mechanism
    but in addition makes use of trusted notaries to further secure the payment transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Interledger layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layer provides interoperability and routing services. This layer contains
    protocols such as **Interledger protocol** (**ILP**), **Interledger quoting protocol**
    (**ILQP**), and **Interledger control protocol** (**ILCP**). ILP packet provides
    the final target of the transaction in a transfer. ILQP is used in making quote
    requests by the senders before the actual transfer. ILCP is used to exchange data
    related to routing information and payment errors between connectors on the payment
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Ledger layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layer contains protocols that enable communication and execution of payment
    transactions between connectors. *Connectors* are basically objects that implement
    the protocol for forwarding payments between different ledgers. It can support
    various protocols such as Simple Ledger protocol, various blockchain protocols,
    legacy protocols, and different proprietary protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Ripple connect consists of various Plug and Play modules that allow connectivity
    between ledgers by using the ILP. It enables the exchange of required data between
    parties before the transaction, visibility, fee management, delivery confirmation,
    and secure communication using Transport layer security. A third-party application
    can connect to the Ripple network via various connectors.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Ripple is a solution that is targeted for financial industry and makes
    real-time payments possible without any settlement risk. As this is a very feature-rich
    platform, covering all aspects of it are not possible in this chapter. Ripple
    and very rich documentation for the platform are available at [https://ripple.com/](https://ripple.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Stellar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stellar is a payment network based on blockchain technology and a novel consensus
    model called **Federated Byzantine Agreement** (**FBA**). FBA works by creating
    quorums of trusted parties. **Stellar Consensus Protocol** (**SCP**) is an implementation
    of FBA.
  prefs: []
  type: TYPE_NORMAL
- en: Key issues identified in the Stellar whitepaper are the cost and complexity
    of current financial infrastructure. This limitation warrants the need for a global
    financial network that addresses these issues without compromising the integrity
    and security of the financial transaction. This requirement has resulted in the
    invention of **Stellar Consensus Protocol** (**SCP**) which is a provably safe
    consensus mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has four main properties: *decentralized control*, which allows participation
    by anyone without any central party; *low latency*, which addresses the much desired
    requirement of fast transaction processing; *flexible trust*,which allows users
    to choose which parties they trust for a specific purpose, and finally, *asymptotic
    security*, which makes use of digital signatures and hash functions for providing
    the required level of security on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: The Stellar network allows transfer and representation of the value of an asset
    by its native digital currency, called Lumens, abbreviated as XLM. Lumens are
    consumed when a transaction is broadcasted on the network, which also serves as
    a deterrent against **Denial of Service** (**DOS**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the Stellar network maintains a distributed ledger that records
    every transaction and is replicated on each Stellar server. The consensus is achieved
    by verifying transactions between servers and updating the ledger with updates.
    The Stellar ledger can also act as a distributed exchange order book by allowing
    users to store their offers to buy or sell currencies.
  prefs: []
  type: TYPE_NORMAL
- en: There are various tools, SDKs, and software that make up the Stellar network.
    The core software is available at [https://github.com/stellar/stellar-core](https://github.com/stellar/stellar-core).
  prefs: []
  type: TYPE_NORMAL
- en: Rootstock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before discussing Rootstock in detail, it's important to define and introduce
    some concepts that are fundamental to the design of Rootstock. These concepts
    include sidechains, drivechains, and two-way pegging. The concept of the sidechain
    was originally developed by Blockstream.
  prefs: []
  type: TYPE_NORMAL
- en: Two way pegging is a mechanism by which value (coins) can transfer between one
    blockchain to another and vice versa. There is no real transfer of coin between
    chains. The idea revolves around the concept of locking the same amount and value
    of coins in a bitcoin blockchain (main chain) and unlocking the equivalent amount
    of tokens in the secondary chain.
  prefs: []
  type: TYPE_NORMAL
- en: Bearing this definition in mind, sidechains can be defined as described in the
    following section. Bearing this definition in mind, sidechains can be defined
    as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sidechain**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a blockchain that runs in parallel with a main blockchain and allows
    transfer of value between them. This means that tokens from one blockchain can
    be used in the sidechain and vice versa. This is also called a pegged sidechain
    because it supports two-way pegged assets.
  prefs: []
  type: TYPE_NORMAL
- en: Drivechain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a relatively new concept, where control on unlocking the locked bitcoins
    (in mainchain) is given to the miners who can vote when to unlock them. This is
    in contrast to sidechains, where consensus is validated though Simple payment
    verification mechanism in order to transfer the coins back to the mainchain.
  prefs: []
  type: TYPE_NORMAL
- en: Rootstock is a smart contract platform which has a two-way peg into bitcoin
    blockchain. The core idea is to increase the scalability and performance of the
    bitcoin system and enable it to work with smart contracts. Rootstock runs a Turing
    complete deterministic virtual machine called **Rootstock Virtual Machine** (**RVM**).
    It is also compatible with the Ethereum virtual machine and allows solidity-compiled
    contracts to run on Rootstock. Smart contracts can also run under the time-a tested
    security of bitcoin blockchain. The Rootstock blockchain works by merge mining
    with bitcoins. This allows RSK blockchain to achieve the same security level as
    bitcoin. This is especially true for preventing double spends and achieving settlement
    finality. It allows scalability, up to 100 transactions per second.
  prefs: []
  type: TYPE_NORMAL
- en: RSK has recently released a test network called Turmeric. It is available at
    [http://www.rsk.co/](http://www.rsk.co/).
  prefs: []
  type: TYPE_NORMAL
- en: Quorum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a blockchain solution built by enhancing the existing Ethereum blockchain.
    There are several enhancements such as transaction privacy and a new consensus
    mechanism that has been introduced in Quorum. Quorum has introduced a new consensus
    model known as QuorumChain, which is based on a majority voting and time based
    mechanism. Another feature called Constellation is also introduced which is a
    general purpose mechanism for submitting information and allows encrypted communication
    between peers. Furthermore, permissioning at node level is governed by smart contracts.
    It also provides a higher level of performance compared to public Ethereum blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Several components make up the Quorum blockchain ecosystem. These are listed
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction manager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This component enables access to encrypted transaction data. It also manages
    local storage and communication with other Transaction managers on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto Enclave
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, this component is responsible for providing cryptographic
    services to ensure transaction privacy. It is also responsible for performing
    key management functions.
  prefs: []
  type: TYPE_NORMAL
- en: QuorumChain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the key innovation in Quorum. It is a Byzantine Fault-tolerant consensus
    mechanism which allows verification and circulation of votes via transactions
    on the blockchain network. In this scheme, a smart contract is used to manage
    the consensus process and nodes can be given voting rights to vote on which new
    block should be accepted. Once an appropriate number of votes is received by the
    voters, the block is considered valid. Nodes can have two roles, namely *Voter*
    or *Maker*. The *Voter* node is allowed to vote, whereas the *Maker* node is the
    one that creates a new block. A node can have either rights, none or only one.
  prefs: []
  type: TYPE_NORMAL
- en: Network manager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This component provides an access control layer for the permissioned network.
  prefs: []
  type: TYPE_NORMAL
- en: A node in the quorum network can take several roles, for example, a Maker node
    that is allowed to create new blocks. Transaction privacy is provided using cryptography
    and the concept that certain transactions are meant to be viewable only by their
    relevant participants. This idea is similar to Corda's idea of private transactions
    that was discussed in the last chapter. As it allows both public and private transactions
    on the blockchain, the state database has been divided into two databases representing
    private and public transactions. As such, there are two separate Patricia-Merkle
    trees that represent the private and public state of the network. A private contract
    state hash is used to provide consensus evidence in private transactions between
    transacting parties.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction in a quorum network consists of various elements such as the recipient,
    the digital signature of the sender, which is used to identify the transaction
    originator, optional ether amount, the optional list of participants that are
    allowed to see the transaction, and a field that contains a hash in case of private
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A transaction goes through several steps before it can reach its destination.
    These steps are described as follows in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: User applications (DAPPs) send the transaction to the quorum node via an API
    exposed by the blockchain network. This also contains the recipient address and
    transaction data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API then encrypts the payload and applies any other necessary cryptographic
    algorithm in order to ensure privacy of the transaction, and is sent to the Transaction
    manager. The hash of the encrypted payload is also calculated at this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After receiving the transaction, the Transaction manager validates the signature
    of the transaction sender and stores the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hash of the previously encrypted payload is sent to the Quorum node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Quorum node starts to validate a block that contains the private transaction,
    it requests more relevant data from the Transaction manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this request is received by the Transaction manager, it sends the encrypted
    payload and relevant symmetric keys to the requestor quorum node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Quorum node has all the data, it decrypts the payload and sends it
    to the EVM for execution. This is how Quorum achieves privacy with symmetric encryption
    on the blockchain, while it is able to use native Ethereum protocol and EVM for
    message transfer and execution respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A similar concept, but quite different in a few aspects, has been proposed before
    in the form of **Hydrachain**, which is based on Ethereum blockchain and allows
    creation of permissioned distributed ledgers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quorum is available for download at [https://github.com/jpmorganchase/quorum](https://github.com/jpmorganchase/quorum).
  prefs: []
  type: TYPE_NORMAL
- en: Tezos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tezos is a generic self-amending cryptographic ledger, which means that it not
    only allows decentralized consensus on the state of the blockchain but also allows
    consensus on how the protocol and nodes are evolved over time. Tezos has been
    developed to address limitations in bitcoin protocol such as issues arising from
    hard forks, cost, and mining power centralization due to Proof of Work, limited
    scripting ability, and security issues. It has been developed in a purely functional
    language called OCaml.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of Tezos distributed ledger is divided into three layers:
    the network layer, consensus layer, and transaction layer. This decomposition
    allows protocol to be evolved in a decentralized fashion. For this purpose, a
    generic network shell is implemented in Tezos that is responsible for maintaining
    the blockchain, which is represented by a combination of consensus and transaction
    layer. This shell provides an interface layer between the network and the protocol.
    A concept of seed protocol has also been introduced, which is used as a mechanism
    to allow stakeholders on the network to approve any changes to the protocol. Tezos
    blockchain starts from a seed protocol compared to a traditional blockchain that
    starts from a genesis block.'
  prefs: []
  type: TYPE_NORMAL
- en: This seed protocol is responsible for defining procedures for amendments in
    the blockchain and even the amendment protocol itself. The reward mechanism in
    Tezos is based on a **Proof of Stake** (**PoS**) algorithm, therefore there is
    no mining requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Contract script language has been developed in Tezos for writing smart contracts,
    which is a stack-based Turing complete language. Smart contracts in Tezos are
    formally verifiable, which allows the code to be mathematically proven for its
    correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Tezos code is available at [https://github.com/tezos/tezos](https://github.com/tezos/tezos).
  prefs: []
  type: TYPE_NORMAL
- en: Storj
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Existing models for cloud-based storage are all centralized solutions, which
    may or may not be as secure as users expect them to be. There is a need to have
    a cloud storage system that is secure, highly available, and above all decentralized.
    Storj aims to provide blockchain based, decentralized, and distributed storage.
    It is a cloud shared by the community instead of a central organization. It allows
    execution of storage contracts between nodes that act as autonomous agents. These
    agents (nodes) execute various functions such as data transfer, validation, and
    perform data integrity checks. The core concept is based on **Distributed Hash
    Tables** (**DHT**) -Kademlia, however this protocol has been enhanced by adding
    new message types and functionalities in Storj. It also implements a peer to peer
    **publish/subscribe** (**pub/sub**) mechanism known as Quasar, which ensures that
    messages successfully reach the nodes that are interested in storage contracts.
    This is achieved via a bloom filter-based storage contract parameters selection
    mechanism called **topics**.
  prefs: []
  type: TYPE_NORMAL
- en: Storj stores files in an encrypted format spread across the network. Before
    the file is stored on the network, it is encrypted using AES-256-CTR symmetric
    encryption and is then stored piece by piece in a distributed manner on the network.
    This process of dissecting the file into pieces is called **sharding** and results
    in increased availability, security, performance, and privacy of the network.
    Also if a node fails the shard is still available because by default a single
    shard is stored at three different locations on the network.
  prefs: []
  type: TYPE_NORMAL
- en: It maintains a blockchain, which serves as a shared ledger and implements standard
    security features such as public/private key cryptography and hash functions similar
    to any other blockchain. As the system is based on hard drive sharing between
    peers, anyone can contribute by sharing their extra space on the drive and get
    paid with Storj's own cryptocurrency called **Storjcoinx** (**SJCX**). SJCX was
    developed as a *counterparty* asset and makes use of bitcoin blockchain for transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Storj code is available at [https://github.com/Storj/](https://github.com/Storj/).
  prefs: []
  type: TYPE_NORMAL
- en: Maidsafe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another distributed storage system similar to Storj. Users are paid
    in Safecoin for their storage space contribution to the network. This mechanism
    of payment is governed by *proof of resource*, which ensures that the disk space
    committed by a user to the network is available, if not then the payment of Safecoin
    will drop accordingly. The files are encrypted and divided into small portions
    before being transmitted on to the network for storage. Another concept of **opportunistic
    caching** has been introduced with Maidsafe, which is a mechanism to create copies
    of frequently accessed data physically closer to where the access requests are
    coming from, which results in high performance of the network. Another novel feature
    of the SAFE network is that it automatically removes any duplicate data on the
    network, thus resulting in reduced storage requirements. Moreover, the concept
    of **churning** has also been introduced, which basically means that data is constantly
    moved across the network so that the data cannot be targeted by malicious adversaries.
    It also keeps multiple copies of data across the network to provide redundancy
    in case a node goes offline or fails.
  prefs: []
  type: TYPE_NORMAL
- en: BigChainDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a scalable blockchain database. It is not strictly a blockchain itself,
    but complements blockchain technology by providing a decentralized database. At
    its core it's a distributed database but with the added attributes of a blockchain
    such as decentralization, immutability, and handling of digital assets. It also
    allows usage of NoSQL for querying the database. It is intended to provide a database
    in a decentralized ecosystem where not only processing is decentralized (blockchain)
    or the file system is decentralized (for example, IPFS) but the database is also
    decentralized. This makes the whole decentralized application ecosystem decentralized.
    This is available at [https://www.bigchaindb.com/](https://www.bigchaindb.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Multichain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multichain has been developed as a platform for the development and deployment
    of private blockchains. It is based on bitcoin code and addresses security, scalability,
    and privacy issues. It is a highly configurable blockchain platform that allows
    users to set different blockchain parameters. It supports control and privacy
    via a granular Permissioning layer. Installation of Multichain is very quick and
    links to installation files are available at [http://www.multichain.com/download-install/](http://www.multichain.com/download-install/).
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tendermint is a software that provides a Byzantine fault-tolerant consensus
    mechanism and state machine replication functionality to an application. Its main
    motivation is to develop a general purpose, secure, and high-performance replicated
    state machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are two components in Tendermint, which are described in following section.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint Core
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a consensus engine that enables secure replication of transactions on
    each node in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint Socket Protocol (TMSP)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is an application interface protocol that allows interfacing with any programming
    language to process transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint allows decoupling of the application process and consensus process,
    which allows any application to benefit from the consensus mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The Tendermint consensus algorithm is a round-based mechanism where validator
    nodes propose new blocks in each round. A locking mechanism is used to ensure
    protection against a scenario where two different blocks are selected for committing
    at the same height of the blockchain. Each validator node maintains a full local
    replicated ledger of blocks that contain transactions. Each block contains a header,
    which consists of the previous block hash, timestamp of the proposal of block,
    current block height, and merkle root hash of all transactions present in the
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint has recently been used in **Cosmos**, which is a network of blockchains
    that allows interoperability between different chains running on BFT consensus
    algorithm. Blockchains on this network are called zones. The first zone in Cosmos
    is called Cosmos hub, which is in fact a public blockchain and is responsible
    for providing connectivity service to other blockchains. For this purpose, the
    hub makes use of **Inter Blockchain Communication protocol** (**IBC**). IBC protocol
    supports two types of transactions called *IBCBlockCimmitTx* and *IBCPacketTx*.
    The first type is used to provide proof of the most recent block hash in a blockchain
    to any party, whereas the latter type is used to provide data origin authentication.
    A packet from one blockchain to another is published by first posting a proof
    to the target chain. The receiving (target) chain checks this proof in order to
    verify that the sending chain has indeed published the packet. In addition, it
    has its own native currency called Atom. This scheme addresses scalability and
    interoperability issues by allowing multiple blockchains to connect to the hub.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint is available at [https://tendermint.com/](https://tendermint.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers various platforms that have been developed to enhance the
    experience of existing blockchain solutions. First, an Ethereum-compliant solution
    named BlockApps STRATO will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: BlockApps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BlockApps is a platform that provides a rich set of tools to build blockchain
    applications. This platform is written in Haskell and is based on modular architecture.
    The solution is scalable and makes it easier to deploy smart contracts and blockchain
    applications. It is available at [http://www.blockapps.net/](http://www.blockapps.net/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, installation and a simple example of deployment will be
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BlockApps can be installed via npm by using the command shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`sudo` is optional, if no administrative rights are required. This will produce
    an output similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: bloc installation via npm (output truncated)
  prefs: []
  type: TYPE_NORMAL
- en: Once installation is complete, applications can be created by following the
    steps shown in following section. An example is shown below that shows how to
    initialize a new application in BlockApps, deploy it on BlockApps TestNet and
    interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Application development and deployment using BlockApps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to initialize the BlockApps application using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It will ask for several parameters: the name of the app, your name, e-mail,
    API URL (apiUrl), and blockchain profile. This is shown in the following screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the command runs and completes successfully, it will create an application
    directory with templates and samples. In this instance, a directory named testApp
    will be created with relevant directories and sample contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: bloc init
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to install the `testApp` which can be achieved by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Application development and deployment using BlockApps](img/image_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: testApp installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation of a new key is required in order to sign the transactions. Keys
    can be generated by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once issued, a password will have to be entered in order to protect the key.
    Once provided, the key will be created and a JSON file will be created. Note that
    the JSON file name is the actual address of the account on the blockchain. Also,
    it will display the message transaction mined, indicating success and deployment
    of the key and transaction (account creation) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generate key
  prefs: []
  type: TYPE_NORMAL
- en: Now, at this point, the new account can be queried by using curl. Simply pass
    the address as an argument in the URL and the result will be returned in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Query the new account using curl
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, a query can be executed via any web browser as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: BlockApps query via web browser
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the process to upload the new contract to the test chain will
    be described. Note that all the contracts are placed in the `./app/contracts`
    directory under the `testApp` directory. As a sample, `Greeter.sol` contract has
    been chosen to be deployed to the network. BlockApps provides an easy method to
    achieve this deployment.
  prefs: []
  type: TYPE_NORMAL
- en: All contracts needs to be placed under the contracts directory in order for
    the compile command to find them and compile.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Greeter contract under contracts directory
  prefs: []
  type: TYPE_NORMAL
- en: Contracts can be compiled by using the command shown in the following screenshot.
    Note that it takes that contract file name as an argument. After successful compilation,
    all relevant JSON files will be written under `./meta` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compilation of Greeter contract
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the contract can be uploaded using the following command. This command
    expects the argument passed to the contract as defined in the contract code. In
    the example, it expected a text string as shown in the following example screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Application development and deployment using BlockApps](img/image_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upload of Greeter contract
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, in case correct arguments are not passed or missing, an error similar
    to following screenshot will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Error in case of wrong or missing arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the deployment is successful it can be verified that the ether has transferred
    from the existing contract to the new contract. Note that the balance has dropped.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deployed contract after installation via web browser
  prefs: []
  type: TYPE_NORMAL
- en: After deployment of the contract, it can be queried using a web browser or any
    CLI tools such as cURL. The URL [http://strato-dev4.blockapps.net/eth/v1.2/account?address=05ee3af04e903f413402d5438b9de3827b1f4e70](http://strato-dev4.blockapps.net/eth/v1.2/account?address=05ee3af04e903f413402d5438b9de3827b1f4e70)
    is required to be passed to the web browser. This is shown in the following screenshot.
    Note that the code in binary format is also available in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Browse to the deployed contract, with code in binary format
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, BlockApps has a feature available to run a local HTTP server,
    which can be started by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will start the web browser, and listen on TCP port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: bloc start
  prefs: []
  type: TYPE_NORMAL
- en: 'After the web server starts, the compiled contracts can be viewed and queried
    using the local web page available as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application development and deployment using BlockApps](img/image_10_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compiled contracts available via browser
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated in the preceding example it is easier to build, deploy, and
    manage contracts using BlockApps. BlockApps aims to provide tools and core infrastructure
    for blockchain applications, and not just blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Eris
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eris is not a single blockchain, it is an open modular platform developed by
    Monax for development of blockchain-based *ecosystem applications*. It offers
    various frameworks, SDKs, and tools that allow accelerated development and deployment
    of blockchain applications. The core idea behind the Eris application platform
    is to enable development and management of *ecosystem applications* with a blockchain
    backend. It allows integration with multiple blockchains and enables various third
    party systems to interact with various other systems. This platform makes use
    of smart contracts written in solidity language. It can interact with blockchains
    such as Ethereum or bitcoin. The interaction can include connectivity commands,
    start, stop, disconnection, and creation of new blockchains. Complexity related
    to setup and interaction with blockchains have been abstracted away in Eris. All
    commands are standardized for different blockchains, and the same commands can
    be used across the platform regardless of the blockchain type being targeted.
  prefs: []
  type: TYPE_NORMAL
- en: 'An ecosystem application can consist the Eris platform, enabling the API gateway
    to allow legacy applications to connect to key management systems, consensus engines,
    and application engines. The Eris platform provides various toolkits that are
    used to provide various services to the developers. These modules are described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chains**: This allows the creation of and interaction with blockchains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packages**: This allows the development of smart contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keys**: This is used for key management and signing operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**: This allows working with distributed data management systems. It
    can be used to interact with file systems such as IPFS and data lakes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: This exposes a set of services that allows the management and
    integration of ecosystem applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several SDKs has also been developed by Eris that allow the development and
    management of ecosystem applications. These SDKs contain smart contracts that
    have been fully tested and address specific needs and requirements of business.
    For example, a finance SDK, insurance SDK, and logistics SDK. There is also a
    base SDK that serves as a basic development kit to manage the lifecycle of an
    ecosystem application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monax has developed its own permissioned blockchain client called Eris:db.
    It is a **Proof of Stake-based** (**PoS**) blockchain system that allows integration
    with a number of different blockchain networks. `Eris:db` consist of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus**: This is based on the Tendermint consensus mechanism, discussed
    before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual machine**: Eris uses **Ethereum Virtual Machine** (**EVM**), as such
    it supports solidity compiled contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions layer**: Being a permissioned ledger, Eris provides an access
    control mechanism that can be used to assign specific roles to different entities
    on the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: This provides various commandline tools and RPC interfaces to
    enable interaction with the backend blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key difference between Ethereum blockchain and Eris:db is that Eris:db makes
    use of a Practical Byzantine Fault-Tolerance algorithm, which is implemented as
    a deposit-based Proof of Stake (DPOS system) whereas Ethereum uses **Proof of
    Work** (**PoW**). Moreover, `Eris:db` uses the ECDSA ed22519 curve scheme whereas
    Ethereum uses the secp256k1 algorithm. Finally, it is permissioned with an access
    control layer on top whereas Ethereum is a public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Eris is a feature-rich application platform that offers a large selection of
    toolkits and services to develop blockchain-based applications. It is available
    at [https://monax.io/](https://monax.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with the introduction of alternative blockchains and is
    divided into two main sections discussing blockchains and platforms. Blockchain
    technology is a very thriving area, as such changes are quite rapid in existing
    solutions and new relevant technologies or tools are being introduced almost every
    day. In this chapter, a careful selection of platforms and blockchains was discussed.
    Several solutions were discussed that complement material covered in previous
    chapters, for example, BlockApps, which supports Ethereum development. New blockchains
    such as Kadena, various new protocols such as Ripple, and concepts such as sidechains
    and drivechains were also discussed. The material covered in this chapter is intended
    to provide a strong foundation for more in-depth research into areas that readers
    are interested in. As said before, blockchain is a very fast moving field and
    there are many other blockchain proposals projects such as **Tauchain**, **Hydrachain**,
    **Elements**, **credits**,and many more that have not been discussed in this chapter.
    Readers are encouraged to keep an eye on the developments in this field in order
    to keep themselves up to date with advancement in this rapidly growing area.
  prefs: []
  type: TYPE_NORMAL
