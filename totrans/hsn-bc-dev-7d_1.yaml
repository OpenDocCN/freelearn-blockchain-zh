- en: Day One - Application Introduction, Installation, and Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain is such a vast topic, is it even possible to become productive, to
    launch your blockchain project, or get that job as a blockchain developer in just
    a week? Blockchain tech is showing up in every industry, from how we bank to how
    we travel, how we prove our identity, and even how we get healthcare, and more.
    So, it raises the question in our minds, can you really learn to create a blockchain
    application in just seven days?
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you're going to learn how to create an online gaming application
    using the Ethereum blockchain in seven days! Along the way, you'll learn how to
    create and use variables using Solidity, and execute business logic using functions;
    you'll eliminate mistakes and errors in code by learning to write tests, and you'll
    interact with the Ethereum blockchain through a user interface that will use React
    and Redux. You'll write code to send and receive funds from your decentralized
    application, and finally you'll learn how to deploy your decentralized app to
    the Ethereum network and Amazon Web Services. In this book, we will break everything
    down to the basics, so you can be confident that the only thing you need to be
    successful is a desire to become a blockchain developer and a willingness to put
    in the effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will serve as the stepping stone to getting started with this
    project, covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the app that we''re going to be building. We''re
    going to build a gaming application that shows our players a number between 0
    and 9, and then they have options to bet whether a mystery number is higher or
    lower than the shown number, and then it can stake how much ether they''re willing
    to bet. The result of their gameplay is shown in the history window, and when
    they win or lose, the money is automatically added or debited from their Ethereum
    account. The following screenshot shows a demo of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8899e320-a7c9-4e99-a33c-47e7f1fa5912.png)'
  prefs: []
  type: TYPE_IMG
- en: To build this, you'll be using Solidity to create the contract that contains
    and executes the rules of the game on the blockchain network. The user interface
    will be written in React, and you'll use Solidity to write the contract code.
    You're going to learn about a tool called Ganache that allows you to host your
    own Ethereum blockchain on your local workstation. We are now ready to start building
    the application. Let's begin by setting up all the required tools on our workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at all the tools you're going to need, not only for this book,
    but to be successful as a blockchain developer. We will learn about all the technologies
    used to host our application, compile, and migrate our code, and test our application.
    So let's get started with our first tool!
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first tool we will use is Visual Studio Code. In its simplest form, it''s
    a text editor, but as you get more familiar with it, it becomes part of your soul
    as a blockchain developer. It packs in a bunch of features that will make your
    life easier, such as syntax highlighting, IntelliSense, and extensions for specific
    programming languages such as the ones we''ll be using in this book: JavaScript
    and Solidity. We''ll use Visual Studio Code to create our smart contract using
    the Solidity programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, go to the following website: [https://code.visualstudio.com/](https://code.visualstudio.com/),
    and download the installation package for your operating system. You should see
    a landing page that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f85ac17-c8c8-4b08-b76b-367b7dc28594.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the one tool that isn't mandatory; all you really need is a code editor
    that you're familiar with, so if you already have an editor you can continue to
    use it for this book as well.
  prefs: []
  type: TYPE_NORMAL
- en: Our smart contract provides two rules for our application—it's written in a
    programming language called Solidity and it lives on the Ethereum blockchain network.
    Another way to think of the contract is to imagine buying a car. In doing so,
    you agree to a purchase price, a down payment, and possibly financing terms. All
    of those details are entered into a contract you sign to purchase the vehicle.
    Instead of printing out that contract and signing a piece of paper, we'll put
    those details into a smart contract, which you or the buyer signs cryptographically.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also use Visual Studio Code to write the JavaScript that renders our website's
    user interface for our application. We'll specifically be using React and Redux
    to create that user interface. Ultimately, what we want to happen is for someone
    to go to our website and for a server to send them a web page containing our application.
    We're going to use Node.js for that so you'll need to install it.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, we will need a networking framework
    that we can use to send and receive data to and from our website. Node.js is one
    of the most popular frameworks used worldwide for such purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js is primarily used for implementing backend APIs that can run JavaScript
    code outside the browser. In this book, we will be using it as a way to connect
    our contracts, GUI, and programming backend into our website. You can install
    Node.js by going to [https://nodejs.org/en/download/](https://nodejs.org/en/download/),
    and choosing the right package for your OS. The landing page for Node.js looks
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01dd018e-c837-4242-a583-216d318e18e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Truffle framework and Ganache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user takes an action in our application that needs to be written into
    the blockchain, it is called a **transaction**. The transaction isn't written
    immediately; instead, it's sent to the network where it waits until it's confirmed
    as a valid transaction by the miners. Once the miners confirm it, it's written
    to the blockchain, at which point we can provide updated state information to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all of this on the Ethereum network represents hundreds of thousands of
    servers, but we don't have hundreds of thousands of servers just lying around,
    and you don't want to wait on external servers every time you need to test during
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re going to use Ganache to simulate our own Ethereum network. It''s
    a standalone application that can create an Ethereum test network on your own
    workstation. To install Ganache, we''ll head to [https://truffleframework.com/ganache](https://truffleframework.com/ganache),
    and download its installer package. The following screenshot shows the landing
    page for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a67c0266-b692-46d7-8aaa-53e7d31f6aa4.png)'
  prefs: []
  type: TYPE_IMG
- en: Once this is done, we need to install the Truffle framework. This is an Ethereum
    development framework that makes it easier for us to do things, like compile our
    contract, interact with the blockchain network, and migrate our contract to the
    Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we''re going to open up a Terminal, whether that means Bash shell
    or Windows Command Prompt, and we will type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note, `npm` is packaged as part of Node.js, which means that if you skip past
    the install Node.js step, you'll need to go back and complete it before this command
    is going to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to get the code required for our application, we will use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads and sets up the code for you. Please ensure that you
    replace the `github_url` value in the preceding block with the actual GitHub repository
    of the book!
  prefs: []
  type: TYPE_NORMAL
- en: You might get some errors while running the `truffle` command. This is a known
    problem and has been embedded as part of the official documentation. You can refer
    to the following link to find the workaround for it: [https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows](https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows).
  prefs: []
  type: TYPE_NORMAL
- en: With our prerequisites out of the way, it's time to get on to some more fun
    stuff, which includes writing some code. In the next section, we're going to take
    a look at what it means to write a contract, and how it interacts as part of the
    blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn the basics of Ethereum contracts. You will learn
    what they are, where they live, how to create them, and how to deploy them to
    the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: A **contract** is a collection of code represented by its functions and data,
    or by the current state of the contract. It resides at a specific address on the
    Ethereum network, and one of the important things to remember is that the Ethereum
    network is public, which means that anyone can view your contract and its data.
  prefs: []
  type: TYPE_NORMAL
- en: This is different from traditional applications that you may be familiar with.
    In traditional apps, the code is typically stored in an application, while the
    data resides elsewhere, either in files on a disk or a database. Now, let's see
    what a contract consists of.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for our contracts are stored in the `contracts` folder. When
    we compile them, they''re sent out to the Ethereum blockchain. Compiling also
    creates a contract metadata that is stored in the `build/contracts` folder. The
    following screenshot shows the structure of the application that we will be building:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1157759a-f86e-4ccc-bf80-00526e23cd91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The contract itself starts with a `pragma` statement, and the `pragma` statement
    tells the compiler about the code. In our case, we want to tell the compiler that
    this code is written in the Solidity programming language, and it uses the `0.5.0` version
    of the Solidity language. So, the code that mentions this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The version info you see in the preceding code block is **SemVer** or **semantic
    versioning**. Basically, in SemVer, the first number represents the major version
    of the package, the middle number represents the minor version, and the third
    number represents the patch level.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key things to remember when upgrading is that upgrading a version
    may make some things incompatible; however, one of the nice things about applications
    that follow SemVer is that if you introduce a change that's not backward compatible
    with the previous versions, you can increment the major version number to tell
    the compiler to use the later patches of the tool. Also, it's not as common, but
    some applications will introduce breaking changes with the minor patch number
    as well, and that's why we use the `^` sign in the code, for older versions of
    Solidity. This `^` sign tells the compiler that it's okay to use any version of
    the Solidity programming language from `0.4.24` all the way up to but not including
    `0.5.0`. This ensures that the version of the compiler that you're using is going
    to be compatible with the version that you wrote it with. However, since we are
    using `0.5.0` here, we won't incorporate that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a contract, we use the `contract` keyword followed by the name of
    our contract, and it''s a common convention that this contract name follows the
    name of the file, so the file for this `Gaming` contract would be `Gaming.sol`.
    We have a set of opening brackets `{` and then if you need to include comments
    you can do so, much like you do in a SQL programming language, with the `/*` sign,
    and we close out our contract with the `}` sign. This can been seen in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a special function in Solidity called a **constructor** function,
    and it runs only once when the contract is created. It''s typically used to initialize
    a contract data. For example, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code snippet, we've got a variable called `owner` and
    a variable called `online`. When the contract is created, we set the `owner` variable
    as the Ethereum address that pushed the contract into the network, and we also
    set the `online` variable as true.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a compiled language, and in order to use the contract on the blockchain,
    it must be compiled and migrated to that network. To compile it, we're going to
    use the Truffle framework. We can do it with the `truffle compile` command, which
    creates a JSON file that contains the contract metadata with information about
    your contract, and we'll use that JSON file to interact with the contract and
    verify its source.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use our contract on the blockchain network, we have to get it from
    our workstation and out into the network, and that's known as **migration**. Because
    we're using the Truffle framework, we can easily do that with the `truffle migrate`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at our directory layout, in the `migrations` directory, we
    will find a file called `1_initial_migration.js`. That file is provided by the
    Truffle framework, and it handles deploying of the contracts. Let''s take a look
    at the code in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's a variable called `Migrations` that requires the Truffle library `Migrations.sol`,
    and then it exports a function which takes a `deployer` object to deploy the migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also got a file called `2_deploy_contracts.js` that''s included in the
    download. That''s the file that''s actually going to migrate the contracts that
    we write as part of this book. Let''s take a look at the code in that file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous file, there's a variable called `Gaming` that requires
    the `Gaming.sol` contract file that we created, and it then runs the deploy method
    to deploy the `Gaming` contract.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help cement this idea of migration, we''ll actually migrate some contracts,
    and then we''ll analyze what happens to the network. To do that, we will use the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to start the Ganache application that will get our private
    blockchain up and running, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a7078b4-ce8a-4348-891c-936c3dc2100b.png)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding screenshot, we've got the Ganache application running.
    Let's take a look at the balance, which is currently 100 ether, and there have
    been no blocks mined, and no transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching over to the console, we will type in the following command to migrate
    the contract to the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the migration is successful, we''ll return to Ganache where we will be
    greeted by something similar to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3f0b754-859a-486c-b04a-ad6b27c39dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that address 0 or account 0 has spent some ether. That was used to
    pay for the migration of that contract. Looking at the blocks, we can see that
    there were four blocks mined, as well as four transactions used to create and
    migrate those contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we switch over to the code editor, in this case Visual Studio Code, in the
    `build/contracts` folder, you can see the contract metadata files here that were
    created as a result of the compiling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d923bc2-8862-49d8-8e27-85e32d8ee401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we open the `Migrations.json` file and scroll all the way to the bottom,
    you can see that it stores the networks that this contract has been deployed to,
    as well as the address of the deployed contract, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dfee7ec-a19d-4fb0-bdc1-98309d9a69d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully created and deployed your first contract
    if you've reached here. You've already seen some of the syntax used as we specified
    the `owner` variable and built a `constructor` function. In the next section,
    we'll discuss some of the syntax and style guides used with the Solidity programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't start our learning journey without covering some of the basic syntax
    guidelines for developing Solidity code. The goal of consistency when writing
    code is not to determine what's right or wrong, but to offer guidelines to help
    ensure that it's always the same. This makes the code more legible and easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important point to remember—it's not the right way or the best way,
    just a consistent way. This doesn't mean that the style guidelines apply for every
    instance. When in doubt, you should look at other script examples and then use
    your best judgment.
  prefs: []
  type: TYPE_NORMAL
- en: Code layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For code layout, we should always use four spaces per indentation level. Spaces
    are preferred over tabs, but even if you use tabs, just avoid mixing tabs and
    spaces in the same file. Let''s take a look at an example in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `contract` as specified first, then the first function declared
    is indented by four spaces. The `if` block itself is indented four spaces from
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Blank lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s recommended to surround top-level declarations with two blank lines,
    and surround function level declarations with a single blank line. This will essentially
    help you to find bugs more quickly than scrolling through a randomly ordered file
    and hoping to find the required line. Let''s use the following example to see
    how we should use blank lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have two contracts declared, and in between
    those two contracts are two blank lines, just so there's a nice big white space
    to tell them apart easily. In our function declarations, each function is separated
    by a single blank line. This should help in easily distinguishing each element
    of the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Line lengths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For line lengths, it''s recommended to have a maximum of 79 characters. The
    recommendation of 79 characters was set way back in the day when people used TTY
    terminals with a maximum width of 80 characters. It''s actually becoming quite
    common now to see up to 99 characters for the line width. Let''s refer to the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As seen here, the first argument is not attached to the line where the function
    is declared, and it's separated by one indent only. Also, there is only one argument
    per line, and, finally, the terminating element goes on a line by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Function layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your functions should be laid out in a specific order. This is the correct
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We haven't talked about functions yet, so what these mean may still be a little
    bit fuzzy to you, but we're going to go into this in great detail in the next
    section, so sit tight with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For structuring the functions, we''re going to open the bracket on the same
    line as the declaration and close the line at the same indentation level as the
    beginning declaration. Also, that opening bracket should be preceded by a single
    space. Let''s have a look at the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As seen, when we declare the `Gaming` contract, we have our opening curly bracket
    with the space in between. Similarly, for our `determineWinner()` function, it
    has the opening curly brace on the same line, and then the closing brace for our
    function is right below it, where the first character for the function begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to declaring variables, double quotes are preferred for strings
    over single quotes. We surround our operators with a space on either side as it
    just helps them stand out in the code so that you can identify them more easily.
    The following code snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The exception to this is when you have operators with a higher priority, you
    can omit the surrounding space in order to signify its precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When naming variables, you should always avoid single-letter variable names,
    such as int L, bool O, and so on. The reason for this is that they're very similar
    looking, and it's just an unnecessary level of complexity added to your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re naming contracts, libraries, structs, and events, you want to
    use CapWords (or CamelCase), where you capitalize the first letter of each word
    in the variable name. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When naming functions, function arguments, variables, and modifiers, you should
    use mixedCase, which is very similar to CapWords, except that you don''t capitalize
    the first letter as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When naming constants, you want to name them in all capitals.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the underscore (**_**) symbol to avoid naming collisions between
    functions, variables, and other objects in the code. The following code block
    shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, I've got this function called `mysteryNumber()`,
    and later in the code when that function is used, it really makes sense for me
    to call my variable `mysteryNumber`, since it is a mysterious number, but I can't
    reuse that name without causing a name collision. So, when I actually get the
    mystery number variable, I put an underscore at the end of it so that `mysteryNumber_` becomes
    the variable that I got from the `mysteryNumber()` function. This makes it easy
    to tell those two apart, yet very clear where I got that mystery number from.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you may be seeing how implementing consistent guidelines about how we
    write the code makes it easier to read and maintain the code. While it's true
    that it doesn't make the code run faster or guarantee that it's correct, it does
    make the human element of coding more enjoyable, which in turn may make it easier
    to collaborate and discuss the function rather than the format of the code. In
    the next section, we're going to take a look at writing tests for our code and
    *why* exactly we would want to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to write code efficiently. While that
    makes it easier to read, it doesn't mean that our code works at all, after all
    broken code should look pretty too, right?
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about your current testing strategy for a minute. After writing your
    code, do you manually test it by using it and then examining the output, and then
    you repeat the same process before you publish the latest release? Well, let me
    ask you this, have you ever forgotten a step, and as a result you released a bug
    in your code that could have been caught if you'd remembered to do that step? Running
    tests before you make any changes is a great idea. We've all spent quite a bit
    of time trying to figure out how our code broke a test, only to find out later
    that the test was broken before we started making any changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, let's write tests that automatically do that for us, and we'll
    use all the time that we save on testing, to write more great code. Our tests
    can be written in Solidity, or they can be written in JavaScript. They can automatically
    validate that the code executes as it's intended to, and they should be run before
    and after every code change.
  prefs: []
  type: TYPE_NORMAL
- en: So, for testing the `Gaming` contract, we're going to name our test file `TestGaming.sol`,
    and the tests themselves go into the `test` directory of the project. They're
    also an actual Solidity contract, which makes them relatively easy to write because
    you use the same techniques that you use to write any other Solidity contract.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an actual example test contract from the application and
    some of the best practices for implementing them. You can access the contract
    by opening the `TestGaming.sol` file in the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s break this contract down into individual bits. The contract begins
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have the `pragma solidity` statement and our Solidity version. Then,
    we import the `Assert` library and `DeployedAddresses` library from Truffle. Along
    with that, we will import the actual contract that we are testing this on, which
    is `Gaming.sol`. The next step is to define our contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Just like any other Solidity contract, we define our contract and give it the
    name `TestGaming`. We give it some initial `ether` to hold on to that we can use
    for our tests, and then we create our `gaming `variable, which is an instance
    of the `Gaming` contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before any of our tests run, we go ahead and grab our deployed contract because
    during the test, every test run deploys a fresh instance of the contract to the
    test network. The following lines of code show how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create functions for every test scenario that we want to test, as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `testPlayerWonGuessHigher()` function tests whether the player guessed that
    the numbers should be higher, and if the number actually was higher, then they
    should have won.
  prefs: []
  type: TYPE_NORMAL
- en: The `testPlayerLostGuessLower()` function tests whether a player who guessed
    lower when the number actually was higher should have lost.
  prefs: []
  type: TYPE_NORMAL
- en: We set up these scenarios in our test, define what we expect to happen, and
    then use these assertions to verify that that's actually what happened. So all
    we have to do is run this test any time we need to feel the need or right before
    we deploy, and we can confidently say that our functions for determining who wins
    and who loses the game are accurately working.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In each chapter of this book, I''m going to give you a homework assignment
    to be completed before you start the next day or chapter. Today''s homework assignment
    is all about getting your development environment set up. Not only is this going
    to help you complete the remainder of this book, but the tools I''m going to show
    you will help you across every blockchain project you take on. Here''s what you
    need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Visual Studio Code. This is the only step that's optional, and it's
    optional only if you already have a code editor that you know and love.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Node.js from [nodejs.org](http://nodejs.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Ganache from the Truffle framework website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Truffle framework itself using the `npm` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've installed Truffle previously, be sure to check that you have at least
    Truffle version 4.1 installed, and if not update it. You can always check your
    Truffle version using the `truffle version` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, install the course code using the `truffle unbox` command and the URL
    for the GitHub repo of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is done, launch Terminal or Command Prompt, depending on your operating
    system, change to the directory where you downloaded the code, and type `truffle
    test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all goes well, Truffle will report back a success message as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c795e39c-3755-4040-aba2-cc0906b90066.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That wraps up day one of the book! In this chapter, we learned all the basics
    of working with blockchain and smart contracts. We learned how to set up the environment
    for creating blockchain applications. We also learned all about the basic code
    syntax, naming conventions, style, and structure to be followed for optimal efficiency.
    We learned how to create a smart contract and how to test it to ensure it is working
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is day two, we're going to take a look at Solidity
    variables and data types, and see how we can use those to construct some business
    logic and data for our application. Welcome to the world of blockchain!
  prefs: []
  type: TYPE_NORMAL
