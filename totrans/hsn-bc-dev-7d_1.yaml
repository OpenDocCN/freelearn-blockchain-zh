- en: Day One - Application Introduction, Installation, and Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain is such a vast topic, is it even possible to become productive, to
    launch your blockchain project, or get that job as a blockchain developer in just
    a week? Blockchain tech is showing up in every industry, from how we bank to how
    we travel, how we prove our identity, and even how we get healthcare, and more.
    So, it raises the question in our minds, can you really learn to create a blockchain
    application in just seven days?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you're going to learn how to create an online gaming application
    using the Ethereum blockchain in seven days! Along the way, you'll learn how to
    create and use variables using Solidity, and execute business logic using functions;
    you'll eliminate mistakes and errors in code by learning to write tests, and you'll
    interact with the Ethereum blockchain through a user interface that will use React
    and Redux. You'll write code to send and receive funds from your decentralized
    application, and finally you'll learn how to deploy your decentralized app to
    the Ethereum network and Amazon Web Services. In this book, we will break everything
    down to the basics, so you can be confident that the only thing you need to be
    successful is a desire to become a blockchain developer and a willingness to put
    in the effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will serve as the stepping stone to getting started with this
    project, covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first smart contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to our application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the app that we''re going to be building. We''re
    going to build a gaming application that shows our players a number between 0
    and 9, and then they have options to bet whether a mystery number is higher or
    lower than the shown number, and then it can stake how much ether they''re willing
    to bet. The result of their gameplay is shown in the history window, and when
    they win or lose, the money is automatically added or debited from their Ethereum
    account. The following screenshot shows a demo of the application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8899e320-a7c9-4e99-a33c-47e7f1fa5912.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: To build this, you'll be using Solidity to create the contract that contains
    and executes the rules of the game on the blockchain network. The user interface
    will be written in React, and you'll use Solidity to write the contract code.
    You're going to learn about a tool called Ganache that allows you to host your
    own Ethereum blockchain on your local workstation. We are now ready to start building
    the application. Let's begin by setting up all the required tools on our workstation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required tools
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at all the tools you're going to need, not only for this book,
    but to be successful as a blockchain developer. We will learn about all the technologies
    used to host our application, compile, and migrate our code, and test our application.
    So let's get started with our first tool!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你将需要的所有工具，不仅是本书，还有作为一个区块链开发者成功所需的工具。我们将了解托管我们的应用程序、编译和迁移我们的代码以及测试我们的应用程序所使用的所有技术。所以让我们开始我们的第一个工具吧！
- en: Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'The first tool we will use is Visual Studio Code. In its simplest form, it''s
    a text editor, but as you get more familiar with it, it becomes part of your soul
    as a blockchain developer. It packs in a bunch of features that will make your
    life easier, such as syntax highlighting, IntelliSense, and extensions for specific
    programming languages such as the ones we''ll be using in this book: JavaScript
    and Solidity. We''ll use Visual Studio Code to create our smart contract using
    the Solidity programming language.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个工具是 Visual Studio Code。在其最简单的形式中，它是一个文本编辑器，但是当你对它更加熟悉时，它将成为你作为区块链开发者的一部分。它包含了许多功能，这些功能将使你的生活更加轻松，比如语法高亮、智能感知以及针对特定编程语言的扩展，比如本书中将要使用的
    JavaScript 和 Solidity。我们将使用 Visual Studio Code 使用 Solidity 编程语言创建我们的智能合约。
- en: 'To install it, go to the following website: [https://code.visualstudio.com/](https://code.visualstudio.com/),
    and download the installation package for your operating system. You should see
    a landing page that looks similar to the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，可以访问以下网站：[https://code.visualstudio.com/](https://code.visualstudio.com/)，并下载适合你操作系统的安装包。你应该看到一个类似于以下屏幕截图的首页：
- en: '![](img/9f85ac17-c8c8-4b08-b76b-367b7dc28594.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f85ac17-c8c8-4b08-b76b-367b7dc28594.png)'
- en: This is the one tool that isn't mandatory; all you really need is a code editor
    that you're familiar with, so if you already have an editor you can continue to
    use it for this book as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一非必需的工具；你真正需要的只是一个你熟悉的代码编辑器，所以如果你已经有一个编辑器，你也可以继续在本书中使用它。
- en: Our smart contract provides two rules for our application—it's written in a
    programming language called Solidity and it lives on the Ethereum blockchain network.
    Another way to think of the contract is to imagine buying a car. In doing so,
    you agree to a purchase price, a down payment, and possibly financing terms. All
    of those details are entered into a contract you sign to purchase the vehicle.
    Instead of printing out that contract and signing a piece of paper, we'll put
    those details into a smart contract, which you or the buyer signs cryptographically.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的智能合约为我们的应用程序提供了两条规则——它是用一种叫做 Solidity 的编程语言编写的，并且它存在于以太坊区块链网络上。另一种想象合约的方式是想象购买一辆汽车。这样做，你同意购买价格、首付款以及可能的融资条款。所有这些细节都输入到一个合约中，你签署以购买车辆。我们不会打印出那个合同然后在一张纸上签名，我们将这些细节放入一个智能合约中，你或者买方会进行加密签名。
- en: We'll also use Visual Studio Code to write the JavaScript that renders our website's
    user interface for our application. We'll specifically be using React and Redux
    to create that user interface. Ultimately, what we want to happen is for someone
    to go to our website and for a server to send them a web page containing our application.
    We're going to use Node.js for that so you'll need to install it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 Visual Studio Code 编写渲染我们应用程序用户界面的 JavaScript。我们将具体使用 React 和 Redux 来创建用户界面。最终，我们希望的是某人访问我们的网站，并且服务器向他们发送一个包含我们应用程序的网页。我们将使用
    Node.js 来实现这一点，所以你需要安装它。
- en: Node.js
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: As we mentioned in the previous section, we will need a networking framework
    that we can use to send and receive data to and from our website. Node.js is one
    of the most popular frameworks used worldwide for such purposes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，我们将需要一个网络框架，可以用来发送和接收数据到和从我们的网站。Node.js 是全球范围内用于此类目的最流行的框架之一。
- en: 'Node.js is primarily used for implementing backend APIs that can run JavaScript
    code outside the browser. In this book, we will be using it as a way to connect
    our contracts, GUI, and programming backend into our website. You can install
    Node.js by going to [https://nodejs.org/en/download/](https://nodejs.org/en/download/),
    and choosing the right package for your OS. The landing page for Node.js looks
    similar to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 主要用于实现后端 API，这些 API 可以在浏览器之外运行 JavaScript 代码。在本书中，我们将使用它来连接我们的合约、GUI
    和编程后端到我们的网站。你可以通过访问 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    并选择适合你操作系统的正确包来安装 Node.js。Node.js 的首页看起来类似于以下屏幕截图：
- en: '![](img/01dd018e-c837-4242-a583-216d318e18e0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01dd018e-c837-4242-a583-216d318e18e0.png)'
- en: Truffle framework and Ganache
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Truffle 框架和 Ganache
- en: When a user takes an action in our application that needs to be written into
    the blockchain, it is called a **transaction**. The transaction isn't written
    immediately; instead, it's sent to the network where it waits until it's confirmed
    as a valid transaction by the miners. Once the miners confirm it, it's written
    to the blockchain, at which point we can provide updated state information to
    the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在我们的应用程序中执行需要写入区块链的操作时，称为**事务**。事务不会立即写入；相反，它被发送到网络，在那里等待矿工确认为有效的事务。一旦矿工确认了它，它就会被写入区块链，此时我们可以向用户提供更新后的状态信息。
- en: Now, all of this on the Ethereum network represents hundreds of thousands of
    servers, but we don't have hundreds of thousands of servers just lying around,
    and you don't want to wait on external servers every time you need to test during
    development.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以太坊网络上的所有这些都代表着数十万台服务器，但我们没有数十万台服务器闲置，并且您不希望在开发期间每次需要测试时都等待外部服务器。
- en: 'So, we''re going to use Ganache to simulate our own Ethereum network. It''s
    a standalone application that can create an Ethereum test network on your own
    workstation. To install Ganache, we''ll head to [https://truffleframework.com/ganache](https://truffleframework.com/ganache),
    and download its installer package. The following screenshot shows the landing
    page for this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用 Ganache 模拟我们自己的以太坊网络。它是一个独立的应用程序，可以在您自己的工作站上创建一个以太坊测试网络。要安装 Ganache，我们将前往
    [https://truffleframework.com/ganache](https://truffleframework.com/ganache)，并下载其安装程序包。以下截图显示了此的登陆页面：
- en: '![](img/a67c0266-b692-46d7-8aaa-53e7d31f6aa4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a67c0266-b692-46d7-8aaa-53e7d31f6aa4.png)'
- en: Once this is done, we need to install the Truffle framework. This is an Ethereum
    development framework that makes it easier for us to do things, like compile our
    contract, interact with the blockchain network, and migrate our contract to the
    Ethereum network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，我们需要安装 Truffle 框架。这是一个以太坊开发框架，使我们能够更轻松地完成一些事情，比如编译我们的合约、与区块链网络交互以及将我们的合约迁移到以太坊网络。
- en: 'For this, we''re going to open up a Terminal, whether that means Bash shell
    or Windows Command Prompt, and we will type in the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将打开一个终端，无论是 Bash shell 还是 Windows 命令提示符，然后输入以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note, `npm` is packaged as part of Node.js, which means that if you skip past
    the install Node.js step, you'll need to go back and complete it before this command
    is going to work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`npm` 被打包为 Node.js 的一部分，这意味着如果您跳过安装 Node.js 步骤，那么在此命令起作用之前，您需要返回并完成它。
- en: 'Now to get the code required for our application, we will use the following
    command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了获取我们应用程序所需的代码，我们将使用以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command downloads and sets up the code for you. Please ensure that you
    replace the `github_url` value in the preceding block with the actual GitHub repository
    of the book!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为您下载并设置代码。请确保在前面的块中用实际的 GitHub 仓库替换 `github_url` 值！
- en: You might get some errors while running the `truffle` command. This is a known
    problem and has been embedded as part of the official documentation. You can refer
    to the following link to find the workaround for it: [https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows](https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `truffle` 命令时，您可能会遇到一些错误。这是一个已知的问题，并作为官方文档的一部分嵌入其中。您可以参考以下链接找到解决方法：[https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows](https://truffleframework.com/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows)。
- en: With our prerequisites out of the way, it's time to get on to some more fun
    stuff, which includes writing some code. In the next section, we're going to take
    a look at what it means to write a contract, and how it interacts as part of the
    blockchain network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经过我们的先决条件，现在是时候进行更有趣的事情了，这包括编写一些代码。在下一节中，我们将看看写合约意味着什么，以及它如何作为区块链网络的一部分进行交互。
- en: Creating our first smart contract
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个智能合约
- en: In this section, you'll learn the basics of Ethereum contracts. You will learn
    what they are, where they live, how to create them, and how to deploy them to
    the Ethereum network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习以太坊合约的基础知识。您将学习它们是什么，它们居住在哪里，如何创建它们以及如何将它们部署到以太坊网络。
- en: A **contract** is a collection of code represented by its functions and data,
    or by the current state of the contract. It resides at a specific address on the
    Ethereum network, and one of the important things to remember is that the Ethereum
    network is public, which means that anyone can view your contract and its data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同**是由其函数和数据或合同的当前状态表示的代码集合。它位于以太坊网络上的特定地址，并且需要记住的一件重要事情是，以太坊网络是公开的，这意味着任何人都可以查看您的合同及其数据。'
- en: This is different from traditional applications that you may be familiar with.
    In traditional apps, the code is typically stored in an application, while the
    data resides elsewhere, either in files on a disk or a database. Now, let's see
    what a contract consists of.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你可能熟悉的传统应用程序不同。在传统应用程序中，代码通常存储在应用程序中，而数据则存储在其他地方，可以是磁盘上的文件或数据库中。现在，让我们看看合同包含什么。
- en: Analyzing the contracts
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析合同
- en: 'The source code for our contracts are stored in the `contracts` folder. When
    we compile them, they''re sent out to the Ethereum blockchain. Compiling also
    creates a contract metadata that is stored in the `build/contracts` folder. The
    following screenshot shows the structure of the application that we will be building:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们合同的源代码存储在`contracts`文件夹中。当我们编译它们时，它们将发送到以太坊区块链。编译还会创建一个存储在`build/contracts`文件夹中的合同元数据。以下截图显示了我们将要构建的应用程序的结构：
- en: '![](img/1157759a-f86e-4ccc-bf80-00526e23cd91.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1157759a-f86e-4ccc-bf80-00526e23cd91.png)'
- en: 'The contract itself starts with a `pragma` statement, and the `pragma` statement
    tells the compiler about the code. In our case, we want to tell the compiler that
    this code is written in the Solidity programming language, and it uses the `0.5.0` version
    of the Solidity language. So, the code that mentions this looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 合同本身以`pragma`语句开头，`pragma`语句告诉编译器有关代码的信息。在我们的情况下，我们想告诉编译器，此代码是用Solidity编程语言编写的，并且使用了Solidity语言的`0.5.0`版本。因此，提及此内容的代码如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The version info you see in the preceding code block is **SemVer** or **semantic
    versioning**. Basically, in SemVer, the first number represents the major version
    of the package, the middle number represents the minor version, and the third
    number represents the patch level.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中看到的版本信息是**SemVer**或**语义化版本**。基本上，在SemVer中，第一个数字表示包的主要版本，中间数字表示次要版本，第三个数字表示补丁级别。
- en: One of the key things to remember when upgrading is that upgrading a version
    may make some things incompatible; however, one of the nice things about applications
    that follow SemVer is that if you introduce a change that's not backward compatible
    with the previous versions, you can increment the major version number to tell
    the compiler to use the later patches of the tool. Also, it's not as common, but
    some applications will introduce breaking changes with the minor patch number
    as well, and that's why we use the `^` sign in the code, for older versions of
    Solidity. This `^` sign tells the compiler that it's okay to use any version of
    the Solidity programming language from `0.4.24` all the way up to but not including
    `0.5.0`. This ensures that the version of the compiler that you're using is going
    to be compatible with the version that you wrote it with. However, since we are
    using `0.5.0` here, we won't incorporate that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级时需要记住的一点是，升级版本可能会导致一些不兼容的情况；然而，遵循SemVer的应用程序中的一个好处是，如果引入的变化与以前的版本不兼容，可以增加主要版本号来告诉编译器使用较新的工具补丁。此外，虽然不太常见，但某些应用程序也会在次要补丁号中引入重大变更，这就是我们在代码中使用`^`符号的原因，用于Solidity的旧版本。这个`^`符号告诉编译器，可以使用Solidity编程语言的任何版本，从`0.4.24`一直到但不包括`0.5.0`。这确保了您使用的编译器版本与您编写的版本兼容。然而，由于我们在这里使用的是`0.5.0`，所以我们不会将其纳入考虑。
- en: 'To declare a contract, we use the `contract` keyword followed by the name of
    our contract, and it''s a common convention that this contract name follows the
    name of the file, so the file for this `Gaming` contract would be `Gaming.sol`.
    We have a set of opening brackets `{` and then if you need to include comments
    you can do so, much like you do in a SQL programming language, with the `/*` sign,
    and we close out our contract with the `}` sign. This can been seen in the following
    code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There''s a special function in Solidity called a **constructor** function,
    and it runs only once when the contract is created. It''s typically used to initialize
    a contract data. For example, let''s take a look at the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the preceding code snippet, we've got a variable called `owner` and
    a variable called `online`. When the contract is created, we set the `owner` variable
    as the Ethereum address that pushed the contract into the network, and we also
    set the `online` variable as true.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a compiled language, and in order to use the contract on the blockchain,
    it must be compiled and migrated to that network. To compile it, we're going to
    use the Truffle framework. We can do it with the `truffle compile` command, which
    creates a JSON file that contains the contract metadata with information about
    your contract, and we'll use that JSON file to interact with the contract and
    verify its source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In order to use our contract on the blockchain network, we have to get it from
    our workstation and out into the network, and that's known as **migration**. Because
    we're using the Truffle framework, we can easily do that with the `truffle migrate`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at our directory layout, in the `migrations` directory, we
    will find a file called `1_initial_migration.js`. That file is provided by the
    Truffle framework, and it handles deploying of the contracts. Let''s take a look
    at the code in that file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's a variable called `Migrations` that requires the Truffle library `Migrations.sol`,
    and then it exports a function which takes a `deployer` object to deploy the migrations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also got a file called `2_deploy_contracts.js` that''s included in the
    download. That''s the file that''s actually going to migrate the contracts that
    we write as part of this book. Let''s take a look at the code in that file now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the previous file, there's a variable called `Gaming` that requires
    the `Gaming.sol` contract file that we created, and it then runs the deploy method
    to deploy the `Gaming` contract.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Testing the contract
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help cement this idea of migration, we''ll actually migrate some contracts,
    and then we''ll analyze what happens to the network. To do that, we will use the
    following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to start the Ganache application that will get our private
    blockchain up and running, as seen in the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a7078b4-ce8a-4348-891c-936c3dc2100b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding screenshot, we've got the Ganache application running.
    Let's take a look at the balance, which is currently 100 ether, and there have
    been no blocks mined, and no transactions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的截图所示，我们有Ganache应用程序正在运行。让我们看一下余额，它目前为100以太，还没有被挖掘的区块，也没有交易。
- en: 'Switching over to the console, we will type in the following command to migrate
    the contract to the network:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到控制台，我们将输入以下命令将合同迁移到网络上：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the migration is successful, we''ll return to Ganache where we will be
    greeted by something similar to this screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦迁移成功，我们将返回Ganache，那里会看到类似这个截图的界面：
- en: '![](img/a3f0b754-859a-486c-b04a-ad6b27c39dc0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f0b754-859a-486c-b04a-ad6b27c39dc0.png)'
- en: We can see that address 0 or account 0 has spent some ether. That was used to
    pay for the migration of that contract. Looking at the blocks, we can see that
    there were four blocks mined, as well as four transactions used to create and
    migrate those contracts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到地址0或账户0已经花费了一些以太坊。这是用来支付合同迁移的费用。从区块来看，我们可以看到挖掘了四个区块，以及用于创建和迁移这些合同的四笔交易。
- en: 'If we switch over to the code editor, in this case Visual Studio Code, in the
    `build/contracts` folder, you can see the contract metadata files here that were
    created as a result of the compiling:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们切换到代码编辑器，本例中为Visual Studio Code，在`build/contracts`文件夹中，您可以看到编译结果产生的合同元数据文件在这里：
- en: '![](img/7d923bc2-8862-49d8-8e27-85e32d8ee401.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d923bc2-8862-49d8-8e27-85e32d8ee401.png)'
- en: 'If we open the `Migrations.json` file and scroll all the way to the bottom,
    you can see that it stores the networks that this contract has been deployed to,
    as well as the address of the deployed contract, as seen in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`Migrations.json`文件并滚动到底部，您可以看到它存储了此合同已部署到的网络，以及部署合同的地址，如下截图所示：
- en: '![](img/7dfee7ec-a19d-4fb0-bdc1-98309d9a69d4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dfee7ec-a19d-4fb0-bdc1-98309d9a69d4.png)'
- en: Congratulations! You have successfully created and deployed your first contract
    if you've reached here. You've already seen some of the syntax used as we specified
    the `owner` variable and built a `constructor` function. In the next section,
    we'll discuss some of the syntax and style guides used with the Solidity programming
    language.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺！如果你已经到达这里，那么你已经成功创建并部署了你的第一个合同。你已经看到了一些语法的用法，因为我们指定了`owner`变量并构建了`constructor`函数。在下一节中，我们将讨论Solidity编程语言使用的一些语法和风格指南。
- en: Understanding the basic syntax
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本语法
- en: We can't start our learning journey without covering some of the basic syntax
    guidelines for developing Solidity code. The goal of consistency when writing
    code is not to determine what's right or wrong, but to offer guidelines to help
    ensure that it's always the same. This makes the code more legible and easier
    to read.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在没有覆盖一些基本的Solidity代码开发语法指南的情况下开始我们的学习之旅。编写代码时的一致性目标并不是为了确定什么是对或错，而是为了提供指南，帮助确保代码总是相同的。这使得代码更易于阅读和理解。
- en: This is an important point to remember—it's not the right way or the best way,
    just a consistent way. This doesn't mean that the style guidelines apply for every
    instance. When in doubt, you should look at other script examples and then use
    your best judgment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的记住点——它并不是正确的方式或最好的方式，只是一个一致的方式。这并不意味着风格指南适用于每个情况。如有疑问，您应该查看其他脚本示例，然后做出最好的判断。
- en: Code layout
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码布局
- en: 'For code layout, we should always use four spaces per indentation level. Spaces
    are preferred over tabs, but even if you use tabs, just avoid mixing tabs and
    spaces in the same file. Let''s take a look at an example in the following code
    block:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码布局，我们应该始终使用每级缩进四个空格。空格优先于制表符，但即使使用制表符，也要避免在同一文件中混合使用制表符和空格。让我们在接下来的代码块中看一个例子：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see the `contract` as specified first, then the first function declared
    is indented by four spaces. The `if` block itself is indented four spaces from
    there.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到指定的`contract`，然后第一个声明的函数缩进了四个空格。`if`块本身从那里缩进了四个空格。
- en: Blank lines
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空行
- en: 'It''s recommended to surround top-level declarations with two blank lines,
    and surround function level declarations with a single blank line. This will essentially
    help you to find bugs more quickly than scrolling through a randomly ordered file
    and hoping to find the required line. Let''s use the following example to see
    how we should use blank lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code block, we have two contracts declared, and in between
    those two contracts are two blank lines, just so there's a nice big white space
    to tell them apart easily. In our function declarations, each function is separated
    by a single blank line. This should help in easily distinguishing each element
    of the code snippet.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Line lengths
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For line lengths, it''s recommended to have a maximum of 79 characters. The
    recommendation of 79 characters was set way back in the day when people used TTY
    terminals with a maximum width of 80 characters. It''s actually becoming quite
    common now to see up to 99 characters for the line width. Let''s refer to the
    following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As seen here, the first argument is not attached to the line where the function
    is declared, and it's separated by one indent only. Also, there is only one argument
    per line, and, finally, the terminating element goes on a line by itself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Function layout
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your functions should be laid out in a specific order. This is the correct
    order:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback functions
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External functions
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public functions
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal functions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We haven't talked about functions yet, so what these mean may still be a little
    bit fuzzy to you, but we're going to go into this in great detail in the next
    section, so sit tight with that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'For structuring the functions, we''re going to open the bracket on the same
    line as the declaration and close the line at the same indentation level as the
    beginning declaration. Also, that opening bracket should be preceded by a single
    space. Let''s have a look at the following code block:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As seen, when we declare the `Gaming` contract, we have our opening curly bracket
    with the space in between. Similarly, for our `determineWinner()` function, it
    has the opening curly brace on the same line, and then the closing brace for our
    function is right below it, where the first character for the function begins.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to declaring variables, double quotes are preferred for strings
    over single quotes. We surround our operators with a space on either side as it
    just helps them stand out in the code so that you can identify them more easily.
    The following code snippet illustrates this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The exception to this is when you have operators with a higher priority, you
    can omit the surrounding space in order to signify its precedence.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When naming variables, you should always avoid single-letter variable names,
    such as int L, bool O, and so on. The reason for this is that they're very similar
    looking, and it's just an unnecessary level of complexity added to your code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re naming contracts, libraries, structs, and events, you want to
    use CapWords (or CamelCase), where you capitalize the first letter of each word
    in the variable name. An example of this is shown in the following snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When naming functions, function arguments, variables, and modifiers, you should
    use mixedCase, which is very similar to CapWords, except that you don''t capitalize
    the first letter as shown in the following code block:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When naming constants, you want to name them in all capitals.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the underscore (**_**) symbol to avoid naming collisions between
    functions, variables, and other objects in the code. The following code block
    shows an example of this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code block, I've got this function called `mysteryNumber()`,
    and later in the code when that function is used, it really makes sense for me
    to call my variable `mysteryNumber`, since it is a mysterious number, but I can't
    reuse that name without causing a name collision. So, when I actually get the
    mystery number variable, I put an underscore at the end of it so that `mysteryNumber_` becomes
    the variable that I got from the `mysteryNumber()` function. This makes it easy
    to tell those two apart, yet very clear where I got that mystery number from.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: By now, you may be seeing how implementing consistent guidelines about how we
    write the code makes it easier to read and maintain the code. While it's true
    that it doesn't make the code run faster or guarantee that it's correct, it does
    make the human element of coding more enjoyable, which in turn may make it easier
    to collaborate and discuss the function rather than the format of the code. In
    the next section, we're going to take a look at writing tests for our code and
    *why* exactly we would want to do that.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to write code efficiently. While that
    makes it easier to read, it doesn't mean that our code works at all, after all
    broken code should look pretty too, right?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about your current testing strategy for a minute. After writing your
    code, do you manually test it by using it and then examining the output, and then
    you repeat the same process before you publish the latest release? Well, let me
    ask you this, have you ever forgotten a step, and as a result you released a bug
    in your code that could have been caught if you'd remembered to do that step? Running
    tests before you make any changes is a great idea. We've all spent quite a bit
    of time trying to figure out how our code broke a test, only to find out later
    that the test was broken before we started making any changes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In this book, let's write tests that automatically do that for us, and we'll
    use all the time that we save on testing, to write more great code. Our tests
    can be written in Solidity, or they can be written in JavaScript. They can automatically
    validate that the code executes as it's intended to, and they should be run before
    and after every code change.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: So, for testing the `Gaming` contract, we're going to name our test file `TestGaming.sol`,
    and the tests themselves go into the `test` directory of the project. They're
    also an actual Solidity contract, which makes them relatively easy to write because
    you use the same techniques that you use to write any other Solidity contract.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了测试`Gaming`合同，我们将命名我们的测试文件为`TestGaming.sol`，测试本身放在项目的`test`目录中。它们也是一个实际的Solidity合同，这使得它们相对容易编写，因为你使用与编写任何其他Solidity合同相同的技术。
- en: Let's take a look at an actual example test contract from the application and
    some of the best practices for implementing them. You can access the contract
    by opening the `TestGaming.sol` file in the text editor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下应用程序中的一个实际的示例测试合同以及实施它们的一些最佳实践。你可以通过在文本编辑器中打开`TestGaming.sol`文件来访问合同。
- en: 'Now, let''s break this contract down into individual bits. The contract begins
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个合同分解成单独的部分。合同开始如下：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, we have the `pragma solidity` statement and our Solidity version. Then,
    we import the `Assert` library and `DeployedAddresses` library from Truffle. Along
    with that, we will import the actual contract that we are testing this on, which
    is `Gaming.sol`. The next step is to define our contract:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了`pragma solidity`语句和我们的Solidity版本。然后，我们从Truffle导入`Assert`库和`DeployedAddresses`库。除此之外，我们还将导入我们正在进行测试的实际合同，即`Gaming.sol`。下一步是定义我们的合同：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just like any other Solidity contract, we define our contract and give it the
    name `TestGaming`. We give it some initial `ether` to hold on to that we can use
    for our tests, and then we create our `gaming `variable, which is an instance
    of the `Gaming` contract.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他Solidity合同一样，我们定义我们的合同并给它命名为`TestGaming`。我们给它一些初始的`ether`来进行保存，我们可以在我们的测试中使用它，然后创建我们的`gaming`变量，这是`Gaming`合同的实例。
- en: 'Before any of our tests run, we go ahead and grab our deployed contract because
    during the test, every test run deploys a fresh instance of the contract to the
    test network. The following lines of code show how this is done:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任何测试运行之前，我们先拿到我们部署的合同，因为在测试过程中，每次测试运行都会向测试网络部署一个全新的合同实例。以下代码显示了如何做到这一点：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we create functions for every test scenario that we want to test, as
    shown in the following code block:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们想要测试的每一个测试场景创建函数，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `testPlayerWonGuessHigher()` function tests whether the player guessed that
    the numbers should be higher, and if the number actually was higher, then they
    should have won.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`testPlayerWonGuessHigher()`函数测试玩家是否猜测数字应该更高，如果数字确实更高，那么他们应该赢了。'
- en: The `testPlayerLostGuessLower()` function tests whether a player who guessed
    lower when the number actually was higher should have lost.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`testPlayerLostGuessLower()`函数测试当数字实际更高时猜测较低的玩家是否应该输掉。'
- en: We set up these scenarios in our test, define what we expect to happen, and
    then use these assertions to verify that that's actually what happened. So all
    we have to do is run this test any time we need to feel the need or right before
    we deploy, and we can confidently say that our functions for determining who wins
    and who loses the game are accurately working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的测试中设置这些场景，定义我们期望发生的事情，然后使用这些断言来验证实际发生的情况。因此，我们只需要在需要感觉或者在部署之前运行这个测试，我们就可以自信地说，我们确定谁赢得比赛和谁输掉比赛的功能是准确工作的。
- en: Assignment
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'In each chapter of this book, I''m going to give you a homework assignment
    to be completed before you start the next day or chapter. Today''s homework assignment
    is all about getting your development environment set up. Not only is this going
    to help you complete the remainder of this book, but the tools I''m going to show
    you will help you across every blockchain project you take on. Here''s what you
    need to do:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的每一章中，我都会给你布置一项作业，要在你开始下一天或下一章之前完成。今天的作业主要是关于设置你的开发环境。这不仅将帮助你完成本书的剩余内容，而且我将向你展示的工具将帮助你处理你接手的每一个区块链项目。以下是你需要做的：
- en: Install Visual Studio Code. This is the only step that's optional, and it's
    optional only if you already have a code editor that you know and love.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Visual Studio Code。这是唯一可选的步骤，只有在你已经有一个你熟悉和喜爱的代码编辑器时才是可选的。
- en: Install Node.js from [nodejs.org](http://nodejs.org).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[nodejs.org](http://nodejs.org)安装Node.js。
- en: Install Ganache from the Truffle framework website.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Truffle框架网站安装Ganache。
- en: Install the Truffle framework itself using the `npm` module.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`模块安装Truffle框架本身。
- en: If you've installed Truffle previously, be sure to check that you have at least
    Truffle version 4.1 installed, and if not update it. You can always check your
    Truffle version using the `truffle version` command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已安装了 Truffle，请确保您至少安装了 Truffle 版本 4.1，并在需要时进行更新。您可以使用 `truffle version`
    命令随时检查您的 Truffle 版本。
- en: Finally, install the course code using the `truffle unbox` command and the URL
    for the GitHub repo of this book.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `truffle unbox` 命令和本书 GitHub 仓库的 URL 安装课程代码。
- en: When that is done, launch Terminal or Command Prompt, depending on your operating
    system, change to the directory where you downloaded the code, and type `truffle
    test`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，启动终端或命令提示符，根据您的操作系统，转到下载代码的目录，然后输入 `truffle test`。
- en: 'If all goes well, Truffle will report back a success message as shown in the
    following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，Truffle 将会返回如下屏幕截图所示的成功消息：
- en: '![](img/c795e39c-3755-4040-aba2-cc0906b90066.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c795e39c-3755-4040-aba2-cc0906b90066.png)'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That wraps up day one of the book! In this chapter, we learned all the basics
    of working with blockchain and smart contracts. We learned how to set up the environment
    for creating blockchain applications. We also learned all about the basic code
    syntax, naming conventions, style, and structure to be followed for optimal efficiency.
    We learned how to create a smart contract and how to test it to ensure it is working
    as expected.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书第一天的内容了！在这一章中，我们学习了使用区块链和智能合约的所有基础知识。我们学会了如何设置环境来创建区块链应用程序。我们还学习了所有关于基本代码语法、命名约定、风格和结构的知识，以便达到最佳效率。我们学会了如何创建智能合约，以及如何测试它以确保其按预期工作。
- en: In the next chapter, which is day two, we're going to take a look at Solidity
    variables and data types, and see how we can use those to construct some business
    logic and data for our application. Welcome to the world of blockchain!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是第二天，我们将看看 Solidity 变量和数据类型，以及如何使用它们构建一些业务逻辑和数据。欢迎来到区块链的世界！
