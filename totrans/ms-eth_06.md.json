["```\npragma solidity 0.5.0;\ncontract Copyright {}\n```", "```\npragma solidity 0.5.0;\ncontract Copyright {\n    // Create the events\n    event RegisteredContent(uint256 counter, bytes32 indexed hashId, string indexed contentUrl, address indexed owner, uint256 timestamp, string email, string termsOfUse);\n}\n```", "```\npragma solidity 0.5.0;\ncontract Copyright {\n    // Create the events\n    event RegisteredContent(uint256 counter, bytes32 indexed hashId, string indexed contentUrl, address indexed owner, uint256 timestamp, string email, string termsOfUse);\n\n    // Create the variables that we'll use\n    struct Content {\n        uint256 counter;\n        bytes32 hashId; // The half keccak256 hash since we can't store the entire 64 bit hash\n        string contentUrl;\n        address owner;\n        uint256 timestamp;\n        string email; // We need a valid email to contact the owner of the content\n        string termsOfUse;\n    }\n    mapping(bytes32 => Content) public copyrightsById;\n    uint256 public counter = 0;\n    address payable public owner; }\n```", "```\n// To setup the owner of the contract\nconstructor() public {\n   owner = msg.sender;\n}\n\n// To add new content to copyright the blockchain\nfunction addContent(bytes32 _hashId, string memory _contentUrl, string memory _email, string memory _termsOfUse) public {\n   // Check that the most important values are not empty\n   require(_hashId != 0 && bytes(_contentUrl).length != 0 && bytes(_contentUrl).length != 0 && bytes(_email).length != 0);\n\n   counter += 1;\n   Content memory newContent = Content(counter, _hashId, _contentUrl, msg.sender, now, _email, _termsOfUse);\n   copyrightsById[_hashId] = newContent;\n   emit RegisteredContent(counter, _hashId, _contentUrl, msg.sender, now, _email, _termsOfUse);\n}\n```", "```\n// To delete something if you're the owner\nfunction deleteCopyrightedByHash(bytes32 _hashId) public {\n    if(copyrightsById[_hashId].owner == msg.sender) {\n        delete copyrightsById[_hashId];\n    }\n}\n\n// To extract the funds locked in this smart contract\nfunction extractFunds() public {\n    owner.transfer(address(this).balance);\n}\n```", "```\nhttps://ropsten.infura.io/v3/8e12dd4433454738a522d9ea7ffcf2cc\n```", "```\nv3/8e12dd4433454738a522d9ea7ffcf2cc\n```", "```\n$ npm i truffle-hd-wallet-provider\n```", "```\n$ truffle deploy --network ropsten\n```", "```\nweb3.toHex('041a34ca22b57f8355a7995e261fded7')\n\"0x3034316133346361323262353766383335356137393935653236316664656437\"\n```", "```\npragma solidity ^0.5.0;\n\ncontract Example {\n    uint256 myNumber = 3;\n}\n```", "```\n$ npm i -g solc\n```", "```\n$ solcjs Example.sol --bin\n```", "```\n60806040526003600055348015601457600080fd5b5060358060226000396000f3fe6080604052600080fdfea165627a7a72305820aa17e74115b5e066ae13d560c624e9abef54adbce68c3443886eadc4e1059cfe0029\n```", "```\n60 03\n```", "```\nstack: [3]\n```", "```\n60 00\n```", "```\nuint256 myNumber = 3;\n```", "```\n6003600055\n```", "```\n60806040526003600055348015601457600080fd5b5060358060226000396000f3fe6080604052600080fdfea165627a7a72305820aa17e74115b5e066ae13d560c624e9abef54adbce68c3443886eadc4e1059cfe0029\n```", "```\ncontract Proxy {\n    address public upgradableContractAddress;\n    function () public {\n        // Delegate the execution to the upgradable contract instead of using the code in this contract since this contract won't change, it's just to keep the address consistent and to have a registry of upgradable contracts\n    }\n}\n```", "```\ncontract Upgradable {\n    address public storageContractAddress;\n    function buyTokens() public {\n        // This is the function that the proxy called in this example. So this contract will execute the needed logic to buy tokens and will update the state variables in the storage contract\n        storageContractAddress.setTokens(userA, 40);\n    }\n}\n```", "```\ncontract Storage {\n    mapping(address => uint256) public tokens;\n\n    function setTokens(address _user, uint256 _number) public {\n        // This function is used to update the storage variables since we don't want any logic to take place in this contract\n        tokens[_user] = _number;\n    }\n}\n```", "```\npragma solidity ^0.5.0;\n\ncontract Storage {\n    uint256 public myNumber;\n    function setMyNumber(uint256 _myNumber) public {\n        myNumber = _myNumber;\n    }\n}\n```", "```\npragma solidity ^0.5.0;\n\ncontract Upgradable {\n    address public storageContract;\n    constructor (address _storageContract) public {\n        storageContract = _storageContract;\n    }\n\n    // A sample function that you could implement for buying tokens for demonstration purposes\n    function buyTokens() public {\n        // Do your logic for buying tokens for instance, calculating how many he will get for the msg.value he sent and so on. To later update the storage information\n        // Create the storage contract instance\n        Storage s = Storage(storageContract);\n        s.setMyNumber(10);\n    }\n}\n\ncontract Storage {\n    uint256 public myNumber;\n    function setMyNumber(uint256 _myNumber) public {\n        myNumber = _myNumber;\n    }\n}\n```", "```\npragma solidity 0.5.0;\n\ncontract Proxy {\n    address public storageAddress;\n    address public upgradableAddress;\n    address public owner = msg.sender;\n\n    address[] public listStorage; // To keep track of past storage contracts\n    address[] public listUpgradable; // To keep track of past upgradable contracts\n}\n```", "```\nmodifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n}\n\nconstructor() public {\n    storageAddress = address(new Storage());\n    upgradableAddress = address(new Upgradable(storageAddress));\n    listStorage.push(storageAddress);\n    listUpgradable.push(upgradableAddress);\n}\n```", "```\nfunction () external {\n    bool isSuccessful;\n    bytes memory message;\n    (isSuccessful, message) = upgradableAddress.delegatecall(msg.data);\n\n    require(isSuccessful);\n}\n```", "```\nfunction upgradeStorage(address _newStorage) public onlyOwner {\n    require(storageAddress != _newStorage);\n    storageAddress = _newStorage;\n    listStorage.push(_newStorage);\n}\n\nfunction upgradeUpgradable(address _newUpgradable) public onlyOwner {\n    require(upgradableAddress != _newUpgradable);\n    upgradableAddress = _newUpgradable;\n    listUpgradable.push(_newUpgradable);\n}\n```", "```\nupgradableAddress.delegatecall(msg.data);\n```", "```\nMyContract(contractAddress).buyTokens(12);\n```", "```\n0000000000000000000000000000000000000000000000000000000000000010\n```", "```\n0x009be4e60000000000000000000000000000000000000000000000000000000000000010\n```", "```\n0x009be4e60000000000000000000000000000000000000000000000000000000000000010\n```", "```\n    function () external {\n        bool isSuccessful;\n        bytes memory message;\n        (isSuccessful, message) = upgradableAddress.delegatecall(msg.data);\n\n        require(isSuccessful);\n    }\n```", "```\n(isSucessful, message)\n```", "```\n    function upgradeStorage(address _newStorage) public onlyOwner {\n        require(storageAddress != _newStorage);\n        storageAddress = _newStorage;\n        listStorage.push(_newStorage);\n    }\n\n    function upgradeUpgradable(address _newUpgradable) public onlyOwner {\n        require(upgradableAddress != _newUpgradable);\n        upgradableAddress = _newUpgradable;\n        listUpgradable.push(_newUpgradable);\n    }\n```", "```\npragma solidity 0.5.0;\n\ncontract StateChannel {\n    constructor () public payable {}\n\n    function exitStateChannel() public {}\n}\n```", "```\npragma solidity 0.5.0;\n\ncontract StateChannel {\n    address payable public playerOne;\n    address payable public playerTwo;\n    uint256 public escrowOne;\n    uint256 public escrowTwo;\n\n    constructor () public payable {}\n\n    function exitStateChannel() public {}\n}\n```", "```\npragma solidity 0.5.0;\n\ncontract StateChannel {\n    address payable public playerOne;\n    address payable public playerTwo;\n    uint256 public escrowOne;\n    uint256 public escrowTwo;\n\n    constructor () public payable {\n        require(msg.value > 0);\n\n        playerOne = msg.sender;\n        escrowOne = msg.value;\n    }\n\n    function setupPlayerTwo() public payable {\n        require(msg.sender != playerOne);\n        require(msg.value > 0);\n\n        playerTwo = msg.sender;\n        escrowTwo = msg.value;\n    }\n\n    function exitStateChannel() public {}\n}\n```", "```\nkeccak256(9, 4, 1, 1549378379, 2948372910);\n\n```", "```\n515e473c03c2d08f92825bad975ff0123f15b3ee2f457942a3484abe749f65b4\n```", "```\nweb3.personal.sign(hash, web3.eth.defaultAccount, (err, result) => {\n    if(err) return err\n    return result\n})\n```", "```\npragma solidity 0.5.0;\n\ncontract StateChannel {\n    address payable public playerOne;\n    address payable public playerTwo;\n    uint256 public escrowOne;\n    uint256 public escrowTwo;\n\n    // Variables to end the game\n    uint256 public betOne;\n    uint256 public betTwo;\n    uint256 public balanceOne;\n    uint256 public balanceTwo;\n    uint256 public callOne;\n    uint256 public callTwo;\n    bool public isPlayer1BalanceSetUp;\n    bool public isPlayer2BalanceSetUp;\n    uint256 public finalBalanceOne;\n    uint256 public finalBalanceTwo;\n}\n```", "```\n\nconstructor () public payable {\n    require(msg.value > 0);\n\n    playerOne = msg.sender;\n    escrowOne = msg.value;\n}\n\nfunction setupPlayerTwo() public payable {\n    require(msg.sender != playerOne);\n    require(msg.value > 0);\n\n    playerTwo = msg.sender;\n    escrowTwo = msg.value;\n}\n```", "```\nfunction exitStateChannel(\n bytes memory playerMessage, \n uint256 playerCall, \n uint256 playerBet, \n uint256 playerBalance, \n uint256 playerNonce, \n uint256 playerSequence, \n address addressOfMessage) \n public \n{\n    require(playerTwo != address(0), '#1 The address of the player is invalid');\n    require(playerMessage.length == 65, '#2 The length of the message is invalid');\n    require(addressOfMessage == playerOne || addressOfMessage == playerTwo, '#3 You must use a valid address of one of the players');\n    uint256 escrowToUse = escrowOne;\n\n    if(addressOfMessage == playerTwo) escrowToUse = escrowTwo;\n\n    // Recreate the signed message for the first player to verify that the parameters are correct\n    bytes32 message = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(playerNonce, playerCall, playerBet, playerBalance, playerSequence))));\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    assembly {\n        r := mload(add(playerMessage, 32))\n        s := mload(add(playerMessage, 64))\n        v := byte(0, mload(add(playerMessage, 96)))\n    }\n\n    address originalSigner = ecrecover(message, v, r, s);\n    require(originalSigner == addressOfMessage, '#4 The signer must be the original address');\n\n    if(addressOfMessage == playerOne) {\n        balanceOne = playerBalance;\n        isPlayer1BalanceSetUp = true;\n        betOne = playerBet;\n        callOne = playerCall;\n    } else {\n        balanceTwo = playerBalance;\n        isPlayer2BalanceSetUp = true;\n        betTwo = playerBet;\n        callTwo = playerCall;\n    }\n\n    if(isPlayer1BalanceSetUp && isPlayer2BalanceSetUp) {\n        if(callOne == callTwo) {\n            finalBalanceTwo = balanceTwo + betTwo;\n            finalBalanceOne = balanceOne - betTwo;\n        } else {\n            finalBalanceOne = balanceOne + betOne;\n            finalBalanceTwo = balanceTwo - betOne;\n        }\n\n        playerOne.transfer(finalBalanceOne);\n        playerTwo.transfer(finalBalanceTwo);\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract BadExample {\n    uint256 public myNumber = 0;\n\n    function counter(uint256 _counter) public {\n        for(uint256 i; i < _counter; i++) {\n            myNumber += 1;\n        }\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract GoodExample {\n    uint256 public myNumber = 0;\n\n    function counter(uint256 _counter) public {\n        uint256 internalCounter = 0;    \n        for(uint256 i; i < _counter; i++) {\n            internalCounter += 1;\n        }\n        myNumber += internalCounter;\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract Example {\n    function doSomething() public {\n        if (conditionOne && conditionTwo) {\n            // Do something\n        }\n        if (conditionTwo || conditionOne) {\n            // Do something\n        }\n        if (alwaysTrue) {\n            // Do something\n        } else {\n            // Do another thing\n        }\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract Example {\n    function doSomething() public {\n        // Notice the condition 2 going first because it will be false most of the times, thus rending the second condition unnecessary to check\n        if (conditionTwo && conditionOne) {\n            // Do something\n        }\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract Example {\n    function doSomething() public {\n        // Notice the condition 1 going first because it will be true most of the times, thus rending the second condition unnecessary to check\n        if (conditionOne || conditionTwo) {\n            // Do something\n        }\n    }\n}\n```", "```\nif (alwaysTrue) {\n    // Do something\n} else {\n    // Do another thing\n}\n```", "```\npragma solidity 0.5.0;\ncontract Example {\n    function doSomething() public {\n        // Notice how we removed the } else { block because it will never be execute\n        if (alwaysTrue) {\n            // Do something\n        }\n    }\n}\n```", "```\npragma solidity 0.5.0;\ncontract GoodExample {\n    // The number of seconds that you have each game to make decisions up to 100\n    uint8 public secondsPerGame;\n\n    // To check if owner's address is setup when executing restricted functions\n    bool public isOwnerAddressSetup;\n\n    // The name of the first player\n    bytes32 public firstPlayersName;\n}\n```", "```\ncontract BadExample {\n    uint256 numberOfTimes;\n    string public name;\n    address public senderAddress;\n}\n```"]