- en: Machine Learning on the Ethereum Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blockchain and AI have been the most interesting topics in recent years for
    a good reason: they are the most advanced technologies that have been created
    to disrupt most established businesses. The fact that we can teach a computer
    to learn by itself is something very powerful, and means that will continue evolving
    the machine learning systems of the future will continue to evolve. Likewise with
    blockchain: the field of distributed computing is just beginning, and it will
    be the default solution for most problems in the future. So why not combine both
    for a revolutionary invention? It turns out that they work nicely together, and
    we can create very interesting dApps that benefit from both worlds, particularly
    by using them to create decentralized marketplaces for solving machine learning
    problems that reward users for their computing power.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding machine learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized machine learning marketplaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a smart contract machine learning marketplace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Machine learning** (**ML**) is a subset of **artificial intelligence** (**AI**),
    which in turn is a field in the broader subject of data science. ML is focused
    on creating programs that learn by themselves to solve specific problems without
    having to write all the logic; we just need to give them lots of input. Trial
    and error is the main mechanism with the machine slowly learns how to achieve
    the right output to a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The moment computers were created was the moment scientists asked themselves,
    "How can we make this machine think and act as a human?". That's why understanding
    how computers learn begins with understanding how humans see the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it for a second: how do you think animals and humans learn to survive
    in the dangerous and confusing world we live in? By learning from others? Well,
    that''s a valid learning system, but all understanding of what we truly know comes
    from experimenting in the face of uncertainty. Imagine the following scenario:
    you are in a primitive world where language hasn''t been invented—we''re talking
    thousands of years ago. You see a flat and shiny red object on the ground that''s
    completely new to you. How do you even begin to understand it? It could be something
    that could kill you or something that could provide you with a new source of materials.
    You don''t know yet, so you begin by trying different things, always with caution,
    since your main goal is to survive. You touch it with a stick: nothing happens.
    You touch it with your hand: it feels warm. You grab it: it feels strong, so you
    try to break it, no success. After some more experimentation, you come to the
    conclusion that what you have in your hands is a strong, naturally formed metallic
    disc that you can use to cook food with the power of the sun.'
  prefs: []
  type: TYPE_NORMAL
- en: All of that specific knowledge came about from experimentation using the trial-and-error
    mechanism. My point is that this is how we've discovered all of what we know in
    the current world, and it's also the system that machine learning algorithms use
    to solve problems by themselves. You give them lots of information and they experiment
    with their tools, which usually are pixel-by-pixel readings of images and bytes
    of data, to generate an outcome. They are used to predict the future given some
    initial conditions, to understand complex problems that can't be solved with classical
    programming, and to create tools to help us do a better job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically speaking, there are three steps to create a machine learning system,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather lots of information about a topic, such as 2,000,000 images of unique
    water bottles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop a machine learning **model** that generates a desired output. In our
    example, let's say that we want to create a model that classifies water bottles
    based on their shape, size, color, chemical composition, and purity because we
    need to find the best water possible for human use. Those attributes are called
    **labels**, as they are precise descriptions of each component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The model consumes all that data in a process called **training**, where it
    adjusts how important each component of our water bottles is to calculate which
    factors determine the best water possible. At some point, it will be trained,
    meaning that it will understand what attributes constitute the best water for
    humans, generating a program that we can use to quickly determine how good a specific
    new water bottle is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's just an example of how we use machine learning to provide solutions to
    complex questions, such as, what's the best water I can consume for optimal health?,
    What does a dangerous person look like?, How do I teach my camera to determine
    whether what it's seeing is a dog or a cat?
  prefs: []
  type: TYPE_NORMAL
- en: In general, the steps are getting data -> creating a model that uses that data
    for creating a program -> using the program for specific situations. There are
    many other different systems where the program learns by getting the data by itself
    using trial and error. Other interesting machine learning algorithms work on the
    biological level to teach robots to act as real-life animals, in order to learn
    and see the world like them.
  prefs: []
  type: TYPE_NORMAL
- en: It's a very hot topic that will continue growing in the coming years to provide
    answers to the most complex problems and questions humans can possibly ask. That's
    why I recommend you explore the vast world of AI. See what's out there before
    combining it with blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized machine learning marketplaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a marketplace to buy and sell computing power from users
    that have strong GPUs and want to help others perform machine learning to teach
    their algorithms to complete a task based on supervised learning, where a program
    learns to generate a desired output from a large quantity of input given a goal
    so that it programs itself.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum comes into the equation when we need to deal with storing permanent
    records of the transactions that took place in our ML marketplace along with the
    trained model that the buyer requested from their parameters so that it's accessible
    anytime. The idea is to create a place where people from all around the world
    can start earning money from a new use of their hardware as an alternative to
    mining, while also providing a secure system for ML algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We will use GPUs to train our machine learning programs because they are great
    at processing lots of parallel operations at the same time, so that we can go
    through large batches of input quickly, faster than with a CPU. We'll also use
    Ethereum as the default payment currency to process decentralized transactions
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most machine learning models nowadays are based on **neural networks** (**NN**),
    which are abstractions of how a human brain works, translated to computers. It''s
    based on virtual individual neurons that receive an input and produce an output
    if a condition is met. For instance, say that a simple neuron contains the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The statement will return a positive value if the input is larger than 10\.
    That function is what's called an activation function, which makes sense because
    it will activate if the function fulfills the conditions. We can combine many
    of those neurons together with different parameters and configurations to get
    what's known as a neural network, which processes complex input to generate precise
    output. When training, we're readjusting the activation function to better adapt
    to our desired goal. This is all done automatically once it's set up in our model.
    At the end, we get a trained program that is capable of answering complex questions
    without having to code each specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the model is adjusted from our training dataset, we can test it with a
    new input from a different source to determine whether it''s generating an optimal
    output. This is important since there''s a risk of overfitting where the machine
    learning program optimizes too much, becoming too specific to our initial input,
    which makes it unable to produce valid results from new data. It''s like a surgeon
    that has to become a general doctor from scratch: it won''t produce great results
    because it''s too specialized.'
  prefs: []
  type: TYPE_NORMAL
- en: Some well-known activation functions are Sigmoid and ReLU. Deep learning is
    the process of stacking several layers of neurons so that the output of a neuron
    is transmitted to another neuron for a more advanced result. These networks are
    known as **deep neural networks** (**DNNs**) because they are made of several
    layers. Make sure to explore the fascinating world of NNs by yourself to learn
    how the technology of the future is being shaped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t use NNs here as they are hard to implement from scratch on **Solidity**
    because of the limitations of the blockchain, so we''ll work with simpler algorithms
    that you can expand as you need. Here''s how our protocol will work:'
  prefs: []
  type: TYPE_NORMAL
- en: A user publishes a set of data, an evaluation function (our ML model), and the
    reward for completing the task to the smart contract in ETH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those that want to fulfil the task will download the published data from the
    first user to train the given ML model in order to generate a trained program
    that will be given back to the smart contract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: External users will take a look at all the published solutions for that particular
    task to determine who is the winner. The buyer will determine the winner based
    on their preference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this protocol, we can establish the following process that the users will
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A buyer, someone who wants their model trained, deploys a smart contract that
    contains the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Their model definition in the constructor—for instance, DNN.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The datasets to train—for instance, an array of handwritten digit images made
    of 30 x 30 pixels. Each image is an array of 30 x 30 pixels (900 pixels) where
    each pixel is another array containing information about the position of the pixel
    and whether it's black or white (we don't want colors in this image to avoid complexity)—for
    instance [[0, true], [1, false]] will represent a 2 x 1 pixel image where the
    first pixel is black while the other is white. This dataset will be published
    to an external website that people can freely access to train the model. In our
    constructor we will provide a URL, namely `https://example.com/dataset`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The reward for training the model is paid in Ethereum, and this arrangement
    set up in the payable constructor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The contract is published and sellers begin to participate in the task of training
    the model. From the dataset, 90% of the data will be used to train the model while
    the remaining 10% will be used to test the results from the program to verify
    its accuracy. To make sure sellers don't copy each other, different random datasets
    will be given to different participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The buyer decides which model works best for them and selects a winner. If an
    expiration time is reached and the buyer hasn't selected a winner, the first participant
    will get the reward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our machine learning marketplace, we'll use a simple linear-regression machine
    learning algorithm in Solidity. Users will submit their data, which will contain
    a name and two number parameters to make predictions. A linear regression is a
    relationship between two factors—for instance, the number of sales in a website
    and the number of visitors. In that case, we can establish a model that allows
    us to predict the number of sales for a given number of visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Simple linear-regression models can be applied to many fields where a variable
    depends on another, and it's one of the simplest machine learning systems available.
    That's why we'll be using it, since it's important to be able to recreate it in
    Solidity to verify solutions provided by other users. Ideally, we'd implement
    an NN or a more complex model, but that would take too much time to develop considering
    the limitations of the blockchain. You can build upon the lessons in this chapter
    to extend the marketplace. In the following section, you'll learn how to create
    the code required for the marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Building a smart contract machine learning marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our ML marketplace will work with linear regression algorithms exclusively
    to simplify the process so that you understand how it all ties together. I encourage
    you to expand the solution for more advanced models to practice your ML and blockchain
    skills. To apply a simple linear regression algorithm, we need the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A prediction function to generate a prediction from data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cost function to combine the prediction results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optimization algorithm to train our algorithm with **gradient descent**,
    which will fine tune the predictions for more precise results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A train function to improve our algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prediction function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to understand that our simple linear-regression algorithms
    predict values using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are predicting the number of sales based on the number of visitors to
    a website, our prediction function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to obtain fixed weight and bias values to optimize our prediction
    function so that we get a realistic estimate of sales. For instance, a trained
    linear regression would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We got a weight of `0.43` and a bias of `0.9` after training from a given dataset.
    We should be able to use that optimized function to make accurate predictions
    for our particular needs with great results. We need to implement the prediction
    function in Python and in Solidity because sellers will use Python to train the
    model, while we''ll use Solidity to verify the result given by those sellers.
    Here''s how our `prediction` function looks in Python and Solidity for our marketplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For your reference, here''s the Solidity function that we''ll add to allow
    sellers and buyers to verify the precision of the model by making predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The cost function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To train our linear-regression algorithm to generate accurate predictions,
    we need a cost function. A cost function is one way to analyze how well our prediction
    function is working for our dataset. It gives us an error rate, which is essentially
    the difference between the real-world result versus the prediction. The smaller
    the error, the better predictions we''ll make. The cost function takes the real
    result and the prediction to output the error from our model, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many different types of cost functions. In our case, we''ll use the
    **mean squared error** (**MSE**) cost function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it clearer, we can add the prediction function with all the parameters
    so that you can see how the variables play our in the cost function, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sum()` is the addition of all the real results minus the prediction squared,
    the sum of all the resulting dataset values. All of this is divided by the number
    of data points. Remember that `result` is the actual value that we are trying
    to predict. For instance, going back to our previous example where we are trying
    to predict how many sales we'll get per visitor, the `result` would be `10` sales,
    which comes from 200 visitors, while prediction is our own estimation from the
    weight and bias.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand the function better, consider the following example
    dataset of fake gun owners in a country and crimes per country; in this example,
    we are interested in learning how the number of guns affects the number of crimes
    per country. Using this data, we can predict crimes so that we can mobilize a
    specific number of police officers to deal with these situations. Remember that
    this is fake data to illustrate how the cost function will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Country** | **Total number of guns** | **Number of crimes per year** |'
  prefs: []
  type: TYPE_TB
- en: '| Germany | 3,520 | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| Estonia | 192 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Bahamas | 91 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Brazil | 9,271 | 88 |'
  prefs: []
  type: TYPE_TB
- en: 'We first initialize our prediction function with a random weight and bias as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The prediction of crimes for Germany would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We get `352.4` crimes, which we can approximate to 352, since it doesn't make
    sense to talk about crimes in terms of decimal points. As you can see, our prediction
    with that weight and bias is higher than the real result of 20 crimes per year,
    since our model isn't trained yet, so it's normal to expect huge differences what
    using real values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we calculate the cost function for all of those values. Let''s see how
    it looks for Germany:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are applying the cost function for one data point to see the error of the
    initial prediction so that you can see how it''s applied. Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The error is `110224`, which is a gigantic number, since we are applying it
    to one data point and our model isn't trained yet. Now do the same for all the
    data points until you generate the error for the entire dataset. Hopefully, you
    will understand the process to calculate the error with that example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to calculate the error to optimize our prediction function to make
    more accurate predictions later on. Now that the concept is clear, we can implement
    that function in Python. In Solidity, we want it to calculate the error from a
    specific solution for our marketplace in order to discard those that have an excessively
    large error. The `cost` function in Python will be used by the buyers to verify
    the result of their training, and it will be used by sellers in Solidity to verify
    the submissions. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xs` parameter is an array of independent variables, `x`—that we saw in
    the prediction function. Here''s how it looks in Solidity; because it''s a pure
    function, we don''t have to worry about gas costs since everything will be executed
    locally without having to modify the state from the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've included the prediction function inside the `for` loop
    to calculate the result minus the prediction squared so that we can calculate
    the error from the `cost` function. This will be used by sellers who want to optimize
    a specific linear regression from a buyer to make accurate predictions.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can make predictions given some parameters and calculate the precision
    of those predictions with the cost function, we have to work on improving those
    predictions by reducing the error. How do we reduce the error generated from the
    cost function? By adjusting the weight and bias of our prediction function with
    an optimization algorithm. In this case, we''ll use gradient descent, which allows
    us to continuously reduce the error. Here''s a graph that explains how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8fc70d2-3709-45f9-bf1e-84e0aee20d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We start with a high error caused by random weight and bias values, then we
    reduce the error by optimizing those parameters until we reach a good-enough prediction
    model, the local minimum in the graph. The idea is to calculate the partial derivatives
    of the **weight** and **bias** to see how they affect the final prediction until
    we reach the minimum. We won''t get into the math of calculating those derivatives,
    since it could lead to confusion, so the resulting function with the partial derivatives
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the implementation of those functions to update the weight
    and bias of our machine learning algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Solidity, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are calculating both derivatives by using the functions described
    in the preceding code block so that we can update the weight and bias with the
    optimized values. The learning rate is the size of the steps we take to reach
    the minimum point of the graph. If we take big steps, we may miss the minimum,
    and if we take small steps, we may take too much time to reach that minimum. In
    any case, it's best to keep a balanced learning rate and try different step sizes.
    Now we have a way to improve our prediction function.
  prefs: []
  type: TYPE_NORMAL
- en: The train function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can begin to improve our model with a new function that loops through several
    optimization calls until we reach the minimum, at which point the model will be
    fully optimized. Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Solidity implementation looks pretty similar, although we have to make
    sure that the results and independent variables, values have the same length to
    avoid errors, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the optimization function along with the cost function
    to continuously reduce the error by updating the weight and bias parameters for
    the specified number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should be able to create and train linear regression models to make
    predictions using the prediction function after training your model with the train
    function. The following is the full Python code for your reference, although you
    can see the updated version on the official GitHub at [https://github.com/merlox/machine-learning-ethereum/blob/master/linearRegression.py](https://github.com/merlox/machine-learning-ethereum/blob/master/linearRegression.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the constructor, which will train the model with some
    initial random values using the `uniform` library because it returns a floating
    number between 0 and 1, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the `prediction` and `cost` function, as you just learned,
    down below the constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we add the optimized weights and the bias function, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we complete the code by creating the `train` function and initialize
    the class outside the scope of the class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve created a Python class that runs the `train` function
    in the constructor. Don''t worry if you''re not familiar with Python; you just
    have to understand that the code is training our linear-regression algorithm for
    more precise calculations. Create a file called `linearRegression.py` and write
    the code there. Then you can run it with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see that the program is constantly reducing the error by taking small
    steps toward the minimum until it gets to a point where it doesn''t improve much.
    That''s okay: we expect it to make precise predictions, but without 100% accuracy.
    You can then take the final weight and bias to make predictions on your own for
    that machine learning model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the smart contract marketplace to see how users will interact
    with it. Our goal is to provide a place where machine learning developers can
    upload their model with a payment in Ethereum with the aim of getting the solution
    from several sellers, from which a winner will be selected based on the error
    or the buyer''s choice. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start adding variables to create our desired application, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We've added three events to notify users that a new job or result has been added,
    as well as when a winner for a proposal is selected. That way, people will be
    notified when their proposal gets updated. Then we have a struct named `Model`,
    which represents our desired linear regression ML model with the dataset, weight,
    bias, and payment, among other important variables. Finally, we've added a couple
    of mappings to sort models created by buyers (those that pay to get their model
    trained) and those models created by sellers, those that train the model from
    the dataset and upload a specific weight and bias in order to win if they are
    selected by the buyer. `latestId` is an identifier to signify which model is the
    latest.
  prefs: []
  type: TYPE_NORMAL
- en: A model that is open means it is still running, so you can send a proposal and
    participate in it for a chance to get selected. If it's closed, you will be able
    to participate, but know that you won't be able to win since the winner has been
    selected already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the three most important functions of our ML marketplace.
    The upload job function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the upload results function, with some added documentation to clarify
    the parameters used inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the choose results function, which is quite lengthy because
    we must make sure that the job is open and that a winner has not been selected
    yet. If there are no winners selected after three days, the first applicant wins
    the reward to avoid losing Ether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `uploadJob` function will be used by buyers to publish their dataset and
    payment in order to get their model trained by participants all over the world.
    The `uploadResult` function will be used by sellers to get information about a
    job to train the specified dataset until the error is minimized. Finally, the
    `chooseResult` function is the one that is used by buyers to select a winner proposal
    for a determined job. The creator of the job has three days to select a winning
    proposal. If after three days no one has applied, then the payment will be returned
    to the owner. If there are participants, but the owner hasn't selected a winner,
    the reward will be sent to the first participant in compensation for their speed;
    in that case, this function has to be executed by an external user to execute
    the payment.
  prefs: []
  type: TYPE_NORMAL
- en: Those are the main components that make our ML marketplace work; however, we
    need a few functions to help people interact with it. Here are the new functions
    that are added to the ML marketplace broken down in pieces to help you understand
    them better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the cost function with complete documentation so that we can
    understand what it''s doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the get model function to retrieve the variables contained in
    the struct model, because we can''t return the struct as it is right now. We have
    to make these types of tricks to get the struct values independently. This function
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add another getter function that gives us all the trained models for
    a particular ID, as shown in the following code. This is useful for sellers who
    want to see what proposals they got for their particular job. If we were to implement
    this machine learning marketplace in a dApp, we''d have to add a few more getters
    for the jobs and other mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have a `cost` function to quickly verify the results uploaded by a proposed
    seller, a `getModel` function that will be mainly used by sellers who want to
    get more specific information about a model, and a `getAllTrainedModels` function
    that returns the participants of a particular job. Note how we're returning the
    most important variables in the struct instead of the entire struct. We are doing
    this for the simple reason that we can't return structs yet in Solidity, so we
    have to separate each variable and return an array for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general workflow of this marketplace is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A buyer with a machine learning model to train uploads their dataset and payment
    to the marketplace with the `uploadJob` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `AddedJob` event gets generated, which notifies users that are interested
    in participating in this marketplace of that new job. They can listen to those
    events by using **web3** or external dApps, since the contract is open source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sellers read the model data—particularly the timestamps, since that's the most
    important piece of information—with the `getModel` function using the `id` model
    they've received from the event. Then they start training the model using the
    Python application we built earlier or their own, since there are many different
    ways that you can train a linear-regression algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They upload their trained weight and bias to that job as a new proposal using
    the `uploadResult` function. This will fire the `AddedResult` event, which will
    notify the buyer whether they're listening to updates so that they can choose
    a winner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before three days have passed since the job was created, the buyer goes through
    the proposals, comparing the error generated by each proposal with the `cost`
    function or their own implementation. They'll almost certainly choose the result
    with the smallest error, although they can choose whichever they want. After selecting
    one, the state of the model will change to `isOpen = false`, which means that
    the winner is selected and the `SelectedWinner` event gets fired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! You now are able to upload and train linear-regression models on
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamental utility of combining blockchain
    and ML, since they are almost opposites, meaning that they complement each other
    well to create optimal security and performance. We started with a general explanation
    of ML so that you could understand all the hype by taking a quick look at the
    process of generating and training machine learning models. Then we dove deeper
    into the technical functionalities of the application so you got a clear vision
    of where machine learning and blockchain meet. Finally, we built the machine learning
    marketplace, as it's a great combination of both technologies. You saw how the
    linear-regression algorithm works step by step with an implementation in Python
    and Solidity. We built the marketplace, where users from all over the world train
    and exchange computational resources for each task, creating a great secure open
    source platform where people interact without censorship, fees, or centralization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore advanced Ethereum implementations similar
    to what you saw in this chapter, but with different industries, starting with
    a blockchain-based social media platform that combines decentralization with social
    interactions on the internet.
  prefs: []
  type: TYPE_NORMAL
