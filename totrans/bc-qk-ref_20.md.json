["```\nxcode-select --install\n```", "```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```", "```\nbrew install automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python3 qt libevent\n```", "```\ngit clone https://github.com/litecoin-project/litecoin\ncd Litecoin\n```", "```\n./contrib/install_db4.sh .\n```", "```\n./autogen.sh\n./configure\nmake\n```", "```\nmake check\n```", "```\nmake deploy\n```", "```\nCAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n{\n int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;\n // Force block reward to zero when right shift is undefined.\n if (halvings >= 64)\n return 0;\n\n CAmount nSubsidy = 50 * COIN;\n // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n nSubsidy >>= halvings;\n return nSubsidy;\n}\n```", "```\ntypedef int64_t CAmount;\n\nstatic const CAmount COIN = 100000000;\nstatic const CAmount CENT = 1000000;\n\nstatic const CAmount MAX_MONEY = 84000000 * COIN;\ninline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n\n#endif // BITCOIN_AMOUNT_H\n```", "```\n  if (nNet > 0 || wtx.IsCoinBase())\n    {\n        //\n        // Credit\n        //\n        for(unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n        {\n            const CTxOut& txout = wtx.tx->vout[i];\n            isminetype mine = wallet->IsMine(txout);\n            if(mine)\n            {\n                TransactionRecord sub(hash, nTime);\n                CTxDestination address;\n                sub.idx = i; // vout index\n                sub.credit = txout.nValue;\n                sub.involvesWatchAddress = mine & ISMINE_WATCH_ONLY;\n                if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*wallet, address))\n                {\n                    // Received by Bitcoin Address\n                    sub.type = TransactionRecord::RecvWithAddress;\n                    sub.address = EncodeDestination(address);\n                }\n                else\n                {\n                    // Received by IP connection (deprecated features), or a multisignature or other non-simple transaction\n                    sub.type = TransactionRecord::RecvFromOther;\n                    sub.address = mapValue[\"from\"];\n                }\n                if (wtx.IsCoinBase())\n                {\n                    // Generated\n                    sub.type = TransactionRecord::Generated;\n                }\n\n                parts.append(sub);\n            }\n        }\n    }\n    else\n    {\n        bool involvesWatchAddress = false;\n        isminetype fAllFromMe = ISMINE_SPENDABLE;\n        for (const CTxIn& txin : wtx.tx->vin)\n        {\n            isminetype mine = wallet->IsMine(txin);\n            if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n            if(fAllFromMe > mine) fAllFromMe = mine;\n        }\n\n        isminetype fAllToMe = ISMINE_SPENDABLE;\n        for (const CTxOut& txout : wtx.tx->vout)\n        {\n            isminetype mine = wallet->IsMine(txout);\n            if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n            if(fAllToMe > mine) fAllToMe = mine;\n        }\n\n        if (fAllFromMe && fAllToMe)\n        {\n            // Payment to self\n            CAmount nChange = wtx.GetChange();\n\n            parts.append(TransactionRecord(hash, nTime, TransactionRecord::SendToSelf, \"\",\n                            -(nDebit - nChange), nCredit - nChange));\n            parts.last().involvesWatchAddress = involvesWatchAddress; // maybe pass to TransactionRecord as constructor argument\n        }\n```", "```\nbool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree)\n{\n    if (!blocktree.LoadBlockIndexGuts(consensus_params, [this](const uint256& hash){ return this->InsertBlockIndex(hash); }))\n        return false;\n\n    boost::this_thread::interruption_point();\n\n    // Calculate nChainWork\n    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n        pindex->nTimeMax = (pindex->pprev ? std::max(pindex->pprev->nTimeMax, pindex->nTime) : pindex->nTime);\n        // We can link the chain of blocks for which we've received transactions at some point.\n        // Pruned nodes may have deleted the block.\n        if (pindex->nTx > 0) {\n            if (pindex->pprev) {\n                if (pindex->pprev->nChainTx) {\n                    pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n                } else {\n                    pindex->nChainTx = 0;\n                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));\n                }\n            } else {\n                pindex->nChainTx = pindex->nTx;\n            }\n        }\n        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && pindex->pprev && (pindex->pprev->nStatus & BLOCK_FAILED_MASK)) {\n            pindex->nStatus |= BLOCK_FAILED_CHILD;\n            setDirtyBlockIndex.insert(pindex);\n        }\n        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n            setBlockIndexCandidates.insert(pindex);\n        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n            pindexBestInvalid = pindex;\n        if (pindex->pprev)\n            pindex->BuildSkip();\n        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n            pindexBestHeader = pindex;\n    }\n\n    return true;\n}\n```", "```\n    const char* pszTimestamp = \"NY Times 05/Oct/2011 Steve Jobs, Appleâ€™s Visionary, Dies at 56\";\n```", "```\nnamespace Checkpoints {\n\n    CBlockIndex* GetLastCheckpoint(const CCheckpointData& data)\n    {\n        const MapCheckpoints& checkpoints = data.mapCheckpoints;\n\n        for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n        {\n            const uint256& hash = i.second;\n            BlockMap::const_iterator t = mapBlockIndex.find(hash);\n            if (t != mapBlockIndex.end())\n                return t->second;\n        }\n        return nullptr;\n   }\n```"]